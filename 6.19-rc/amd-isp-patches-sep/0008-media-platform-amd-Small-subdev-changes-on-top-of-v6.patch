From a9db98bb9b9954eb5ae578a256af7d2ee51de11a Mon Sep 17 00:00:00 2001
From: Sultan Alsawaf <sultan@kerneltoast.com>
Date: Fri, 28 Nov 2025 18:40:33 -0800
Subject: [PATCH 8/8] media: platform: amd: Small subdev changes on top of v6
 driver

-Fixed buf_sent_cnt not getting reset when the stream is stopped, even
 though start_stream_cmd_sent would get reset
-Removed duplicate start_stream_cmd_sent and buf_sent_cnt reset in
 isp4sd_pwron_and_init(), the same two lines appear lower in the function
 and the duplication isn't needed
-Removed duplicate call to isp4sd_reset_stream_info() when the stream is
 stopped. Achieved this and removed duplicate status setting in the process
 by rolling isp4sd_reset_stream_info() and isp4sd_reset_camera_info() into
 isp4sd_uninit_stream()
-Removed always-false status check in isp4sd_uninit_stream()
-A few small style cleanups

Signed-off-by: Sultan Alsawaf <sultan@kerneltoast.com>
---
 drivers/media/platform/amd/isp4/isp4_subdev.c | 70 +++++--------------
 1 file changed, 19 insertions(+), 51 deletions(-)

diff --git a/drivers/media/platform/amd/isp4/isp4_subdev.c b/drivers/media/platform/amd/isp4/isp4_subdev.c
index 2612ca283..7d48ad0d5 100644
--- a/drivers/media/platform/amd/isp4/isp4_subdev.c
+++ b/drivers/media/platform/amd/isp4/isp4_subdev.c
@@ -60,7 +60,7 @@ static int isp4sd_setup_fw_mem_pool(struct isp4_subdev *isp_subdev)
 	isp4if_split_addr64(ispif->fw_mem_pool->gpu_mc_addr,
 			    &buf_type.buffer.buf_base_a_lo,
 			    &buf_type.buffer.buf_base_a_hi);
-	buf_type.buffer.buf_size_a = (u32)ispif->fw_mem_pool->mem_size;
+	buf_type.buffer.buf_size_a = ispif->fw_mem_pool->mem_size;
 
 	ret = isp4if_send_command(ispif, CMD_ID_SEND_BUFFER,
 				  &buf_type, sizeof(buf_type));
@@ -124,10 +124,10 @@ static int isp4sd_send_meta_buf(struct isp4_subdev *isp_subdev)
 		}
 		buf_type.buffer_type = BUFFER_TYPE_META_INFO;
 		buf_type.buffer.vmid_space.bit.space = ADDR_SPACE_TYPE_GPU_VA;
-		isp4if_split_addr64(isp_subdev->ispif.meta_info_buf[i]->gpu_mc_addr,
+		isp4if_split_addr64(meta_info_buf->gpu_mc_addr,
 				    &buf_type.buffer.buf_base_a_lo,
 				    &buf_type.buffer.buf_base_a_hi);
-		buf_type.buffer.buf_size_a = (u32)isp_subdev->ispif.meta_info_buf[i]->mem_size;
+		buf_type.buffer.buf_size_a = meta_info_buf->mem_size;
 		ret = isp4if_send_command(ispif, CMD_ID_SEND_BUFFER,
 					  &buf_type, sizeof(buf_type));
 		if (ret) {
@@ -205,8 +205,7 @@ static int isp4sd_kickoff_stream(struct isp4_subdev *isp_subdev, u32 w, u32 h)
 	sensor_info->status = ISP4SD_START_STATUS_OFF;
 
 	if (!sensor_info->start_stream_cmd_sent &&
-	    sensor_info->buf_sent_cnt >=
-	    ISP4SD_MIN_BUF_CNT_BEF_START_STREAM) {
+	    sensor_info->buf_sent_cnt >= ISP4SD_MIN_BUF_CNT_BEF_START_STREAM) {
 		int ret = isp4if_send_command(ispif, CMD_ID_START_STREAM,
 					      NULL, 0);
 		if (ret) {
@@ -324,7 +323,7 @@ static int isp4sd_init_stream(struct isp4_subdev *isp_subdev)
 	struct device *dev = isp_subdev->dev;
 	int ret;
 
-	ret  = isp4sd_setup_fw_mem_pool(isp_subdev);
+	ret = isp4sd_setup_fw_mem_pool(isp_subdev);
 	if (ret) {
 		dev_err(dev, "fail to setup fw mem pool\n");
 		return ret;
@@ -339,10 +338,12 @@ static int isp4sd_init_stream(struct isp4_subdev *isp_subdev)
 	return 0;
 }
 
-static void isp4sd_reset_stream_info(struct isp4_subdev *isp_subdev,
-				     struct v4l2_subdev_state *state, u32 pad)
+static void isp4sd_uninit_stream(struct isp4_subdev *isp_subdev,
+				 struct v4l2_subdev_state *state, u32 pad)
 {
 	struct isp4sd_sensor_info *sensor_info = &isp_subdev->sensor_info;
+	struct isp4sd_output_info *output_info = &sensor_info->output_info;
+	struct isp4_interface *ispif = &isp_subdev->ispif;
 	struct v4l2_mbus_framefmt *format;
 
 	format = v4l2_subdev_state_get_format(state, pad, 0);
@@ -353,35 +354,14 @@ static void isp4sd_reset_stream_info(struct isp4_subdev *isp_subdev,
 		format->code = MEDIA_BUS_FMT_YUYV8_1_5X8;
 	}
 
-	sensor_info->output_info.start_status = ISP4SD_START_STATUS_OFF;
-}
-
-static void isp4sd_reset_camera_info(struct isp4_subdev *isp_subdev,
-				     struct v4l2_subdev_state *state, u32 pad)
-{
-	struct isp4sd_sensor_info *sensor_info = &isp_subdev->sensor_info;
-
-	sensor_info->status = ISP4SD_START_STATUS_OFF;
-	isp4sd_reset_stream_info(isp_subdev, state, pad);
+	isp4if_clear_bufq(ispif);
+	isp4if_clear_cmdq(ispif);
 
 	sensor_info->start_stream_cmd_sent = false;
-}
+	sensor_info->buf_sent_cnt = 0;
 
-static int isp4sd_uninit_stream(struct isp4_subdev *isp_subdev,
-				struct v4l2_subdev_state *state, u32 pad)
-{
-	struct isp4sd_output_info *output_info = &isp_subdev->sensor_info.output_info;
-	struct isp4_interface *ispif = &isp_subdev->ispif;
-	struct device *dev = isp_subdev->dev;
-
-	if (output_info->start_status == ISP4SD_START_STATUS_STARTED) {
-		dev_dbg(dev, "fail for stream is still running\n");
-		return -EINVAL;
-	}
-
-	isp4sd_reset_camera_info(isp_subdev, state, pad);
-	isp4if_clear_cmdq(ispif);
-	return 0;
+	sensor_info->status = ISP4SD_START_STATUS_OFF;
+	output_info->start_status = ISP4SD_START_STATUS_OFF;
 }
 
 static void isp4sd_fw_resp_cmd_done(struct isp4_subdev *isp_subdev,
@@ -461,7 +441,7 @@ static void isp4sd_fw_resp_frame_done(struct isp4_subdev *isp_subdev,
 	struct device *dev = isp_subdev->dev;
 	struct isp4if_img_buf_node *prev;
 	struct isp4fw_meta_info *meta;
-	u64 mc = 0;
+	u64 mc;
 
 	mc = isp4if_join_addr64(para->package_addr_lo, para->package_addr_hi);
 	meta = isp4sd_get_meta_by_mc(isp_subdev, mc);
@@ -685,9 +665,6 @@ static int isp4sd_pwron_and_init(struct isp4_subdev *isp_subdev)
 
 	isp4sd_module_enable(isp_subdev, true);
 
-	isp_subdev->sensor_info.start_stream_cmd_sent = false;
-	isp_subdev->sensor_info.buf_sent_cnt = 0;
-
 	if (ispif->status < ISP4IF_STATUS_PWR_ON) {
 		unsigned int perf_state = ISP4SD_PERFORMANCE_STATE_HIGH;
 
@@ -739,17 +716,17 @@ static int isp4sd_pwron_and_init(struct isp4_subdev *isp_subdev)
 static int isp4sd_stop_stream(struct isp4_subdev *isp_subdev,
 			      struct v4l2_subdev_state *state, u32 pad)
 {
-	struct isp4sd_output_info *output_info =
-			&isp_subdev->sensor_info.output_info;
+	struct isp4sd_sensor_info *sensor_info = &isp_subdev->sensor_info;
+	struct isp4sd_output_info *output_info = &sensor_info->output_info;
 	struct isp4_interface *ispif = &isp_subdev->ispif;
 	struct device *dev = isp_subdev->dev;
-	int ret = 0;
 
 	guard(mutex)(&isp_subdev->ops_mutex);
 	dev_dbg(dev, "status %i\n", output_info->start_status);
 
 	if (output_info->start_status == ISP4SD_START_STATUS_STARTED) {
 		struct isp4fw_cmd_enable_out_ch cmd_ch_disable;
+		int ret;
 
 		/*
 		 * The struct will be shared with ISP FW, use memset() to guarantee
@@ -774,11 +751,6 @@ static int isp4sd_stop_stream(struct isp4_subdev *isp_subdev,
 			dev_dbg(dev, "wait stop stream suc\n");
 	}
 
-	isp4if_clear_bufq(ispif);
-
-	output_info->start_status = ISP4SD_START_STATUS_OFF;
-	isp4sd_reset_stream_info(isp_subdev, state, pad);
-
 	isp4sd_uninit_stream(isp_subdev, state, pad);
 
 	/*
@@ -870,7 +842,6 @@ static int isp4sd_ioc_send_img_buf(struct v4l2_subdev *sd,
 		    ISP4SD_MIN_BUF_CNT_BEF_START_STREAM) {
 			ret = isp4if_send_command(ispif, CMD_ID_START_STREAM,
 						  NULL, 0);
-
 			if (ret) {
 				dev_err(dev, "fail to START_STREAM");
 				goto error_release_buf_node;
@@ -1000,8 +971,8 @@ static const struct isp4vid_ops isp4sd_isp4vid_ops = {
 int isp4sd_init(struct isp4_subdev *isp_subdev, struct v4l2_device *v4l2_dev,
 		int irq[ISP4SD_MAX_FW_RESP_STREAM_NUM])
 {
+	struct isp4sd_sensor_info *sensor_info = &isp_subdev->sensor_info;
 	struct isp4_interface *ispif = &isp_subdev->ispif;
-	struct isp4sd_sensor_info *sensor_info;
 	struct device *dev = v4l2_dev->dev;
 	int ret;
 
@@ -1034,12 +1005,9 @@ int isp4sd_init(struct isp4_subdev *isp_subdev, struct v4l2_device *v4l2_dev,
 		goto err_media_clean_up;
 	}
 
-	sensor_info = &isp_subdev->sensor_info;
-
 	isp4if_init(ispif, dev, isp_subdev->mmio);
 
 	mutex_init(&isp_subdev->ops_mutex);
-	sensor_info->start_stream_cmd_sent = false;
 	sensor_info->status = ISP4SD_START_STATUS_OFF;
 
 	/* create ISP enable gpio control */
-- 
2.52.0

