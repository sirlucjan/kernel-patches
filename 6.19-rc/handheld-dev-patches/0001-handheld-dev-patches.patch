From 25c863c277ec640c248e660eb6563f5648c18caf Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sat, 19 Feb 2022 16:08:36 -0800
Subject: [PATCH 001/112] mfd: Add MFD core driver for Steam Deck

Add MFD core driver for Steam Deck. Doesn't really do much so far
besides instantiating a number of MFD cells that implement all the
interesting functionality.

(cherry picked from commit 5f534c2d6ebdefccb9c024eb0f013bc1c0c622d9)
[fwd-ported to v6.11]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/mfd/Kconfig     |  11 ++++
 drivers/mfd/Makefile    |   2 +
 drivers/mfd/steamdeck.c | 127 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 140 insertions(+)
 create mode 100644 drivers/mfd/steamdeck.c

diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index aace5766b..133e8526a 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -2540,6 +2540,17 @@ config MFD_RSMU_SPI
 	  Additional drivers must be enabled in order to use the functionality
 	  of the device.
 
+config MFD_STEAMDECK
+	tristate "Valve Steam Deck"
+	select MFD_CORE
+	depends on ACPI
+	depends on X86_64 || COMPILE_TEST
+	help
+	  This driver registers various MFD cells that expose aspects
+	  of Steam Deck specific ACPI functionality.
+
+	  Say N here, unless you are running on Steam Deck hardware.
+
 config MFD_UPBOARD_FPGA
 	tristate "Support for the AAeon UP board FPGA"
 	depends on (X86 && ACPI)
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index e75e8045c..5fc48aa2b 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -301,6 +301,8 @@ obj-$(CONFIG_MFD_QNAP_MCU)	+= qnap-mcu.o
 obj-$(CONFIG_MFD_RSMU_I2C)	+= rsmu_i2c.o rsmu_core.o
 obj-$(CONFIG_MFD_RSMU_SPI)	+= rsmu_spi.o rsmu_core.o
 
+obj-$(CONFIG_MFD_STEAMDECK)	+= steamdeck.o
+
 obj-$(CONFIG_MFD_UPBOARD_FPGA)	+= upboard-fpga.o
 
 obj-$(CONFIG_MFD_LOONGSON_SE)	+= loongson-se.o
diff --git a/drivers/mfd/steamdeck.c b/drivers/mfd/steamdeck.c
new file mode 100644
index 000000000..0e504b3c2
--- /dev/null
+++ b/drivers/mfd/steamdeck.c
@@ -0,0 +1,127 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/*
+ * Steam Deck EC MFD core driver
+ *
+ * Copyright (C) 2021-2022 Valve Corporation
+ *
+ */
+
+#include <linux/acpi.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/core.h>
+
+#define STEAMDECK_STA_OK			\
+	(ACPI_STA_DEVICE_ENABLED |		\
+	 ACPI_STA_DEVICE_PRESENT |		\
+	 ACPI_STA_DEVICE_FUNCTIONING)
+
+struct steamdeck {
+	struct acpi_device *adev;
+	struct device *dev;
+};
+
+#define STEAMDECK_ATTR_RO(_name, _method)				\
+	static ssize_t _name##_show(struct device *dev,			\
+				    struct device_attribute *attr,	\
+				    char *buf)				\
+	{								\
+		struct steamdeck *sd = dev_get_drvdata(dev);		\
+		unsigned long long val;					\
+									\
+		if (ACPI_FAILURE(acpi_evaluate_integer(			\
+					 sd->adev->handle,		\
+					 _method, NULL, &val)))		\
+			return -EIO;					\
+									\
+		return sysfs_emit(buf, "%llu\n", val);			\
+	}								\
+	static DEVICE_ATTR_RO(_name)
+
+STEAMDECK_ATTR_RO(firmware_version, "PDFW");
+STEAMDECK_ATTR_RO(board_id, "BOID");
+
+static struct attribute *steamdeck_attrs[] = {
+	&dev_attr_firmware_version.attr,
+	&dev_attr_board_id.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(steamdeck);
+
+static const struct mfd_cell steamdeck_cells[] = {
+	{ .name = "steamdeck-hwmon"  },
+	{ .name = "steamdeck-leds"   },
+	{ .name = "steamdeck-extcon" },
+};
+
+static void steamdeck_remove_sysfs_groups(void *data)
+{
+	struct steamdeck *sd = data;
+
+	sysfs_remove_groups(&sd->dev->kobj, steamdeck_groups);
+}
+
+static int steamdeck_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	unsigned long long sta;
+	struct steamdeck *sd;
+	acpi_status status;
+	int ret;
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+	sd->adev = ACPI_COMPANION(dev);
+	sd->dev = dev;
+	platform_set_drvdata(pdev, sd);
+
+	status = acpi_evaluate_integer(sd->adev->handle, "_STA",
+				       NULL, &sta);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Status check failed (0x%x)\n", status);
+		return -EINVAL;
+	}
+
+	if ((sta & STEAMDECK_STA_OK) != STEAMDECK_STA_OK) {
+		dev_err(dev, "Device is not ready\n");
+		return -EINVAL;
+	}
+
+	ret = sysfs_create_groups(&dev->kobj, steamdeck_groups);
+	if (ret) {
+		dev_err(dev, "Failed to create sysfs group\n");
+		return ret;
+	}
+
+	ret = devm_add_action_or_reset(dev, steamdeck_remove_sysfs_groups,
+				       sd);
+	if (ret) {
+		dev_err(dev, "Failed to register devres action\n");
+		return ret;
+	}
+
+	return devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,
+				    steamdeck_cells, ARRAY_SIZE(steamdeck_cells),
+				    NULL, 0, NULL);
+}
+
+static const struct acpi_device_id steamdeck_device_ids[] = {
+	{ "VLV0100", 0 },
+	{ "", 0 },
+};
+MODULE_DEVICE_TABLE(acpi, steamdeck_device_ids);
+
+static struct platform_driver steamdeck_driver = {
+	.probe = steamdeck_probe,
+	.driver = {
+		.name = "steamdeck",
+		.acpi_match_table = steamdeck_device_ids,
+	},
+};
+module_platform_driver(steamdeck_driver);
+
+MODULE_AUTHOR("Andrey Smirnov <andrew.smirnov@gmail.com>");
+MODULE_DESCRIPTION("Steam Deck EC MFD core driver");
+MODULE_LICENSE("GPL");
-- 
2.52.0


From 2909ed7532c7c49e555d451c2a1c6e03df3f83e4 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sun, 24 Sep 2023 15:02:33 -0700
Subject: [PATCH 002/112] mfd: steamdeck: Expose controller board power in
 sysfs

As of version 118 Deck's BIOS implements "SCBP" method that allows
gating power of the controller board (VBUS). Add a basic WO method to
our root MFD device to allow toggling that.

Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
(cherry picked from commit f97f32718acc10cbb51fef925842392e80904d74)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/mfd/steamdeck.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/drivers/mfd/steamdeck.c b/drivers/mfd/steamdeck.c
index 0e504b3c2..a60fa7db9 100644
--- a/drivers/mfd/steamdeck.c
+++ b/drivers/mfd/steamdeck.c
@@ -41,9 +41,29 @@ struct steamdeck {
 STEAMDECK_ATTR_RO(firmware_version, "PDFW");
 STEAMDECK_ATTR_RO(board_id, "BOID");
 
+static ssize_t controller_board_power_store(struct device *dev,
+					    struct device_attribute *attr,
+					    const char *buf, size_t count)
+{
+	struct steamdeck *sd = dev_get_drvdata(dev);
+	bool enabled;
+	ssize_t ret = kstrtobool(buf, &enabled);
+
+	if (ret)
+		return ret;
+
+	if (ACPI_FAILURE(acpi_execute_simple_method(sd->adev->handle,
+						    "SCBP", enabled)))
+		return -EIO;
+
+	return count;
+}
+static DEVICE_ATTR_WO(controller_board_power);
+
 static struct attribute *steamdeck_attrs[] = {
 	&dev_attr_firmware_version.attr,
 	&dev_attr_board_id.attr,
+	&dev_attr_controller_board_power.attr,
 	NULL
 };
 
-- 
2.52.0


From c698042dde6cab2ff187eeeb3047de67cede42cc Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sun, 27 Feb 2022 12:58:05 -0800
Subject: [PATCH 003/112] leds: steamdeck: Add support for Steam Deck LED

(cherry picked from commit 85a86d19aa7022ff0555023d53aef78323a42d0c)
[cristian: fwd-ported to v6.8]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/leds/Kconfig          |  7 ++++
 drivers/leds/Makefile         |  1 +
 drivers/leds/leds-steamdeck.c | 74 +++++++++++++++++++++++++++++++++++
 3 files changed, 82 insertions(+)
 create mode 100644 drivers/leds/leds-steamdeck.c

diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 11e7282dc..65395dfab 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -1016,6 +1016,13 @@ config LEDS_ACER_A500
 	  This option enables support for the Power Button LED of
 	  Acer Iconia Tab A500.
 
+config LEDS_STEAMDECK
+	tristate "LED support for Steam Deck"
+	depends on LEDS_CLASS && MFD_STEAMDECK
+	help
+	  This option enabled support for the status LED (next to the
+	  power button) on Steam Deck
+
 source "drivers/leds/blink/Kconfig"
 
 comment "Flash and Torch LED drivers"
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 9a0333ec1..e93fa6d6d 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -86,6 +86,7 @@ obj-$(CONFIG_LEDS_QNAP_MCU)		+= leds-qnap-mcu.o
 obj-$(CONFIG_LEDS_REGULATOR)		+= leds-regulator.o
 obj-$(CONFIG_LEDS_SC27XX_BLTC)		+= leds-sc27xx-bltc.o
 obj-$(CONFIG_LEDS_ST1202)		+= leds-st1202.o
+obj-$(CONFIG_LEDS_STEAMDECK)		+= leds-steamdeck.o
 obj-$(CONFIG_LEDS_SUN50I_A100)		+= leds-sun50i-a100.o
 obj-$(CONFIG_LEDS_SUNFIRE)		+= leds-sunfire.o
 obj-$(CONFIG_LEDS_SYSCON)		+= leds-syscon.o
diff --git a/drivers/leds/leds-steamdeck.c b/drivers/leds/leds-steamdeck.c
new file mode 100644
index 000000000..686500b8d
--- /dev/null
+++ b/drivers/leds/leds-steamdeck.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/*
+ * Steam Deck EC MFD LED cell driver
+ *
+ * Copyright (C) 2021-2022 Valve Corporation
+ *
+ */
+
+#include <linux/acpi.h>
+#include <linux/leds.h>
+#include <linux/platform_device.h>
+
+struct steamdeck_led {
+	struct acpi_device *adev;
+	struct led_classdev cdev;
+};
+
+static int steamdeck_leds_brightness_set(struct led_classdev *cdev,
+					 enum led_brightness value)
+{
+	struct steamdeck_led *sd = container_of(cdev, struct steamdeck_led,
+						cdev);
+
+	if (ACPI_FAILURE(acpi_execute_simple_method(sd->adev->handle,
+						    "CHBV", value)))
+		return -EIO;
+
+	return 0;
+}
+
+static int steamdeck_leds_probe(struct platform_device *pdev)
+{
+  	struct device *dev = &pdev->dev;
+	struct steamdeck_led *sd;
+	int ret;
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+
+	sd->adev = ACPI_COMPANION(dev->parent);
+
+	sd->cdev.name = "status:white";
+	sd->cdev.brightness_set_blocking = steamdeck_leds_brightness_set;
+	sd->cdev.max_brightness = 100;
+
+	ret = devm_led_classdev_register(dev, &sd->cdev);
+	if (ret) {
+		dev_err(dev, "Failed to register LEDs device: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct platform_device_id steamdeck_leds_id_table[] = {
+	{ .name = "steamdeck-leds" },
+	{}
+};
+MODULE_DEVICE_TABLE(platform, steamdeck_leds_id_table);
+
+static struct platform_driver steamdeck_leds_driver = {
+	.probe = steamdeck_leds_probe,
+	.driver = {
+		.name = "steamdeck-leds",
+	},
+	.id_table = steamdeck_leds_id_table,
+};
+module_platform_driver(steamdeck_leds_driver);
+
+MODULE_AUTHOR("Andrey Smirnov <andrew.smirnov@gmail.com>");
+MODULE_DESCRIPTION("Steam Deck LEDs driver");
+MODULE_LICENSE("GPL");
-- 
2.52.0


From 385209fb63a2a737a1a7772624f8cf465ffcb018 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Mon, 20 Nov 2023 05:42:03 -0800
Subject: [PATCH 004/112] leds-steamdeck: Add support for LED birghtness
 multiplier

Add support for LED birghtness multiplier exposed via custom sysfs
attribute (led_brightness_multiplier).

Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
(cherry picked from commit c4ea057992e189ec8821cde3a65e2cc0529a5088)
(cherry picked from commit e90fb9bec45c15c0c541ce60b994bab3922ddadf)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/leds/leds-steamdeck.c | 49 +++++++++++++++++++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/drivers/leds/leds-steamdeck.c b/drivers/leds/leds-steamdeck.c
index 686500b8d..ada9fffc0 100644
--- a/drivers/leds/leds-steamdeck.c
+++ b/drivers/leds/leds-steamdeck.c
@@ -16,6 +16,54 @@ struct steamdeck_led {
 	struct led_classdev cdev;
 };
 
+static ssize_t led_brightness_multiplier_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	struct led_classdev *cdev = dev_get_drvdata(dev);
+	struct steamdeck_led *sd = container_of(cdev, struct steamdeck_led,
+						cdev);
+	unsigned long long led_brightness_multiplier;
+
+	if (ACPI_FAILURE(acpi_evaluate_integer(sd->adev->handle,
+					       "GLDM",
+					       NULL,
+					       &led_brightness_multiplier)))
+		return -EIO;
+
+
+	return sprintf(buf, "%llu", led_brightness_multiplier);
+}
+
+static ssize_t led_brightness_multiplier_store(struct device *dev,
+					       struct device_attribute *attr,
+					       const char *buf, size_t count)
+{
+	struct led_classdev *cdev = dev_get_drvdata(dev);
+	struct steamdeck_led *sd = container_of(cdev, struct steamdeck_led,
+						cdev);
+	unsigned long value;
+
+	if (kstrtoul(buf, 10, &value) || value > 100)
+		return -EINVAL;
+
+
+	if (ACPI_FAILURE(acpi_execute_simple_method(sd->adev->handle,
+						    "SLDM", value)))
+		return -EIO;
+
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(led_brightness_multiplier);
+
+static struct attribute *steamdeck_led_attrs[] = {
+	&dev_attr_led_brightness_multiplier.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(steamdeck_led);
+
 static int steamdeck_leds_brightness_set(struct led_classdev *cdev,
 					 enum led_brightness value)
 {
@@ -44,6 +92,7 @@ static int steamdeck_leds_probe(struct platform_device *pdev)
 	sd->cdev.name = "status:white";
 	sd->cdev.brightness_set_blocking = steamdeck_leds_brightness_set;
 	sd->cdev.max_brightness = 100;
+	sd->cdev.groups = steamdeck_led_groups;
 
 	ret = devm_led_classdev_register(dev, &sd->cdev);
 	if (ret) {
-- 
2.52.0


From 301c3d9cf842563bee99d0f62c0e641dcdf56b36 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sun, 27 Feb 2022 14:46:08 -0800
Subject: [PATCH 005/112] extcon: Add driver for Steam Deck

(cherry picked from commit f9f2eddae582ae39d5f89c1218448fc259b90aa8)
[cristian: fwd-ported to v6.8]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/extcon/Kconfig            |   7 ++
 drivers/extcon/Makefile           |   1 +
 drivers/extcon/extcon-steamdeck.c | 180 ++++++++++++++++++++++++++++++
 3 files changed, 188 insertions(+)
 create mode 100644 drivers/extcon/extcon-steamdeck.c

diff --git a/drivers/extcon/Kconfig b/drivers/extcon/Kconfig
index aec46bf03..2b26545df 100644
--- a/drivers/extcon/Kconfig
+++ b/drivers/extcon/Kconfig
@@ -227,4 +227,11 @@ config EXTCON_RTK_TYPE_C
 	  The DHC (Digital Home Hub) RTD series SoC contains a type c module.
 	  This driver will detect the status of the type-c port.
 
+config EXTCON_STEAMDECK
+	tristate "Steam Deck extcon support"
+	depends on MFD_STEAMDECK
+	help
+	  Say Y here to enable support of USB Type C cable detection extcon
+	  support on Steam Deck devices
+
 endif
diff --git a/drivers/extcon/Makefile b/drivers/extcon/Makefile
index 6482f2bfd..770dceb94 100644
--- a/drivers/extcon/Makefile
+++ b/drivers/extcon/Makefile
@@ -28,3 +28,4 @@ obj-$(CONFIG_EXTCON_USB_GPIO)	+= extcon-usb-gpio.o
 obj-$(CONFIG_EXTCON_USBC_CROS_EC) += extcon-usbc-cros-ec.o
 obj-$(CONFIG_EXTCON_USBC_TUSB320) += extcon-usbc-tusb320.o
 obj-$(CONFIG_EXTCON_RTK_TYPE_C) += extcon-rtk-type-c.o
+obj-$(CONFIG_EXTCON_STEAMDECK)  += extcon-steamdeck.o
diff --git a/drivers/extcon/extcon-steamdeck.c b/drivers/extcon/extcon-steamdeck.c
new file mode 100644
index 000000000..74f190adc
--- /dev/null
+++ b/drivers/extcon/extcon-steamdeck.c
@@ -0,0 +1,180 @@
+
+#include <linux/acpi.h>
+#include <linux/platform_device.h>
+#include <linux/extcon-provider.h>
+
+#define ACPI_STEAMDECK_NOTIFY_STATUS	0x80
+
+/* 0 - port connected, 1 -port disconnected */
+#define ACPI_STEAMDECK_PORT_CONNECT	BIT(0)
+/* 0 - Upstream Facing Port, 1 - Downdstream Facing Port */
+#define ACPI_STEAMDECK_CUR_DATA_ROLE	BIT(3)
+/*
+ * Debouncing delay to allow negotiation process to settle. 2s value
+ * was arrived at via trial and error.
+ */
+#define STEAMDECK_ROLE_SWITCH_DELAY	(msecs_to_jiffies(2000))
+
+struct steamdeck_extcon {
+	struct acpi_device *adev;
+	struct delayed_work role_work;
+	struct extcon_dev *edev;
+	struct device *dev;
+};
+
+static int steamdeck_read_pdcs(struct steamdeck_extcon *sd, unsigned long long *pdcs)
+{
+	acpi_status status;
+
+	status = acpi_evaluate_integer(sd->adev->handle, "PDCS", NULL, pdcs);
+	if (ACPI_FAILURE(status)) {
+		dev_err(sd->dev, "PDCS evaluation failed: %s\n",
+			acpi_format_exception(status));
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void steamdeck_usb_role_work(struct work_struct *work)
+{
+	struct steamdeck_extcon *sd =
+		container_of(work, struct steamdeck_extcon, role_work.work);
+	unsigned long long pdcs;
+	bool usb_host;
+
+	if (steamdeck_read_pdcs(sd, &pdcs))
+		return;
+
+	/*
+	 * We only care about these two
+	 */
+	pdcs &= ACPI_STEAMDECK_PORT_CONNECT | ACPI_STEAMDECK_CUR_DATA_ROLE;
+
+	/*
+	 * For "connect" events our role is determined by a bit in
+	 * PDCS, for "disconnect" we switch to being a gadget
+	 * unconditionally. The thinking for the latter is we don't
+	 * want to start acting as a USB host until we get
+	 * confirmation from the firmware that we are a USB host
+	 */
+	usb_host = (pdcs & ACPI_STEAMDECK_PORT_CONNECT) ?
+		pdcs & ACPI_STEAMDECK_CUR_DATA_ROLE : false;
+
+	dev_dbg(sd->dev, "USB role is %s\n", usb_host ? "host" : "device");
+	WARN_ON(extcon_set_state_sync(sd->edev, EXTCON_USB_HOST,
+				      usb_host));
+
+}
+
+static void steamdeck_notify(acpi_handle handle, u32 event, void *context)
+{
+	struct device *dev = context;
+	struct steamdeck_extcon *sd = dev_get_drvdata(dev);
+	unsigned long long pdcs;
+	unsigned long delay;
+
+	switch (event) {
+	case ACPI_STEAMDECK_NOTIFY_STATUS:
+		if (steamdeck_read_pdcs(sd, &pdcs))
+			return;
+		/*
+		 * We process "disconnect" events immediately and
+		 * "connect" events with a delay to give the HW time
+		 * to settle. For example attaching USB hub (at least
+		 * for HW used for testing) will generate intermediary
+		 * event with "host" bit not set, followed by the one
+		 * that does have it set.
+		 */
+		delay = (pdcs & ACPI_STEAMDECK_PORT_CONNECT) ?
+			STEAMDECK_ROLE_SWITCH_DELAY : 0;
+
+		queue_delayed_work(system_long_wq, &sd->role_work, delay);
+		break;
+	default:
+		dev_warn(dev, "Unsupported event [0x%x]\n", event);
+	}
+}
+
+static void steamdeck_remove_notify_handler(void *data)
+{
+	struct steamdeck_extcon *sd = data;
+
+	acpi_remove_notify_handler(sd->adev->handle, ACPI_DEVICE_NOTIFY,
+				   steamdeck_notify);
+	cancel_delayed_work_sync(&sd->role_work);
+}
+
+static const unsigned int steamdeck_extcon_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_CHG_USB_SDP,
+	EXTCON_CHG_USB_CDP,
+	EXTCON_CHG_USB_DCP,
+	EXTCON_CHG_USB_ACA,
+	EXTCON_NONE,
+};
+
+static int steamdeck_extcon_probe(struct platform_device *pdev)
+{
+  	struct device *dev = &pdev->dev;
+	struct steamdeck_extcon *sd;
+	acpi_status status;
+	int ret;
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+
+	INIT_DELAYED_WORK(&sd->role_work, steamdeck_usb_role_work);
+	platform_set_drvdata(pdev, sd);
+	sd->adev = ACPI_COMPANION(dev->parent);
+	sd->dev  = dev;
+	sd->edev = devm_extcon_dev_allocate(dev, steamdeck_extcon_cable);
+	if (IS_ERR(sd->edev))
+		return PTR_ERR(sd->edev);
+
+	ret = devm_extcon_dev_register(dev, sd->edev);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register extcon device: %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * Set initial role value
+	 */
+	queue_delayed_work(system_long_wq, &sd->role_work, 0);
+	flush_delayed_work(&sd->role_work);
+
+	status = acpi_install_notify_handler(sd->adev->handle,
+					     ACPI_DEVICE_NOTIFY,
+					     steamdeck_notify,
+					     dev);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Error installing ACPI notify handler\n");
+		return -EIO;
+	}
+
+	ret = devm_add_action_or_reset(dev, steamdeck_remove_notify_handler,
+				       sd);
+	return ret;
+}
+
+static const struct platform_device_id steamdeck_extcon_id_table[] = {
+	{ .name = "steamdeck-extcon" },
+	{}
+};
+MODULE_DEVICE_TABLE(platform, steamdeck_extcon_id_table);
+
+static struct platform_driver steamdeck_extcon_driver = {
+	.probe = steamdeck_extcon_probe,
+	.driver = {
+		.name = "steamdeck-extcon",
+	},
+	.id_table = steamdeck_extcon_id_table,
+};
+module_platform_driver(steamdeck_extcon_driver);
+
+MODULE_AUTHOR("Andrey Smirnov <andrew.smirnov@gmail.com>");
+MODULE_DESCRIPTION("Steam Deck extcon driver");
+MODULE_LICENSE("GPL");
-- 
2.52.0


From e48d49b4d863d6be7928715da0912c90c0bf74a1 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sat, 19 Feb 2022 16:09:45 -0800
Subject: [PATCH 006/112] hwmon: Add driver for Steam Deck's EC sensors

Add driver for sensors exposed by EC firmware on Steam Deck hardware.

(cherry picked from commit 6917aac77bee6185ae3920b936cdbe7876118c0b)
[fwd-ported to v6.11]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/hwmon/Kconfig           |  11 ++
 drivers/hwmon/Makefile          |   1 +
 drivers/hwmon/steamdeck-hwmon.c | 224 ++++++++++++++++++++++++++++++++
 3 files changed, 236 insertions(+)
 create mode 100644 drivers/hwmon/steamdeck-hwmon.c

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 157678b82..abe0ff79c 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -2170,6 +2170,17 @@ config SENSORS_SCH5636
 	  This driver can also be built as a module. If so, the module
 	  will be called sch5636.
 
+config SENSORS_STEAMDECK
+	tristate "Steam Deck EC sensors"
+	depends on MFD_STEAMDECK
+	help
+	  If you say yes here you get support for the hardware
+	  monitoring features exposed by EC firmware on Steam Deck
+	  devices
+
+	  This driver can also be built as a module. If so, the module
+	  will be called steamdeck-hwmon.
+
 config SENSORS_STTS751
 	tristate "ST Microelectronics STTS751"
 	depends on I2C
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index eade8e3b1..a103c887c 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -220,6 +220,7 @@ obj-$(CONFIG_SENSORS_SMSC47M1)	+= smsc47m1.o
 obj-$(CONFIG_SENSORS_SMSC47M192)+= smsc47m192.o
 obj-$(CONFIG_SENSORS_SPARX5)	+= sparx5-temp.o
 obj-$(CONFIG_SENSORS_SPD5118)	+= spd5118.o
+obj-$(CONFIG_SENSORS_STEAMDECK) += steamdeck-hwmon.o
 obj-$(CONFIG_SENSORS_STTS751)	+= stts751.o
 obj-$(CONFIG_SENSORS_SURFACE_FAN)+= surface_fan.o
 obj-$(CONFIG_SENSORS_SURFACE_TEMP)+= surface_temp.o
diff --git a/drivers/hwmon/steamdeck-hwmon.c b/drivers/hwmon/steamdeck-hwmon.c
new file mode 100644
index 000000000..fab9e9460
--- /dev/null
+++ b/drivers/hwmon/steamdeck-hwmon.c
@@ -0,0 +1,224 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Steam Deck EC sensors driver
+ *
+ * Copyright (C) 2021-2022 Valve Corporation
+ */
+
+#include <linux/acpi.h>
+#include <linux/hwmon.h>
+#include <linux/platform_device.h>
+
+#define STEAMDECK_HWMON_NAME	"steamdeck-hwmon"
+
+struct steamdeck_hwmon {
+	struct acpi_device *adev;
+};
+
+static long
+steamdeck_hwmon_get(struct steamdeck_hwmon *sd, const char *method)
+{
+	unsigned long long val;
+	if (ACPI_FAILURE(acpi_evaluate_integer(sd->adev->handle,
+					       (char *)method, NULL, &val)))
+		return -EIO;
+
+	return val;
+}
+
+static int
+steamdeck_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+		     u32 attr, int channel, long *out)
+{
+	struct steamdeck_hwmon *sd = dev_get_drvdata(dev);
+
+	switch (type) {
+	case hwmon_curr:
+		if (attr != hwmon_curr_input)
+			return -EOPNOTSUPP;
+
+		*out = steamdeck_hwmon_get(sd, "PDAM");
+		if (*out < 0)
+			return *out;
+		break;
+	case hwmon_in:
+		if (attr != hwmon_in_input)
+			return -EOPNOTSUPP;
+
+		*out = steamdeck_hwmon_get(sd, "PDVL");
+		if (*out < 0)
+			return *out;
+		break;
+	case hwmon_temp:
+		if (attr != hwmon_temp_input)
+			return -EOPNOTSUPP;
+
+		*out = steamdeck_hwmon_get(sd, "BATT");
+		if (*out < 0)
+			return *out;
+		/*
+		 * Assuming BATT returns deg C we need to mutiply it
+		 * by 1000 to convert to mC
+		 */
+		*out *= 1000;
+		break;
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			*out = steamdeck_hwmon_get(sd, "FANR");
+			if (*out < 0)
+				return *out;
+			break;
+		case hwmon_fan_target:
+			*out = steamdeck_hwmon_get(sd, "FSSR");
+			if (*out < 0)
+				return *out;
+			break;
+		case hwmon_fan_fault:
+			*out = steamdeck_hwmon_get(sd, "FANC");
+			if (*out < 0)
+				return *out;
+			/*
+			 * FANC (Fan check):
+			 * 0: Abnormal
+			 * 1: Normal
+			 */
+			*out = !*out;
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int
+steamdeck_hwmon_read_string(struct device *dev, enum hwmon_sensor_types type,
+			    u32 attr, int channel, const char **str)
+{
+	switch (type) {
+		/*
+		 * These two aren't, strictly speaking, measured. EC
+		 * firmware just reports what PD negotiation resulted
+		 * in.
+		 */
+	case hwmon_curr:
+		*str = "PD Contract Current";
+		break;
+	case hwmon_in:
+		*str = "PD Contract Voltage";
+		break;
+	case hwmon_temp:
+		*str = "Battery Temp";
+		break;
+	case hwmon_fan:
+		*str = "System Fan";
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int
+steamdeck_hwmon_write(struct device *dev, enum hwmon_sensor_types type,
+		      u32 attr, int channel, long val)
+{
+	struct steamdeck_hwmon *sd = dev_get_drvdata(dev);
+
+	if (type != hwmon_fan ||
+	    attr != hwmon_fan_target)
+		return -EOPNOTSUPP;
+
+	val = clamp_val(val, 0, 7300);
+
+	if (ACPI_FAILURE(acpi_execute_simple_method(sd->adev->handle,
+						    "FANS", val)))
+		return -EIO;
+
+	return 0;
+}
+
+static umode_t
+steamdeck_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,
+			   u32 attr, int channel)
+{
+	if (type == hwmon_fan &&
+	    attr == hwmon_fan_target)
+		return 0644;
+
+	return 0444;
+}
+
+static const struct hwmon_channel_info *steamdeck_hwmon_info[] = {
+	HWMON_CHANNEL_INFO(in,
+			   HWMON_I_INPUT | HWMON_I_LABEL),
+	HWMON_CHANNEL_INFO(curr,
+			   HWMON_C_INPUT | HWMON_C_LABEL),
+	HWMON_CHANNEL_INFO(temp,
+			   HWMON_T_INPUT | HWMON_T_LABEL),
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_LABEL |
+			   HWMON_F_TARGET | HWMON_F_FAULT),
+	NULL
+};
+
+static const struct hwmon_ops steamdeck_hwmon_ops = {
+	.is_visible = steamdeck_hwmon_is_visible,
+	.read = steamdeck_hwmon_read,
+	.read_string = steamdeck_hwmon_read_string,
+	.write = steamdeck_hwmon_write,
+};
+
+static const struct hwmon_chip_info steamdeck_hwmon_chip_info = {
+	.ops = &steamdeck_hwmon_ops,
+	.info = steamdeck_hwmon_info,
+};
+
+static int steamdeck_hwmon_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct steamdeck_hwmon *sd;
+	struct device *hwmon;
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+
+	sd->adev = ACPI_COMPANION(dev->parent);
+	hwmon = devm_hwmon_device_register_with_info(dev,
+						     "steamdeck_hwmon",
+						     sd,
+						     &steamdeck_hwmon_chip_info,
+						     NULL);
+	if (IS_ERR(hwmon)) {
+		dev_err(dev, "Failed to register HWMON device");
+		return PTR_ERR(hwmon);
+	}
+
+	return 0;
+}
+
+static const struct platform_device_id steamdeck_hwmon_id_table[] = {
+	{ .name = STEAMDECK_HWMON_NAME },
+	{}
+};
+MODULE_DEVICE_TABLE(platform, steamdeck_hwmon_id_table);
+
+static struct platform_driver steamdeck_hwmon_driver = {
+	.probe = steamdeck_hwmon_probe,
+	.driver = {
+		.name = STEAMDECK_HWMON_NAME,
+	},
+	.id_table = steamdeck_hwmon_id_table,
+};
+module_platform_driver(steamdeck_hwmon_driver);
+
+MODULE_AUTHOR("Andrey Smirnov <andrew.smirnov@gmail.com>");
+MODULE_DESCRIPTION("Steam Deck EC sensors driver");
+MODULE_LICENSE("GPL");
-- 
2.52.0


From c40bc478b015caf0ba42ad32defc0fb1404406eb Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sat, 15 Jul 2023 12:58:54 -0700
Subject: [PATCH 007/112] hwmon: steamdeck-hwmon: Add support for max battery
 level/rate

Add support for max battery level/charge rate attributes.

Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
(cherry picked from commit 50af83e8fd75dc52221edd3fb6fd7a7f70c4d8a4)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/hwmon/steamdeck-hwmon.c | 72 ++++++++++++++++++++++++++++++++-
 1 file changed, 71 insertions(+), 1 deletion(-)

diff --git a/drivers/hwmon/steamdeck-hwmon.c b/drivers/hwmon/steamdeck-hwmon.c
index fab9e9460..9d0a5471b 100644
--- a/drivers/hwmon/steamdeck-hwmon.c
+++ b/drivers/hwmon/steamdeck-hwmon.c
@@ -180,6 +180,76 @@ static const struct hwmon_chip_info steamdeck_hwmon_chip_info = {
 	.info = steamdeck_hwmon_info,
 };
 
+
+static ssize_t
+steamdeck_hwmon_simple_store(struct device *dev, const char *buf, size_t count,
+			     const char *method,
+			     unsigned long upper_limit)
+{
+	struct steamdeck_hwmon *sd = dev_get_drvdata(dev);
+	unsigned long value;
+
+	if (kstrtoul(buf, 10, &value) || value >= upper_limit)
+		return -EINVAL;
+
+	if (ACPI_FAILURE(acpi_execute_simple_method(sd->adev->handle,
+						    (char *)method, value)))
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t
+steamdeck_hwmon_simple_show(struct device *dev, char *buf,
+			    const char *method)
+{
+	struct steamdeck_hwmon *sd = dev_get_drvdata(dev);
+	unsigned long value;
+
+	value = steamdeck_hwmon_get(sd, method);
+	if (value < 0)
+		return value;
+
+	return sprintf(buf, "%ld\n", value);
+}
+
+#define STEAMDECK_HWMON_ATTR_RW(_name, _set_method, _get_method,	\
+				_upper_limit)				\
+	static ssize_t _name##_show(struct device *dev,			\
+				    struct device_attribute *attr,	\
+				    char *buf)				\
+	{								\
+		return steamdeck_hwmon_simple_show(dev, buf,		\
+						   _get_method);	\
+	}								\
+	static ssize_t _name##_store(struct device *dev,		\
+				     struct device_attribute *attr,	\
+				     const char *buf, size_t count)	\
+	{								\
+		return steamdeck_hwmon_simple_store(dev, buf, count,	\
+						    _set_method,	\
+						    _upper_limit);	\
+	}								\
+	static DEVICE_ATTR_RW(_name)
+
+STEAMDECK_HWMON_ATTR_RW(max_battery_charge_level, "FCBL", "SFBL", 101);
+STEAMDECK_HWMON_ATTR_RW(max_battery_charge_rate,  "CHGR", "GCHR", 101);
+
+static struct attribute *steamdeck_hwmon_attributes[] = {
+	&dev_attr_max_battery_charge_level.attr,
+	&dev_attr_max_battery_charge_rate.attr,
+	NULL
+};
+
+static const struct attribute_group steamdeck_hwmon_group = {
+	.attrs = steamdeck_hwmon_attributes,
+};
+
+static const struct attribute_group *steamdeck_hwmon_groups[] = {
+	&steamdeck_hwmon_group,
+	NULL
+};
+
 static int steamdeck_hwmon_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -195,7 +265,7 @@ static int steamdeck_hwmon_probe(struct platform_device *pdev)
 						     "steamdeck_hwmon",
 						     sd,
 						     &steamdeck_hwmon_chip_info,
-						     NULL);
+						     steamdeck_hwmon_groups);
 	if (IS_ERR(hwmon)) {
 		dev_err(dev, "Failed to register HWMON device");
 		return PTR_ERR(hwmon);
-- 
2.52.0


From 074dc48521c4efc780bd1b7a3e6fc43014c317ba Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Fri, 2 Sep 2022 19:13:12 +0300
Subject: [PATCH 008/112] usb: dwc3: Hardcode jupiter ACPI device as extcon
 name

Hardcode jupiter ACPI device as extcon name in order to connect the
two together. This is really a hack and should really be coming from
our ACPI tables.

(cherry picked from commit 190ce1057f9bafd3ca4e11e7cda286c234666196)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>

[Fwd port to 6.0]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/usb/dwc3/dwc3-pci.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c
index 6ecadc81b..9ce961c8b 100644
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@ -195,6 +195,7 @@ static const struct property_entry dwc3_pci_mr_properties[] = {
 	PROPERTY_ENTRY_BOOL("usb-role-switch"),
 	PROPERTY_ENTRY_STRING("role-switch-default-mode", "host"),
 	PROPERTY_ENTRY_BOOL("linux,sysdev_is_parent"),
+	PROPERTY_ENTRY_STRING("linux,extcon-name", "VLV0100:00"),
 	{}
 };
 
-- 
2.52.0


From 1f2a0a6bf87e0d4067fc7c7276271a0bfce4a15d Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sat, 29 Oct 2022 15:25:21 -0700
Subject: [PATCH 009/112] usb: dwc3: Drop "usb-role-swtich" from
 dwc3_pci_mr_properties

Having both "usb-role-swtich" and "linux,extcon-name" is a conflicting
configuration since the two are mutually exclusive. This wasn't a
problem before since "linux,extcon-name" had a priority, but recent
change in the kernel changed that, breaking Deck's role detection
integration.

Fix this by dropping "usb-role-switch" (and "role-switch-default-mode"
with it), to allow dwc3 driver to use extcon as it should.

(cherry picked from commit 498d5dccfac3e71b95fe3b9d6a156f15b6028aec)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/usb/dwc3/dwc3-pci.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c
index 9ce961c8b..d3105e97f 100644
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@ -192,8 +192,6 @@ static const struct property_entry dwc3_pci_amd_properties[] = {
 
 static const struct property_entry dwc3_pci_mr_properties[] = {
 	PROPERTY_ENTRY_STRING("dr_mode", "otg"),
-	PROPERTY_ENTRY_BOOL("usb-role-switch"),
-	PROPERTY_ENTRY_STRING("role-switch-default-mode", "host"),
 	PROPERTY_ENTRY_BOOL("linux,sysdev_is_parent"),
 	PROPERTY_ENTRY_STRING("linux,extcon-name", "VLV0100:00"),
 	{}
-- 
2.52.0


From 929d432621cb85982b94881d58dfb0ea76e16048 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sun, 27 Feb 2022 16:34:23 -0800
Subject: [PATCH 010/112] usb: dwc3: Fix "linux,extcon-name"

(cherry picked from commit 601ff3cebe00d1d5e4f165f4ac69a8ec0a57549e)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/usb/dwc3/dwc3-pci.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c
index d3105e97f..21cbaaaaf 100644
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@ -193,7 +193,7 @@ static const struct property_entry dwc3_pci_amd_properties[] = {
 static const struct property_entry dwc3_pci_mr_properties[] = {
 	PROPERTY_ENTRY_STRING("dr_mode", "otg"),
 	PROPERTY_ENTRY_BOOL("linux,sysdev_is_parent"),
-	PROPERTY_ENTRY_STRING("linux,extcon-name", "VLV0100:00"),
+	PROPERTY_ENTRY_STRING("linux,extcon-name", "steamdeck-extcon"),
 	{}
 };
 
-- 
2.52.0


From 0902bc0084247e76cb00ae5d55ef8c808b8bafbd Mon Sep 17 00:00:00 2001
From: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date: Fri, 26 Jul 2024 23:51:33 +0300
Subject: [PATCH 011/112] media: platform: cros-ec: Add AMD Lilac to the match
 table

Original commit: d03c74b3643b ("add missing lilac chromeos entry")

Co-developed-by: Pierre-Loup A. Griffais <pgriffais@valvesoftware.com>
Signed-off-by: Pierre-Loup A. Griffais <pgriffais@valvesoftware.com>
[fwd-ported to v6.11]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/media/cec/platform/cros-ec/cros-ec-cec.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/media/cec/platform/cros-ec/cros-ec-cec.c b/drivers/media/cec/platform/cros-ec/cros-ec-cec.c
index 419b9a7ab..22282578a 100644
--- a/drivers/media/cec/platform/cros-ec/cros-ec-cec.c
+++ b/drivers/media/cec/platform/cros-ec/cros-ec-cec.c
@@ -296,6 +296,7 @@ struct cec_dmi_match {
 };
 
 static const char *const port_b_conns[] = { "Port B", NULL };
+static const char *const port_c_conns[] = { "Port C", NULL };
 static const char *const port_db_conns[] = { "Port D", "Port B", NULL };
 static const char *const port_ba_conns[] = { "Port B", "Port A", NULL };
 static const char *const port_ab_conns[] = { "Port A", "Port B", NULL };
@@ -334,6 +335,8 @@ static const struct cec_dmi_match cec_dmi_match_table[] = {
 	{ "Google", "Dirks", "0000:00:02.0", port_ab_conns },
 	/* Google Moxie */
 	{ "Google", "Moxie", "0000:00:02.0", port_b_conns },
+	/* AMD Lilac */
+	{ "AMD", "Lilac", "0000:06:00.0", port_c_conns },
 };
 
 static struct device *cros_ec_cec_find_hdmi_dev(struct device *dev,
-- 
2.52.0


From 0ebea1482c31621faf02b1ca2afc9e50e453f3f5 Mon Sep 17 00:00:00 2001
From: Ethan Geller <ethang@valvesoftware.com>
Date: Thu, 16 Nov 2023 21:31:48 +0000
Subject: [PATCH 012/112] ASoC: max98388: Fix power on when resuming from
 suspend

Fix Max98388 issue where speakers would not be powered on when we resume
from S3.

The issue was that when we flush the regmap to the amp on resume, we
were also flushing a value of 1 to the SW_RESET pin.

Theoretically, this is fixed by marking the SW_RESET register volatile.
However, we did not observe a fix after marking the register volatile,
so we opted for a more complete fix of ensuring SW_RESET is zero in our
regmap after we have waited for the reset loop to be complete.

(cherry picked from commit c0c65da7ca4b0a4f93272f5e932dd7eed90703c8)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 sound/soc/codecs/max98388.c | 24 ++++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/sound/soc/codecs/max98388.c b/sound/soc/codecs/max98388.c
index 076f15a98..42f1e0b7f 100644
--- a/sound/soc/codecs/max98388.c
+++ b/sound/soc/codecs/max98388.c
@@ -390,27 +390,43 @@ static void max98388_reset(struct max98388_priv *max98388, struct device *dev)
 {
 	int ret, reg, count;
 
+
 	/* Software Reset */
 	ret = regmap_update_bits(max98388->regmap,
 				 MAX98388_R2000_SW_RESET,
 				 MAX98388_SOFT_RESET,
 				 MAX98388_SOFT_RESET);
-	if (ret)
+
+	if (ret) {
 		dev_err(dev, "Reset command failed. (ret:%d)\n", ret);
+		goto exit;
+	}
+
 
 	count = 0;
 	while (count < 3) {
 		usleep_range(10000, 11000);
+
 		/* Software Reset Verification */
 		ret = regmap_read(max98388->regmap,
 				  MAX98388_R22FF_REV_ID, &reg);
+
 		if (!ret) {
 			dev_info(dev, "Reset completed (retry:%d)\n", count);
-			return;
+			goto exit;
 		}
 		count++;
 	}
+
 	dev_err(dev, "Reset failed. (ret:%d)\n", ret);
+
+
+exit:
+	regcache_cache_only(max98388->regmap, true);
+	ret = regmap_update_bits(max98388->regmap,
+				 MAX98388_R2000_SW_RESET,
+				 MAX98388_SOFT_RESET, 0);
+	regcache_cache_only(max98388->regmap, false);
 }
 
 static int max98388_probe(struct snd_soc_component *component)
@@ -419,6 +435,7 @@ static int max98388_probe(struct snd_soc_component *component)
 
 	/* Software Reset */
 	max98388_reset(max98388, component->dev);
+	usleep_range(400, 1000);
 
 	/* General channel source configuration */
 	regmap_write(max98388->regmap,
@@ -812,6 +829,7 @@ static bool max98388_readable_register(struct device *dev,
 	case MAX98388_R210E_AUTO_RESTART:
 	case MAX98388_R210F_GLOBAL_EN:
 	case MAX98388_R22FF_REV_ID:
+	case MAX98388_R2000_SW_RESET:
 		return true;
 	default:
 		return false;
@@ -824,6 +842,7 @@ static bool max98388_volatile_reg(struct device *dev, unsigned int reg)
 	case MAX98388_R2001_INT_RAW1 ... MAX98388_R2005_INT_STATE2:
 	case MAX98388_R210F_GLOBAL_EN:
 	case MAX98388_R22FF_REV_ID:
+	case MAX98388_R2000_SW_RESET:
 		return true;
 	default:
 		return false;
@@ -867,6 +886,7 @@ static int max98388_resume(struct device *dev)
 
 	regcache_cache_only(max98388->regmap, false);
 	max98388_reset(max98388, dev);
+	usleep_range(400, 1000);
 	regcache_sync(max98388->regmap);
 
 	return 0;
-- 
2.52.0


From 1e41edb236b8977bd197ee2a4ad36564916b1e26 Mon Sep 17 00:00:00 2001
From: Christian Marcheselli <christianm@valvesoftware.com>
Date: Fri, 31 Mar 2023 15:21:25 -0700
Subject: [PATCH 013/112] Added in Quectel patches for bluetooth

[Fwd-ported to v6.11.6]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 include/net/bluetooth/hci.h      |  1 +
 include/net/bluetooth/hci_core.h |  2 +-
 net/bluetooth/hci_core.c         | 10 +++++-----
 net/bluetooth/mgmt.c             |  4 ++--
 4 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/include/net/bluetooth/hci.h b/include/net/bluetooth/hci.h
index a27cd3626..df156ed2c 100644
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@ -486,6 +486,7 @@ enum {
 #define HCI_CMD_TIMEOUT		msecs_to_jiffies(2000)	/* 2 seconds */
 #define HCI_NCMD_TIMEOUT	msecs_to_jiffies(4000)	/* 4 seconds */
 #define HCI_ACL_TX_TIMEOUT	msecs_to_jiffies(45000)	/* 45 seconds */
+#define HCI_AUTO_ON_TIMEOUT	msecs_to_jiffies(200)	/* 0.2 seconds */
 #define HCI_AUTO_OFF_TIMEOUT	msecs_to_jiffies(2000)	/* 2 seconds */
 #define HCI_ACL_CONN_TIMEOUT	msecs_to_jiffies(20000)	/* 20 seconds */
 #define HCI_LE_CONN_TIMEOUT	msecs_to_jiffies(20000)	/* 20 seconds */
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4263e71a2..0d22c87a0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -497,7 +497,7 @@ struct hci_dev {
 	struct workqueue_struct	*workqueue;
 	struct workqueue_struct	*req_workqueue;
 
-	struct work_struct	power_on;
+	struct delayed_work	power_on;
 	struct delayed_work	power_off;
 	struct work_struct	error_reset;
 	struct work_struct	cmd_sync_work;
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index 8ccec73dc..978d73eb9 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -519,7 +519,7 @@ int hci_dev_close(__u16 dev)
 		goto done;
 	}
 
-	cancel_work_sync(&hdev->power_on);
+	cancel_delayed_work(&hdev->power_on);
 	if (hci_dev_test_and_clear_flag(hdev, HCI_AUTO_OFF))
 		cancel_delayed_work(&hdev->power_off);
 
@@ -942,7 +942,7 @@ static const struct rfkill_ops hci_rfkill_ops = {
 
 static void hci_power_on(struct work_struct *work)
 {
-	struct hci_dev *hdev = container_of(work, struct hci_dev, power_on);
+	struct hci_dev *hdev = container_of(work, struct hci_dev, power_on.work);
 	int err;
 
 	BT_DBG("%s", hdev->name);
@@ -2547,7 +2547,7 @@ struct hci_dev *hci_alloc_dev_priv(int sizeof_priv)
 	INIT_WORK(&hdev->rx_work, hci_rx_work);
 	INIT_WORK(&hdev->cmd_work, hci_cmd_work);
 	INIT_WORK(&hdev->tx_work, hci_tx_work);
-	INIT_WORK(&hdev->power_on, hci_power_on);
+	INIT_DELAYED_WORK(&hdev->power_on, hci_power_on);
 	INIT_WORK(&hdev->error_reset, hci_error_reset);
 
 	hci_cmd_sync_init(hdev);
@@ -2668,7 +2668,7 @@ int hci_register_dev(struct hci_dev *hdev)
 	if (error)
 		BT_WARN("register suspend notifier failed error:%d\n", error);
 
-	queue_work(hdev->req_workqueue, &hdev->power_on);
+	queue_delayed_work(hdev->req_workqueue, &hdev->power_on,HCI_AUTO_ON_TIMEOUT);
 
 	idr_init(&hdev->adv_monitors_idr);
 	msft_register(hdev);
@@ -2705,7 +2705,7 @@ void hci_unregister_dev(struct hci_dev *hdev)
 	disable_work_sync(&hdev->rx_work);
 	disable_work_sync(&hdev->cmd_work);
 	disable_work_sync(&hdev->tx_work);
-	disable_work_sync(&hdev->power_on);
+	disable_delayed_work(&hdev->power_on);
 	disable_work_sync(&hdev->error_reset);
 
 	hci_cmd_sync_clear(hdev);
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index 0e46f9e08..df4689b26 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -8100,7 +8100,7 @@ static int set_external_config(struct sock *sk, struct hci_dev *hdev,
 			hci_dev_set_flag(hdev, HCI_CONFIG);
 			hci_dev_set_flag(hdev, HCI_AUTO_OFF);
 
-			queue_work(hdev->req_workqueue, &hdev->power_on);
+			queue_work(hdev->req_workqueue, &hdev->power_on.work);
 		} else {
 			set_bit(HCI_RAW, &hdev->flags);
 			mgmt_index_added(hdev);
@@ -8156,7 +8156,7 @@ static int set_public_address(struct sock *sk, struct hci_dev *hdev,
 		hci_dev_set_flag(hdev, HCI_CONFIG);
 		hci_dev_set_flag(hdev, HCI_AUTO_OFF);
 
-		queue_work(hdev->req_workqueue, &hdev->power_on);
+		queue_work(hdev->req_workqueue, &hdev->power_on.work);
 	}
 
 unlock:
-- 
2.52.0


From ad8893b3c4500b455d4cf282d16502710fe4bda4 Mon Sep 17 00:00:00 2001
From: "Pierre-Loup A. Griffais" <pgriffais@valvesoftware.com>
Date: Tue, 23 May 2023 19:01:49 -0700
Subject: [PATCH 014/112] acpi match based on Quanta's 11T09 bios

[Fwd-ported from v6.5]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/bluetooth/hci_qca.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/bluetooth/hci_qca.c b/drivers/bluetooth/hci_qca.c
index 888176b0f..7cadd6227 100644
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@ -2735,6 +2735,7 @@ static const struct acpi_device_id qca_bluetooth_acpi_match[] = {
 	{ "DLA16390", (kernel_ulong_t)&qca_soc_data_qca6390 },
 	{ "DLB16390", (kernel_ulong_t)&qca_soc_data_qca6390 },
 	{ "DLB26390", (kernel_ulong_t)&qca_soc_data_qca6390 },
+	{ "QCOM2066", (kernel_ulong_t)&qca_soc_data_qca2066 },
 	{ },
 };
 MODULE_DEVICE_TABLE(acpi, qca_bluetooth_acpi_match);
-- 
2.52.0


From 4e4d81e66504bc707c0e7a8b030cd0ef1f1fee4d Mon Sep 17 00:00:00 2001
From: Rolando Roca <rolandor@valvesoftware.com>
Date: Fri, 22 Sep 2023 14:23:12 -0700
Subject: [PATCH 015/112] Bluetooth: Fixed an issue where the Steam Deck could
 not into sleep because it continued advertizing after the Steam Controller
 was disconnected.

<Change Type>: Poor experience

<<< Test Notes >>>
<Test-Proposal>:
1)BT BR/EDR gamepad wakeup function
1)BT BLE gamepad wakeup function
<Stress-Test>: Y

[Fwd-ported from v6.5]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 net/bluetooth/hci_sync.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/bluetooth/hci_sync.c b/net/bluetooth/hci_sync.c
index cbc3a75d7..589aba62a 100644
--- a/net/bluetooth/hci_sync.c
+++ b/net/bluetooth/hci_sync.c
@@ -6218,7 +6218,7 @@ int hci_suspend_sync(struct hci_dev *hdev)
 
 	if (hci_conn_count(hdev)) {
 		/* Soft disconnect everything (power off) */
-		err = hci_disconnect_all_sync(hdev, HCI_ERROR_REMOTE_POWER_OFF);
+		err = hci_disconnect_all_sync(hdev, HCI_ERROR_REMOTE_USER_TERM);
 		if (err) {
 			/* Set state to BT_RUNNING so resume doesn't notify */
 			hdev->suspend_state = BT_RUNNING;
-- 
2.52.0


From 29571855d85854ebd8f8d8b8bbd8932f6ace6bbf Mon Sep 17 00:00:00 2001
From: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date: Mon, 22 Apr 2024 13:23:25 +0300
Subject: [PATCH 016/112] Bluetooth: hci_sync: Fix BLE devices turning wakeup
 on/off

This is part 1 from initial patch provided by
  "zhongjun.yu" <zhongjun.yu@quectel.com>
and ported to v6.5:

1) Fixed an issue where BLE devices could not turn wakeup on or off.
2) Resolved an issue where bluez lib could not receive
   MGMT_EV_DEVICE_FLAGS_CHANGED notifications after sending
   MGMT_OP_SET_DEVICE_FLAGS

<Change Type>: Develop the function to set the Bluetooth device wake-up
switch

<<< Test Notes >>>
<Test-Proposal>:
1) python script set_wakeup.py
2) valve sw guys Developing UI validation
<Stress-Test>: Y

[fwd-ported to v6.11 and dropped part 2 due to a breakage with BlueZ 5.78+]
Link: https://gitlab.steamos.cloud/holo-team/tasks/-/issues/1456
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 net/bluetooth/hci_sync.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/net/bluetooth/hci_sync.c b/net/bluetooth/hci_sync.c
index 589aba62a..3d724479d 100644
--- a/net/bluetooth/hci_sync.c
+++ b/net/bluetooth/hci_sync.c
@@ -2749,6 +2749,7 @@ static u8 hci_update_accept_list_sync(struct hci_dev *hdev)
 	struct bdaddr_list *b, *t;
 	u8 num_entries = 0;
 	bool pend_conn, pend_report;
+	struct hci_conn_params *conn_params;
 	u8 filter_policy;
 	size_t i, n;
 	int err;
@@ -2826,6 +2827,15 @@ static u8 hci_update_accept_list_sync(struct hci_dev *hdev)
 			continue;
 		}
 
+		/* During suspend, only wakeable devices can be in acceptlist */
+		conn_params = hci_conn_params_lookup(hdev,&b->bdaddr,b->bdaddr_type);
+		if (conn_params && hdev->suspended &&
+		    !(conn_params->flags & HCI_CONN_FLAG_REMOTE_WAKEUP)) {
+			hci_le_del_accept_list_sync(hdev, &b->bdaddr,
+						    b->bdaddr_type);
+			continue;
+		}
+
 		num_entries++;
 	}
 
-- 
2.52.0


From 1c76dd5dc6fa1bcc21432c781b739a0c64a334a4 Mon Sep 17 00:00:00 2001
From: Robert Beckett <bob.beckett@collabora.com>
Date: Thu, 21 Nov 2024 21:12:03 +0000
Subject: [PATCH 017/112] Bluetooth: btrtl: add suspend handling to ignore
 BT_DIS

With new fw, btrtl can be set to ignore the BT_DIS
pin that is usually asserted during suspend.
This allows the device to be a wakeup source and
allows us to wakeup via bluetooth peripherals.

Signed-off-by: Robert Beckett <bob.beckett@collabora.com>
[Rebased onto v6.11.[4,5] to fix conflicts on drivers/bluetooth/btusb.c]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/bluetooth/btrtl.c | 144 ++++++++++++++++++++++++++++++++++++++
 drivers/bluetooth/btrtl.h |  13 ++++
 drivers/bluetooth/btusb.c |  16 +++++
 3 files changed, 173 insertions(+)

diff --git a/drivers/bluetooth/btrtl.c b/drivers/bluetooth/btrtl.c
index 5603b282f..1ecf85f2e 100644
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@ -9,6 +9,7 @@
 #include <linux/firmware.h>
 #include <linux/unaligned.h>
 #include <linux/usb.h>
+#include <linux/dmi.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
@@ -51,6 +52,9 @@
 #define	RTL_CHIP_SUBVER (&(struct rtl_vendor_cmd) {{0x10, 0x38, 0x04, 0x28, 0x80}})
 #define	RTL_CHIP_REV    (&(struct rtl_vendor_cmd) {{0x10, 0x3A, 0x04, 0x28, 0x80}})
 #define	RTL_SEC_PROJ    (&(struct rtl_vendor_cmd) {{0x10, 0xA4, 0xAD, 0x00, 0xb0}})
+#define	RTL_IGNORE_MASK (&(struct rtl_vendor_cmd) {{0x10, 0x34, 0x60, 0x00, 0xb0}})
+
+#define	RTL_IGNORE_BT_DIS BIT(0)
 
 #define RTL_PATCH_SNIPPETS		0x01
 #define RTL_PATCH_DUMMY_HEADER		0x02
@@ -449,6 +453,58 @@ static int btrtl_vendor_read_reg16(struct hci_dev *hdev,
 	return 0;
 }
 
+static int btrtl_vendor_read_reg16_unlocked(struct hci_dev *hdev,
+					    struct rtl_vendor_cmd *cmd, u8 *rp)
+{
+	int ret;
+
+	hci_req_sync_lock(hdev);
+	ret = btrtl_vendor_read_reg16(hdev, cmd, rp);
+	hci_req_sync_unlock(hdev);
+
+	return ret;
+}
+
+static int btrtl_vendor_write_reg16(struct hci_dev *hdev,
+				    struct rtl_vendor_cmd *cmd, const u8 * const rp)
+{
+	struct sk_buff *skb;
+	u8 buf[sizeof(*cmd) + 2];
+	int err = 0;
+
+	memcpy(buf, cmd, sizeof(*cmd));
+	memcpy(buf + sizeof(*cmd), rp, 2);
+
+	skb = __hci_cmd_sync(hdev, 0xfc62, sizeof(buf), buf, HCI_INIT_TIMEOUT);
+	if (IS_ERR(skb)) {
+		err = PTR_ERR(skb);
+		rtl_dev_err(hdev, "RTL: Write reg16 failed (%d)", err);
+		return err;
+	}
+
+	if (skb->len != 1 || skb->data[0]) {
+		bt_dev_err(hdev, "RTL: Write reg16 length mismatch");
+		kfree_skb(skb);
+		return -EIO;
+	}
+
+	kfree_skb(skb);
+
+	return 0;
+}
+
+static int btrtl_vendor_write_reg16_unlocked(struct hci_dev *hdev,
+					    struct rtl_vendor_cmd *cmd, u8 *rp)
+{
+	int ret;
+
+	hci_req_sync_lock(hdev);
+	ret = btrtl_vendor_write_reg16(hdev, cmd, rp);
+	hci_req_sync_unlock(hdev);
+
+	return ret;
+}
+
 static void *rtl_iov_pull_data(struct rtl_iovec *iov, u32 len)
 {
 	void *data = iov->data;
@@ -1297,8 +1353,44 @@ int btrtl_download_firmware(struct hci_dev *hdev,
 }
 EXPORT_SYMBOL_GPL(btrtl_download_firmware);
 
+static const struct dmi_system_id btrtl_can_ignore_bt_dis_table[] = {
+	{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Valve"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Jupiter"),
+		},
+	},
+	{}
+};
+
+static bool btrtl_fw_can_ignore_bt_dis(struct hci_dev *hdev)
+{
+	struct sk_buff *skb;
+	struct hci_rp_read_local_version *rp;
+	bool ret = false;
+
+	if (!dmi_check_system(btrtl_can_ignore_bt_dis_table))
+		return false;
+
+	skb = btrtl_read_local_version(hdev);
+	if (IS_ERR(skb))
+		return false;
+
+	rp = (struct hci_rp_read_local_version *)skb->data;
+	if (le16_to_cpu(rp->hci_rev) == 0x98d7 &&
+	    le16_to_cpu(rp->lmp_subver) == 0x081e)
+		ret = true;
+
+	kfree_skb(skb);
+
+	return ret;
+}
+
 void btrtl_set_quirks(struct hci_dev *hdev, struct btrtl_device_info *btrtl_dev)
 {
+	if (btrtl_fw_can_ignore_bt_dis(hdev))
+		btrealtek_set_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS);
+
 	/* Enable controller to do both LE scan and BR/EDR inquiry
 	 * simultaneously.
 	 */
@@ -1511,6 +1603,58 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 }
 EXPORT_SYMBOL_GPL(btrtl_get_uart_settings);
 
+int btrtl_early_suspend(struct hci_dev *hdev)
+{
+	int ret = 0;
+	u16 ignore_mask;
+	u8 buf[2];
+
+	if (!btrealtek_test_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS))
+		return -EOPNOTSUPP;
+
+	if (hci_dev_test_flag(hdev, HCI_POWERING_DOWN))
+		return 0;
+
+	ret = btrtl_vendor_read_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+	if (ret)
+		return ret;
+
+	ignore_mask = get_unaligned_le16(buf);
+	ignore_mask |= RTL_IGNORE_BT_DIS;
+	put_unaligned_le16(ignore_mask, buf);
+
+	ret = btrtl_vendor_write_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(btrtl_early_suspend);
+
+int btrtl_late_resume(struct hci_dev *hdev)
+{
+	int ret = 0;
+	u16 ignore_mask;
+	u8 buf[2];
+
+	if (!btrealtek_test_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS))
+		return -EOPNOTSUPP;
+
+	if (hci_dev_test_flag(hdev, HCI_POWERING_DOWN))
+		return 0;
+
+	ret = btrtl_vendor_read_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+	if (ret)
+		return ret;
+
+	ignore_mask = get_unaligned_le16(buf);
+	ignore_mask &= ~RTL_IGNORE_BT_DIS;
+	put_unaligned_le16(ignore_mask, buf);
+
+	ret = btrtl_vendor_write_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(btrtl_late_resume);
+
 MODULE_AUTHOR("Daniel Drake <drake@endlessm.com>");
 MODULE_DESCRIPTION("Bluetooth support for Realtek devices ver " VERSION);
 MODULE_VERSION(VERSION);
diff --git a/drivers/bluetooth/btrtl.h b/drivers/bluetooth/btrtl.h
index a2d9d34f9..61be34ccb 100644
--- a/drivers/bluetooth/btrtl.h
+++ b/drivers/bluetooth/btrtl.h
@@ -105,6 +105,7 @@ struct rtl_vendor_cmd {
 
 enum {
 	REALTEK_ALT6_CONTINUOUS_TX_CHIP,
+	REALTEK_CAN_IGNORE_BT_DIS,
 
 	__REALTEK_NUM_FLAGS,
 };
@@ -148,6 +149,8 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 			    unsigned int *controller_baudrate,
 			    u32 *device_baudrate, bool *flow_control);
 void btrtl_set_driver_name(struct hci_dev *hdev, const char *driver_name);
+int btrtl_early_suspend(struct hci_dev *hdev);
+int btrtl_late_resume(struct hci_dev *hdev);
 
 #else
 
@@ -195,4 +198,14 @@ static inline void btrtl_set_driver_name(struct hci_dev *hdev, const char *drive
 {
 }
 
+static inline int btrtl_early_suspend(struct hci_dev *hdev, pm_message_t message)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int btrtl_late_resume(struct hci_dev *hdev)
+{
+	return -EOPNOTSUPP;
+}
+
 #endif
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index ded09e94d..77c96a6d4 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -963,9 +963,11 @@ struct btusb_data {
 
 	int (*setup_on_usb)(struct hci_dev *hdev);
 
+	int (*early_suspend)(struct hci_dev *hdev);
 	int (*suspend)(struct hci_dev *hdev);
 	int (*resume)(struct hci_dev *hdev);
 	int (*disconnect)(struct hci_dev *hdev);
+	int (*late_resume)(struct hci_dev *hdev);
 
 	int oob_wake_irq;   /* irq for out-of-band wake-on-bt */
 
@@ -4300,6 +4302,8 @@ static int btusb_probe(struct usb_interface *intf,
 		hdev->shutdown = btrtl_shutdown_realtek;
 		hdev->reset = btusb_rtl_reset;
 		hdev->hw_error = btusb_rtl_hw_error;
+		data->early_suspend = btrtl_early_suspend;
+		data->late_resume = btrtl_late_resume;
 
 		/* Realtek devices need to set remote wakeup on auto-suspend */
 		set_bit(BTUSB_WAKEUP_AUTOSUSPEND, &data->flags);
@@ -4466,6 +4470,8 @@ static void btusb_disconnect(struct usb_interface *intf)
 static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct btusb_data *data = usb_get_intfdata(intf);
+	struct hci_dev *hdev = data->hdev;
+	int ret = 0;
 
 	BT_DBG("intf %p", intf);
 
@@ -4478,6 +4484,11 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 	if (data->suspend_count++)
 		return 0;
 
+	if (data->early_suspend)
+		ret = data->early_suspend(hdev);
+	if (ret && ret != -EOPNOTSUPP)
+		return ret;
+
 	spin_lock_irq(&data->txlock);
 	if (!(PMSG_IS_AUTO(message) && data->tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &data->flags);
@@ -4605,6 +4616,11 @@ static int btusb_resume(struct usb_interface *intf)
 	spin_unlock_irq(&data->txlock);
 	schedule_work(&data->work);
 
+	if (data->late_resume)
+		err = data->late_resume(hdev);
+	if (err && err != -EOPNOTSUPP)
+		goto done;
+
 	return 0;
 
 failed:
-- 
2.52.0


From 9022b61fe4f281c7e652eaf20e26ac606b4f51ad Mon Sep 17 00:00:00 2001
From: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date: Sat, 9 Dec 2023 20:03:30 +0200
Subject: [PATCH 018/112] ASoC: amd: acp: Use correct DAI link ID for BT codec

Commit 671dd2ffbd8b ("ASoC: amd: acp: Add new cpu dai and dailink
creation for I2S BT instance") added I2S BT support in ACP common
machine driver, but using an unexpected BT_BE_ID set to 3 instead of 2:

[ 7.799659] snd_sof_amd_vangogh 0000:04:00.5: Firmware info: version 0:0:0-7863d
[ 7.803906] snd_sof_amd_vangogh 0000:04:00.5: Firmware: ABI 3:26:0 Kernel ABI 3:23:0
[ 7.872873] snd_sof_amd_vangogh 0000:04:00.5: Topology: ABI 3:26:0 Kernel ABI 3:23:0
[ 8.508218] sof_mach nau8821-max: ASoC: physical link acp-bt-codec (id 2) not exist
[ 8.513468] sof_mach nau8821-max: ASoC: topology: could not load header: -22
[ 8.518853] snd_sof_amd_vangogh 0000:04:00.5: error: tplg component load failed -22
[ 8.524049] snd_sof_amd_vangogh 0000:04:00.5: error: failed to load DSP topology -22
[ 8.529230] snd_sof_amd_vangogh 0000:04:00.5: ASoC: error at snd_soc_component_probe on 0000:04:00.5: -22
[ 8.534465] sof_mach nau8821-max: ASoC: failed to instantiate card -22
[ 8.539820] sof_mach nau8821-max: error -EINVAL: Failed to register card(sof-nau8821-max)
[ 8.545022] sof_mach: probe of nau8821-max failed with error -22

Move BT_BE_ID to position 2 in the enum, as expected by the current
topology found on Steam Deck.

Note this is not accepted upstream as it would break the other devices
which rely on BT_BE_ID set to 3.  The proper solution would be to update
the topology file on Steam Deck.

Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 sound/soc/amd/acp/acp-mach.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sound/soc/amd/acp/acp-mach.h b/sound/soc/amd/acp/acp-mach.h
index f94c30c20..c3b3f0479 100644
--- a/sound/soc/amd/acp/acp-mach.h
+++ b/sound/soc/amd/acp/acp-mach.h
@@ -29,8 +29,8 @@
 enum be_id {
 	HEADSET_BE_ID = 0,
 	AMP_BE_ID,
-	DMIC_BE_ID,
 	BT_BE_ID,
+	DMIC_BE_ID,
 };
 
 enum cpu_endpoints {
-- 
2.52.0


From df642e7c82f35e0bc1b20396b4d59f40860cd9e4 Mon Sep 17 00:00:00 2001
From: Ethan Geller <ethang@valvesoftware.com>
Date: Fri, 18 Oct 2024 22:14:18 +0000
Subject: [PATCH 019/112] ASoC: nau8821: Reset 8821 clock on start

This fixes the 3.5mm sound hissing bug, it is unclear if this needs to stay
or get fixed in FW, as of now.

Signed-off-by: Ethan Geller <ethang@valvesoftware.com>
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 sound/soc/codecs/nau8821.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/sound/soc/codecs/nau8821.c b/sound/soc/codecs/nau8821.c
index 3beb3c44d..bcb36187f 100644
--- a/sound/soc/codecs/nau8821.c
+++ b/sound/soc/codecs/nau8821.c
@@ -1418,6 +1418,10 @@ static int nau8821_set_fll(struct snd_soc_component *component,
 	mdelay(2);
 	regmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,
 		NAU8821_CLK_SRC_MASK, NAU8821_CLK_SRC_VCO);
+	regmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,
+		NAU8821_CLK_SRC_MASK, NAU8821_CLK_SRC_MCLK);
+	regmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,
+		NAU8821_CLK_SRC_MASK, NAU8821_CLK_SRC_VCO);
 
 	return 0;
 }
-- 
2.52.0


From 0999320acd497698ffce67f14c36ca13a1cdc760 Mon Sep 17 00:00:00 2001
From: Robert Beckett <bob.beckett@collabora.com>
Date: Tue, 18 Feb 2025 19:24:07 +0000
Subject: [PATCH 020/112] fixup! [FOR-UPSTREAM] Bluetooth: btrtl: add suspend
 handling to ignore BT_DIS

Turns out 5/7 call chains that can lead to the close flushing the
request work come from another work item, most of which don't set any
state that we can gate the enabling on.

Given the number of possible paths that this can end up with a guranteed
lock inversion issue, it seems more prudent to rely on the same
guarantees that made the original btrtl code not need to lock, which
was to only do requests at start of day before registering with the
HCI subsystem so that no lock taking is ever required.

This commit simplifies the design considerably, and avoids any chance
of the lock inversion happing.

Signed-off-by: Robert Beckett <bob.beckett@collabora.com>
---
 drivers/bluetooth/btrtl.c | 107 +++++++++-----------------------------
 drivers/bluetooth/btrtl.h |  13 -----
 drivers/bluetooth/btusb.c |  16 ------
 3 files changed, 24 insertions(+), 112 deletions(-)

diff --git a/drivers/bluetooth/btrtl.c b/drivers/bluetooth/btrtl.c
index 1ecf85f2e..85991c259 100644
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@ -453,18 +453,6 @@ static int btrtl_vendor_read_reg16(struct hci_dev *hdev,
 	return 0;
 }
 
-static int btrtl_vendor_read_reg16_unlocked(struct hci_dev *hdev,
-					    struct rtl_vendor_cmd *cmd, u8 *rp)
-{
-	int ret;
-
-	hci_req_sync_lock(hdev);
-	ret = btrtl_vendor_read_reg16(hdev, cmd, rp);
-	hci_req_sync_unlock(hdev);
-
-	return ret;
-}
-
 static int btrtl_vendor_write_reg16(struct hci_dev *hdev,
 				    struct rtl_vendor_cmd *cmd, const u8 * const rp)
 {
@@ -493,18 +481,6 @@ static int btrtl_vendor_write_reg16(struct hci_dev *hdev,
 	return 0;
 }
 
-static int btrtl_vendor_write_reg16_unlocked(struct hci_dev *hdev,
-					    struct rtl_vendor_cmd *cmd, u8 *rp)
-{
-	int ret;
-
-	hci_req_sync_lock(hdev);
-	ret = btrtl_vendor_write_reg16(hdev, cmd, rp);
-	hci_req_sync_unlock(hdev);
-
-	return ret;
-}
-
 static void *rtl_iov_pull_data(struct rtl_iovec *iov, u32 len)
 {
 	void *data = iov->data;
@@ -1363,33 +1339,49 @@ static const struct dmi_system_id btrtl_can_ignore_bt_dis_table[] = {
 	{}
 };
 
-static bool btrtl_fw_can_ignore_bt_dis(struct hci_dev *hdev)
+static void btrtl_handle_fw_can_ignore_bt_dis(struct hci_dev *hdev)
 {
 	struct sk_buff *skb;
 	struct hci_rp_read_local_version *rp;
-	bool ret = false;
+	bool can_ignore = false;
+	u16 ignore_mask;
+	u8 buf[2];
+	int ret;
 
 	if (!dmi_check_system(btrtl_can_ignore_bt_dis_table))
-		return false;
+		return;
 
 	skb = btrtl_read_local_version(hdev);
 	if (IS_ERR(skb))
-		return false;
+		return;
 
 	rp = (struct hci_rp_read_local_version *)skb->data;
 	if (le16_to_cpu(rp->hci_rev) == 0x98d7 &&
 	    le16_to_cpu(rp->lmp_subver) == 0x081e)
-		ret = true;
+		can_ignore = true;
 
 	kfree_skb(skb);
+	if (!can_ignore)
+		return;
 
-	return ret;
+	ret = btrtl_vendor_read_reg16(hdev, RTL_IGNORE_MASK, buf);
+	if (ret) {
+		rtl_dev_warn(hdev, "failed to read ignore mask, will not wake on bluetooth");
+		return;
+	}
+
+	ignore_mask = get_unaligned_le16(buf);
+	ignore_mask |= RTL_IGNORE_BT_DIS;
+	put_unaligned_le16(ignore_mask, buf);
+
+	ret = btrtl_vendor_write_reg16(hdev, RTL_IGNORE_MASK, buf);
+	if (ret)
+		rtl_dev_warn(hdev, "failed to write ignore mask, will not wake on bluetooth");
 }
 
 void btrtl_set_quirks(struct hci_dev *hdev, struct btrtl_device_info *btrtl_dev)
 {
-	if (btrtl_fw_can_ignore_bt_dis(hdev))
-		btrealtek_set_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS);
+	btrtl_handle_fw_can_ignore_bt_dis(hdev);
 
 	/* Enable controller to do both LE scan and BR/EDR inquiry
 	 * simultaneously.
@@ -1603,57 +1595,6 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 }
 EXPORT_SYMBOL_GPL(btrtl_get_uart_settings);
 
-int btrtl_early_suspend(struct hci_dev *hdev)
-{
-	int ret = 0;
-	u16 ignore_mask;
-	u8 buf[2];
-
-	if (!btrealtek_test_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS))
-		return -EOPNOTSUPP;
-
-	if (hci_dev_test_flag(hdev, HCI_POWERING_DOWN))
-		return 0;
-
-	ret = btrtl_vendor_read_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
-	if (ret)
-		return ret;
-
-	ignore_mask = get_unaligned_le16(buf);
-	ignore_mask |= RTL_IGNORE_BT_DIS;
-	put_unaligned_le16(ignore_mask, buf);
-
-	ret = btrtl_vendor_write_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(btrtl_early_suspend);
-
-int btrtl_late_resume(struct hci_dev *hdev)
-{
-	int ret = 0;
-	u16 ignore_mask;
-	u8 buf[2];
-
-	if (!btrealtek_test_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS))
-		return -EOPNOTSUPP;
-
-	if (hci_dev_test_flag(hdev, HCI_POWERING_DOWN))
-		return 0;
-
-	ret = btrtl_vendor_read_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
-	if (ret)
-		return ret;
-
-	ignore_mask = get_unaligned_le16(buf);
-	ignore_mask &= ~RTL_IGNORE_BT_DIS;
-	put_unaligned_le16(ignore_mask, buf);
-
-	ret = btrtl_vendor_write_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(btrtl_late_resume);
 
 MODULE_AUTHOR("Daniel Drake <drake@endlessm.com>");
 MODULE_DESCRIPTION("Bluetooth support for Realtek devices ver " VERSION);
diff --git a/drivers/bluetooth/btrtl.h b/drivers/bluetooth/btrtl.h
index 61be34ccb..a2d9d34f9 100644
--- a/drivers/bluetooth/btrtl.h
+++ b/drivers/bluetooth/btrtl.h
@@ -105,7 +105,6 @@ struct rtl_vendor_cmd {
 
 enum {
 	REALTEK_ALT6_CONTINUOUS_TX_CHIP,
-	REALTEK_CAN_IGNORE_BT_DIS,
 
 	__REALTEK_NUM_FLAGS,
 };
@@ -149,8 +148,6 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 			    unsigned int *controller_baudrate,
 			    u32 *device_baudrate, bool *flow_control);
 void btrtl_set_driver_name(struct hci_dev *hdev, const char *driver_name);
-int btrtl_early_suspend(struct hci_dev *hdev);
-int btrtl_late_resume(struct hci_dev *hdev);
 
 #else
 
@@ -198,14 +195,4 @@ static inline void btrtl_set_driver_name(struct hci_dev *hdev, const char *drive
 {
 }
 
-static inline int btrtl_early_suspend(struct hci_dev *hdev, pm_message_t message)
-{
-	return -EOPNOTSUPP;
-}
-
-static inline int btrtl_late_resume(struct hci_dev *hdev)
-{
-	return -EOPNOTSUPP;
-}
-
 #endif
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 77c96a6d4..ded09e94d 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -963,11 +963,9 @@ struct btusb_data {
 
 	int (*setup_on_usb)(struct hci_dev *hdev);
 
-	int (*early_suspend)(struct hci_dev *hdev);
 	int (*suspend)(struct hci_dev *hdev);
 	int (*resume)(struct hci_dev *hdev);
 	int (*disconnect)(struct hci_dev *hdev);
-	int (*late_resume)(struct hci_dev *hdev);
 
 	int oob_wake_irq;   /* irq for out-of-band wake-on-bt */
 
@@ -4302,8 +4300,6 @@ static int btusb_probe(struct usb_interface *intf,
 		hdev->shutdown = btrtl_shutdown_realtek;
 		hdev->reset = btusb_rtl_reset;
 		hdev->hw_error = btusb_rtl_hw_error;
-		data->early_suspend = btrtl_early_suspend;
-		data->late_resume = btrtl_late_resume;
 
 		/* Realtek devices need to set remote wakeup on auto-suspend */
 		set_bit(BTUSB_WAKEUP_AUTOSUSPEND, &data->flags);
@@ -4470,8 +4466,6 @@ static void btusb_disconnect(struct usb_interface *intf)
 static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct btusb_data *data = usb_get_intfdata(intf);
-	struct hci_dev *hdev = data->hdev;
-	int ret = 0;
 
 	BT_DBG("intf %p", intf);
 
@@ -4484,11 +4478,6 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 	if (data->suspend_count++)
 		return 0;
 
-	if (data->early_suspend)
-		ret = data->early_suspend(hdev);
-	if (ret && ret != -EOPNOTSUPP)
-		return ret;
-
 	spin_lock_irq(&data->txlock);
 	if (!(PMSG_IS_AUTO(message) && data->tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &data->flags);
@@ -4616,11 +4605,6 @@ static int btusb_resume(struct usb_interface *intf)
 	spin_unlock_irq(&data->txlock);
 	schedule_work(&data->work);
 
-	if (data->late_resume)
-		err = data->late_resume(hdev);
-	if (err && err != -EOPNOTSUPP)
-		goto done;
-
 	return 0;
 
 failed:
-- 
2.52.0


From 0ebb9c422922f8f65bdbfe8be352bf363849d5dc Mon Sep 17 00:00:00 2001
From: Swapnil Patel <swapatel@amd.com>
Date: Tue, 21 Nov 2023 17:00:14 -0500
Subject: [PATCH 021/112] Add 2s delay before enabling DP link for dock

---
 .../gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c    | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
index ebd74b43e..a1f3a45f4 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
@@ -96,6 +96,8 @@
 #define FN(reg_name, field_name) \
 	hws->shifts->field_name, hws->masks->field_name
 
+static const uint8_t DP_SINK_BRANCH_DEV_NAME_KT50X0[] = "KT50X0!";
+
 struct dce110_hw_seq_reg_offsets {
 	uint32_t crtc;
 };
@@ -3327,6 +3329,13 @@ void dce110_enable_dp_link_output(
 			link->dc->res_pool->dp_clock_source;
 	const struct link_hwss *link_hwss = get_link_hwss(link, link_res);
 	unsigned int i;
+	if (link->ctx->dce_version == DCN_VERSION_3_01 &&
+	    link->dpcd_caps.sink_dev_id == DP_BRANCH_DEVICE_ID_0060AD &&
+	    memcmp(&link->dpcd_caps.branch_dev_name,
+		   DP_SINK_BRANCH_DEV_NAME_KT50X0,
+		   sizeof(link->dpcd_caps.branch_dev_name)) == 0) {
+		msleep(2000);
+	}
 
 	/*
 	 * Add the logic to extract BOTH power up and power down sequences
-- 
2.52.0


From 8452fd12ab169de145dd63e70e8a372fbbe6ef45 Mon Sep 17 00:00:00 2001
From: Andres Rodriguez <andresx7@gmail.com>
Date: Tue, 8 Nov 2022 17:32:25 -0500
Subject: [PATCH 022/112] mmc: core: add safe_trim_quirk attribute

This attribute is intended to be used by userspace tools to identify
if trimming a device is safe or not. It helps in cases where a
userspace tool is aware of the necessity of the quirk and a user
accidentally downgrades their kernel to a one that doesn't have
support for the quirk.

Signed-off-by: Andres Rodriguez <andresx7@gmail.com>
(cherry picked from commit dfc5952c55f58d0e0863ccba0aa598fdae16ed14)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/mmc/core/mmc.c    | 2 ++
 drivers/mmc/core/quirks.h | 2 ++
 drivers/mmc/core/sd.c     | 2 ++
 include/linux/mmc/card.h  | 1 +
 4 files changed, 7 insertions(+)

diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 7c86efb10..3da0044b5 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -817,6 +817,7 @@ MMC_DEV_ATTR(rel_sectors, "%#x\n", card->ext_csd.rel_sectors);
 MMC_DEV_ATTR(ocr, "0x%08x\n", card->ocr);
 MMC_DEV_ATTR(rca, "0x%04x\n", card->rca);
 MMC_DEV_ATTR(cmdq_en, "%d\n", card->ext_csd.cmdq_en);
+MMC_DEV_ATTR(safe_trim_quirk, "%d\n", card->safe_trim_quirk_version);
 
 static ssize_t mmc_fwrev_show(struct device *dev,
 			      struct device_attribute *attr,
@@ -876,6 +877,7 @@ static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_rca.attr,
 	&dev_attr_dsr.attr,
 	&dev_attr_cmdq_en.attr,
+	&dev_attr_safe_trim_quirk.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(mmc_std);
diff --git a/drivers/mmc/core/quirks.h b/drivers/mmc/core/quirks.h
index c417ed34c..e6c5eca9d 100644
--- a/drivers/mmc/core/quirks.h
+++ b/drivers/mmc/core/quirks.h
@@ -264,4 +264,6 @@ static inline void mmc_fixup_device(struct mmc_card *card,
 		dev_dbg(&card->dev, "calling %ps\n", f->vendor_fixup);
 		f->vendor_fixup(card, f->data);
 	}
+
+	card->safe_trim_quirk_version = 1;
 }
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 948948ca9..5335220f6 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -727,6 +727,7 @@ MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
 MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
 MMC_DEV_ATTR(ocr, "0x%08x\n", card->ocr);
 MMC_DEV_ATTR(rca, "0x%04x\n", card->rca);
+MMC_DEV_ATTR(safe_trim_quirk, "%d\n", card->safe_trim_quirk_version);
 
 
 static ssize_t mmc_dsr_show(struct device *dev, struct device_attribute *attr,
@@ -789,6 +790,7 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_ocr.attr,
 	&dev_attr_rca.attr,
 	&dev_attr_dsr.attr,
+	&dev_attr_safe_trim_quirk.attr,
 	NULL,
 };
 
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index e9e964c20..74d1e74c3 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -308,6 +308,7 @@ struct mmc_card {
 	unsigned int		state;		/* (our) card state */
 	unsigned int		quirks; 	/* card quirks */
 	unsigned int		quirk_max_rate;	/* max rate set by quirks */
+	unsigned int		safe_trim_quirk_version; /* advertise if we have protection for cards which misbehave with trim */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
 						/* for byte mode */
-- 
2.52.0


From 0e9090f83cd2430fd70b8197fa5a60fa4e4b1880 Mon Sep 17 00:00:00 2001
From: Zhan Liu <zhan.liu@amd.com>
Date: Thu, 27 Jan 2022 20:39:46 -0500
Subject: [PATCH 023/112] drm/amd/display: keep eDP Vdd on when eDP stream is
 already enabled

[Why]
Even if can_apply_edp_fast_boot is set to 1 at boot, this flag will
be cleared to 0 at S3 resume.

[How]
Keep eDP Vdd on when eDP stream is already enabled.

Change-Id: Idfecaac45e5ec39c5a2a4eaf9f3afa50063cfe1b
Link: https://gitlab.steamos.cloud/jupiter/tasks/uploads/d0998325ac80e21e50476749c32c16ba/0001-drm-amd-display-keep-eDP-Vdd-on-when-eDP-stream-is-a.patch
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 .../amd/display/dc/hwss/dce110/dce110_hwseq.c | 24 +++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
index a1f3a45f4..7d7896faf 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
@@ -2019,9 +2019,29 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 				break;
 			}
 		}
-		// We are trying to enable eDP, don't power down VDD
-		if (can_apply_edp_fast_boot)
+
+		/*
+		 * TO-DO: So far the code logic below only addresses single eDP case.
+		 * For dual eDP case, there are a few things that need to be
+		 * implemented first:
+		 *
+		 * 1. Change the fastboot logic above, so eDP link[0 or 1]'s
+		 * stream[0 or 1] will all be checked.
+		 *
+		 * 2. Change keep_edp_vdd_on to an array, and maintain keep_edp_vdd_on
+		 * for each eDP.
+		 *
+		 * Once above 2 things are completed, we can then change the logic below
+		 * correspondingly, so dual eDP case will be fully covered.
+		 */
+
+		// We are trying to enable eDP, don't power down VDD if eDP stream is existing
+		if ((edp_stream_num == 1 && edp_streams[0] != NULL) || can_apply_edp_fast_boot) {
 			keep_edp_vdd_on = true;
+			DC_LOG_EVENT_LINK_TRAINING("Keep eDP Vdd on\n");
+		} else {
+			DC_LOG_EVENT_LINK_TRAINING("No eDP stream enabled, turn eDP Vdd off\n");
+		}
 	}
 
 	// Check seamless boot support
-- 
2.52.0


From b95ac211d1064d571abdf45244eff08e6e273fc7 Mon Sep 17 00:00:00 2001
From: Swapnil Patel <Swapnil.Patel@amd.com>
Date: Thu, 29 Sep 2022 15:56:05 -0400
Subject: [PATCH 024/112] amd/display: Increased DP Alt mode timeout from 200ms
 to 500ms. SWDEV-358114

(cherry picked from commit 69adff1e215ea0d12569053ae2948681b80acda5)
[Fwd-ported to DC_VER 3.2.237]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/gpu/drm/amd/display/dc/link/link_detection.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/display/dc/link/link_detection.c b/drivers/gpu/drm/amd/display/dc/link/link_detection.c
index 7fa6bc97a..5261cf02d 100644
--- a/drivers/gpu/drm/amd/display/dc/link/link_detection.c
+++ b/drivers/gpu/drm/amd/display/dc/link/link_detection.c
@@ -644,7 +644,7 @@ static bool wait_for_entering_dp_alt_mode(struct dc_link *link)
 	 * 500 microseconds * 400 tries us 200 ms
 	 **/
 	unsigned int sleep_time_in_microseconds = 500;
-	unsigned int tries_allowed = 400;
+	unsigned int tries_allowed = 1000;
 	bool is_in_alt_mode;
 	unsigned long long enter_timestamp;
 	unsigned long long finish_timestamp;
-- 
2.52.0


From 519a5f49f7bfe1d9185d6f0aca7be47aac7f0e1f Mon Sep 17 00:00:00 2001
From: Swapnil Patel <swapatel@amd.com>
Date: Thu, 2 Nov 2023 16:16:49 -0400
Subject: [PATCH 025/112] Disable modes with >1200 MHz Pixel clocks when
 connected via dock

---
 drivers/gpu/drm/amd/display/dc/link/link_validation.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/drivers/gpu/drm/amd/display/dc/link/link_validation.c b/drivers/gpu/drm/amd/display/dc/link/link_validation.c
index acdc162de..53b7ea0da 100644
--- a/drivers/gpu/drm/amd/display/dc/link/link_validation.c
+++ b/drivers/gpu/drm/amd/display/dc/link/link_validation.c
@@ -35,6 +35,8 @@
 
 #define DC_LOGGER_INIT(logger)
 
+static const uint8_t DP_SINK_BRANCH_DEV_NAME_KT50X0[] = "KT50X0!";
+
 static uint32_t get_tmds_output_pixel_clock_100hz(const struct dc_crtc_timing *timing)
 {
 
@@ -292,6 +294,15 @@ static bool dp_validate_mode_timing(
 		timing->v_addressable == (uint32_t) 480)
 		return true;
 
+	if (link->ctx->dce_version == DCN_VERSION_3_01 &&
+	    link->dpcd_caps.sink_dev_id == DP_BRANCH_DEVICE_ID_0060AD &&
+	    memcmp(&link->dpcd_caps.branch_dev_name,
+		   DP_SINK_BRANCH_DEV_NAME_KT50X0,
+		   sizeof(link->dpcd_caps.branch_dev_name)) == 0) {
+		if (timing->pix_clk_100hz / 10 >= (uint32_t) 1200000)
+			return false; /* KT50X0 does not support Pxl clock >= 1200MHz */
+	}
+
 	link_setting = dp_get_verified_link_cap(link);
 
 	/* TODO: DYNAMIC_VALIDATION needs to be implemented */
-- 
2.52.0


From a9bdbe5e68de7439d8003dcbaee720f51cccaa4f Mon Sep 17 00:00:00 2001
From: Joshua Ashton <joshua@froggi.es>
Date: Tue, 13 Feb 2024 18:28:41 +0000
Subject: [PATCH 026/112] drm/amd/display: Enable 3 overlay planes for Steam
 Deck

---
 drivers/gpu/drm/amd/display/dc/dc.h                         | 2 +-
 .../drm/amd/display/dc/resource/dcn301/dcn301_resource.c    | 6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 29edfa51e..94147fcf1 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -68,7 +68,7 @@ struct dcn_dccg_reg_state;
 /**
  * MAX_SURFACES - representative of the upper bound of surfaces that can be piped to a single CRTC
  */
-#define MAX_SURFACES 4
+#define MAX_SURFACES 6
 /**
  * MAX_PLANES - representative of the upper bound of planes that are supported by the HW
  */
diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn301/dcn301_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn301/dcn301_resource.c
index 3ad6a3d48..18d2a8107 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn301/dcn301_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn301/dcn301_resource.c
@@ -1440,9 +1440,9 @@ static bool dcn301_resource_construct(
 	dc->caps.max_cursor_size = 256;
 	dc->caps.min_horizontal_blanking_period = 80;
 	dc->caps.dmdata_alloc_size = 2048;
-	dc->caps.max_slave_planes = 2;
-	dc->caps.max_slave_yuv_planes = 2;
-	dc->caps.max_slave_rgb_planes = 2;
+	dc->caps.max_slave_planes = 3;
+	dc->caps.max_slave_yuv_planes = 3;
+	dc->caps.max_slave_rgb_planes = 3;
 	dc->caps.is_apu = true;
 	dc->caps.post_blend_color_processing = true;
 	dc->caps.force_dp_tps4_for_cp2520 = true;
-- 
2.52.0


From 61d57dccae9cc6775393159396b6d60606e7db0b Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Fri, 22 Mar 2024 14:53:42 -0400
Subject: [PATCH 027/112] drm/amd/display: Don't limit YUV420 to HDMI

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
(cherry picked from commit 56c8e3cbeb24a1f15ba764bd692d5c8807bd1d55)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index a8a59126b..01356d040 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -6685,8 +6685,7 @@ static void fill_stream_properties_from_drm_display_mode(
 	timing_out->v_border_top = 0;
 	timing_out->v_border_bottom = 0;
 	/* TODO: un-hardcode */
-	if (drm_mode_is_420_only(info, mode_in)
-			&& stream->signal == SIGNAL_TYPE_HDMI_TYPE_A)
+	if (drm_mode_is_420_only(info, mode_in))
 		timing_out->pixel_encoding = PIXEL_ENCODING_YCBCR420;
 	else if (drm_mode_is_420_also(info, mode_in)
 			&& aconnector
-- 
2.52.0


From c5feab9d6b2b4bdfb7c59074a83dd2e6ef6ab6ab Mon Sep 17 00:00:00 2001
From: Hersen Wu <hersenxs.wu@amd.com>
Date: Thu, 25 May 2023 08:37:40 -0400
Subject: [PATCH 028/112] drm/amd/display: edp do not add non-edid timings

[Why] most edp support only timings from edid. applying
non-edid timings, especially those timings out of edp
bandwidth, may damage edp.

[How] do not add non-edid timings for edp.

Cc: Mario Limonciello <mario.limonciello@amd.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: stable@vger.kernel.org
Acked-by: Stylon Wang <stylon.wang@amd.com>
Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
Reviewed-by: Roman Li <roman.li@amd.com>
Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 01356d040..52c2490ed 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -8903,7 +8903,12 @@ static int amdgpu_dm_connector_get_modes(struct drm_connector *connector)
 		}
 	} else {
 		amdgpu_dm_connector_ddc_get_modes(connector, drm_edid);
-		if (encoder)
+		/* most eDP supports only timings from its edid,
+		 * usually only detailed timings are available
+		 * from eDP edid. timings which are not from edid
+		 * may damage eDP
+		 */
+		if (encoder && connector->connector_type != DRM_MODE_CONNECTOR_eDP)
 			amdgpu_dm_connector_add_common_modes(encoder, connector);
 		amdgpu_dm_connector_add_freesync_modes(connector, drm_edid);
 	}
-- 
2.52.0


From 262dd57599be2f01a6f27e67a8b364fd3b5e7070 Mon Sep 17 00:00:00 2001
From: "Pierre-Loup A. Griffais" <pgriffais@valvesoftware.com>
Date: Tue, 14 Jun 2022 14:31:18 -0700
Subject: [PATCH 029/112] drivers: video: backlight: Disable backlight
 notification events

We don't want to generate udev events for brightness changes on Steam
Deck, as some games like Celeste will re-enumerate controller devices in
response to this event.

Patch from Sam Lantinga.

(cherry picked from commit 85da5a5f7b69f22f960776cde3bf5862f3613363)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/video/backlight/backlight.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/video/backlight/backlight.c b/drivers/video/backlight/backlight.c
index 1e9b7e85d..b9af334e3 100644
--- a/drivers/video/backlight/backlight.c
+++ b/drivers/video/backlight/backlight.c
@@ -116,6 +116,7 @@ EXPORT_SYMBOL(backlight_notify_blank_all);
 static void backlight_generate_event(struct backlight_device *bd,
 				     enum backlight_update_reason reason)
 {
+#if 0 // We don't want to generate udev events for brightness changes on Steam Deck, as some games like Celeste will re-enumerate controller devices in response to this event.
 	char *envp[2];
 
 	switch (reason) {
@@ -131,6 +132,7 @@ static void backlight_generate_event(struct backlight_device *bd,
 	}
 	envp[1] = NULL;
 	kobject_uevent_env(&bd->dev.kobj, KOBJ_CHANGE, envp);
+#endif // 0
 	sysfs_notify(&bd->dev.kobj, NULL, "actual_brightness");
 }
 
-- 
2.52.0


From 00659e8660b73634602b48176fd13d77aa648294 Mon Sep 17 00:00:00 2001
From: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date: Fri, 4 Mar 2022 21:20:39 +0000
Subject: [PATCH 030/112] ACPICA: Limit error message flood caused by firmware
 bug

The following error messages are generated because of an infinite
recursion in the latest production BIOS:

ACPI Error: Method reached maximum reentrancy limit (255) (20210331/dsmethod-309)
ACPI Error: Aborting method \_SB.PCI0.LPC0.EC0.VFCD.PDVL due to previous error (AE_AML_METHOD_LIMIT) (20210331/psparse-529)
[...]
ACPI Error: Aborting method \_SB.PCI0.LPC0.EC0.VFCD.PDVL due to previous error (AE_AML_METHOD_LIMIT) (20210331/psparse-529)

Let's detect this and limit the amount of errors generated.

Additionally, add a kernel parameter 'acpi_no_msg_flood_detect' to
disable the detection for debugging purposes.

https://gitlab.steamos.cloud/jupiter/linux-integration/-/issues/11

Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/acpi/acpica/dsmethod.c |  5 ++--
 drivers/acpi/acpica/uterror.c  | 53 ++++++++++++++++++++++++++++++++++
 2 files changed, 56 insertions(+), 2 deletions(-)

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 45ec32e81..f6450854d 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -306,8 +306,9 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 	/* Prevent wraparound of thread count */
 
 	if (obj_desc->method.thread_count == ACPI_UINT8_MAX) {
-		ACPI_ERROR((AE_INFO,
-			    "Method reached maximum reentrancy limit (255)"));
+		/* Suppressing this due to firmware bug flooding the logs */
+		/*ACPI_ERROR((AE_INFO,
+			    "Method reached maximum reentrancy limit (255)"));*/
 		return_ACPI_STATUS(AE_AML_METHOD_LIMIT);
 	}
 
diff --git a/drivers/acpi/acpica/uterror.c b/drivers/acpi/acpica/uterror.c
index 918aca7c4..4a482de2e 100644
--- a/drivers/acpi/acpica/uterror.c
+++ b/drivers/acpi/acpica/uterror.c
@@ -278,6 +278,56 @@ acpi_ut_namespace_error(const char *module_name,
 }
 #endif
 
+/*******************************************************************************
+ *
+ * Limit the error message flood caused by a firmware bug:
+ *
+ * ACPI Error: Method reached maximum reentrancy limit (255) (20210331/dsmethod-309)
+ * ACPI Error: Aborting method \_SB.PCI0.LPC0.EC0.VFCD.PDVL due to previous error (AE_AML_METHOD_LIMIT) (20210331/psparse-529)
+ * [...]
+ * ACPI Error: Aborting method \_SB.PCI0.LPC0.EC0.VFCD.PDVL due to previous error (AE_AML_METHOD_LIMIT) (20210331/psparse-529)
+ *
+ ******************************************************************************/
+
+static bool acpi_disable_msg_flood_detect;
+
+static int __init acpi_no_msg_flood_detect_setup(char *s)
+{
+	acpi_disable_msg_flood_detect = true;
+	pr_info("ACPI error message flood detection disabled\n");
+
+	return 0;
+}
+
+early_param("acpi_no_msg_flood_detect", acpi_no_msg_flood_detect_setup);
+
+static bool acpi_skip_print_node(struct acpi_namespace_node *node)
+{
+	static bool skip_print = false;
+	struct acpi_buffer buffer;
+	acpi_status status;
+
+	if (acpi_disable_msg_flood_detect || !node)
+		return false;
+
+	if (!skip_print) {
+		/* Convert handle to full pathname */
+		buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+
+		status = acpi_ns_handle_to_pathname(node, &buffer, TRUE);
+		if (ACPI_SUCCESS(status)) {
+			skip_print = !strcmp((const char *)buffer.pointer,
+					     "\\_SB.PCI0.LPC0.EC0.VFCD.PDVL");
+			ACPI_FREE(buffer.pointer);
+
+			if (skip_print)
+				return false; /* print once */
+		}
+	}
+
+	return skip_print;
+}
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_method_error
@@ -305,6 +355,9 @@ acpi_ut_method_error(const char *module_name,
 	acpi_status status;
 	struct acpi_namespace_node *node = prefix_node;
 
+	if (acpi_skip_print_node(node))
+		return;
+
 	ACPI_MSG_REDIRECT_BEGIN;
 	acpi_os_printf(ACPI_MSG_ERROR);
 
-- 
2.52.0


From a177e2d38ad5fdb5e7ea190f0cf713971f9506be Mon Sep 17 00:00:00 2001
From: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
Date: Wed, 4 Dec 2019 18:30:54 -0800
Subject: [PATCH 031/112] Input: uinput - Add UI_SET_PHYS_STR and
 UI_SET_UNIQ_STR

The ioctl definition for UI_SET_PHYS is ambiguous because it is defined
with size = sizeof(char*) but is expected to be given a variable length
string. Add a deprecation notice for UI_SET_PHYS and provide
UI_SET_PHYS_STR(len) which expects a size from the user.

Also support setting the uniq attribute of the input device. The uniq
attribute is used as a unique identifier for the connected device.

For example, uinput devices created by BlueZ will store the address of
the connected device as the uniq property.

Signed-off-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
---
 drivers/input/misc/uinput.c | 48 +++++++++++++++++++++++++------------
 include/uapi/linux/uinput.h |  5 ++++
 2 files changed, 38 insertions(+), 15 deletions(-)

diff --git a/drivers/input/misc/uinput.c b/drivers/input/misc/uinput.c
index 13336a2fd..a8e7293ff 100644
--- a/drivers/input/misc/uinput.c
+++ b/drivers/input/misc/uinput.c
@@ -20,6 +20,7 @@
  */
 #include <uapi/linux/uinput.h>
 #include <linux/poll.h>
+#include <linux/printk.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/module.h>
@@ -285,7 +286,7 @@ static int uinput_dev_flush(struct input_dev *dev, struct file *file)
 
 static void uinput_destroy_device(struct uinput_device *udev)
 {
-	const char *name, *phys;
+	const char *name, *phys, *uniq;
 	struct input_dev *dev = udev->dev;
 	enum uinput_state old_state = udev->state;
 
@@ -294,6 +295,7 @@ static void uinput_destroy_device(struct uinput_device *udev)
 	if (dev) {
 		name = dev->name;
 		phys = dev->phys;
+		uniq = dev->uniq;
 		if (old_state == UIST_CREATED) {
 			uinput_flush_requests(udev);
 			input_unregister_device(dev);
@@ -302,6 +304,7 @@ static void uinput_destroy_device(struct uinput_device *udev)
 		}
 		kfree(name);
 		kfree(phys);
+		kfree(uniq);
 		udev->dev = NULL;
 	}
 }
@@ -885,6 +888,24 @@ static int uinput_str_to_user(void __user *dest, const char *str,
 	return ret ? -EFAULT : len;
 }
 
+static int uinput_get_user_str(struct uinput_device *udev, const char **kptr,
+			       const char *uptr, unsigned int size)
+{
+	char *tmp;
+
+	if (udev->state == UIST_CREATED)
+		return -EINVAL;
+
+	tmp = strndup_user(uptr, size);
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
+
+	kfree(*kptr);
+	*kptr = tmp;
+
+	return 0;
+}
+
 static long uinput_ioctl_handler(struct file *file, unsigned int cmd,
 				 unsigned long arg, void __user *p)
 {
@@ -893,7 +914,6 @@ static long uinput_ioctl_handler(struct file *file, unsigned int cmd,
 	struct uinput_ff_upload ff_up;
 	struct uinput_ff_erase  ff_erase;
 	struct uinput_request   *req;
-	char			*phys;
 	const char		*name;
 	unsigned int		size;
 
@@ -970,19 +990,8 @@ static long uinput_ioctl_handler(struct file *file, unsigned int cmd,
 		goto out;
 
 	case UI_SET_PHYS:
-		if (udev->state == UIST_CREATED) {
-			retval = -EINVAL;
-			goto out;
-		}
-
-		phys = strndup_user(p, 1024);
-		if (IS_ERR(phys)) {
-			retval = PTR_ERR(phys);
-			goto out;
-		}
-
-		kfree(udev->dev->phys);
-		udev->dev->phys = phys;
+		pr_warn_once("uinput: UI_SET_PHYS is deprecated. Use UI_SET_PHYS_STR");
+		retval = uinput_get_user_str(udev, &udev->dev->phys, p, 1024);
 		goto out;
 
 	case UI_BEGIN_FF_UPLOAD:
@@ -1077,6 +1086,15 @@ static long uinput_ioctl_handler(struct file *file, unsigned int cmd,
 	case UI_ABS_SETUP & ~IOCSIZE_MASK:
 		retval = uinput_abs_setup(udev, p, size);
 		goto out;
+
+	case UI_SET_PHYS_STR(0):
+		retval = uinput_get_user_str(udev, &udev->dev->phys, p, size);
+		goto out;
+
+	case UI_SET_UNIQ_STR(0):
+		retval = uinput_get_user_str(udev, &udev->dev->uniq, p, size);
+		goto out;
+
 	}
 
 	retval = -EINVAL;
diff --git a/include/uapi/linux/uinput.h b/include/uapi/linux/uinput.h
index c9e677e3a..84d4fa142 100644
--- a/include/uapi/linux/uinput.h
+++ b/include/uapi/linux/uinput.h
@@ -142,9 +142,14 @@ struct uinput_abs_setup {
 #define UI_SET_LEDBIT		_IOW(UINPUT_IOCTL_BASE, 105, int)
 #define UI_SET_SNDBIT		_IOW(UINPUT_IOCTL_BASE, 106, int)
 #define UI_SET_FFBIT		_IOW(UINPUT_IOCTL_BASE, 107, int)
+
+/* DEPRECATED: Data size is ambiguous. Use UI_SET_PHYS_STR instead. */
 #define UI_SET_PHYS		_IOW(UINPUT_IOCTL_BASE, 108, char*)
+
 #define UI_SET_SWBIT		_IOW(UINPUT_IOCTL_BASE, 109, int)
 #define UI_SET_PROPBIT		_IOW(UINPUT_IOCTL_BASE, 110, int)
+#define UI_SET_PHYS_STR(len)	_IOC(_IOC_WRITE, UINPUT_IOCTL_BASE, 111, len)
+#define UI_SET_UNIQ_STR(len)	_IOC(_IOC_WRITE, UINPUT_IOCTL_BASE, 112, len)
 
 #define UI_BEGIN_FF_UPLOAD	_IOWR(UINPUT_IOCTL_BASE, 200, struct uinput_ff_upload)
 #define UI_END_FF_UPLOAD	_IOW(UINPUT_IOCTL_BASE, 201, struct uinput_ff_upload)
-- 
2.52.0


From b5506560bcaa8cc97ac912ebb07311ae7f45b731 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 1 Nov 2025 11:47:03 +0100
Subject: [PATCH 032/112] HID: asus: simplify RGB init sequence

Currently, RGB initialization forks depending on whether a device is
NKEY. Then, NKEY devices are initialized using 0x5a, 0x5d, 0x5e
endpoints, and non-NKEY devices with 0x5a and then a
backlight check, which is omitted for NKEY devices.

Remove the fork, using a common initialization sequence for both,
where they are both only initialized with 0x5a, then checked for
backlight support. This patch should not affect existing functionality.

0x5d and 0x5e endpoint initializations are performed by Windows
userspace programs associated with different usages that reside under
the vendor HID. Specifically, 0x5d is used by Armoury Crate, which
controls RGB and 0x5e by an animation program for certain Asus laptops.
Neither is used currently in the driver.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 62 +++++++++++++++---------------------------
 1 file changed, 22 insertions(+), 40 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 472bca546..d99064927 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -639,50 +639,32 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 	unsigned char kbd_func;
 	int ret;
 
-	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD) {
-		/* Initialize keyboard */
-		ret = asus_kbd_init(hdev, FEATURE_KBD_REPORT_ID);
+	ret = asus_kbd_init(hdev, FEATURE_KBD_REPORT_ID);
+	if (ret < 0)
+		return ret;
+
+	/* Get keyboard functions */
+	ret = asus_kbd_get_functions(hdev, &kbd_func, FEATURE_KBD_REPORT_ID);
+	if (ret < 0)
+		return ret;
+
+	if (dmi_match(DMI_PRODUCT_FAMILY, "ProArt P16")) {
+		ret = asus_kbd_disable_oobe(hdev);
 		if (ret < 0)
 			return ret;
-
-		/* The LED endpoint is initialised in two HID */
-		ret = asus_kbd_init(hdev, FEATURE_KBD_LED_REPORT_ID1);
-		if (ret < 0)
-			return ret;
-
-		ret = asus_kbd_init(hdev, FEATURE_KBD_LED_REPORT_ID2);
-		if (ret < 0)
-			return ret;
-
-		if (dmi_match(DMI_PRODUCT_FAMILY, "ProArt P16")) {
-			ret = asus_kbd_disable_oobe(hdev);
-			if (ret < 0)
-				return ret;
-		}
-
-		if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
-			intf = to_usb_interface(hdev->dev.parent);
-			udev = interface_to_usbdev(intf);
-			validate_mcu_fw_version(hdev,
-				le16_to_cpu(udev->descriptor.idProduct));
-		}
-
-	} else {
-		/* Initialize keyboard */
-		ret = asus_kbd_init(hdev, FEATURE_KBD_REPORT_ID);
-		if (ret < 0)
-			return ret;
-
-		/* Get keyboard functions */
-		ret = asus_kbd_get_functions(hdev, &kbd_func, FEATURE_KBD_REPORT_ID);
-		if (ret < 0)
-			return ret;
-
-		/* Check for backlight support */
-		if (!(kbd_func & SUPPORT_KBD_BACKLIGHT))
-			return -ENODEV;
 	}
 
+	if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
+		intf = to_usb_interface(hdev->dev.parent);
+		udev = interface_to_usbdev(intf);
+		validate_mcu_fw_version(
+			hdev, le16_to_cpu(udev->descriptor.idProduct));
+	}
+
+	/* Check for backlight support */
+	if (!(kbd_func & SUPPORT_KBD_BACKLIGHT))
+		return -ENODEV;
+
 	drvdata->kbd_backlight = devm_kzalloc(&hdev->dev,
 					      sizeof(struct asus_kbd_leds),
 					      GFP_KERNEL);
-- 
2.52.0


From 2e714e2b1a09962e1596031c57761dc88e0463f5 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 1 Nov 2025 11:47:04 +0100
Subject: [PATCH 033/112] HID: asus: use same report_id in response

Currently, asus_kbd_get_functions prods the device using feature
report report_id, but then is hardcoded to check the response through
FEATURE_KBD_REPORT_ID. This only works if report_id is that value
(currently true). So, use report_id in the response as well to
maintain functionality if that value changes in the future.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index d99064927..69c703015 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -423,7 +423,7 @@ static int asus_kbd_get_functions(struct hid_device *hdev,
 	if (!readbuf)
 		return -ENOMEM;
 
-	ret = hid_hw_raw_request(hdev, FEATURE_KBD_REPORT_ID, readbuf,
+	ret = hid_hw_raw_request(hdev, report_id, readbuf,
 				 FEATURE_KBD_REPORT_SIZE, HID_FEATURE_REPORT,
 				 HID_REQ_GET_REPORT);
 	if (ret < 0) {
-- 
2.52.0


From 8b531b80a1e68d951b9e16ade30a141a0e295598 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 1 Nov 2025 11:47:05 +0100
Subject: [PATCH 034/112] HID: asus: fortify keyboard handshake

Handshaking with an Asus device involves sending it a feature report
with the string "ASUS Tech.Inc." and then reading it back to verify the
handshake was successful, under the feature ID the interaction will
take place.

Currently, the driver only does the first part. Add the readback to
verify the handshake was successful. As this could cause breakages,
allow the verification to fail with a dmesg error until we verify
all devices work with it (they seem to).

Since the response is more than 16 bytes, increase the buffer size
to 64 as well to avoid overflow errors.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 32 +++++++++++++++++++++++++++++---
 1 file changed, 29 insertions(+), 3 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 69c703015..0d0ced940 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -49,7 +49,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define FEATURE_REPORT_ID 0x0d
 #define INPUT_REPORT_ID 0x5d
 #define FEATURE_KBD_REPORT_ID 0x5a
-#define FEATURE_KBD_REPORT_SIZE 16
+#define FEATURE_KBD_REPORT_SIZE 64
 #define FEATURE_KBD_LED_REPORT_ID1 0x5d
 #define FEATURE_KBD_LED_REPORT_ID2 0x5e
 
@@ -394,14 +394,40 @@ static int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t bu
 
 static int asus_kbd_init(struct hid_device *hdev, u8 report_id)
 {
+	/*
+	 * The handshake is first sent as a set_report, then retrieved
+	 * from a get_report. They should be equal.
+	 */
 	const u8 buf[] = { report_id, 0x41, 0x53, 0x55, 0x53, 0x20, 0x54,
 		     0x65, 0x63, 0x68, 0x2e, 0x49, 0x6e, 0x63, 0x2e, 0x00 };
+	u8 *readbuf;
 	int ret;
 
 	ret = asus_kbd_set_report(hdev, buf, sizeof(buf));
-	if (ret < 0)
-		hid_err(hdev, "Asus failed to send init command: %d\n", ret);
+	if (ret < 0) {
+		hid_err(hdev, "Asus failed to send handshake: %d\n", ret);
+		return ret;
+	}
 
+	readbuf = kzalloc(FEATURE_KBD_REPORT_SIZE, GFP_KERNEL);
+	if (!readbuf)
+		return -ENOMEM;
+
+	ret = hid_hw_raw_request(hdev, report_id, readbuf,
+				 FEATURE_KBD_REPORT_SIZE, HID_FEATURE_REPORT,
+				 HID_REQ_GET_REPORT);
+	if (ret < 0) {
+		hid_err(hdev, "Asus failed to receive handshake ack: %d\n", ret);
+	} else if (memcmp(readbuf, buf, sizeof(buf)) != 0) {
+		hid_warn(hdev, "Asus handshake returned invalid response: %*ph\n",
+			FEATURE_KBD_REPORT_SIZE, readbuf);
+		/*
+		 * Do not return error if handshake is wrong until this is
+		 * verified to work for all devices.
+		 */
+	}
+
+	kfree(readbuf);
 	return ret;
 }
 
-- 
2.52.0


From 81c14bc788d9204b54475ed2b9f896e444cc0cf6 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 1 Nov 2025 11:47:06 +0100
Subject: [PATCH 035/112] HID: asus: prevent binding to all HID devices on ROG

Currently, when hid-asus is not loaded, NKEY keyboards load as ~6
event devices with a pretty ASUSTEK name. When it loads, it concatenates
all applications per HID endpoint, renames them, and prints errors
when some of them do not have an input device.

Therefore, change probe so that this is no longer the case. Stop
renaming the devices, omit the check for .input which causes errors
on e.g., the Z13 for some hiddev only devices, and move RGB checks
into probe.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 52 ++++++++++++++++++++++++++++--------------
 1 file changed, 35 insertions(+), 17 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 0d0ced940..3d755a34c 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -48,6 +48,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define T100CHI_MOUSE_REPORT_ID 0x06
 #define FEATURE_REPORT_ID 0x0d
 #define INPUT_REPORT_ID 0x5d
+#define HID_USAGE_PAGE_VENDOR 0xff310000
 #define FEATURE_KBD_REPORT_ID 0x5a
 #define FEATURE_KBD_REPORT_SIZE 64
 #define FEATURE_KBD_LED_REPORT_ID1 0x5d
@@ -90,6 +91,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
 #define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
 #define QUIRK_ROG_ALLY_XPAD		BIT(13)
+#define QUIRK_SKIP_REPORT_FIXUP		BIT(14)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -126,7 +128,6 @@ struct asus_drvdata {
 	struct input_dev *tp_kbd_input;
 	struct asus_kbd_leds *kbd_backlight;
 	const struct asus_touchpad_info *tp;
-	bool enable_backlight;
 	struct power_supply *battery;
 	struct power_supply_desc battery_desc;
 	int battery_capacity;
@@ -317,7 +318,7 @@ static int asus_e1239t_event(struct asus_drvdata *drvdat, u8 *data, int size)
 static int asus_event(struct hid_device *hdev, struct hid_field *field,
 		      struct hid_usage *usage, __s32 value)
 {
-	if ((usage->hid & HID_USAGE_PAGE) == 0xff310000 &&
+	if ((usage->hid & HID_USAGE_PAGE) == HID_USAGE_PAGE_VENDOR &&
 	    (usage->hid & HID_USAGE) != 0x00 &&
 	    (usage->hid & HID_USAGE) != 0xff && !usage->type) {
 		hid_warn(hdev, "Unmapped Asus vendor usagepage code 0x%02x\n",
@@ -932,11 +933,6 @@ static int asus_input_configured(struct hid_device *hdev, struct hid_input *hi)
 
 	drvdata->input = input;
 
-	if (drvdata->enable_backlight &&
-	    !asus_kbd_wmi_led_control_present(hdev) &&
-	    asus_kbd_register_leds(hdev))
-		hid_warn(hdev, "Failed to initialize backlight.\n");
-
 	return 0;
 }
 
@@ -1009,15 +1005,6 @@ static int asus_input_mapping(struct hid_device *hdev,
 			return -1;
 		}
 
-		/*
-		 * Check and enable backlight only on devices with UsagePage ==
-		 * 0xff31 to avoid initializing the keyboard firmware multiple
-		 * times on devices with multiple HID descriptors but same
-		 * PID/VID.
-		 */
-		if (drvdata->quirks & QUIRK_USE_KBD_BACKLIGHT)
-			drvdata->enable_backlight = true;
-
 		set_bit(EV_REP, hi->input->evbit);
 		return 1;
 	}
@@ -1134,8 +1121,10 @@ static int __maybe_unused asus_reset_resume(struct hid_device *hdev)
 
 static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)
 {
-	int ret;
+	struct hid_report_enum *rep_enum;
 	struct asus_drvdata *drvdata;
+	struct hid_report *rep;
+	int ret, is_vendor = 0;
 
 	drvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);
 	if (drvdata == NULL) {
@@ -1219,12 +1208,37 @@ static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		return ret;
 	}
 
+	/* Check for vendor for RGB init and handle generic devices properly. */
+	rep_enum = &hdev->report_enum[HID_INPUT_REPORT];
+	list_for_each_entry(rep, &rep_enum->report_list, list) {
+		if ((rep->application & HID_USAGE_PAGE) == HID_USAGE_PAGE_VENDOR)
+			is_vendor = true;
+	}
+
+	/*
+	 * For ROG keyboards, disable fixups except vendor devices.
+	 */
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD && !is_vendor)
+		drvdata->quirks |= QUIRK_SKIP_REPORT_FIXUP;
+
 	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
 	if (ret) {
 		hid_err(hdev, "Asus hw start failed: %d\n", ret);
 		return ret;
 	}
 
+	if (is_vendor && (drvdata->quirks & QUIRK_USE_KBD_BACKLIGHT) &&
+	    !asus_kbd_wmi_led_control_present(hdev) &&
+	    asus_kbd_register_leds(hdev))
+		hid_warn(hdev, "Failed to initialize backlight.\n");
+
+	/*
+	 * For ROG keyboards, skip rename for consistency and ->input check as
+	 * some devices do not have inputs.
+	 */
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD)
+		return 0;
+
 	/*
 	 * Check that input registration succeeded. Checking that
 	 * HID_CLAIMED_INPUT is set prevents a UAF when all input devices
@@ -1353,6 +1367,10 @@ static const __u8 *asus_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		rdesc = new_rdesc;
 	}
 
+	/* Vendor fixups should only apply to NKEY vendor devices. */
+	if (drvdata->quirks & QUIRK_SKIP_REPORT_FIXUP)
+		return rdesc;
+
 	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD &&
 			*rsize == 331 && rdesc[190] == 0x85 && rdesc[191] == 0x5a &&
 			rdesc[204] == 0x95 && rdesc[205] == 0x05) {
-- 
2.52.0


From 1205ece7c59b8330aa663b34cdaffca35f2854d4 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 1 Nov 2025 11:47:07 +0100
Subject: [PATCH 036/112] HID: asus: initialize LED endpoint early for old NKEY
 keyboards

These keyboards have always had initialization in the kernel for 0x5d.
At this point, it is hard to verify again and we risk regressions by
removing this. Therefore, initialize with 0x5d as well.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 3d755a34c..a0201e92a 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -92,6 +92,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
 #define QUIRK_ROG_ALLY_XPAD		BIT(13)
 #define QUIRK_SKIP_REPORT_FIXUP		BIT(14)
+#define QUIRK_ROG_NKEY_LEGACY		BIT(15)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -670,6 +671,16 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 	if (ret < 0)
 		return ret;
 
+	if (drvdata->quirks & QUIRK_ROG_NKEY_LEGACY) {
+		/*
+		 * These keyboards might need 0x5d for shortcuts to work.
+		 * As it has been more than 5 years, it is hard to verify.
+		 */
+		ret = asus_kbd_init(hdev, FEATURE_KBD_LED_REPORT_ID1);
+		if (ret < 0)
+			return ret;
+	}
+
 	/* Get keyboard functions */
 	ret = asus_kbd_get_functions(hdev, &kbd_func, FEATURE_KBD_REPORT_ID);
 	if (ret < 0)
@@ -1410,10 +1421,10 @@ static const struct hid_device_id asus_devices[] = {
 	  QUIRK_USE_KBD_BACKLIGHT },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_LEGACY },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD2),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_LEGACY },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_Z13_LIGHTBAR),
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
-- 
2.52.0


From 818eb74cfa48fa989f5617cfbd0a7abffe3cf26d Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 1 Nov 2025 11:47:08 +0100
Subject: [PATCH 037/112] platform/x86: asus-wmi: Add support for multiple kbd
 led handlers

Some devices, such as the Z13 have multiple Aura devices connected
to them by USB. In addition, they might have a WMI interface for
RGB. In Windows, Armoury Crate exposes a unified brightness slider
for all of them, with 3 brightness levels.

Therefore, to be synergistic in Linux, and support existing tooling
such as UPower, allow adding listeners to the RGB device of the WMI
interface. If WMI does not exist, lazy initialize the interface.

Since both hid-asus and asus-wmi can both interact with the led
objects including from an atomic context, protect the brightness
access with a spinlock and update the values from a workqueue.
Use this workqueue to process WMI keyboard events as well, so they
are processed asynchronously.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Tested-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/asus-wmi.c            | 179 +++++++++++++++++----
 include/linux/platform_data/x86/asus-wmi.h |  17 ++
 2 files changed, 169 insertions(+), 27 deletions(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 0775faded..5ed9a4f84 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -38,6 +38,7 @@
 #include <linux/rfkill.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
+#include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/units.h>
 
@@ -256,6 +257,9 @@ struct asus_wmi {
 	int tpd_led_wk;
 	struct led_classdev kbd_led;
 	int kbd_led_wk;
+	bool kbd_led_notify;
+	bool kbd_led_avail;
+	bool kbd_led_registered;
 	struct led_classdev lightbar_led;
 	int lightbar_led_wk;
 	struct led_classdev micmute_led;
@@ -264,6 +268,7 @@ struct asus_wmi {
 	struct work_struct tpd_led_work;
 	struct work_struct wlan_led_work;
 	struct work_struct lightbar_led_work;
+	struct work_struct kbd_led_work;
 
 	struct asus_rfkill wlan;
 	struct asus_rfkill bluetooth;
@@ -1615,6 +1620,99 @@ static void asus_wmi_battery_exit(struct asus_wmi *asus)
 
 /* LEDs ***********************************************************************/
 
+struct asus_hid_ref {
+	struct list_head listeners;
+	struct asus_wmi *asus;
+	/* Protects concurrent access from hid-asus and asus-wmi to leds */
+	spinlock_t lock;
+};
+
+static struct asus_hid_ref asus_ref = {
+	.listeners = LIST_HEAD_INIT(asus_ref.listeners),
+	.asus = NULL,
+	/*
+	 * Protects .asus, .asus.kbd_led_{wk,notify}, and .listener refs. Other
+	 * asus variables are read-only after .asus is set. Except the led cdev
+	 * device if not kbd_led_avail. That becomes read-only after the
+	 * first hid-asus listener registers and triggers the work queue. It is
+	 * then not referenced again until unregistering, which happens after
+	 * .asus ref is dropped. Since .asus needs to be accessed by hid-asus
+	 * IRQs to check if forwarding events is possible, a spinlock is used.
+	 */
+	.lock = __SPIN_LOCK_UNLOCKED(asus_ref.lock),
+};
+
+/*
+ * Allows registering hid-asus listeners that want to be notified of
+ * keyboard backlight changes.
+ */
+int asus_hid_register_listener(struct asus_hid_listener *bdev)
+{
+	struct asus_wmi *asus;
+
+	guard(spinlock_irqsave)(&asus_ref.lock);
+	list_add_tail(&bdev->list, &asus_ref.listeners);
+	asus = asus_ref.asus;
+	if (asus)
+		queue_work(asus->led_workqueue, &asus->kbd_led_work);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(asus_hid_register_listener);
+
+/*
+ * Allows unregistering hid-asus listeners that were added with
+ * asus_hid_register_listener().
+ */
+void asus_hid_unregister_listener(struct asus_hid_listener *bdev)
+{
+	guard(spinlock_irqsave)(&asus_ref.lock);
+	list_del(&bdev->list);
+}
+EXPORT_SYMBOL_GPL(asus_hid_unregister_listener);
+
+static void do_kbd_led_set(struct led_classdev *led_cdev, int value);
+
+static void kbd_led_update_all(struct work_struct *work)
+{
+	struct asus_wmi *asus;
+	bool registered, notify;
+	int ret, value;
+
+	asus = container_of(work, struct asus_wmi, kbd_led_work);
+
+	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
+		registered = asus->kbd_led_registered;
+		value = asus->kbd_led_wk;
+		notify = asus->kbd_led_notify;
+	}
+
+	if (!registered) {
+		/*
+		 * This workqueue runs under asus-wmi, which means probe has
+		 * completed and asus-wmi will keep running until it finishes.
+		 * Therefore, we can safely register the LED without holding
+		 * a spinlock.
+		 */
+		ret = devm_led_classdev_register(&asus->platform_device->dev,
+					    &asus->kbd_led);
+		if (!ret) {
+			scoped_guard(spinlock_irqsave, &asus_ref.lock)
+				asus->kbd_led_registered = true;
+		} else {
+			pr_warn("Failed to register keyboard backlight LED: %d\n", ret);
+			return;
+		}
+	}
+
+	if (value >= 0)
+		do_kbd_led_set(&asus->kbd_led, value);
+	if (notify) {
+		scoped_guard(spinlock_irqsave, &asus_ref.lock)
+			asus->kbd_led_notify = false;
+		led_classdev_notify_brightness_hw_changed(&asus->kbd_led, value);
+	}
+}
+
 /*
  * These functions actually update the LED's, and are called from a
  * workqueue. By doing this as separate work rather than when the LED
@@ -1661,7 +1759,8 @@ static void kbd_led_update(struct asus_wmi *asus)
 {
 	int ctrl_param = 0;
 
-	ctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);
+	scoped_guard(spinlock_irqsave, &asus_ref.lock)
+		ctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);
 	asus_wmi_set_devstate(ASUS_WMI_DEVID_KBD_BACKLIGHT, ctrl_param, NULL);
 }
 
@@ -1694,32 +1793,41 @@ static int kbd_led_read(struct asus_wmi *asus, int *level, int *env)
 
 static void do_kbd_led_set(struct led_classdev *led_cdev, int value)
 {
+	struct asus_hid_listener *listener;
 	struct asus_wmi *asus;
 	int max_level;
 
 	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
 	max_level = asus->kbd_led.max_brightness;
 
-	asus->kbd_led_wk = clamp_val(value, 0, max_level);
-	kbd_led_update(asus);
+	scoped_guard(spinlock_irqsave, &asus_ref.lock)
+		asus->kbd_led_wk = clamp_val(value, 0, max_level);
+
+	if (asus->kbd_led_avail)
+		kbd_led_update(asus);
+
+	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
+		list_for_each_entry(listener, &asus_ref.listeners, list)
+			listener->brightness_set(listener, asus->kbd_led_wk);
+	}
 }
 
-static int kbd_led_set(struct led_classdev *led_cdev, enum led_brightness value)
+static void kbd_led_set(struct led_classdev *led_cdev, enum led_brightness value)
 {
 	/* Prevent disabling keyboard backlight on module unregister */
 	if (led_cdev->flags & LED_UNREGISTERING)
-		return 0;
+		return;
 
 	do_kbd_led_set(led_cdev, value);
-	return 0;
 }
 
 static void kbd_led_set_by_kbd(struct asus_wmi *asus, enum led_brightness value)
 {
-	struct led_classdev *led_cdev = &asus->kbd_led;
-
-	do_kbd_led_set(led_cdev, value);
-	led_classdev_notify_brightness_hw_changed(led_cdev, asus->kbd_led_wk);
+	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
+		asus->kbd_led_wk = value;
+		asus->kbd_led_notify = true;
+	}
+	queue_work(asus->led_workqueue, &asus->kbd_led_work);
 }
 
 static enum led_brightness kbd_led_get(struct led_classdev *led_cdev)
@@ -1729,10 +1837,18 @@ static enum led_brightness kbd_led_get(struct led_classdev *led_cdev)
 
 	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
 
+	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
+		if (!asus->kbd_led_avail)
+			return asus->kbd_led_wk;
+	}
+
 	retval = kbd_led_read(asus, &value, NULL);
 	if (retval < 0)
 		return retval;
 
+	scoped_guard(spinlock_irqsave, &asus_ref.lock)
+		asus->kbd_led_wk = value;
+
 	return value;
 }
 
@@ -1844,7 +1960,9 @@ static int camera_led_set(struct led_classdev *led_cdev,
 
 static void asus_wmi_led_exit(struct asus_wmi *asus)
 {
-	led_classdev_unregister(&asus->kbd_led);
+	scoped_guard(spinlock_irqsave, &asus_ref.lock)
+		asus_ref.asus = NULL;
+
 	led_classdev_unregister(&asus->tpd_led);
 	led_classdev_unregister(&asus->wlan_led);
 	led_classdev_unregister(&asus->lightbar_led);
@@ -1882,22 +2000,25 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 			goto error;
 	}
 
-	if (!kbd_led_read(asus, &led_val, NULL) && !dmi_check_system(asus_use_hid_led_dmi_ids)) {
-		pr_info("using asus-wmi for asus::kbd_backlight\n");
-		asus->kbd_led_wk = led_val;
-		asus->kbd_led.name = "asus::kbd_backlight";
-		asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
-		asus->kbd_led.brightness_set_blocking = kbd_led_set;
-		asus->kbd_led.brightness_get = kbd_led_get;
-		asus->kbd_led.max_brightness = 3;
+	asus->kbd_led.name = "asus::kbd_backlight";
+	asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
+	asus->kbd_led.brightness_set = kbd_led_set;
+	asus->kbd_led.brightness_get = kbd_led_get;
+	asus->kbd_led.max_brightness = 3;
+	asus->kbd_led_avail = !kbd_led_read(asus, &led_val, NULL);
+	INIT_WORK(&asus->kbd_led_work, kbd_led_update_all);
 
+	if (asus->kbd_led_avail) {
+		asus->kbd_led_wk = led_val;
 		if (num_rgb_groups != 0)
 			asus->kbd_led.groups = kbd_rgb_mode_groups;
+	} else
+		asus->kbd_led_wk = -1;
 
-		rv = led_classdev_register(&asus->platform_device->dev,
-					   &asus->kbd_led);
-		if (rv)
-			goto error;
+	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
+		asus_ref.asus = asus;
+		if (asus->kbd_led_avail || !list_empty(&asus_ref.listeners))
+			queue_work(asus->led_workqueue, &asus->kbd_led_work);
 	}
 
 	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_WIRELESS_LED)
@@ -4372,6 +4493,7 @@ static int asus_wmi_get_event_code(union acpi_object *obj)
 
 static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 {
+	enum led_brightness led_value;
 	unsigned int key_value = 1;
 	bool autorelease = 1;
 
@@ -4388,19 +4510,22 @@ static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 		return;
 	}
 
+	scoped_guard(spinlock_irqsave, &asus_ref.lock)
+		led_value = asus->kbd_led_wk;
+
 	if (code == NOTIFY_KBD_BRTUP) {
-		kbd_led_set_by_kbd(asus, asus->kbd_led_wk + 1);
+		kbd_led_set_by_kbd(asus, led_value + 1);
 		return;
 	}
 	if (code == NOTIFY_KBD_BRTDWN) {
-		kbd_led_set_by_kbd(asus, asus->kbd_led_wk - 1);
+		kbd_led_set_by_kbd(asus, led_value - 1);
 		return;
 	}
 	if (code == NOTIFY_KBD_BRTTOGGLE) {
-		if (asus->kbd_led_wk == asus->kbd_led.max_brightness)
+		if (led_value == asus->kbd_led.max_brightness)
 			kbd_led_set_by_kbd(asus, 0);
 		else
-			kbd_led_set_by_kbd(asus, asus->kbd_led_wk + 1);
+			kbd_led_set_by_kbd(asus, led_value + 1);
 		return;
 	}
 
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 419491d4a..dbaff0fdb 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -172,12 +172,21 @@ enum asus_ally_mcu_hack {
 	ASUS_WMI_ALLY_MCU_HACK_DISABLED,
 };
 
+/* Used to notify hid-asus when asus-wmi changes keyboard backlight */
+struct asus_hid_listener {
+	struct list_head list;
+	void (*brightness_set)(struct asus_hid_listener *listener, int brightness);
+};
+
 #if IS_REACHABLE(CONFIG_ASUS_WMI)
 void set_ally_mcu_hack(enum asus_ally_mcu_hack status);
 void set_ally_mcu_powersave(bool enabled);
 int asus_wmi_get_devstate_dsts(u32 dev_id, u32 *retval);
 int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param, u32 *retval);
 int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval);
+
+int asus_hid_register_listener(struct asus_hid_listener *cdev);
+void asus_hid_unregister_listener(struct asus_hid_listener *cdev);
 #else
 static inline void set_ally_mcu_hack(enum asus_ally_mcu_hack status)
 {
@@ -198,6 +207,14 @@ static inline int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
 {
 	return -ENODEV;
 }
+
+static inline int asus_hid_register_listener(struct asus_hid_listener *bdev)
+{
+	return -ENODEV;
+}
+static inline void asus_hid_unregister_listener(struct asus_hid_listener *bdev)
+{
+}
 #endif
 
 #endif	/* __PLATFORM_DATA_X86_ASUS_WMI_H */
-- 
2.52.0


From cfdc3fdb7343bc154e6b5a2455a31a6bd7255bc4 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 1 Nov 2025 11:47:09 +0100
Subject: [PATCH 038/112] HID: asus: listen to the asus-wmi brightness device
 instead of creating one

Some ROG laptops expose multiple interfaces for controlling the
keyboard/RGB brightness. This creates a name conflict under
asus::kbd_brightness, where the second device ends up being
named asus::kbd_brightness_1 and they are both broken.

Therefore, register a listener to the asus-wmi brightness device
instead of creating a new one.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 64 +++++++-----------------------------------
 1 file changed, 10 insertions(+), 54 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index a0201e92a..9b9528867 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -104,7 +104,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define TRKID_SGN       ((TRKID_MAX + 1) >> 1)
 
 struct asus_kbd_leds {
-	struct led_classdev cdev;
+	struct asus_hid_listener listener;
 	struct hid_device *hdev;
 	struct work_struct work;
 	unsigned int brightness;
@@ -496,11 +496,11 @@ static void asus_schedule_work(struct asus_kbd_leds *led)
 	spin_unlock_irqrestore(&led->lock, flags);
 }
 
-static void asus_kbd_backlight_set(struct led_classdev *led_cdev,
-				   enum led_brightness brightness)
+static void asus_kbd_backlight_set(struct asus_hid_listener *listener,
+				   int brightness)
 {
-	struct asus_kbd_leds *led = container_of(led_cdev, struct asus_kbd_leds,
-						 cdev);
+	struct asus_kbd_leds *led = container_of(listener, struct asus_kbd_leds,
+						 listener);
 	unsigned long flags;
 
 	spin_lock_irqsave(&led->lock, flags);
@@ -510,20 +510,6 @@ static void asus_kbd_backlight_set(struct led_classdev *led_cdev,
 	asus_schedule_work(led);
 }
 
-static enum led_brightness asus_kbd_backlight_get(struct led_classdev *led_cdev)
-{
-	struct asus_kbd_leds *led = container_of(led_cdev, struct asus_kbd_leds,
-						 cdev);
-	enum led_brightness brightness;
-	unsigned long flags;
-
-	spin_lock_irqsave(&led->lock, flags);
-	brightness = led->brightness;
-	spin_unlock_irqrestore(&led->lock, flags);
-
-	return brightness;
-}
-
 static void asus_kbd_backlight_work(struct work_struct *work)
 {
 	struct asus_kbd_leds *led = container_of(work, struct asus_kbd_leds, work);
@@ -540,34 +526,6 @@ static void asus_kbd_backlight_work(struct work_struct *work)
 		hid_err(led->hdev, "Asus failed to set keyboard backlight: %d\n", ret);
 }
 
-/* WMI-based keyboard backlight LED control (via asus-wmi driver) takes
- * precedence. We only activate HID-based backlight control when the
- * WMI control is not available.
- */
-static bool asus_kbd_wmi_led_control_present(struct hid_device *hdev)
-{
-	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
-	u32 value;
-	int ret;
-
-	if (!IS_ENABLED(CONFIG_ASUS_WMI))
-		return false;
-
-	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD &&
-			dmi_check_system(asus_use_hid_led_dmi_ids)) {
-		hid_info(hdev, "using HID for asus::kbd_backlight\n");
-		return false;
-	}
-
-	ret = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS,
-				       ASUS_WMI_DEVID_KBD_BACKLIGHT, 0, &value);
-	hid_dbg(hdev, "WMI backlight check: rc %d value %x", ret, value);
-	if (ret)
-		return false;
-
-	return !!(value & ASUS_WMI_DSTS_PRESENCE_BIT);
-}
-
 /*
  * We don't care about any other part of the string except the version section.
  * Example strings: FGA80100.RC72LA.312_T01, FGA80100.RC71LS.318_T01
@@ -712,14 +670,11 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 	drvdata->kbd_backlight->removed = false;
 	drvdata->kbd_backlight->brightness = 0;
 	drvdata->kbd_backlight->hdev = hdev;
-	drvdata->kbd_backlight->cdev.name = "asus::kbd_backlight";
-	drvdata->kbd_backlight->cdev.max_brightness = 3;
-	drvdata->kbd_backlight->cdev.brightness_set = asus_kbd_backlight_set;
-	drvdata->kbd_backlight->cdev.brightness_get = asus_kbd_backlight_get;
+	drvdata->kbd_backlight->listener.brightness_set = asus_kbd_backlight_set;
 	INIT_WORK(&drvdata->kbd_backlight->work, asus_kbd_backlight_work);
 	spin_lock_init(&drvdata->kbd_backlight->lock);
 
-	ret = devm_led_classdev_register(&hdev->dev, &drvdata->kbd_backlight->cdev);
+	ret = asus_hid_register_listener(&drvdata->kbd_backlight->listener);
 	if (ret < 0) {
 		/* No need to have this still around */
 		devm_kfree(&hdev->dev, drvdata->kbd_backlight);
@@ -1108,7 +1063,7 @@ static int __maybe_unused asus_resume(struct hid_device *hdev) {
 
 	if (drvdata->kbd_backlight) {
 		const u8 buf[] = { FEATURE_KBD_REPORT_ID, 0xba, 0xc5, 0xc4,
-				drvdata->kbd_backlight->cdev.brightness };
+				drvdata->kbd_backlight->brightness };
 		ret = asus_kbd_set_report(hdev, buf, sizeof(buf));
 		if (ret < 0) {
 			hid_err(hdev, "Asus failed to set keyboard backlight: %d\n", ret);
@@ -1239,7 +1194,6 @@ static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	}
 
 	if (is_vendor && (drvdata->quirks & QUIRK_USE_KBD_BACKLIGHT) &&
-	    !asus_kbd_wmi_led_control_present(hdev) &&
 	    asus_kbd_register_leds(hdev))
 		hid_warn(hdev, "Failed to initialize backlight.\n");
 
@@ -1286,6 +1240,8 @@ static void asus_remove(struct hid_device *hdev)
 	unsigned long flags;
 
 	if (drvdata->kbd_backlight) {
+		asus_hid_unregister_listener(&drvdata->kbd_backlight->listener);
+
 		spin_lock_irqsave(&drvdata->kbd_backlight->lock, flags);
 		drvdata->kbd_backlight->removed = true;
 		spin_unlock_irqrestore(&drvdata->kbd_backlight->lock, flags);
-- 
2.52.0


From 994aa309028709b7bdc89f8cc1e0e486e6a04163 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 1 Nov 2025 11:47:10 +0100
Subject: [PATCH 039/112] platform/x86: asus-wmi: remove unused keyboard
 backlight quirk

The quirk for selecting whether keyboard backlight should be controlled
by HID or WMI is not needed anymore, so remove it.

This commit was cleaned up. Replace with the proper series on 7.0.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c                        |  1 -
 drivers/platform/x86/asus-wmi.c               |  1 -
 .../platform_data/x86/asus-wmi-leds-ids.h     | 50 -------------------
 3 files changed, 52 deletions(-)
 delete mode 100644 include/linux/platform_data/x86/asus-wmi-leds-ids.h

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 9b9528867..e5d3f28c1 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -27,7 +27,6 @@
 #include <linux/hid.h>
 #include <linux/module.h>
 #include <linux/platform_data/x86/asus-wmi.h>
-#include <linux/platform_data/x86/asus-wmi-leds-ids.h>
 #include <linux/input/mt.h>
 #include <linux/usb.h> /* For to_usb_interface for T100 touchpad intf check */
 #include <linux/power_supply.h>
diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 5ed9a4f84..a9c089068 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -31,7 +31,6 @@
 #include <linux/pci.h>
 #include <linux/pci_hotplug.h>
 #include <linux/platform_data/x86/asus-wmi.h>
-#include <linux/platform_data/x86/asus-wmi-leds-ids.h>
 #include <linux/platform_device.h>
 #include <linux/platform_profile.h>
 #include <linux/power_supply.h>
diff --git a/include/linux/platform_data/x86/asus-wmi-leds-ids.h b/include/linux/platform_data/x86/asus-wmi-leds-ids.h
deleted file mode 100644
index 034a039c4..000000000
--- a/include/linux/platform_data/x86/asus-wmi-leds-ids.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __PLATFORM_DATA_X86_ASUS_WMI_LEDS_IDS_H
-#define __PLATFORM_DATA_X86_ASUS_WMI_LEDS_IDS_H
-
-#include <linux/dmi.h>
-#include <linux/types.h>
-
-/* To be used by both hid-asus and asus-wmi to determine which controls kbd_brightness */
-#if IS_REACHABLE(CONFIG_ASUS_WMI) || IS_REACHABLE(CONFIG_HID_ASUS)
-static const struct dmi_system_id asus_use_hid_led_dmi_ids[] = {
-	{
-		.matches = {
-			DMI_MATCH(DMI_PRODUCT_FAMILY, "ROG Zephyrus"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_PRODUCT_FAMILY, "ROG Strix"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_PRODUCT_FAMILY, "ROG Flow"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_PRODUCT_FAMILY, "ProArt P16"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "GA403U"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "GU605M"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
-		},
-	},
-	{ },
-};
-#endif
-
-#endif	/* __PLATFORM_DATA_X86_ASUS_WMI_LEDS_IDS_H */
-- 
2.52.0


From 8231ff1ace9c58a7718467cbb08900971d3dbe36 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 1 Nov 2025 11:47:11 +0100
Subject: [PATCH 040/112] platform/x86: asus-wmi: add keyboard brightness event
 handler

The keyboard brightness control of Asus WMI keyboards is handled in
kernel, which leads to the shortcut going from brightness 0, to 1,
to 2, and 3.

However, for HID keyboards it is exposed as a key and handled by the
user's desktop environment. For the toggle button, this means that
brightness control becomes on/off. In addition, in the absence of a
DE, the keyboard brightness does not work.

Therefore, expose an event handler for the keyboard brightness control
which can then be used by hid-asus. Since this handler is called from
an interrupt context, defer the actual work to a workqueue.

In the process, introduce ASUS_EV_MAX_BRIGHTNESS to hold the constant
for maximum brightness since it is shared between hid-asus/asus-wmi.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Tested-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/asus-wmi.c            | 46 +++++++++++++++++++---
 include/linux/platform_data/x86/asus-wmi.h | 13 ++++++
 2 files changed, 54 insertions(+), 5 deletions(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index a9c089068..e79289d61 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1712,6 +1712,44 @@ static void kbd_led_update_all(struct work_struct *work)
 	}
 }
 
+/*
+ * This function is called from hid-asus to inform asus-wmi of brightness
+ * changes initiated by the keyboard backlight keys.
+ */
+int asus_hid_event(enum asus_hid_event event)
+{
+	struct asus_wmi *asus;
+	int brightness;
+
+	guard(spinlock_irqsave)(&asus_ref.lock);
+	asus = asus_ref.asus;
+	if (!asus || !asus->kbd_led_registered)
+		return -EBUSY;
+
+	brightness = asus->kbd_led_wk;
+
+	switch (event) {
+	case ASUS_EV_BRTUP:
+		brightness += 1;
+		break;
+	case ASUS_EV_BRTDOWN:
+		brightness -= 1;
+		break;
+	case ASUS_EV_BRTTOGGLE:
+		if (brightness >= ASUS_EV_MAX_BRIGHTNESS)
+			brightness = 0;
+		else
+			brightness += 1;
+		break;
+	}
+
+	asus->kbd_led_wk = clamp_val(brightness, 0, ASUS_EV_MAX_BRIGHTNESS);
+	asus->kbd_led_notify = true;
+	queue_work(asus->led_workqueue, &asus->kbd_led_work);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(asus_hid_event);
+
 /*
  * These functions actually update the LED's, and are called from a
  * workqueue. By doing this as separate work rather than when the LED
@@ -1794,13 +1832,11 @@ static void do_kbd_led_set(struct led_classdev *led_cdev, int value)
 {
 	struct asus_hid_listener *listener;
 	struct asus_wmi *asus;
-	int max_level;
 
 	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
-	max_level = asus->kbd_led.max_brightness;
 
 	scoped_guard(spinlock_irqsave, &asus_ref.lock)
-		asus->kbd_led_wk = clamp_val(value, 0, max_level);
+		asus->kbd_led_wk = clamp_val(value, 0, ASUS_EV_MAX_BRIGHTNESS);
 
 	if (asus->kbd_led_avail)
 		kbd_led_update(asus);
@@ -2003,7 +2039,7 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 	asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
 	asus->kbd_led.brightness_set = kbd_led_set;
 	asus->kbd_led.brightness_get = kbd_led_get;
-	asus->kbd_led.max_brightness = 3;
+	asus->kbd_led.max_brightness = ASUS_EV_MAX_BRIGHTNESS;
 	asus->kbd_led_avail = !kbd_led_read(asus, &led_val, NULL);
 	INIT_WORK(&asus->kbd_led_work, kbd_led_update_all);
 
@@ -4521,7 +4557,7 @@ static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 		return;
 	}
 	if (code == NOTIFY_KBD_BRTTOGGLE) {
-		if (led_value == asus->kbd_led.max_brightness)
+		if (led_value == ASUS_EV_MAX_BRIGHTNESS)
 			kbd_led_set_by_kbd(asus, 0);
 		else
 			kbd_led_set_by_kbd(asus, led_value + 1);
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index dbaff0fdb..377b5a8ab 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -178,6 +178,14 @@ struct asus_hid_listener {
 	void (*brightness_set)(struct asus_hid_listener *listener, int brightness);
 };
 
+enum asus_hid_event {
+	ASUS_EV_BRTUP,
+	ASUS_EV_BRTDOWN,
+	ASUS_EV_BRTTOGGLE,
+};
+
+#define ASUS_EV_MAX_BRIGHTNESS 3
+
 #if IS_REACHABLE(CONFIG_ASUS_WMI)
 void set_ally_mcu_hack(enum asus_ally_mcu_hack status);
 void set_ally_mcu_powersave(bool enabled);
@@ -187,6 +195,7 @@ int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval);
 
 int asus_hid_register_listener(struct asus_hid_listener *cdev);
 void asus_hid_unregister_listener(struct asus_hid_listener *cdev);
+int asus_hid_event(enum asus_hid_event event);
 #else
 static inline void set_ally_mcu_hack(enum asus_ally_mcu_hack status)
 {
@@ -215,6 +224,10 @@ static inline int asus_hid_register_listener(struct asus_hid_listener *bdev)
 static inline void asus_hid_unregister_listener(struct asus_hid_listener *bdev)
 {
 }
+static inline int asus_hid_event(enum asus_hid_event event)
+{
+	return -ENODEV;
+}
 #endif
 
 #endif	/* __PLATFORM_DATA_X86_ASUS_WMI_H */
-- 
2.52.0


From b210dd13ea5017feec84fa93f660f973922ebe9c Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 1 Nov 2025 11:47:12 +0100
Subject: [PATCH 041/112] HID: asus: add support for the asus-wmi brightness
 handler

If the asus-wmi brightness handler is available, send the
keyboard brightness events to it instead of passing them
to userspace. If it is not, fall back to sending them to it.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Tested-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index e5d3f28c1..de64451e3 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -325,6 +325,17 @@ static int asus_event(struct hid_device *hdev, struct hid_field *field,
 			 usage->hid & HID_USAGE);
 	}
 
+	if (usage->type == EV_KEY && value) {
+		switch (usage->code) {
+		case KEY_KBDILLUMUP:
+			return !asus_hid_event(ASUS_EV_BRTUP);
+		case KEY_KBDILLUMDOWN:
+			return !asus_hid_event(ASUS_EV_BRTDOWN);
+		case KEY_KBDILLUMTOGGLE:
+			return !asus_hid_event(ASUS_EV_BRTTOGGLE);
+		}
+	}
+
 	return 0;
 }
 
-- 
2.52.0


From 43d51f4b2da13aadf81669b67031e6fe96c13e36 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 19:45:58 +0100
Subject: [PATCH 042/112] HID: asus: add basic RGB support

Adds basic RGB support to hid-asus through multi-index. The interface
works quite well, but has not gone through much stability testing.
Applied on demand, if userspace does not touch the RGB sysfs, not
even initialization is done. Ensuring compatibility with existing
userspace programs.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/Kconfig    |   1 +
 drivers/hid/hid-asus.c | 175 +++++++++++++++++++++++++++++++++++++----
 2 files changed, 159 insertions(+), 17 deletions(-)

diff --git a/drivers/hid/Kconfig b/drivers/hid/Kconfig
index 920a64b66..80005c022 100644
--- a/drivers/hid/Kconfig
+++ b/drivers/hid/Kconfig
@@ -189,6 +189,7 @@ config HID_APPLETB_KBD
 config HID_ASUS
 	tristate "Asus"
 	depends on USB_HID
+	depends on LEDS_CLASS_MULTICOLOR
 	depends on LEDS_CLASS
 	depends on ASUS_WMI || ASUS_WMI=n
 	select POWER_SUPPLY
diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index de64451e3..799cf43d2 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -23,6 +23,7 @@
 /*
  */
 
+#include <linux/array_size.h>
 #include <linux/dmi.h>
 #include <linux/hid.h>
 #include <linux/module.h>
@@ -30,6 +31,7 @@
 #include <linux/input/mt.h>
 #include <linux/usb.h> /* For to_usb_interface for T100 touchpad intf check */
 #include <linux/power_supply.h>
+#include <linux/led-class-multicolor.h>
 #include <linux/leds.h>
 
 #include "hid-ids.h"
@@ -52,6 +54,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define FEATURE_KBD_REPORT_SIZE 64
 #define FEATURE_KBD_LED_REPORT_ID1 0x5d
 #define FEATURE_KBD_LED_REPORT_ID2 0x5e
+#define FEATURE_KBD_LED_REPORT_SIZE 7
 
 #define ROG_ALLY_REPORT_SIZE 64
 #define ROG_ALLY_X_MIN_MCU 313
@@ -92,6 +95,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define QUIRK_ROG_ALLY_XPAD		BIT(13)
 #define QUIRK_SKIP_REPORT_FIXUP		BIT(14)
 #define QUIRK_ROG_NKEY_LEGACY		BIT(15)
+#define QUIRK_ROG_NKEY_RGB		BIT(16)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -104,9 +108,15 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 
 struct asus_kbd_leds {
 	struct asus_hid_listener listener;
+	struct led_classdev_mc mc_led;
+	struct mc_subled subled_info[3];
 	struct hid_device *hdev;
 	struct work_struct work;
 	unsigned int brightness;
+	u8 rgb_colors[3];
+	bool rgb_init;
+	bool rgb_set;
+	bool rgb_registered;
 	spinlock_t lock;
 	bool removed;
 };
@@ -506,11 +516,8 @@ static void asus_schedule_work(struct asus_kbd_leds *led)
 	spin_unlock_irqrestore(&led->lock, flags);
 }
 
-static void asus_kbd_backlight_set(struct asus_hid_listener *listener,
-				   int brightness)
+static void do_asus_kbd_backlight_set(struct asus_kbd_leds *led, int brightness)
 {
-	struct asus_kbd_leds *led = container_of(listener, struct asus_kbd_leds,
-						 listener);
 	unsigned long flags;
 
 	spin_lock_irqsave(&led->lock, flags);
@@ -520,9 +527,56 @@ static void asus_kbd_backlight_set(struct asus_hid_listener *listener,
 	asus_schedule_work(led);
 }
 
-static void asus_kbd_backlight_work(struct work_struct *work)
+static void asus_kbd_listener_set(struct asus_hid_listener *listener,
+				   int brightness)
+{
+	struct asus_kbd_leds *led = container_of(listener, struct asus_kbd_leds,
+						 listener);
+	do_asus_kbd_backlight_set(led, brightness);
+	if (led->rgb_registered) {
+		led->mc_led.led_cdev.brightness = brightness;
+		led_classdev_notify_brightness_hw_changed(&led->mc_led.led_cdev,
+							  brightness);
+	}
+}
+
+static void asus_kbd_brightness_set(struct led_classdev *led_cdev,
+				    enum led_brightness brightness)
+{
+	struct led_classdev_mc *mc_cdev = lcdev_to_mccdev(led_cdev);
+	struct asus_kbd_leds *led = container_of(mc_cdev, struct asus_kbd_leds,
+						 mc_led);
+	unsigned long flags;
+
+	spin_lock_irqsave(&led->lock, flags);
+	led->rgb_colors[0] = mc_cdev->subled_info[0].intensity;
+	led->rgb_colors[1] = mc_cdev->subled_info[1].intensity;
+	led->rgb_colors[2] = mc_cdev->subled_info[2].intensity;
+	led->rgb_set = true;
+	spin_unlock_irqrestore(&led->lock, flags);
+
+	do_asus_kbd_backlight_set(led, brightness);
+}
+
+static enum led_brightness asus_kbd_brightness_get(struct led_classdev *led_cdev)
+{
+	struct led_classdev_mc *mc_led;
+	struct asus_kbd_leds *led;
+	enum led_brightness brightness;
+	unsigned long flags;
+
+	mc_led = lcdev_to_mccdev(led_cdev);
+	led = container_of(mc_led, struct asus_kbd_leds, mc_led);
+
+	spin_lock_irqsave(&led->lock, flags);
+	brightness = led->brightness;
+	spin_unlock_irqrestore(&led->lock, flags);
+
+	return brightness;
+}
+
+static void asus_kbd_backlight_work(struct asus_kbd_leds *led)
 {
-	struct asus_kbd_leds *led = container_of(work, struct asus_kbd_leds, work);
 	u8 buf[] = { FEATURE_KBD_REPORT_ID, 0xba, 0xc5, 0xc4, 0x00 };
 	int ret;
 	unsigned long flags;
@@ -627,12 +681,71 @@ static void validate_mcu_fw_version(struct hid_device *hdev, int idProduct)
 	}
 }
 
+static void asus_kbd_rgb_work(struct asus_kbd_leds *led)
+{
+	u8 rgb_buf[][FEATURE_KBD_LED_REPORT_SIZE] = {
+		{ FEATURE_KBD_LED_REPORT_ID1, 0xB3 }, /* set mode */
+		{ FEATURE_KBD_LED_REPORT_ID1, 0xB5 }, /* apply mode */
+		{ FEATURE_KBD_LED_REPORT_ID1, 0xB4 }, /* save to mem */
+	};
+	unsigned long flags;
+	uint8_t colors[3];
+	bool rgb_init, rgb_set;
+	int ret;
+
+	spin_lock_irqsave(&led->lock, flags);
+	rgb_init = led->rgb_init;
+	rgb_set = led->rgb_set;
+	led->rgb_set = false;
+	colors[0] = led->rgb_colors[0];
+	colors[1] = led->rgb_colors[1];
+	colors[2] = led->rgb_colors[2];
+	spin_unlock_irqrestore(&led->lock, flags);
+
+	if (!rgb_set)
+		return;
+
+	if (rgb_init) {
+		ret = asus_kbd_init(led->hdev, FEATURE_KBD_LED_REPORT_ID1);
+		if (ret < 0) {
+			hid_err(led->hdev, "Asus failed to init RGB: %d\n", ret);
+			return;
+		}
+		spin_lock_irqsave(&led->lock, flags);
+		led->rgb_init = false;
+		spin_unlock_irqrestore(&led->lock, flags);
+	}
+
+	/* Protocol is: 54b3 zone (0=all) mode (0=solid) RGB */
+	rgb_buf[0][4] = colors[0];
+	rgb_buf[0][5] = colors[1];
+	rgb_buf[0][6] = colors[2];
+
+	for (size_t i = 0; i < ARRAY_SIZE(rgb_buf); i++) {
+		ret = asus_kbd_set_report(led->hdev, rgb_buf[i], sizeof(rgb_buf[i]));
+		if (ret < 0) {
+			hid_err(led->hdev, "Asus failed to set RGB: %d\n", ret);
+			return;
+		}
+	}
+}
+
+static void asus_kbd_work(struct work_struct *work)
+{
+	struct asus_kbd_leds *led = container_of(work, struct asus_kbd_leds,
+						 work);
+	asus_kbd_backlight_work(led);
+	asus_kbd_rgb_work(led);
+}
+
 static int asus_kbd_register_leds(struct hid_device *hdev)
 {
 	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
 	struct usb_interface *intf;
 	struct usb_device *udev;
 	unsigned char kbd_func;
+	struct asus_kbd_leds *leds;
+	bool rgb_init = true;
 	int ret;
 
 	ret = asus_kbd_init(hdev, FEATURE_KBD_REPORT_ID);
@@ -647,6 +760,7 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 		ret = asus_kbd_init(hdev, FEATURE_KBD_LED_REPORT_ID1);
 		if (ret < 0)
 			return ret;
+		rgb_init = false;
 	}
 
 	/* Get keyboard functions */
@@ -677,20 +791,47 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 	if (!drvdata->kbd_backlight)
 		return -ENOMEM;
 
-	drvdata->kbd_backlight->removed = false;
-	drvdata->kbd_backlight->brightness = 0;
-	drvdata->kbd_backlight->hdev = hdev;
-	drvdata->kbd_backlight->listener.brightness_set = asus_kbd_backlight_set;
-	INIT_WORK(&drvdata->kbd_backlight->work, asus_kbd_backlight_work);
+	leds = drvdata->kbd_backlight;
+	leds->removed = false;
+	leds->brightness = ASUS_EV_MAX_BRIGHTNESS;
+	leds->hdev = hdev;
+	leds->listener.brightness_set = asus_kbd_listener_set;
+
+	leds->rgb_colors[0] = 0;
+	leds->rgb_colors[1] = 0;
+	leds->rgb_colors[2] = 0;
+	leds->rgb_init = rgb_init;
+	leds->rgb_set = false;
+	leds->mc_led.led_cdev.name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
+					"asus-%s:rgb:peripheral",
+					strlen(hdev->uniq) ?
+					hdev->uniq : dev_name(&hdev->dev));
+	leds->mc_led.led_cdev.flags = LED_BRIGHT_HW_CHANGED;
+	leds->mc_led.led_cdev.max_brightness = ASUS_EV_MAX_BRIGHTNESS;
+	leds->mc_led.led_cdev.brightness_set = asus_kbd_brightness_set;
+	leds->mc_led.led_cdev.brightness_get = asus_kbd_brightness_get;
+	leds->mc_led.subled_info = leds->subled_info;
+	leds->mc_led.num_colors = ARRAY_SIZE(leds->subled_info);
+	leds->subled_info[0].color_index = LED_COLOR_ID_RED;
+	leds->subled_info[1].color_index = LED_COLOR_ID_GREEN;
+	leds->subled_info[2].color_index = LED_COLOR_ID_BLUE;
+
+	INIT_WORK(&drvdata->kbd_backlight->work, asus_kbd_work);
 	spin_lock_init(&drvdata->kbd_backlight->lock);
 
 	ret = asus_hid_register_listener(&drvdata->kbd_backlight->listener);
-	if (ret < 0) {
-		/* No need to have this still around */
-		devm_kfree(&hdev->dev, drvdata->kbd_backlight);
+	/* Asus-wmi might not be accessible so this is not fatal. */
+	if (!ret)
+		hid_warn(hdev, "Asus-wmi brightness listener not registered\n");
+
+	if (drvdata->quirks & QUIRK_ROG_NKEY_RGB) {
+		ret = devm_led_classdev_multicolor_register(&hdev->dev, &leds->mc_led);
+		if (!ret)
+			leds->rgb_registered = true;
+		return ret;
 	}
 
-	return ret;
+	return 0;
 }
 
 /*
@@ -1393,7 +1534,7 @@ static const struct hid_device_id asus_devices[] = {
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_LEGACY },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_Z13_LIGHTBAR),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD},
@@ -1422,7 +1563,7 @@ static const struct hid_device_id asus_devices[] = {
 	 */
 	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
 		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_ROG_Z13_FOLIO),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
 		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_T101HA_KEYBOARD) },
 	{ }
-- 
2.52.0


From 3f27c596b817cece6993b37f3976d04897612aa3 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 19:45:59 +0100
Subject: [PATCH 043/112] HID: asus: add RGB support to the ROG Ally units

Apply the RGB quirk to the QOG Ally units to enable basic RGB support.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 799cf43d2..2864f8238 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -1537,10 +1537,12 @@ static const struct hid_device_id asus_devices[] = {
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD},
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD
+		| QUIRK_ROG_ALLY_XPAD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD
+		| QUIRK_ROG_ALLY_XPAD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
-- 
2.52.0


From 45bf6c0bd3c749cfb76478febebddab2238df794 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 12 Jul 2025 11:35:37 +0200
Subject: [PATCH 044/112] HID: asus: add Zenbook Duo Keyboards

Add the initial Zenbook Duo keyboard and the 2025 variant that is
both bluetooth and USB.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 10 ++++++++++
 drivers/hid/hid-ids.h  |  3 +++
 2 files changed, 13 insertions(+)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 2864f8238..4f8c44c8a 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -1102,6 +1102,7 @@ static int asus_input_mapping(struct hid_device *hdev,
 		case 0x8b: asus_map_key_clear(KEY_PROG1);	break; /* ProArt Creator Hub key */
 		case 0x6b: asus_map_key_clear(KEY_F21);		break; /* ASUS touchpad toggle */
 		case 0x38: asus_map_key_clear(KEY_PROG1);	break; /* ROG key */
+		case 0x86: asus_map_key_clear(KEY_PROG1);	break; /* Zenbook Duo MyASUS */
 		case 0xba: asus_map_key_clear(KEY_PROG2);	break; /* Fn+C ASUS Splendid */
 		case 0x5c: asus_map_key_clear(KEY_PROG3);	break; /* Fn+Space Power4Gear */
 		case 0x99: asus_map_key_clear(KEY_PROG4);	break; /* Fn+F5 "fan" symbol */
@@ -1566,6 +1567,15 @@ static const struct hid_device_id asus_devices[] = {
 	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
 		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_ROG_Z13_FOLIO),
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
+	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
+		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_ZENBOOK_DUO_KEYBOARD),
+		QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
+		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_ZENBOOK_DUO_KEYBOARD_2),
+		QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	{ HID_DEVICE(BUS_BLUETOOTH, HID_GROUP_GENERIC,
+		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_ZENBOOK_DUO_KEYBOARD_2_BLUETOOTH),
+		QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
 	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
 		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_T101HA_KEYBOARD) },
 	{ }
diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 9c2bf584d..31b71223f 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -229,6 +229,9 @@
 #define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X		0x1b4c
 #define USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD	0x196b
 #define USB_DEVICE_ID_ASUSTEK_FX503VD_KEYBOARD	0x1869
+#define USB_DEVICE_ID_ASUSTEK_ZENBOOK_DUO_KEYBOARD		0x1b2c
+#define USB_DEVICE_ID_ASUSTEK_ZENBOOK_DUO_KEYBOARD_2		0x1bf2
+#define USB_DEVICE_ID_ASUSTEK_ZENBOOK_DUO_KEYBOARD_2_BLUETOOTH	0x1bf3
 
 #define USB_VENDOR_ID_ATEN		0x0557
 #define USB_DEVICE_ID_ATEN_UC100KM	0x2004
-- 
2.52.0


From 81031292fb21e76e1a5aed5b29c1e534857b10e8 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 24 Oct 2025 17:56:17 +0200
Subject: [PATCH 045/112] platform/x86: asus-wmi: add early backlight init
 quirk

The Asus Zenbook Duo's keyboard is detacheable and when it is detached
there is no led device initialized. This prevents userspace from probing
for backlight brightness support on boot. Add a quirk to always
initialize the backlight device early so that it is always available.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/asus-nb-wmi.c | 1 +
 drivers/platform/x86/asus-wmi.c    | 4 +++-
 drivers/platform/x86/asus-wmi.h    | 1 +
 3 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/drivers/platform/x86/asus-nb-wmi.c b/drivers/platform/x86/asus-nb-wmi.c
index a38a65f5c..da0e805ef 100644
--- a/drivers/platform/x86/asus-nb-wmi.c
+++ b/drivers/platform/x86/asus-nb-wmi.c
@@ -148,6 +148,7 @@ static struct quirk_entry quirk_asus_ignore_fan = {
 
 static struct quirk_entry quirk_asus_zenbook_duo_kbd = {
 	.key_wlan_event = ASUS_WMI_KEY_IGNORE,
+	.init_backlight_early = true,
 };
 
 static struct quirk_entry quirk_asus_z13 = {
diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index e79289d61..d2f7f48d8 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -2052,7 +2052,9 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 
 	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
 		asus_ref.asus = asus;
-		if (asus->kbd_led_avail || !list_empty(&asus_ref.listeners))
+		if (asus->kbd_led_avail ||
+		    asus->driver->quirks->init_backlight_early ||
+		    !list_empty(&asus_ref.listeners))
 			queue_work(asus->led_workqueue, &asus->kbd_led_work);
 	}
 
diff --git a/drivers/platform/x86/asus-wmi.h b/drivers/platform/x86/asus-wmi.h
index 5cd4392b9..73710ae9a 100644
--- a/drivers/platform/x86/asus-wmi.h
+++ b/drivers/platform/x86/asus-wmi.h
@@ -41,6 +41,7 @@ struct quirk_entry {
 	bool wmi_force_als_set;
 	bool wmi_ignore_fan;
 	bool filter_i8042_e1_extended_codes;
+	bool init_backlight_early;
 	int key_wlan_event;
 	enum asus_wmi_tablet_switch_mode tablet_switch_mode;
 	int wapf;
-- 
2.52.0


From cb6fc7ad78bc9c7dcbfab6f6a4f343640c0f60ac Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 27 Aug 2025 17:31:06 +0200
Subject: [PATCH 046/112] Revert "platform/x86: asus-wmi: Refactor Ally
 suspend/resume"

This reverts commit feea7bd6b02d43a794e3f065650d89cf8d8e8e59.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c                     |   4 -
 drivers/platform/x86/asus-wmi.c            | 152 ++++++---------------
 include/linux/platform_data/x86/asus-wmi.h |  14 --
 3 files changed, 38 insertions(+), 132 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 4f8c44c8a..2f0b5e5e6 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -675,9 +675,6 @@ static void validate_mcu_fw_version(struct hid_device *hdev, int idProduct)
 		hid_warn(hdev,
 			"The MCU firmware version must be %d or greater to avoid issues with suspend.\n",
 			min_version);
-	} else {
-		set_ally_mcu_hack(ASUS_WMI_ALLY_MCU_HACK_DISABLED);
-		set_ally_mcu_powersave(true);
 	}
 }
 
@@ -1599,5 +1596,4 @@ static struct hid_driver asus_driver = {
 };
 module_hid_driver(asus_driver);
 
-MODULE_IMPORT_NS("ASUS_WMI");
 MODULE_LICENSE("GPL");
diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index d2f7f48d8..eff4119be 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -140,20 +140,16 @@ module_param(fnlock_default, bool, 0444);
 #define ASUS_MINI_LED_2024_STRONG	0x01
 #define ASUS_MINI_LED_2024_OFF		0x02
 
+/* Controls the power state of the USB0 hub on ROG Ally which input is on */
 #define ASUS_USB0_PWR_EC0_CSEE "\\_SB.PCI0.SBRG.EC0.CSEE"
-/*
- * The period required to wait after screen off/on/s2idle.check in MS.
- * Time here greatly impacts the wake behaviour. Used in suspend/wake.
- */
-#define ASUS_USB0_PWR_EC0_CSEE_WAIT	600
-#define ASUS_USB0_PWR_EC0_CSEE_OFF	0xB7
-#define ASUS_USB0_PWR_EC0_CSEE_ON	0xB8
+/* 300ms so far seems to produce a reliable result on AC and battery */
+#define ASUS_USB0_PWR_EC0_CSEE_WAIT 1500
 
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
 static int throttle_thermal_policy_write(struct asus_wmi *);
 
-static const struct dmi_system_id asus_rog_ally_device[] = {
+static const struct dmi_system_id asus_ally_mcu_quirk[] = {
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
@@ -280,6 +276,9 @@ struct asus_wmi {
 	u32 tablet_switch_dev_id;
 	bool tablet_switch_inverted;
 
+	/* The ROG Ally device requires the MCU USB device be disconnected before suspend */
+	bool ally_mcu_usb_switch;
+
 	enum fan_type fan_type;
 	enum fan_type gpu_fan_type;
 	enum fan_type mid_fan_type;
@@ -339,9 +338,6 @@ struct asus_wmi {
 	struct asus_wmi_driver *driver;
 };
 
-/* Global to allow setting externally without requiring driver data */
-static enum asus_ally_mcu_hack use_ally_mcu_hack = ASUS_WMI_ALLY_MCU_HACK_INIT;
-
 #if IS_ENABLED(CONFIG_ASUS_WMI_DEPRECATED_ATTRS)
 static void asus_wmi_show_deprecated(void)
 {
@@ -1433,44 +1429,6 @@ static DEVICE_ATTR_RW(nv_temp_target);
 #endif /* IS_ENABLED(CONFIG_ASUS_WMI_DEPRECATED_ATTRS) */
 
 /* Ally MCU Powersave ********************************************************/
-
-/*
- * The HID driver needs to check MCU version and set this to false if the MCU FW
- * version is >= the minimum requirements. New FW do not need the hacks.
- */
-void set_ally_mcu_hack(enum asus_ally_mcu_hack status)
-{
-	use_ally_mcu_hack = status;
-	pr_debug("%s Ally MCU suspend quirk\n",
-		 status == ASUS_WMI_ALLY_MCU_HACK_ENABLED ? "Enabled" : "Disabled");
-}
-EXPORT_SYMBOL_NS_GPL(set_ally_mcu_hack, "ASUS_WMI");
-
-/*
- * mcu_powersave should be enabled always, as it is fixed in MCU FW versions:
- * - v313 for Ally X
- * - v319 for Ally 1
- * The HID driver checks MCU versions and so should set this if requirements match
- */
-void set_ally_mcu_powersave(bool enabled)
-{
-	int result, err;
-
-	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_MCU_POWERSAVE, enabled, &result);
-	if (err) {
-		pr_warn("Failed to set MCU powersave: %d\n", err);
-		return;
-	}
-	if (result > 1) {
-		pr_warn("Failed to set MCU powersave (result): 0x%x\n", result);
-		return;
-	}
-
-	pr_debug("%s MCU Powersave\n",
-		 enabled ? "Enabled" : "Disabled");
-}
-EXPORT_SYMBOL_NS_GPL(set_ally_mcu_powersave, "ASUS_WMI");
-
 #if IS_ENABLED(CONFIG_ASUS_WMI_DEPRECATED_ATTRS)
 static ssize_t mcu_powersave_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
@@ -5023,21 +4981,6 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_platform;
 
-	if (use_ally_mcu_hack == ASUS_WMI_ALLY_MCU_HACK_INIT) {
-		if (acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
-					&& dmi_check_system(asus_rog_ally_device))
-			use_ally_mcu_hack = ASUS_WMI_ALLY_MCU_HACK_ENABLED;
-		if (dmi_match(DMI_BOARD_NAME, "RC71")) {
-			/*
-			 * These steps ensure the device is in a valid good state, this is
-			 * especially important for the Ally 1 after a reboot.
-			 */
-			acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE,
-						   ASUS_USB0_PWR_EC0_CSEE_ON);
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-		}
-	}
-
 	/* ensure defaults for tunables */
 #if IS_ENABLED(CONFIG_ASUS_WMI_DEPRECATED_ATTRS)
 	asus->ppt_pl2_sppt = 5;
@@ -5051,6 +4994,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 	asus->egpu_enable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_EGPU);
 	asus->dgpu_disable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_DGPU);
 	asus->kbd_rgb_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_TUF_RGB_STATE);
+	asus->oobe_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_OOBE);
 
 	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MINI_LED_MODE))
 		asus->mini_led_dev_id = ASUS_WMI_DEVID_MINI_LED_MODE;
@@ -5240,6 +5184,34 @@ static int asus_hotk_resume(struct device *device)
 	return 0;
 }
 
+static int asus_hotk_resume_early(struct device *device)
+{
+	struct asus_wmi *asus = dev_get_drvdata(device);
+
+	if (asus->ally_mcu_usb_switch) {
+		/* sleep required to prevent USB0 being yanked then reappearing rapidly */
+		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8)))
+			dev_err(device, "ROG Ally MCU failed to connect USB dev\n");
+		else
+			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+	}
+	return 0;
+}
+
+static int asus_hotk_prepare(struct device *device)
+{
+	struct asus_wmi *asus = dev_get_drvdata(device);
+
+	if (asus->ally_mcu_usb_switch) {
+		/* sleep required to ensure USB0 is disabled before sleep continues */
+		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7)))
+			dev_err(device, "ROG Ally MCU failed to disconnect USB dev\n");
+		else
+			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+	}
+	return 0;
+}
+
 static int asus_hotk_restore(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
@@ -5287,50 +5259,11 @@ static int asus_hotk_restore(struct device *device)
 	return 0;
 }
 
-static int asus_hotk_prepare(struct device *device)
-{
-	if (use_ally_mcu_hack == ASUS_WMI_ALLY_MCU_HACK_ENABLED) {
-		acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE,
-					   ASUS_USB0_PWR_EC0_CSEE_OFF);
-		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
-#if defined(CONFIG_SUSPEND)
-static void asus_ally_s2idle_restore(void)
-{
-	if (use_ally_mcu_hack == ASUS_WMI_ALLY_MCU_HACK_ENABLED) {
-		acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE,
-					   ASUS_USB0_PWR_EC0_CSEE_ON);
-		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-}
-
-/* Use only for Ally devices due to the wake_on_ac */
-static struct acpi_s2idle_dev_ops asus_ally_s2idle_dev_ops = {
-	.restore = asus_ally_s2idle_restore,
-};
-
-static void asus_s2idle_check_register(void)
-{
-	if (acpi_register_lps0_dev(&asus_ally_s2idle_dev_ops))
-		pr_warn("failed to register LPS0 sleep handler in asus-wmi\n");
-}
-
-static void asus_s2idle_check_unregister(void)
-{
-	acpi_unregister_lps0_dev(&asus_ally_s2idle_dev_ops);
-}
-#else
-static void asus_s2idle_check_register(void) {}
-static void asus_s2idle_check_unregister(void) {}
-#endif /* CONFIG_SUSPEND */
-
 static const struct dev_pm_ops asus_pm_ops = {
 	.thaw = asus_hotk_thaw,
 	.restore = asus_hotk_restore,
 	.resume = asus_hotk_resume,
+	.resume_early = asus_hotk_resume_early,
 	.prepare = asus_hotk_prepare,
 };
 
@@ -5358,13 +5291,7 @@ static int asus_wmi_probe(struct platform_device *pdev)
 			return ret;
 	}
 
-	asus_s2idle_check_register();
-
-	ret = asus_wmi_add(pdev);
-	if (ret)
-		asus_s2idle_check_unregister();
-
-	return ret;
+	return asus_wmi_add(pdev);
 }
 
 static bool used;
@@ -5398,9 +5325,6 @@ EXPORT_SYMBOL_GPL(asus_wmi_register_driver);
 
 void asus_wmi_unregister_driver(struct asus_wmi_driver *driver)
 {
-	guard(mutex)(&register_mutex);
-	asus_s2idle_check_unregister();
-
 	platform_device_unregister(driver->platform_device);
 	platform_driver_unregister(&driver->platform_driver);
 	used = false;
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 377b5a8ab..38198afc7 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -166,12 +166,6 @@
 #define ASUS_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
 #define ASUS_WMI_DSTS_LIGHTBAR_MASK	0x0000000F
 
-enum asus_ally_mcu_hack {
-	ASUS_WMI_ALLY_MCU_HACK_INIT,
-	ASUS_WMI_ALLY_MCU_HACK_ENABLED,
-	ASUS_WMI_ALLY_MCU_HACK_DISABLED,
-};
-
 /* Used to notify hid-asus when asus-wmi changes keyboard backlight */
 struct asus_hid_listener {
 	struct list_head list;
@@ -187,8 +181,6 @@ enum asus_hid_event {
 #define ASUS_EV_MAX_BRIGHTNESS 3
 
 #if IS_REACHABLE(CONFIG_ASUS_WMI)
-void set_ally_mcu_hack(enum asus_ally_mcu_hack status);
-void set_ally_mcu_powersave(bool enabled);
 int asus_wmi_get_devstate_dsts(u32 dev_id, u32 *retval);
 int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param, u32 *retval);
 int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval);
@@ -197,12 +189,6 @@ int asus_hid_register_listener(struct asus_hid_listener *cdev);
 void asus_hid_unregister_listener(struct asus_hid_listener *cdev);
 int asus_hid_event(enum asus_hid_event event);
 #else
-static inline void set_ally_mcu_hack(enum asus_ally_mcu_hack status)
-{
-}
-static inline void set_ally_mcu_powersave(bool enabled)
-{
-}
 static inline int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param, u32 *retval)
 {
 	return -ENODEV;
-- 
2.52.0


From 8a0ea321e0ed003745373a2075c6b0ff7cf8add9 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 27 Aug 2025 17:35:01 +0200
Subject: [PATCH 047/112] Revert "hid-asus: check ROG Ally MCU version and
 warn"

This reverts commit 00e005c952f74f50a3f86af96f56877be4685e14.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 114 ++---------------------------------------
 1 file changed, 5 insertions(+), 109 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 2f0b5e5e6..2cfca75d3 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -56,10 +56,6 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define FEATURE_KBD_LED_REPORT_ID2 0x5e
 #define FEATURE_KBD_LED_REPORT_SIZE 7
 
-#define ROG_ALLY_REPORT_SIZE 64
-#define ROG_ALLY_X_MIN_MCU 313
-#define ROG_ALLY_MIN_MCU 319
-
 #define SUPPORT_KBD_BACKLIGHT BIT(0)
 
 #define MAX_TOUCH_MAJOR 8
@@ -92,10 +88,9 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define QUIRK_MEDION_E1239T		BIT(10)
 #define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
 #define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
-#define QUIRK_ROG_ALLY_XPAD		BIT(13)
-#define QUIRK_SKIP_REPORT_FIXUP		BIT(14)
-#define QUIRK_ROG_NKEY_LEGACY		BIT(15)
-#define QUIRK_ROG_NKEY_RGB		BIT(16)
+#define QUIRK_SKIP_REPORT_FIXUP		BIT(13)
+#define QUIRK_ROG_NKEY_LEGACY		BIT(14)
+#define QUIRK_ROG_NKEY_RGB		BIT(15)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -590,94 +585,6 @@ static void asus_kbd_backlight_work(struct asus_kbd_leds *led)
 		hid_err(led->hdev, "Asus failed to set keyboard backlight: %d\n", ret);
 }
 
-/*
- * We don't care about any other part of the string except the version section.
- * Example strings: FGA80100.RC72LA.312_T01, FGA80100.RC71LS.318_T01
- * The bytes "5a 05 03 31 00 1a 13" and possibly more come before the version
- * string, and there may be additional bytes after the version string such as
- * "75 00 74 00 65 00" or a postfix such as "_T01"
- */
-static int mcu_parse_version_string(const u8 *response, size_t response_size)
-{
-	const u8 *end = response + response_size;
-	const u8 *p = response;
-	int dots, err, version;
-	char buf[4];
-
-	dots = 0;
-	while (p < end && dots < 2) {
-		if (*p++ == '.')
-			dots++;
-	}
-
-	if (dots != 2 || p >= end || (p + 3) >= end)
-		return -EINVAL;
-
-	memcpy(buf, p, 3);
-	buf[3] = '\0';
-
-	err = kstrtoint(buf, 10, &version);
-	if (err || version < 0)
-		return -EINVAL;
-
-	return version;
-}
-
-static int mcu_request_version(struct hid_device *hdev)
-{
-	u8 *response __free(kfree) = kzalloc(ROG_ALLY_REPORT_SIZE, GFP_KERNEL);
-	const u8 request[] = { 0x5a, 0x05, 0x03, 0x31, 0x00, 0x20 };
-	int ret;
-
-	if (!response)
-		return -ENOMEM;
-
-	ret = asus_kbd_set_report(hdev, request, sizeof(request));
-	if (ret < 0)
-		return ret;
-
-	ret = hid_hw_raw_request(hdev, FEATURE_REPORT_ID, response,
-				ROG_ALLY_REPORT_SIZE, HID_FEATURE_REPORT,
-				HID_REQ_GET_REPORT);
-	if (ret < 0)
-		return ret;
-
-	ret = mcu_parse_version_string(response, ROG_ALLY_REPORT_SIZE);
-	if (ret < 0) {
-		pr_err("Failed to parse MCU version: %d\n", ret);
-		print_hex_dump(KERN_ERR, "MCU: ", DUMP_PREFIX_NONE,
-			      16, 1, response, ROG_ALLY_REPORT_SIZE, false);
-	}
-
-	return ret;
-}
-
-static void validate_mcu_fw_version(struct hid_device *hdev, int idProduct)
-{
-	int min_version, version;
-
-	version = mcu_request_version(hdev);
-	if (version < 0)
-		return;
-
-	switch (idProduct) {
-	case USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY:
-		min_version = ROG_ALLY_MIN_MCU;
-		break;
-	case USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X:
-		min_version = ROG_ALLY_X_MIN_MCU;
-		break;
-	default:
-		min_version = 0;
-	}
-
-	if (version < min_version) {
-		hid_warn(hdev,
-			"The MCU firmware version must be %d or greater to avoid issues with suspend.\n",
-			min_version);
-	}
-}
-
 static void asus_kbd_rgb_work(struct asus_kbd_leds *led)
 {
 	u8 rgb_buf[][FEATURE_KBD_LED_REPORT_SIZE] = {
@@ -738,8 +645,6 @@ static void asus_kbd_work(struct work_struct *work)
 static int asus_kbd_register_leds(struct hid_device *hdev)
 {
 	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
-	struct usb_interface *intf;
-	struct usb_device *udev;
 	unsigned char kbd_func;
 	struct asus_kbd_leds *leds;
 	bool rgb_init = true;
@@ -771,13 +676,6 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 			return ret;
 	}
 
-	if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
-		intf = to_usb_interface(hdev->dev.parent);
-		udev = interface_to_usbdev(intf);
-		validate_mcu_fw_version(
-			hdev, le16_to_cpu(udev->descriptor.idProduct));
-	}
-
 	/* Check for backlight support */
 	if (!(kbd_func & SUPPORT_KBD_BACKLIGHT))
 		return -ENODEV;
@@ -1535,12 +1433,10 @@ static const struct hid_device_id asus_devices[] = {
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD
-		| QUIRK_ROG_ALLY_XPAD | QUIRK_ROG_NKEY_RGB },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD
-		| QUIRK_ROG_ALLY_XPAD | QUIRK_ROG_NKEY_RGB },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
-- 
2.52.0


From 93c7eb4166ce5098b46f70c307d091d84ccfdb4d Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 12 Oct 2024 19:07:48 +0200
Subject: [PATCH 048/112] remove ally quirk from asus_hid

Unfortunately it bails with ENOMEM preventing the controller which
might cause issues and sends random initialization commands not meant
for the platform (should NOOP though).
---
 drivers/hid/hid-asus.c | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 2cfca75d3..f04b67038 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -1431,12 +1431,6 @@ static const struct hid_device_id asus_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_Z13_LIGHTBAR),
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
-	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
-	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
-- 
2.52.0


From e4dcd00b0d57cf968386b37f07f95e29da7f3269 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 12 Oct 2024 19:11:05 +0200
Subject: [PATCH 049/112] Add DSDT config for original Ally older BIOSes

Older ROG Ally BIOSes do not have a speaker configuration in the DSDT.
Patch is originally by Jonathan LoBue <jlobue10@gmail.com>.
---
 .../codecs/side-codecs/cs35l41_hda_property.c | 39 ++++++++++++++++++-
 1 file changed, 38 insertions(+), 1 deletion(-)

diff --git a/sound/hda/codecs/side-codecs/cs35l41_hda_property.c b/sound/hda/codecs/side-codecs/cs35l41_hda_property.c
index 16d5ea771..1997c1aaa 100644
--- a/sound/hda/codecs/side-codecs/cs35l41_hda_property.c
+++ b/sound/hda/codecs/side-codecs/cs35l41_hda_property.c
@@ -6,8 +6,10 @@
 //
 // Author: Stefan Binding <sbinding@opensource.cirrus.com>
 
+#include <linux/dmi.h>
 #include <linux/acpi.h>
 #include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
 #include <linux/string.h>
 #include "cs35l41_hda_property.h"
 #include <linux/spi/spi.h>
@@ -30,6 +32,41 @@ struct cs35l41_config {
 	int boost_cap_microfarad; /* Required if boost_type == Internal */
 };
 
+static int asus_rog_2023_ally_fix(struct cs35l41_hda *cs35l41, struct device *physdev, int id,
+				const char *hid)
+{
+	const char *rog_ally_bios_ver = dmi_get_system_info(DMI_BIOS_VERSION);
+	const char *rog_ally_bios_num = rog_ally_bios_ver + 6; // Dropping the RC71L. part before the number
+	int rog_ally_bios_int, err;
+	
+	err = kstrtoint(rog_ally_bios_num, 10, &rog_ally_bios_int);
+	if(err || rog_ally_bios_int >= 330){
+		printk(KERN_INFO "DSD properties exist in the %d BIOS. Not applying DSD override...\n", rog_ally_bios_int);
+		return -ENOENT; //Patch not applicable. Exiting...
+	}
+
+	struct cs35l41_hw_cfg *hw_cfg = &cs35l41->hw_cfg;
+
+	dev_info(cs35l41->dev, "Adding DSD properties for %s\n", cs35l41->acpi_subsystem_id);
+
+	cs35l41->index = id == 0x40 ? 0 : 1;
+	cs35l41->channel_index = 0;
+	cs35l41->reset_gpio = gpiod_get_index(physdev, NULL, 0, GPIOD_OUT_HIGH);
+	cs35l41->speaker_id = cs35l41_get_speaker_id(physdev, 0, 0, 2);
+	hw_cfg->spk_pos = cs35l41->index;
+	hw_cfg->gpio1.func = CS35L41_NOT_USED;
+	hw_cfg->gpio1.valid = true;
+	hw_cfg->gpio2.func = CS35L41_INTERRUPT;
+	hw_cfg->gpio2.valid = true;
+	hw_cfg->bst_type = CS35L41_INT_BOOST;
+	hw_cfg->bst_ind = 1000; /* 1,000nH Inductance value */
+	hw_cfg->bst_ipk = 4500; /* 4,500mA peak current */
+	hw_cfg->bst_cap = 24; /* 24 microFarad cap value */
+	hw_cfg->valid = true;
+
+	return 0;
+}
+
 static const struct cs35l41_config cs35l41_config_table[] = {
 	{ "10251826", 2, EXTERNAL, { CS35L41_LEFT, CS35L41_RIGHT, 0, 0 }, 0, -1, -1, 0, 0, 0 },
 	{ "1025182C", 2, EXTERNAL, { CS35L41_LEFT, CS35L41_RIGHT, 0, 0 }, 0, -1, -1, 0, 0, 0 },
@@ -520,7 +557,7 @@ static const struct cs35l41_prop_model cs35l41_prop_model_table[] = {
 	{ "CSC3551", "104316A3", generic_dsd_config },
 	{ "CSC3551", "104316D3", generic_dsd_config },
 	{ "CSC3551", "104316F3", generic_dsd_config },
-	{ "CSC3551", "104317F3", generic_dsd_config },
+	{ "CSC3551", "104317F3", asus_rog_2023_ally_fix },
 	{ "CSC3551", "10431863", generic_dsd_config },
 	{ "CSC3551", "104318D3", generic_dsd_config },
 	{ "CSC3551", "10431A63", missing_speaker_id_gpio2 },
-- 
2.52.0


From fce72209cb4d0e43a9c696325cb94f78d0f5038a Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 17 Apr 2025 11:41:53 +0200
Subject: [PATCH 050/112] Revert "platform/x86: firmware_attributes_class: Drop
 lifecycle functions"

This reverts commit 6af39604c788d9df0ca697bab603202cf74c1a8c.
---
 drivers/platform/x86/firmware_attributes_class.c | 13 +++++++++++++
 drivers/platform/x86/firmware_attributes_class.h |  2 ++
 2 files changed, 15 insertions(+)

diff --git a/drivers/platform/x86/firmware_attributes_class.c b/drivers/platform/x86/firmware_attributes_class.c
index 736e96c18..87672c49e 100644
--- a/drivers/platform/x86/firmware_attributes_class.c
+++ b/drivers/platform/x86/firmware_attributes_class.c
@@ -22,6 +22,19 @@ static __exit void fw_attributes_class_exit(void)
 }
 module_exit(fw_attributes_class_exit);
 
+int fw_attributes_class_get(const struct class **fw_attr_class)
+{
+	*fw_attr_class = &firmware_attributes_class;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fw_attributes_class_get);
+
+int fw_attributes_class_put(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fw_attributes_class_put);
+
 MODULE_AUTHOR("Mark Pearson <markpearson@lenovo.com>");
 MODULE_DESCRIPTION("Firmware attributes class helper module");
 MODULE_LICENSE("GPL");
diff --git a/drivers/platform/x86/firmware_attributes_class.h b/drivers/platform/x86/firmware_attributes_class.h
index d27abe54f..ef6c3764a 100644
--- a/drivers/platform/x86/firmware_attributes_class.h
+++ b/drivers/platform/x86/firmware_attributes_class.h
@@ -8,5 +8,7 @@
 #include <linux/device/class.h>
 
 extern const struct class firmware_attributes_class;
+int fw_attributes_class_get(const struct class **fw_attr_class);
+int fw_attributes_class_put(void);
 
 #endif /* FW_ATTR_CLASS_H */
-- 
2.52.0


From 88e282189ab6cc09232651383a4d4a6d3060ba52 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Fri, 24 May 2024 10:54:36 +1200
Subject: [PATCH 051/112] platform/x86: asus-wmi: don't fail if
 platform_profile already registered

On some newer laptops it appears that an AMD driver can register a
platform_profile handler. If this happens then the asus_wmi driver would
error with -EEXIST when trying to register its own handler leaving the
user with a possibly unusable system - this is especially true for
laptops with an MCU that emit a stream of HID packets, some of which can
be misinterpreted as shutdown signals.

We can safely continue loading the driver instead of bombing out.

Signed-off-by: Luke D. Jones <luke@ljones.dev>
---
 drivers/platform/x86/asus-wmi.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index eff4119be..1046ad699 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -5024,7 +5024,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 		goto fail_fan_boost_mode;
 
 	err = platform_profile_setup(asus);
-	if (err)
+	if (err && err != -EEXIST)
 		goto fail_platform_profile_setup;
 
 	err = asus_wmi_sysfs_init(asus->platform_device);
-- 
2.52.0


From fa02aac02579297f73f7704c19f216299ac81e2e Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Sat, 21 Sep 2024 16:04:58 +1200
Subject: [PATCH 052/112] hid-asus: Add MODULE_IMPORT_NS(ASUS_WMI)

A small change to asus_wmi_evaluate_method() was introduced during
asus-armoury driver development to put the exports behind a namespace.

Import that namespace here.

Signed-off-by: Luke D. Jones <luke@ljones.dev>
Acked-by: Jiri Kosina <jkosina@suse.com>
---
 drivers/hid/hid-asus.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index f04b67038..45c5ac672 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -1486,4 +1486,5 @@ static struct hid_driver asus_driver = {
 };
 module_hid_driver(asus_driver);
 
+MODULE_IMPORT_NS("ASUS_WMI");
 MODULE_LICENSE("GPL");
-- 
2.52.0


From 33a70bb9aafe7558eba73f3bcf489a25668f6213 Mon Sep 17 00:00:00 2001
From: Alesh Slovak <alesh@playtron.one>
Date: Tue, 30 Jul 2024 20:40:06 -0400
Subject: [PATCH 053/112] drm: panel-orientation-quirks: Add Aya Neo 2S
 orientation quirk

---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 3a218fb59..734a49b9f 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -203,6 +203,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_MATCH(DMI_PRODUCT_NAME, "AYANEO 2"),
 		},
 		.driver_data = (void *)&lcd1200x1920_rightside_up,
+	}, {	/* AYA NEO AYANEO 2S */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AYANEO 2S"),
+		},
+		.driver_data = (void *)&lcd1200x1920_rightside_up,
 	}, {	/* AYA NEO 2021 */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYADEVICE"),
-- 
2.52.0


From 9b6096dd16c8fb64fbb83cb2aed8c7cc2cd79287 Mon Sep 17 00:00:00 2001
From: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
Date: Thu, 8 Aug 2024 15:19:32 +0200
Subject: [PATCH 054/112] drm: panel-orientation-quirks: Add AYANEO FLIP DS
 quirk

---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 734a49b9f..aae1634f5 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -209,6 +209,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AYANEO 2S"),
 		},
 		.driver_data = (void *)&lcd1200x1920_rightside_up,
+	}, {	/* AYA NEO FLIP DS */
+		.matches = {
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "FLIP DS"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* AYA NEO 2021 */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYADEVICE"),
-- 
2.52.0


From 71c742d9dc50faab56665d5dea79e1d2ac226824 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 22 Dec 2024 18:15:12 +0100
Subject: [PATCH 055/112] drm: panel-orientation-quirks: Add OneXPlayer X1 AMD
 and Intel quirk

The OneXPlayer X1 series features a 2k 10.95 display with a portrait
orientation. Add a quirk to set the panel orientation to portrait mode
to both the Intel and AMD variants.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index aae1634f5..a32017d18 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -498,6 +498,24 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONE XPLAYER"),
 		},
 		.driver_data = (void *)&lcd1200x1920_leftside_up,
+	}, {	/* OneXPlayer X1 AMD */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 A"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 AMD Strix Point */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Pro"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 Intel */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 i"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OrangePi Neo */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "OrangePi"),
-- 
2.52.0


From 8f12706c5a9a8e5bb0bbfb69756623e3f6e2f127 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 22 Dec 2024 18:18:09 +0100
Subject: [PATCH 056/112] drm: panel-orientation-quirks: Add OneXPlayer X1 Mini
 (AMD) quirk

The OneXPlayer X1 mini features a 2k 8.8 display with a portrait
orientation. Add a quirk to set the panel orientation to portrait
mode. There is no Intel variant.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index a32017d18..3c86f9be5 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -516,6 +516,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 i"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 mini (AMD) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 mini"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OrangePi Neo */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "OrangePi"),
-- 
2.52.0


From 1ef10ad3e93034515cbeceb0cc72f38f6c6def07 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Mon, 23 Jun 2025 18:23:22 +0200
Subject: [PATCH 057/112] drm: panel-orientation-quirks: Add OneXPlayer X1Mini
 Pro quirk

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 3c86f9be5..5dffb1bdc 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -522,6 +522,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 mini"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 mini pro (AMD Strix Point) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Mini Pro"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OrangePi Neo */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "OrangePi"),
-- 
2.52.0


From 7da6420b7c57733b11426dfc71fe88838351a32d Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 22 Dec 2024 18:19:28 +0100
Subject: [PATCH 058/112] drm: panel-orientation-quirks: Add OneXPlayer F1Pro
 quirk

The OneXPlayer F1Pro has a 144hz 1920x1080 portrait OLED panel.
Add a quirk to correct the panel portrait orientation. In addition,
it comes with a red limited edition variant in the Chinese market,
so add that as well.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 5dffb1bdc..fd159709d 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -528,6 +528,18 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Mini Pro"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer OneXFly F1 Pro (OLED) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1Pro"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
+	}, {	/* OneXPlayer OneXFly F1 Pro (OLED) LE Red variant */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1 EVA-02"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* OrangePi Neo */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "OrangePi"),
-- 
2.52.0


From a40fd16a3133bce338b442cb5b0c1cfa55c6ccb8 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Wed, 2 Oct 2024 22:17:26 +0200
Subject: [PATCH 059/112] HID: Add quirk to ignore the touchscreen battery on
 OneXPlayer X1

The X1 devices come with a pen-capable touchscreen, in which the HID
descriptor reports there is always a battery at 100% charge. Quirk it
to not report the battery status.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-ids.h   | 1 +
 drivers/hid/hid-input.c | 2 ++
 2 files changed, 3 insertions(+)

diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 31b71223f..7e400ff31 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -1068,6 +1068,7 @@
 #define USB_VENDOR_ID_NOVATEK		0x0603
 #define USB_DEVICE_ID_NOVATEK_PCT	0x0600
 #define USB_DEVICE_ID_NOVATEK_MOUSE	0x1602
+#define I2C_DEVICE_ID_ONEXPLAYER_X1    0xF001
 
 #define USB_VENDOR_ID_NTI               0x0757
 #define USB_DEVICE_ID_USB_SUN           0x0a00
diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index 2633fcd8f..13dafdc9e 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -404,6 +404,8 @@ static const struct hid_device_id hid_battery_quirks[] = {
 	 */
 	{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, HID_ANY_ID), HID_BATTERY_QUIRK_IGNORE },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ELAN, HID_ANY_ID), HID_BATTERY_QUIRK_IGNORE },
+	{ HID_I2C_DEVICE(USB_VENDOR_ID_NOVATEK, I2C_DEVICE_ID_ONEXPLAYER_X1),
+	  HID_BATTERY_QUIRK_IGNORE },
 	{}
 };
 
-- 
2.52.0


From 06eb745ba92200e97e5f445ce7def65be4ecbc28 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 22 Dec 2024 18:04:42 +0100
Subject: [PATCH 060/112] drm: panel-orientation-quirks: Add Zotac Gaming Zone
 quirk

The Zotac Gaming Zone handheld features a 1080p portrait OLED screen.
Add the rotation to the panel orientation quirks.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index fd159709d..b06ab3cd0 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -540,6 +540,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1 EVA-02"),
 		},
 		.driver_data = (void *)&lcd1080x1920_leftside_up,
+	}, {	/* Zotac Gaming Zone (OLED) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ZOTAC"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ZOTAC GAMING ZONE"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* OrangePi Neo */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "OrangePi"),
-- 
2.52.0


From d7d676b54e07a6c9cac9c645fddf00741b0b3d83 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 18 Mar 2025 20:38:27 +0100
Subject: [PATCH 061/112] drm: panel-orientation-quirks: Add OneXPlayer F1 Hawk
 Point

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index b06ab3cd0..3ec26fade 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -528,7 +528,7 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Mini Pro"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
-	}, {	/* OneXPlayer OneXFly F1 Pro (OLED) */
+	}, {	/* OneXPlayer OneXFly F1 Pro (OLED) Strix Point */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1Pro"),
@@ -540,6 +540,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1 EVA-02"),
 		},
 		.driver_data = (void *)&lcd1080x1920_leftside_up,
+	}, {	/* OneXPlayer OneXFly F1 Pro (OLED) Hawk Point */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1 OLED"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* Zotac Gaming Zone (OLED) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ZOTAC"),
-- 
2.52.0


From 5c7ae89290c315712e5507c41188ab6734560ef9 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 23:42:51 +0100
Subject: [PATCH 062/112] drm: panel-orientation-quirks: Add OneXPlayer G1 Amd
 & Intel

Add quirks for the new clamshell device OneXPlayer G1 for both AMD
and Intel. The device has a 1600x2560p 144hz LCD panel.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 3ec26fade..96f2c435e 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -546,6 +546,18 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1 OLED"),
 		},
 		.driver_data = (void *)&lcd1080x1920_leftside_up,
+	}, {	/* OneXPlayer OneXFly G1 AMD */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER G1 A"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer OneXFly G1 Intel */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER G1 i"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* Zotac Gaming Zone (OLED) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ZOTAC"),
-- 
2.52.0


From 27b39acee477f8a4deb919d4db5b6aab38857dcb Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 23 Apr 2025 10:19:53 +0200
Subject: [PATCH 063/112] drm: panel-orientation-quirks: Add GPD Win Max (2021)

Right side up, DSI-1, 800x1280 screen.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 96f2c435e..05b1c993c 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -321,6 +321,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "G1619-01"),
 		},
 		.driver_data = (void *)&lcd800x1280_rightside_up,
+	}, {	/* GPD Win Max (2021) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "GPD"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "G1619-03"),
+		},
+		.driver_data = (void *)&lcd800x1280_rightside_up,
 	}, {	/*
 		 * GPD Pocket, note that the DMI data is less generic then
 		 * it seems, devices with a board-vendor of "AMI Corporation"
-- 
2.52.0


From 3681ef2b3f23dcf6440d3337df51aedbbe39ae2a Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 01:07:55 +0200
Subject: [PATCH 064/112] drm: panel-orientation-quirks: Add Steamfork quirks

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 .../gpu/drm/drm_panel_orientation_quirks.c    | 26 ++++++++++++++++++-
 1 file changed, 25 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 05b1c993c..79d89b17b 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -179,6 +179,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Win600"),
 		},
 		.driver_data = (void *)&lcd720x1280_rightside_up,
+	}, {	/* AOKZOE A1 Pro */
+		.matches = {
+		 DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AOKZOE"),
+		 DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AOKZOE A1 Pro"),
+		},
+		.driver_data = (void *)&lcd1200x1920_leftside_up,
 	}, {	/* Asus T100HA */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
@@ -218,9 +224,15 @@ static const struct dmi_system_id orientation_data[] = {
 	}, {	/* AYA NEO 2021 */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYADEVICE"),
-		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AYA NEO 2021"),
+		  DMI_MATCH(DMI_PRODUCT_NAME, "AYA NEO"),
 		},
 		.driver_data = (void *)&lcd800x1280_rightside_up,
+	}, {	/* AYA NEO 2021 series (alternate vendor id) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
+		  DMI_MATCH(DMI_PRODUCT_NAME, "NEO 2021"),
+ 		},
+ 		.driver_data = (void *)&lcd800x1280_rightside_up,
 	}, {	/* AYA NEO AIR */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
@@ -348,6 +360,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_BOARD_NAME, "Default string"),
 		},
 		.driver_data = (void *)&gpd_pocket2,
+	}, {	/* GPD Pocket 4 */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "GPD"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "G1628-04"),
+		},
+		.driver_data = (void *)&lcd1600x2560_rightside_up,
 	}, {	/* GPD Win (same note on DMI match as GPD Pocket) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AMI Corporation"),
@@ -582,6 +600,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Galaxy Book 10.6"),
 		},
 		.driver_data = (void *)&lcd1280x1920_rightside_up,
+	}, {    /* Tectoy Zeenix Lite (AYN Loki Zero Rebadge) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Tectoy"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Zeenix Lite"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* Valve Steam Deck (Jupiter) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Valve"),
-- 
2.52.0


From 98e6b6313efbbe82b5c4c20bc9be9244121a3b35 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 22 Aug 2025 23:20:49 +0200
Subject: [PATCH 065/112] drm: panel-orientation-quirks: Add Ayaneo 3

The Ayaneo 3 comes with two panels, an OLED right side up 1080p panel
and an IPS landscape 1080p panel. However, both have the same DMI data.

As the landscape panel is 1920x1080 and the right side up panel is
1080x1920, the width and height arguments are used to differentiate
the panels.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 79d89b17b..7590b804d 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -215,6 +215,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AYANEO 2S"),
 		},
 		.driver_data = (void *)&lcd1200x1920_rightside_up,
+	}, {	/* AYANEO 3 */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AYANEO 3"),
+		},
+		.driver_data = (void *)&lcd1080x1920_rightside_up,
 	}, {	/* AYA NEO FLIP DS */
 		.matches = {
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
-- 
2.52.0


From 659b0cc8415655bb68c03b9105514642c8608faa Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 24 Aug 2025 00:17:26 +0200
Subject: [PATCH 066/112] drm: panel-orientation-quirks: Add Zeenix Pro

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 7590b804d..f508ffbd6 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -612,6 +612,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Zeenix Lite"),
 		},
 		.driver_data = (void *)&lcd1080x1920_leftside_up,
+	}, {    /* Tectoy Zeenix Pro (AYN Loki Max Rebadge) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Tectoy"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Zeenix Pro"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* Valve Steam Deck (Jupiter) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Valve"),
-- 
2.52.0


From fed8d6f270f9ba016dd5c912faba4ef6c503a571 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 20 Jul 2025 03:01:58 +0200
Subject: [PATCH 067/112] drm: panel-orientation-quirks: Add OneXPlayer X1Pro
 EVA-2 quirk This is a special edition of the X1 that uses this year's Intel
 CPU.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index f508ffbd6..ed1901de4 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -540,6 +540,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Pro"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1Pro EVA variant */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Pro EVA-02"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OneXPlayer X1 Intel */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
-- 
2.52.0


From 07cfee84fbe7d527a7e303439dccd05d3e3ae580 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 01:11:23 +0200
Subject: [PATCH 068/112] Input: goodix - add support for ACPI ID GDIX1003

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/input/touchscreen/goodix.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/input/touchscreen/goodix.c b/drivers/input/touchscreen/goodix.c
index f8798d11e..7fd600e21 100644
--- a/drivers/input/touchscreen/goodix.c
+++ b/drivers/input/touchscreen/goodix.c
@@ -1524,6 +1524,7 @@ static DEFINE_SIMPLE_DEV_PM_OPS(goodix_pm_ops, goodix_suspend, goodix_resume);
 
 static const struct i2c_device_id goodix_ts_id[] = {
 	{ "GDIX1001:00" },
+	{ "GDIX1003:00" },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, goodix_ts_id);
-- 
2.52.0


From 5f94f98f40642b7a72c494c42b6109830529c933 Mon Sep 17 00:00:00 2001
From: CVMagic <546352+CVMagic@users.noreply.github.com>
Date: Thu, 25 Apr 2024 09:39:40 -0500
Subject: [PATCH 069/112] Codec: Add aw87xxx codec with ACPI implementation

Full implementation including all commits.

Bouhaa fixed some warnings.

Co-developed-by: bouhaa <boukehaarsma23@gmail.com>
---
 sound/soc/codecs/Kconfig                      |    2 +
 sound/soc/codecs/Makefile                     |    1 +
 sound/soc/codecs/aw87xxx/Kconfig              |    5 +
 sound/soc/codecs/aw87xxx/Makefile             |    4 +
 sound/soc/codecs/aw87xxx/aw87xxx.c            | 1554 +++++
 sound/soc/codecs/aw87xxx/aw87xxx.h            |  130 +
 sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.c    | 1558 +++++
 sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.h    |  191 +
 sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.c  |  515 ++
 sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.h  |   73 +
 sound/soc/codecs/aw87xxx/aw87xxx_device.c     |  977 +++
 sound/soc/codecs/aw87xxx/aw87xxx_device.h     |  149 +
 sound/soc/codecs/aw87xxx/aw87xxx_dsp.c        |  355 ++
 sound/soc/codecs/aw87xxx/aw87xxx_dsp.h        |   65 +
 sound/soc/codecs/aw87xxx/aw87xxx_log.h        |   33 +
 sound/soc/codecs/aw87xxx/aw87xxx_monitor.c    | 1208 ++++
 sound/soc/codecs/aw87xxx/aw87xxx_monitor.h    |   96 +
 sound/soc/codecs/aw87xxx/aw87xxx_pid_18_reg.h | 2315 ++++++++
 sound/soc/codecs/aw87xxx/aw87xxx_pid_39_reg.h |   67 +
 .../codecs/aw87xxx/aw87xxx_pid_59_3x9_reg.h   |   93 +
 .../codecs/aw87xxx/aw87xxx_pid_59_5x9_reg.h   |   94 +
 sound/soc/codecs/aw87xxx/aw87xxx_pid_5a_reg.h | 4124 +++++++++++++
 sound/soc/codecs/aw87xxx/aw87xxx_pid_60_reg.h | 5246 +++++++++++++++++
 sound/soc/codecs/aw87xxx/aw87xxx_pid_76_reg.h | 1205 ++++
 sound/soc/codecs/aw87xxx/aw87xxx_pid_9b_reg.h |   81 +
 25 files changed, 20141 insertions(+)
 create mode 100644 sound/soc/codecs/aw87xxx/Kconfig
 create mode 100644 sound/soc/codecs/aw87xxx/Makefile
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_device.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_device.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_dsp.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_dsp.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_log.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_monitor.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_monitor.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_18_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_39_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_59_3x9_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_59_5x9_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_5a_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_60_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_76_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_9b_reg.h

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 061791e61..dde28c733 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -2832,4 +2832,6 @@ config SND_SOC_LPASS_TX_MACRO
 	select SND_SOC_LPASS_MACRO_COMMON
 	tristate "Qualcomm TX Macro in LPASS(Low Power Audio SubSystem)"
 
+source "sound/soc/codecs/aw87xxx/Kconfig"
+
 endmenu
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index d687d4f74..f32095de2 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -864,6 +864,7 @@ obj-$(CONFIG_SND_SOC_WSA884X)	+= snd-soc-wsa884x.o
 obj-$(CONFIG_SND_SOC_ZL38060)	+= snd-soc-zl38060.o
 
 # Amp
+obj-$(CONFIG_SND_SOC_AW87XXX)    += aw87xxx/
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_MAX98504)	+= snd-soc-max98504.o
 obj-$(CONFIG_SND_SOC_SIMPLE_AMPLIFIER)	+= snd-soc-simple-amplifier.o
diff --git a/sound/soc/codecs/aw87xxx/Kconfig b/sound/soc/codecs/aw87xxx/Kconfig
new file mode 100644
index 000000000..bd0f208e2
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/Kconfig
@@ -0,0 +1,5 @@
+config SND_SOC_AW87XXX
+	tristate "SoC Audio for awinic AW87XXX Smart K PA"
+	depends on I2C
+	help
+	  This option enables support for AW87XXX Smart K PA.
diff --git a/sound/soc/codecs/aw87xxx/Makefile b/sound/soc/codecs/aw87xxx/Makefile
new file mode 100644
index 000000000..d32f319a5
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/Makefile
@@ -0,0 +1,4 @@
+#for AWINIC AW87XXX Smart K PA
+snd-soc-aw87xxx-objs := aw87xxx.o aw87xxx_device.o aw87xxx_monitor.o aw87xxx_bin_parse.o aw87xxx_dsp.o aw87xxx_acf_bin.o
+obj-$(CONFIG_SND_SOC_AW87XXX) += snd-soc-aw87xxx.o
+
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx.c b/sound/soc/codecs/aw87xxx/aw87xxx.c
new file mode 100644
index 000000000..837a60dea
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx.c
@@ -0,0 +1,1554 @@
+/*
+ * aw87xxx.c  aw87xxx pa module
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: Barry <zhaozhongbo@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/firmware.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/gameport.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/kthread.h>
+#include <linux/vmalloc.h>
+#include <uapi/sound/asound.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include "aw87xxx.h"
+#include "aw87xxx_device.h"
+#include "aw87xxx_log.h"
+#include "aw87xxx_monitor.h"
+#include "aw87xxx_acf_bin.h"
+#include "aw87xxx_bin_parse.h"
+#include "aw87xxx_dsp.h"
+
+/*****************************************************************
+* aw87xxx marco
+******************************************************************/
+#define AW87XXX_I2C_NAME	"aw87xxx_pa"
+#define AW87XXX_DRIVER_VERSION	"v2.7.0"
+#define AW87XXX_FW_BIN_NAME	"aw87xxx_acf.bin"
+#define AW87XXX_PROF_MUSIC	"Music"
+/*************************************************************************
+ * aw87xxx variable
+ ************************************************************************/
+static LIST_HEAD(g_aw87xxx_list);
+static DEFINE_MUTEX(g_aw87xxx_mutex_lock);
+unsigned int g_aw87xxx_dev_cnt = 0;
+
+static const char *const aw87xxx_monitor_switch[] = {"Disable", "Enable"};
+static const char *const aw87xxx_spin_switch[] = {"spin_0", "spin_90",
+					 "spin_180", "spin_270"};
+#if defined(AW_KERNEL_VER_OVER_6_16_1)
+static void new_snd_soc_unregister_component(struct device *dev)
+{
+	return snd_soc_unregister_component_by_driver(dev, NULL);
+}
+static struct aw_componet_codec_ops aw_componet_codec_ops = {
+	.add_codec_controls = snd_soc_add_component_controls,
+	.unregister_codec = new_snd_soc_unregister_component,
+};
+#elif defined(AW_KERNEL_VER_OVER_4_19_1)
+static struct aw_componet_codec_ops aw_componet_codec_ops = {
+	.add_codec_controls = snd_soc_add_component_controls,
+	.unregister_codec = snd_soc_unregister_component,
+};
+#else
+static struct aw_componet_codec_ops aw_componet_codec_ops = {
+	.add_codec_controls = snd_soc_add_codec_controls,
+	.unregister_codec = snd_soc_unregister_codec,
+};
+#endif
+
+enum smi_bus_type {
+	SMI_I2C,
+	SMI_SPI,
+	SMI_AUTO_DETECT,
+};
+
+struct smi_instance {
+	const char *type;
+	unsigned int flags;
+	int irq_idx;
+};
+
+struct smi_node {
+	enum smi_bus_type bus_type;
+	struct smi_instance instances[];
+};
+
+/************************************************************************
+ *
+ * aw87xxx device update profile
+ *
+ ************************************************************************/
+static int aw87xxx_power_down(struct aw87xxx *aw87xxx, char *profile)
+{
+	int ret = 0;
+	struct aw_prof_desc *prof_desc = NULL;
+	struct aw_prof_info *prof_info = &aw87xxx->acf_info.prof_info;
+	struct aw_data_container *data_container = NULL;
+	struct aw_device *aw_dev = &aw87xxx->aw_dev;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+
+	if (!prof_info->status) {
+		AW_DEV_LOGE(aw87xxx->dev, "profile_cfg not load");
+		return -EINVAL;
+	}
+
+	prof_desc = aw87xxx_acf_get_prof_desc_form_name(aw87xxx->dev, &aw87xxx->acf_info, profile);
+	if (prof_desc == NULL)
+		goto no_bin_pwr_off;
+
+	if (!prof_desc->prof_st)
+		goto no_bin_pwr_off;
+
+
+	data_container = &prof_desc->data_container;
+	AW_DEV_LOGD(aw87xxx->dev, "get profile[%s] data len [%d]",
+			profile, data_container->len);
+
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGI(aw87xxx->dev, "profile[%s] has already load ", profile);
+	} else {
+		if (aw_dev->ops.pwr_off_func) {
+			ret = aw_dev->ops.pwr_off_func(aw_dev, data_container);
+			if (ret < 0) {
+				AW_DEV_LOGE(aw87xxx->dev, "load profile[%s] failed ", profile);
+				goto pwr_off_failed;
+			}
+		} else {
+			ret = aw87xxx_dev_default_pwr_off(aw_dev, data_container);
+			if (ret < 0) {
+				AW_DEV_LOGE(aw87xxx->dev, "load profile[%s] failed ", profile);
+				goto pwr_off_failed;
+			}
+		}
+	}
+
+	aw87xxx->current_profile = prof_desc->prof_name;
+	return 0;
+
+pwr_off_failed:
+no_bin_pwr_off:
+	aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, false);
+	aw87xxx->current_profile = aw87xxx->prof_off_name;
+	return ret;
+}
+
+static int aw87xxx_power_on(struct aw87xxx *aw87xxx, char *profile)
+{
+	int ret = -EINVAL;
+	struct aw_prof_desc *prof_desc = NULL;
+	struct aw_prof_info *prof_info = &aw87xxx->acf_info.prof_info;
+	struct aw_data_container *data_container = NULL;
+	struct aw_device *aw_dev = &aw87xxx->aw_dev;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+
+	if (!prof_info->status) {
+		AW_DEV_LOGE(aw87xxx->dev, "profile_cfg not load");
+		return -EINVAL;
+	}
+
+	if (0 == strncmp(profile, aw87xxx->prof_off_name, AW_PROFILE_STR_MAX))
+		return aw87xxx_power_down(aw87xxx, profile);
+
+	prof_desc = aw87xxx_acf_get_prof_desc_form_name(aw87xxx->dev, &aw87xxx->acf_info, profile);
+	if (prof_desc == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "not found [%s] parameter", profile);
+		return -EINVAL;
+	}
+
+	if (!prof_desc->prof_st) {
+		AW_DEV_LOGE(aw87xxx->dev, "not found data container");
+		return -EINVAL;
+	}
+
+	data_container = &prof_desc->data_container;
+	AW_DEV_LOGD(aw87xxx->dev, "get profile[%s] data len [%d]",
+			profile, data_container->len);
+
+	if (aw_dev->ops.pwr_on_func) {
+		ret = aw_dev->ops.pwr_on_func(aw_dev, data_container);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "load profile[%s] failed ",
+				profile);
+			return aw87xxx_power_down(aw87xxx, aw87xxx->prof_off_name);
+		}
+	} else {
+		ret = aw87xxx_dev_default_pwr_on(aw_dev, data_container);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "load profile[%s] failed ",
+				profile);
+			return aw87xxx_power_down(aw87xxx, aw87xxx->prof_off_name);
+		}
+	}
+
+	aw87xxx->current_profile = prof_desc->prof_name;
+	AW_DEV_LOGD(aw87xxx->dev, "load profile[%s] succeed", profile);
+
+	return 0;
+}
+
+
+
+int aw87xxx_update_profile(struct aw87xxx *aw87xxx, char *profile)
+{
+	int ret = -1;
+
+	AW_DEV_LOGD(aw87xxx->dev, "load profile[%s] enter", profile);
+	mutex_lock(&aw87xxx->reg_lock);
+	aw87xxx_monitor_stop(&aw87xxx->monitor);
+	if (0 == strncmp(profile, aw87xxx->prof_off_name, AW_PROFILE_STR_MAX)) {
+		ret = aw87xxx_power_down(aw87xxx, profile);
+	} else {
+		ret = aw87xxx_power_on(aw87xxx, profile);
+		if (!ret)
+			aw87xxx_monitor_start(&aw87xxx->monitor);
+	}
+	mutex_unlock(&aw87xxx->reg_lock);
+
+	return ret;
+}
+
+int aw87xxx_update_profile_esd(struct aw87xxx *aw87xxx, char *profile)
+{
+	int ret = -1;
+
+	if (0 == strncmp(profile, aw87xxx->prof_off_name, AW_PROFILE_STR_MAX))
+		ret = aw87xxx_power_down(aw87xxx, profile);
+	else
+		ret = aw87xxx_power_on(aw87xxx, profile);
+
+	return ret;
+}
+
+char *aw87xxx_show_current_profile(int dev_index)
+{
+	struct list_head *pos = NULL;
+	struct aw87xxx *aw87xxx = NULL;
+
+	list_for_each(pos, &g_aw87xxx_list) {
+		aw87xxx = list_entry(pos, struct aw87xxx, list);
+		if (aw87xxx->dev_index == dev_index) {
+			AW_DEV_LOGI(aw87xxx->dev, "current profile is [%s]",
+				aw87xxx->current_profile);
+			return aw87xxx->current_profile;
+		}
+	}
+
+	AW_LOGE("not found struct aw87xxx, dev_index = [%d]", dev_index);
+	return NULL;
+}
+EXPORT_SYMBOL(aw87xxx_show_current_profile);
+
+int aw87xxx_set_profile(int dev_index, char *profile)
+{
+	struct list_head *pos = NULL;
+	struct aw87xxx *aw87xxx = NULL;
+
+	list_for_each(pos, &g_aw87xxx_list) {
+		aw87xxx = list_entry(pos, struct aw87xxx, list);
+		if (profile && aw87xxx->dev_index == dev_index) {
+			AW_DEV_LOGD(aw87xxx->dev, "set dev_index = %d, profile = %s",
+				dev_index, profile);
+			return aw87xxx_update_profile(aw87xxx, profile);
+		}
+	}
+
+	AW_LOGE("not found struct aw87xxx, dev_index = [%d]", dev_index);
+	return -EINVAL;
+}
+EXPORT_SYMBOL(aw87xxx_set_profile);
+
+int aw87xxx_set_profile_by_id(int dev_index, int profile_id)
+{
+	char *profile = NULL;
+
+	profile = aw87xxx_ctos_get_prof_name(profile_id);
+	if (profile == NULL) {
+		AW_LOGE("aw87xxx, dev_index[%d] profile[%d] not support!",
+					dev_index, profile_id);
+		return -EINVAL;
+	}
+
+	AW_LOGI("aw87xxx, dev_index[%d] set profile[%s] by id[%d]",
+					dev_index, profile, profile_id);
+	return aw87xxx_set_profile(dev_index, profile);
+}
+EXPORT_SYMBOL(aw87xxx_set_profile_by_id);
+
+/****************************************************************************
+ *
+ * aw87xxx Kcontrols
+ *
+ ****************************************************************************/
+static int aw87xxx_profile_switch_info(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	int count = 0;
+	char *name = NULL;
+	char *profile_name = NULL;
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+
+	if (aw87xxx == NULL) {
+		AW_LOGE("get struct aw87xxx failed");
+		return -EINVAL;
+	}
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+
+	/*make sure have prof */
+	count = aw87xxx_acf_get_profile_count(aw87xxx->dev, &aw87xxx->acf_info);
+	if (count <= 0) {
+		uinfo->value.enumerated.items = 0;
+		AW_DEV_LOGE(aw87xxx->dev, "get count[%d] failed", count);
+		return 0;
+	}
+
+	uinfo->value.enumerated.items = count;
+	if (uinfo->value.enumerated.item >= count)
+		uinfo->value.enumerated.item = count - 1;
+
+	name = uinfo->value.enumerated.name;
+	count = uinfo->value.enumerated.item;
+	profile_name = aw87xxx_acf_get_prof_name_form_index(aw87xxx->dev,
+		&aw87xxx->acf_info, count);
+	if (profile_name == NULL) {
+		strscpy(uinfo->value.enumerated.name, "NULL",
+			strlen("NULL") + 1);
+		return 0;
+	}
+
+	strscpy(name, profile_name, sizeof(uinfo->value.enumerated.name));
+
+	return 0;
+}
+
+static int aw87xxx_profile_switch_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	int ret = -1;
+	char *profile_name = NULL;
+	int index = ucontrol->value.integer.value[0];
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+	struct acf_bin_info *acf_info = NULL;
+
+	if (aw87xxx == NULL) {
+		AW_LOGE("get struct aw87xxx failed");
+		return -EINVAL;
+	}
+
+	acf_info = &aw87xxx->acf_info;
+
+	profile_name = aw87xxx_acf_get_prof_name_form_index(aw87xxx->dev, acf_info, index);
+	if (!profile_name) {
+		AW_DEV_LOGE(aw87xxx->dev, "not found profile name,index=[%d]",
+				index);
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "set profile [%s]", profile_name);
+
+	ret = aw87xxx_update_profile(aw87xxx, profile_name);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "set dev_index[%d] profile failed, profile = %s",
+			aw87xxx->dev_index, profile_name);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int aw87xxx_profile_switch_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	int index = 0;
+	char *profile;
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+
+	if (aw87xxx == NULL) {
+		AW_LOGE("get struct aw87xxx failed");
+		return -EINVAL;
+	}
+
+	if (!aw87xxx->current_profile) {
+		AW_DEV_LOGE(aw87xxx->dev, "profile not init");
+		return -EINVAL;
+	}
+
+	profile = aw87xxx->current_profile;
+	AW_DEV_LOGI(aw87xxx->dev, "current profile:[%s]",
+		aw87xxx->current_profile);
+
+
+	index = aw87xxx_acf_get_prof_index_form_name(aw87xxx->dev,
+		&aw87xxx->acf_info, aw87xxx->current_profile);
+	if (index < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "get profile index failed");
+		return index;
+	}
+
+	ucontrol->value.integer.value[0] = index;
+
+	return 0;
+}
+
+static int aw87xxx_vmax_get_info(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = INT_MIN;
+	uinfo->value.integer.max = AW_VMAX_MAX;
+
+	return 0;
+}
+
+static int aw87xxx_vmax_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	int ret = -1;
+	int vmax_val = 0;
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+
+	if (aw87xxx == NULL) {
+		AW_LOGE("get struct aw87xxx failed");
+		return -EINVAL;
+	}
+
+	ret = aw87xxx_monitor_no_dsp_get_vmax(&aw87xxx->monitor, &vmax_val);
+	if (ret < 0)
+		return ret;
+
+	ucontrol->value.integer.value[0] = vmax_val;
+	AW_DEV_LOGI(aw87xxx->dev, "get vmax = [0x%x]", vmax_val);
+
+	return 0;
+}
+
+static int aw87xxx_monitor_switch_info(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	int count;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	count = ARRAY_SIZE(aw87xxx_monitor_switch);
+
+	uinfo->value.enumerated.items = count;
+
+	if (uinfo->value.enumerated.item >= count)
+		uinfo->value.enumerated.item = count - 1;
+
+	strscpy(uinfo->value.enumerated.name,
+		aw87xxx_monitor_switch[uinfo->value.enumerated.item],
+		strlen(aw87xxx_monitor_switch[uinfo->value.enumerated.item]) + 1);
+
+	return 0;
+}
+
+static int aw87xxx_monitor_switch_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	uint32_t ctrl_value = ucontrol->value.integer.value[0];
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+	struct aw_monitor *aw_monitor = &aw87xxx->monitor;
+	int ret = -1;
+
+	ret = aw87xxx_dev_monitor_switch_set(aw_monitor, ctrl_value);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int aw87xxx_monitor_switch_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+	struct aw_monitor *aw_monitor = &aw87xxx->monitor;
+
+	ucontrol->value.integer.value[0] = aw_monitor->monitor_hdr.monitor_switch;
+
+	AW_DEV_LOGI(aw87xxx->dev, "monitor switch is %ld", ucontrol->value.integer.value[0]);
+	return 0;
+}
+
+static int aw87xxx_spin_switch_info(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	int count;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	count = ARRAY_SIZE(aw87xxx_spin_switch);
+
+	uinfo->value.enumerated.items = count;
+
+	if (uinfo->value.enumerated.item >= count)
+		uinfo->value.enumerated.item = count - 1;
+
+	strscpy(uinfo->value.enumerated.name,
+		aw87xxx_spin_switch[uinfo->value.enumerated.item],
+		strlen(aw87xxx_spin_switch[uinfo->value.enumerated.item]) + 1);
+
+	return 0;
+}
+
+static int aw87xxx_spin_switch_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	uint32_t ctrl_value = 0;
+	int ret = 0;
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+	ctrl_value = ucontrol->value.integer.value[0];
+
+	ret = aw87xxx_dsp_set_spin(ctrl_value);
+	if (ret) {
+		AW_DEV_LOGE(aw87xxx->dev, "write spin failed");
+		return ret;
+	}
+	AW_DEV_LOGD(aw87xxx->dev, "write spin done ctrl_value=%d", ctrl_value);
+	return 0;
+}
+
+static int aw87xxx_spin_switch_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+
+	ucontrol->value.integer.value[0] = aw87xxx_dsp_get_spin();
+	AW_DEV_LOGD(aw87xxx->dev, "current spin is %ld", ucontrol->value.integer.value[0]);
+
+	return 0;
+}
+
+
+static int aw87xxx_kcontrol_dynamic_create(struct aw87xxx *aw87xxx,
+						void *codec)
+{
+	struct snd_kcontrol_new *aw87xxx_kcontrol = NULL;
+	aw_snd_soc_codec_t *soc_codec = (aw_snd_soc_codec_t *)codec;
+	char *kctl_name[AW87XXX_PRIVATE_KCONTROL_NUM];
+	int kcontrol_num = AW87XXX_PRIVATE_KCONTROL_NUM;
+	int ret = -1;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+	aw87xxx->codec = soc_codec;
+
+	aw87xxx_kcontrol = devm_kzalloc(aw87xxx->dev,
+			sizeof(struct snd_kcontrol_new) * kcontrol_num,
+			GFP_KERNEL);
+	if (aw87xxx_kcontrol == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "aw87xxx_kcontrol devm_kzalloc failed");
+		return -ENOMEM;
+	}
+
+	kctl_name[0] = devm_kzalloc(aw87xxx->dev, AW_NAME_BUF_MAX,
+			GFP_KERNEL);
+	if (kctl_name[0] == NULL)
+		return -ENOMEM;
+
+	snprintf(kctl_name[0], AW_NAME_BUF_MAX, "aw87xxx_profile_switch_%d",
+			aw87xxx->dev_index);
+
+	aw87xxx_kcontrol[0].name = kctl_name[0];
+	aw87xxx_kcontrol[0].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	aw87xxx_kcontrol[0].info = aw87xxx_profile_switch_info;
+	aw87xxx_kcontrol[0].get = aw87xxx_profile_switch_get;
+	aw87xxx_kcontrol[0].put = aw87xxx_profile_switch_put;
+	aw87xxx_kcontrol[0].private_value = (unsigned long)aw87xxx;
+
+	kctl_name[1] = devm_kzalloc(aw87xxx->codec->dev, AW_NAME_BUF_MAX,
+			GFP_KERNEL);
+	if (kctl_name[1] == NULL)
+		return -ENOMEM;
+
+	snprintf(kctl_name[1], AW_NAME_BUF_MAX, "aw87xxx_vmax_get_%d",
+			aw87xxx->dev_index);
+
+	aw87xxx_kcontrol[1].name = kctl_name[1];
+	aw87xxx_kcontrol[1].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	aw87xxx_kcontrol[1].access = SNDRV_CTL_ELEM_ACCESS_READ;
+	aw87xxx_kcontrol[1].info = aw87xxx_vmax_get_info;
+	aw87xxx_kcontrol[1].get = aw87xxx_vmax_get;
+	aw87xxx_kcontrol[1].private_value = (unsigned long)aw87xxx;
+
+	kctl_name[2] = devm_kzalloc(aw87xxx->codec->dev, AW_NAME_BUF_MAX,
+			GFP_KERNEL);
+	if (kctl_name[2] == NULL)
+		return -ENOMEM;
+
+	snprintf(kctl_name[2], AW_NAME_BUF_MAX, "aw87xxx_monitor_switch_%d",
+			aw87xxx->dev_index);
+
+	aw87xxx_kcontrol[2].name = kctl_name[2];
+	aw87xxx_kcontrol[2].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	aw87xxx_kcontrol[2].info = aw87xxx_monitor_switch_info;
+	aw87xxx_kcontrol[2].get = aw87xxx_monitor_switch_get;
+	aw87xxx_kcontrol[2].put = aw87xxx_monitor_switch_put;
+	aw87xxx_kcontrol[2].private_value = (unsigned long)aw87xxx;
+
+	ret = aw_componet_codec_ops.add_codec_controls(aw87xxx->codec,
+				aw87xxx_kcontrol, kcontrol_num);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "add codec controls failed, ret = %d",
+			ret);
+		return ret;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "add codec controls[%s,%s,%s]",
+		aw87xxx_kcontrol[0].name,
+		aw87xxx_kcontrol[1].name,
+		aw87xxx_kcontrol[2].name);
+
+	return 0;
+}
+
+static int aw87xxx_public_kcontrol_create(struct aw87xxx *aw87xxx,
+						void *codec)
+{
+	struct snd_kcontrol_new *aw87xxx_kcontrol = NULL;
+	aw_snd_soc_codec_t *soc_codec = (aw_snd_soc_codec_t *)codec;
+	char *kctl_name[AW87XXX_PUBLIC_KCONTROL_NUM];
+	int kcontrol_num = AW87XXX_PUBLIC_KCONTROL_NUM;
+	int ret = -1;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+	aw87xxx->codec = soc_codec;
+
+	aw87xxx_kcontrol = devm_kzalloc(aw87xxx->dev,
+			sizeof(struct snd_kcontrol_new) * kcontrol_num,
+			GFP_KERNEL);
+	if (aw87xxx_kcontrol == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "aw87xxx_kcontrol devm_kzalloc failed");
+		return -ENOMEM;
+	}
+
+	kctl_name[0] = devm_kzalloc(aw87xxx->dev, AW_NAME_BUF_MAX,
+			GFP_KERNEL);
+	if (kctl_name[0] == NULL)
+		return -ENOMEM;
+
+	snprintf(kctl_name[0], AW_NAME_BUF_MAX, "aw87xxx_spin_switch");
+
+	aw87xxx_kcontrol[0].name = kctl_name[0];
+	aw87xxx_kcontrol[0].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	aw87xxx_kcontrol[0].info = aw87xxx_spin_switch_info;
+	aw87xxx_kcontrol[0].get = aw87xxx_spin_switch_get;
+	aw87xxx_kcontrol[0].put = aw87xxx_spin_switch_put;
+	aw87xxx_kcontrol[0].private_value = (unsigned long)aw87xxx;
+
+	ret = aw_componet_codec_ops.add_codec_controls(aw87xxx->codec,
+				aw87xxx_kcontrol, kcontrol_num);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "add codec controls failed, ret = %d",
+			ret);
+		return ret;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "add public codec controls[%s]",
+		aw87xxx_kcontrol[0].name);
+
+	return 0;
+}
+
+/****************************************************************************
+ *
+ *aw87xxx kcontrol create
+ *
+ ****************************************************************************/
+int aw87xxx_add_codec_controls(void *codec)
+{
+	struct list_head *pos = NULL;
+	struct aw87xxx *aw87xxx = NULL;
+	int ret = -1;
+
+	list_for_each(pos, &g_aw87xxx_list) {
+		aw87xxx = list_entry(pos, struct aw87xxx, list);
+		ret = aw87xxx_kcontrol_dynamic_create(aw87xxx, codec);
+		if (ret < 0)
+			return ret;
+
+		if (aw87xxx->dev_index == 0) {
+			ret = aw87xxx_public_kcontrol_create(aw87xxx, codec);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(aw87xxx_add_codec_controls);
+
+
+/****************************************************************************
+ *
+ * aw87xxx firmware cfg load
+ *
+ ***************************************************************************/
+static void aw87xxx_fw_cfg_free(struct aw87xxx *aw87xxx)
+{
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+	aw87xxx_acf_profile_free(aw87xxx->dev, &aw87xxx->acf_info);
+	aw87xxx_monitor_cfg_free(&aw87xxx->monitor);
+}
+
+static int aw87xxx_init_default_prof(struct aw87xxx *aw87xxx)
+{
+	char *profile = NULL;
+
+	profile = aw87xxx_acf_get_prof_off_name(aw87xxx->dev, &aw87xxx->acf_info);
+	if (profile == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "get profile off name failed");
+		return -EINVAL;
+	}
+
+	snprintf(aw87xxx->prof_off_name, AW_PROFILE_STR_MAX, "%s", profile);
+	aw87xxx->current_profile = profile;
+	AW_DEV_LOGI(aw87xxx->dev, "init profile name [%s]",
+		aw87xxx->current_profile);
+
+	return 0;
+}
+
+static void aw87xxx_fw_load_retry(struct aw87xxx *aw87xxx)
+{
+	struct acf_bin_info *acf_info = &aw87xxx->acf_info;
+	int ram_timer_val = 2000;
+
+	AW_DEV_LOGD(aw87xxx->dev, "failed to read [%s]",
+			aw87xxx->fw_name);
+
+	if (acf_info->load_count < AW_LOAD_FW_RETRIES) {
+		AW_DEV_LOGD(aw87xxx->dev,
+			"restart hrtimer to load firmware");
+		schedule_delayed_work(&aw87xxx->fw_load_work,
+			msecs_to_jiffies(ram_timer_val));
+	} else {
+		acf_info->load_count = 0;
+		AW_DEV_LOGE(aw87xxx->dev,
+			"can not load firmware,please check name or file exists");
+		return;
+	}
+	acf_info->load_count++;
+}
+
+static void aw87xxx_fw_load(const struct firmware *fw, void *context)
+{
+	int ret = -1;
+	struct aw87xxx *aw87xxx = context;
+	struct acf_bin_info *acf_info = &aw87xxx->acf_info;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+
+	if (!fw) {
+		aw87xxx_fw_load_retry(aw87xxx);
+		return;
+	}
+
+	AW_DEV_LOGD(aw87xxx->dev, "loaded %s - size: %ld",
+		aw87xxx->fw_name, (u_long)(fw ? fw->size : 0));
+
+	mutex_lock(&aw87xxx->reg_lock);
+	acf_info->fw_data = vmalloc(fw->size);
+	if (!acf_info->fw_data) {
+		AW_DEV_LOGE(aw87xxx->dev, "fw_data kzalloc memory failed");
+		goto exit_vmalloc_failed;
+	}
+	memset(acf_info->fw_data, 0, fw->size);
+	memcpy(acf_info->fw_data, fw->data, fw->size);
+	acf_info->fw_size = fw->size;
+
+	ret = aw87xxx_acf_parse(aw87xxx->dev, &aw87xxx->acf_info);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "fw_data parse failed");
+		goto exit_acf_parse_failed;
+	}
+
+	ret = aw87xxx_init_default_prof(aw87xxx);
+	if (ret < 0) {
+		aw87xxx_fw_cfg_free(aw87xxx);
+		goto exit_acf_parse_failed;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "acf parse succeed");
+	mutex_unlock(&aw87xxx->reg_lock);
+	release_firmware(fw);
+	// Updating profile to "Music" because the firmware is set to "off" during init
+	aw87xxx_update_profile(aw87xxx, AW87XXX_PROF_MUSIC);
+
+	return;
+
+exit_acf_parse_failed:
+exit_vmalloc_failed:
+	release_firmware(fw);
+	mutex_unlock(&aw87xxx->reg_lock);
+}
+
+static void aw87xxx_fw_load_work_routine(struct work_struct *work)
+{
+	struct aw87xxx *aw87xxx = container_of(work,
+			struct aw87xxx, fw_load_work.work);
+	struct aw_prof_info *prof_info = &aw87xxx->acf_info.prof_info;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+
+	if (prof_info->status == AW_ACF_WAIT) {
+		request_firmware_nowait(THIS_MODULE,
+//				FW_ACTION_HOTPLUG,
+				FW_ACTION_UEVENT,
+				aw87xxx->fw_name,
+				aw87xxx->dev,
+				GFP_KERNEL, aw87xxx,
+				aw87xxx_fw_load);
+	}
+}
+
+static void aw87xxx_fw_load_init(struct aw87xxx *aw87xxx)
+{
+#ifdef AW_CFG_UPDATE_DELAY
+	int cfg_timer_val = AW_CFG_UPDATE_DELAY_TIMER;
+#else
+	int cfg_timer_val = 0;
+#endif
+	AW_DEV_LOGI(aw87xxx->dev, "enter");
+	snprintf(aw87xxx->fw_name, AW87XXX_FW_NAME_MAX, "%s", AW87XXX_FW_BIN_NAME);
+	aw87xxx_acf_init(&aw87xxx->aw_dev, &aw87xxx->acf_info, aw87xxx->dev_index);
+
+	INIT_DELAYED_WORK(&aw87xxx->fw_load_work, aw87xxx_fw_load_work_routine);
+	schedule_delayed_work(&aw87xxx->fw_load_work,
+			msecs_to_jiffies(cfg_timer_val));
+}
+
+/****************************************************************************
+ *
+ *aw87xxx attribute node
+ *
+ ****************************************************************************/
+static ssize_t aw87xxx_attr_get_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	int ret = 0;
+	unsigned int i = 0;
+	unsigned char reg_val = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_device *aw_dev = &aw87xxx->aw_dev;
+
+	mutex_lock(&aw87xxx->reg_lock);
+	for (i = 0; i < aw_dev->reg_max_addr; i++) {
+		if (!(aw_dev->reg_access[i] & AW_DEV_REG_RD_ACCESS))
+			continue;
+		ret = aw87xxx_dev_i2c_read_byte(&aw87xxx->aw_dev, i, &reg_val);
+		if (ret < 0) {
+			len += snprintf(buf + len, PAGE_SIZE - len,
+					"read reg [0x%x] failed\n", i);
+			AW_DEV_LOGE(aw87xxx->dev, "read reg [0x%x] failed", i);
+		} else {
+			len += snprintf(buf + len, PAGE_SIZE - len,
+					"reg:0x%02X=0x%02X\n", i, reg_val);
+			AW_DEV_LOGD(aw87xxx->dev, "reg:0x%02X=0x%02X",
+					i, reg_val);
+		}
+	}
+	mutex_unlock(&aw87xxx->reg_lock);
+
+	return len;
+}
+
+static ssize_t aw87xxx_attr_set_reg(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t len)
+{
+	unsigned int databuf[2] = { 0 };
+	int ret = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+
+	mutex_lock(&aw87xxx->reg_lock);
+	if (sscanf(buf, "0x%x 0x%x", &databuf[0], &databuf[1]) == 2) {
+		if (databuf[0] >= aw87xxx->aw_dev.reg_max_addr) {
+			AW_DEV_LOGE(aw87xxx->dev, "set reg[0x%x] error,is out of reg_addr_max[0x%x]",
+				databuf[0], aw87xxx->aw_dev.reg_max_addr);
+			mutex_unlock(&aw87xxx->reg_lock);
+			return -EINVAL;
+		}
+
+		ret = aw87xxx_dev_i2c_write_byte(&aw87xxx->aw_dev,
+					databuf[0], databuf[1]);
+		if (ret < 0)
+			AW_DEV_LOGE(aw87xxx->dev, "set [0x%x]=0x%x failed",
+				databuf[0], databuf[1]);
+		else
+			AW_DEV_LOGD(aw87xxx->dev, "set [0x%x]=0x%x succeed",
+				databuf[0], databuf[1]);
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "i2c write cmd input error");
+	}
+	mutex_unlock(&aw87xxx->reg_lock);
+
+	return len;
+}
+
+static ssize_t aw87xxx_attr_get_profile(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	unsigned int i = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_prof_info *prof_info = &aw87xxx->acf_info.prof_info;
+
+	if (!prof_info->status) {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"profile_cfg not load\n");
+		return len;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "current profile:[%s]", aw87xxx->current_profile);
+
+	for (i = 0; i < prof_info->count; i++) {
+		if (!strncmp(aw87xxx->current_profile, prof_info->prof_name_list[i],
+				AW_PROFILE_STR_MAX))
+			len += snprintf(buf + len, PAGE_SIZE - len,
+				">%s\n", prof_info->prof_name_list[i]);
+		else
+			len += snprintf(buf + len, PAGE_SIZE - len,
+				" %s\n", prof_info->prof_name_list[i]);
+	}
+
+	return len;
+}
+
+static ssize_t aw87xxx_attr_set_profile(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t len)
+{
+	char profile[AW_PROFILE_STR_MAX] = {0};
+	int ret = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+
+	if (strlen(buf) > AW_PROFILE_STR_MAX) {
+		AW_DEV_LOGE(aw87xxx->dev, "input profile_str_len is out of max[%d]",
+				AW_PROFILE_STR_MAX);
+		return -EINVAL;
+	}
+
+	if (sscanf(buf, "%s", profile) == 1) {
+		AW_DEV_LOGD(aw87xxx->dev, "set profile [%s]", profile);
+		ret = aw87xxx_update_profile(aw87xxx, profile);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "set profile[%s] failed",
+				profile);
+			return ret;
+		}
+	}
+
+	return len;
+}
+
+static ssize_t aw87xxx_attr_get_hwen(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	int hwen = aw87xxx->aw_dev.hwen_status;
+
+	if (hwen >= AW_DEV_HWEN_INVALID)
+		len += snprintf(buf + len, PAGE_SIZE - len, "hwen_status: invalid\n");
+	else if (hwen == AW_DEV_HWEN_ON)
+		len += snprintf(buf + len, PAGE_SIZE - len, "hwen_status: on\n");
+	else if (hwen == AW_DEV_HWEN_OFF)
+		len += snprintf(buf + len, PAGE_SIZE - len, "hwen_status: off\n");
+
+	return len;
+}
+
+static ssize_t aw87xxx_attr_set_hwen(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t len)
+{
+	int ret = -1;
+	unsigned int state;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+
+	ret = kstrtouint(buf, 0, &state);
+	if (ret) {
+		AW_DEV_LOGE(aw87xxx->dev, "fail to channelge str to int");
+		return ret;
+	}
+
+	mutex_lock(&aw87xxx->reg_lock);
+	if (state == AW_DEV_HWEN_OFF)
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, false); /*OFF*/
+	else if (state == AW_DEV_HWEN_ON)
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, true); /*ON*/
+	else
+		AW_DEV_LOGE(aw87xxx->dev, "input [%d] error, hwen_on=[%d],hwen_off=[%d]",
+			state, AW_DEV_HWEN_ON, AW_DEV_HWEN_OFF);
+	mutex_unlock(&aw87xxx->reg_lock);
+	return len;
+}
+
+int aw87xxx_awrw_write(struct aw87xxx *aw87xxx,
+			const char *buf, size_t count)
+{
+	int i = 0, ret = -1;
+	char *data_buf = NULL;
+	int buf_len = 0;
+	int temp_data = 0;
+	int data_str_size = 0;
+	char *reg_data;
+	struct aw_i2c_packet *packet = &aw87xxx->i2c_packet;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+	/* one addr or one data string Composition of Contains two bytes of symbol(0X)*/
+	/* and two byte of hexadecimal data*/
+	data_str_size = 2 + 2 * AWRW_DATA_BYTES;
+
+	/* The buf includes the first address of the register to be written and all data */
+	buf_len = AWRW_ADDR_BYTES + packet->reg_num * AWRW_DATA_BYTES;
+	AW_DEV_LOGI(aw87xxx->dev, "buf_len = %d,reg_num = %d", buf_len, packet->reg_num);
+	data_buf = vmalloc(buf_len);
+	if (data_buf == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "alloc memory failed");
+		return -ENOMEM;
+	}
+	memset(data_buf, 0, buf_len);
+
+	data_buf[0] = packet->reg_addr;
+	reg_data = data_buf + 1;
+
+	AW_DEV_LOGD(aw87xxx->dev, "reg_addr: 0x%02x", data_buf[0]);
+
+	/*ag:0x00 0x01 0x01 0x01 0x01 0x00\x0a*/
+	for (i = 0; i < packet->reg_num; i++) {
+		ret = sscanf(buf + AWRW_HDR_LEN + 1 + i * (data_str_size + 1),
+			"0x%x", &temp_data);
+		if (ret != 1) {
+			AW_DEV_LOGE(aw87xxx->dev, "sscanf failed,ret=%d", ret);
+			vfree(data_buf);
+			data_buf = NULL;
+			return ret;
+		}
+		reg_data[i] = temp_data;
+		AW_DEV_LOGD(aw87xxx->dev, "[%d] : 0x%02x", i, reg_data[i]);
+	}
+
+	mutex_lock(&aw87xxx->reg_lock);
+	ret = i2c_master_send(aw87xxx->aw_dev.i2c, data_buf, buf_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "write failed");
+		vfree(data_buf);
+		data_buf = NULL;
+		return -EFAULT;
+	}
+	mutex_unlock(&aw87xxx->reg_lock);
+
+	vfree(data_buf);
+	data_buf = NULL;
+
+	AW_DEV_LOGD(aw87xxx->dev, "down");
+	return 0;
+}
+
+static int aw87xxx_awrw_data_check(struct aw87xxx *aw87xxx,
+			int *data, size_t count)
+{
+	struct aw_i2c_packet *packet = &aw87xxx->i2c_packet;
+	int req_data_len = 0;
+	int act_data_len = 0;
+	int data_str_size = 0;
+
+	if ((data[AWRW_HDR_ADDR_BYTES] != AWRW_ADDR_BYTES) ||
+		(data[AWRW_HDR_DATA_BYTES] != AWRW_DATA_BYTES)) {
+		AW_DEV_LOGE(aw87xxx->dev, "addr_bytes [%d] or data_bytes [%d] unsupport",
+			data[AWRW_HDR_ADDR_BYTES], data[AWRW_HDR_DATA_BYTES]);
+		return -EINVAL;
+	}
+
+	/* one data string Composition of Contains two bytes of symbol(0x)*/
+	/* and two byte of hexadecimal data*/
+	data_str_size = 2 + 2 * AWRW_DATA_BYTES;
+	act_data_len = count - AWRW_HDR_LEN - 1;
+
+	/* There is a comma(,) or space between each piece of data */
+	if (data[AWRW_HDR_WR_FLAG] == AWRW_FLAG_WRITE) {
+		/*ag:0x00 0x01 0x01 0x01 0x01 0x00\x0a*/
+		req_data_len = (data_str_size + 1) * packet->reg_num;
+		if (req_data_len > act_data_len) {
+			AW_DEV_LOGE(aw87xxx->dev, "data_len checkfailed,requeset data_len [%d],actaul data_len [%d]",
+				req_data_len, act_data_len);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+/* flag addr_bytes data_bytes reg_num reg_addr*/
+static int aw87xxx_awrw_parse_buf(struct aw87xxx *aw87xxx,
+			const char *buf, size_t count, int *wr_status)
+{
+	int data[AWRW_HDR_MAX] = {0};
+	struct aw_i2c_packet *packet = &aw87xxx->i2c_packet;
+	int ret = -1;
+
+	if (sscanf(buf, "0x%02x 0x%02x 0x%02x 0x%02x 0x%02x",
+		&data[AWRW_HDR_WR_FLAG], &data[AWRW_HDR_ADDR_BYTES],
+		&data[AWRW_HDR_DATA_BYTES], &data[AWRW_HDR_REG_NUM],
+		&data[AWRW_HDR_REG_ADDR]) == 5) {
+
+		packet->reg_addr = data[AWRW_HDR_REG_ADDR];
+		packet->reg_num = data[AWRW_HDR_REG_NUM];
+		*wr_status = data[AWRW_HDR_WR_FLAG];
+		ret = aw87xxx_awrw_data_check(aw87xxx, data, count);
+		if (ret < 0)
+			return ret;
+
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static ssize_t aw87xxx_attr_awrw_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_i2c_packet *packet = &aw87xxx->i2c_packet;
+	int wr_status = 0;
+	int ret = -1;
+
+	if (count < AWRW_HDR_LEN) {
+		AW_DEV_LOGE(aw87xxx->dev, "data count too smaller, please check write format");
+		AW_DEV_LOGE(aw87xxx->dev, "string %s,count=%ld",
+			buf, (u_long)count);
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "string:[%s],count=%ld", buf, (u_long)count);
+	ret = aw87xxx_awrw_parse_buf(aw87xxx, buf, count, &wr_status);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "can not parse string");
+		return ret;
+	}
+
+	if (wr_status == AWRW_FLAG_WRITE) {
+		ret = aw87xxx_awrw_write(aw87xxx, buf, count);
+		if (ret < 0)
+			return ret;
+	} else if (wr_status == AWRW_FLAG_READ) {
+		packet->status = AWRW_I2C_ST_READ;
+		AW_DEV_LOGI(aw87xxx->dev, "read_cmd:reg_addr[0x%02x], reg_num[%d]",
+			packet->reg_addr, packet->reg_num);
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "please check str format, unsupport read_write_status: %d",
+			wr_status);
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t aw87xxx_attr_awrw_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_i2c_packet *packet = &aw87xxx->i2c_packet;
+	int data_len = 0;
+	size_t len = 0;
+	int ret = -1, i = 0;
+	char *reg_data = NULL;
+
+	if (packet->status != AWRW_I2C_ST_READ) {
+		AW_DEV_LOGE(aw87xxx->dev, "please write read cmd first");
+		return -EINVAL;
+	}
+
+	data_len = AWRW_DATA_BYTES * packet->reg_num;
+	reg_data = (char *)vmalloc(data_len);
+	if (reg_data == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "memory alloc failed");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	mutex_lock(&aw87xxx->reg_lock);
+	ret = aw87xxx_dev_i2c_read_msg(&aw87xxx->aw_dev, packet->reg_addr,
+				(char *)reg_data, data_len);
+	if (ret < 0) {
+		ret = -EFAULT;
+		mutex_unlock(&aw87xxx->reg_lock);
+		goto exit;
+	}
+	mutex_unlock(&aw87xxx->reg_lock);
+
+	AW_DEV_LOGI(aw87xxx->dev, "reg_addr 0x%02x, reg_num %d",
+		packet->reg_addr, packet->reg_num);
+
+	for (i = 0; i < data_len; i++) {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"0x%02x,", reg_data[i]);
+		AW_DEV_LOGI(aw87xxx->dev, "0x%02x", reg_data[i]);
+	}
+
+	ret = len;
+
+exit:
+	if (reg_data) {
+		vfree(reg_data);
+		reg_data = NULL;
+	}
+	packet->status = AWRW_I2C_ST_NONE;
+	return ret;
+}
+
+static ssize_t aw87xxx_drv_ver_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+		"driver_ver: %s \n", AW87XXX_DRIVER_VERSION);
+
+	return len;
+}
+
+static DEVICE_ATTR(reg, S_IWUSR | S_IRUGO,
+		aw87xxx_attr_get_reg, aw87xxx_attr_set_reg);
+static DEVICE_ATTR(profile, S_IWUSR | S_IRUGO,
+		aw87xxx_attr_get_profile, aw87xxx_attr_set_profile);
+static DEVICE_ATTR(hwen, S_IWUSR | S_IRUGO,
+		aw87xxx_attr_get_hwen, aw87xxx_attr_set_hwen);
+static DEVICE_ATTR(awrw, S_IWUSR | S_IRUGO,
+	aw87xxx_attr_awrw_show, aw87xxx_attr_awrw_store);
+static DEVICE_ATTR(drv_ver, S_IRUGO, aw87xxx_drv_ver_show, NULL);
+
+static struct attribute *aw87xxx_attributes[] = {
+	&dev_attr_reg.attr,
+	&dev_attr_profile.attr,
+	&dev_attr_hwen.attr,
+	&dev_attr_awrw.attr,
+	&dev_attr_drv_ver.attr,
+	NULL
+};
+
+static struct attribute_group aw87xxx_attribute_group = {
+	.attrs = aw87xxx_attributes
+};
+
+/****************************************************************************
+ *
+ *aw87xxx device probe
+ *
+ ****************************************************************************/
+static const struct acpi_gpio_params reset_gpio = { 0, 0, false };
+static const struct acpi_gpio_mapping reset_acpi_gpios[] = {
+  { "reset-gpios", &reset_gpio, 1 },
+  { }
+};
+
+static struct aw87xxx *aw87xxx_malloc_init(struct i2c_client *client)
+{
+	struct aw87xxx *aw87xxx = NULL;
+
+	aw87xxx = devm_kzalloc(&client->dev, sizeof(struct aw87xxx),
+			GFP_KERNEL);
+	if (aw87xxx == NULL) {
+		AW_DEV_LOGE(&client->dev, "failed to devm_kzalloc aw87xxx");
+		return NULL;
+	}
+	memset(aw87xxx, 0, sizeof(struct aw87xxx));
+
+	aw87xxx->dev = &client->dev;
+	aw87xxx->aw_dev.dev = &client->dev;
+	aw87xxx->aw_dev.i2c_bus = client->adapter->nr;
+	aw87xxx->aw_dev.i2c_addr = client->addr;
+	aw87xxx->aw_dev.i2c = client;
+	aw87xxx->aw_dev.hwen_status = false;
+	aw87xxx->aw_dev.reg_access = NULL;
+	aw87xxx->aw_dev.hwen_status = AW_DEV_HWEN_INVALID;
+	aw87xxx->off_bin_status = AW87XXX_NO_OFF_BIN;
+	aw87xxx->codec = NULL;
+	aw87xxx->current_profile = aw87xxx->prof_off_name;
+
+	mutex_init(&aw87xxx->reg_lock);
+
+	AW_DEV_LOGI(&client->dev, "Driver struct alloc and mutex init done, devinfo: i2c_bus=%u, i2c_addr=%x", client->adapter->nr, client->addr);
+	return aw87xxx;
+}
+
+static int aw87xxx_i2c_probe(struct i2c_client *client)
+{
+	struct device_node *dev_node = client->dev.of_node;
+	const struct smi_node *node;
+	struct acpi_device *adev = ACPI_COMPANION(&client->dev);
+	struct aw87xxx *aw87xxx = NULL;
+	struct gpio_desc *gpiod = NULL;
+	struct i2c_board_info board_info = {};
+	char i2c_name[32];
+	int ret = -1;
+	int acpi_dev_count = 0;
+
+	/* aw87xxx Get APCI I2C device count */
+	if(g_aw87xxx_dev_cnt == 0){
+		acpi_dev_count = i2c_acpi_client_count(adev);
+		AW_DEV_LOGI(&client->dev, "I2C_ACPI_CLIENT_COUNT returned [%d]", acpi_dev_count);
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		AW_DEV_LOGE(&client->dev, "check_functionality failed");
+		ret = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	/* aw87xxx i2c_dev struct init */
+	aw87xxx = aw87xxx_malloc_init(client);
+	if (aw87xxx == NULL)
+		goto exit_malloc_init_failed;
+
+	i2c_set_clientdata(client, aw87xxx);
+
+	aw87xxx_device_parse_port_id_dt(&aw87xxx->aw_dev);
+	aw87xxx_device_parse_topo_id_dt(&aw87xxx->aw_dev);
+
+	/* aw87xxx Get ACPI GPIO */
+
+	if (g_aw87xxx_dev_cnt == 0){
+		ret = devm_acpi_dev_add_driver_gpios(aw87xxx->dev, reset_acpi_gpios);
+		if(ret){
+			AW_DEV_LOGE(aw87xxx->dev, "Unable to add GPIO mapping table");
+			goto exit_device_init_failed;
+		}
+
+		gpiod = devm_gpiod_get(aw87xxx->dev, "reset", GPIOD_OUT_LOW);
+		if (gpiod == NULL){
+			AW_DEV_LOGE(aw87xxx->dev, "Gpiod returned NULL failing gracefully.");
+			goto exit_device_init_failed;
+		}
+
+		if (IS_ERR(gpiod)){
+			AW_DEV_LOGE(aw87xxx->dev, "Get gpiod failed.");
+			goto exit_device_init_failed;
+		}
+
+		aw87xxx->aw_dev.rst_gpio = desc_to_gpio(gpiod);
+		aw87xxx->aw_dev.hwen_status = AW_DEV_HWEN_OFF;
+		AW_DEV_LOGI(aw87xxx->dev, "reset gpio[%x] parse succeed", aw87xxx->aw_dev.rst_gpio);
+
+		if (gpio_is_valid(aw87xxx->aw_dev.rst_gpio)) {
+			ret = devm_gpio_request_one(aw87xxx->dev, aw87xxx->aw_dev.rst_gpio, GPIOF_OUT_INIT_LOW, "aw87xxx_reset");
+			if ((ret < 0) && (ret != -EBUSY)) {
+					AW_DEV_LOGE(aw87xxx->dev, "reset request failed, returned [%d]", ret);
+					goto exit_device_init_failed;
+			}
+		}else{
+			/*Disabling RESET GPIO*/
+			AW_DEV_LOGI(aw87xxx->dev, "no reset gpio provided, hardware reset unavailable");
+			aw87xxx->aw_dev.rst_gpio = AW_NO_RESET_GPIO;
+			aw87xxx->aw_dev.hwen_status = AW_DEV_HWEN_INVALID;
+		}
+
+	}
+
+	/*hw power on PA*/
+	if(g_aw87xxx_dev_cnt == 0) {
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, true);
+	}
+
+	/* aw87xxx devices private attributes init */
+	ret = aw87xxx_dev_init(&aw87xxx->aw_dev);
+	if (ret < 0)
+		goto exit_device_init_failed;
+
+	/*product register reset */
+	aw87xxx_dev_soft_reset(&aw87xxx->aw_dev);
+
+	/*hw power off */
+	if(g_aw87xxx_dev_cnt == 0) {
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, false);
+	}
+
+	/* create debug attrbute nodes */
+	ret = sysfs_create_group(&aw87xxx->dev->kobj, &aw87xxx_attribute_group);
+	if (ret < 0)
+		AW_DEV_LOGE(aw87xxx->dev, "failed to create sysfs nodes, will not allowed to use");
+
+	/* cfg_load init */
+	aw87xxx_fw_load_init(aw87xxx);
+
+	/*monitor init*/
+	aw87xxx_monitor_init(aw87xxx->dev, &aw87xxx->monitor, dev_node);
+
+	/*add device to total list */
+	mutex_lock(&g_aw87xxx_mutex_lock);
+	g_aw87xxx_dev_cnt++;
+	list_add(&aw87xxx->list, &g_aw87xxx_list);
+	aw87xxx->dev_index = g_aw87xxx_dev_cnt;
+
+	mutex_unlock(&g_aw87xxx_mutex_lock);
+	AW_DEV_LOGI(aw87xxx->dev, "succeed, dev_index=[%d], g_aw87xxx_dev_cnt= [%d]",
+			aw87xxx->dev_index, g_aw87xxx_dev_cnt);
+
+	AW_DEV_LOGI(aw87xxx->dev, "acpi_c=[%d] dev_c=[%d]", acpi_dev_count, g_aw87xxx_dev_cnt);
+
+	/* Attempt to add other I2C AMPs */
+	if ((acpi_dev_count > 1) && (g_aw87xxx_dev_cnt == 1)){
+		/* power on the chip */
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, true);
+
+		node = device_get_match_data(aw87xxx->dev);
+		memset(&board_info, 0, sizeof(board_info));
+		strscpy(board_info.type, client->name, I2C_NAME_SIZE);
+		snprintf(i2c_name, sizeof(i2c_name), "%s.%d", client->name, 1);
+		board_info.dev_name = i2c_name;
+
+		aw87xxx_i2c_probe(i2c_acpi_new_device_by_fwnode(acpi_fwnode_handle(adev), 1, &board_info));
+	}
+
+	return 0;
+
+exit_device_init_failed:
+	AW_DEV_LOGE(aw87xxx->dev, "pa init failed");
+
+	devm_kfree(&client->dev, aw87xxx);
+	aw87xxx = NULL;
+exit_malloc_init_failed:
+exit_check_functionality_failed:
+	return ret;
+}
+
+static void aw87xxx_i2c_remove(struct i2c_client *client)
+{
+	struct aw87xxx *aw87xxx = i2c_get_clientdata(client);
+
+	aw87xxx_monitor_exit(&aw87xxx->monitor);
+
+	/*rm attr node*/
+	sysfs_remove_group(&aw87xxx->dev->kobj, &aw87xxx_attribute_group);
+
+	aw87xxx_fw_cfg_free(aw87xxx);
+
+	mutex_lock(&g_aw87xxx_mutex_lock);
+	g_aw87xxx_dev_cnt--;
+	list_del(&aw87xxx->list);
+	mutex_unlock(&g_aw87xxx_mutex_lock);
+
+	devm_kfree(&client->dev, aw87xxx);
+	aw87xxx = NULL;
+
+//	return 0;
+}
+
+static void aw87xxx_i2c_shutdown(struct i2c_client *client)
+{
+	struct aw87xxx *aw87xxx = i2c_get_clientdata(client);
+
+	AW_DEV_LOGI(&client->dev, "enter");
+
+	/*soft and hw power off*/
+	aw87xxx_update_profile(aw87xxx, aw87xxx->prof_off_name);
+}
+
+static int aw87xxx_runtime_suspend(struct device *dev)
+{
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+
+	AW_DEV_LOGI(aw87xxx->dev, "Suspending...");
+
+	// soft and hw power off
+	aw87xxx_update_profile(aw87xxx, aw87xxx->prof_off_name);
+
+	return 0;
+}
+
+static int aw87xxx_runtime_resume(struct device *dev)
+{
+	struct list_head *pos = NULL;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+
+	// Power on PA
+	if (aw87xxx->dev_index == 1)
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, true);
+
+	// Set profile to Music
+	list_for_each_prev(pos, &g_aw87xxx_list) {
+		aw87xxx = list_entry(pos, struct aw87xxx, list);
+		AW_DEV_LOGI(aw87xxx->dev, "Resuming...");
+
+		mutex_lock(&aw87xxx->reg_lock);
+		aw87xxx_power_on(aw87xxx, AW87XXX_PROF_MUSIC);
+		mutex_unlock(&aw87xxx->reg_lock);
+	}
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(aw87xxx_pm_ops, aw87xxx_runtime_suspend, aw87xxx_runtime_resume);
+
+static const struct acpi_device_id aw87xxx_acpi_match[] = {
+        { "AWDZ8830", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, aw87xxx_acpi_match);
+
+// This is not necessary if the acpi match probes correctly. This is needed for userspace `new_device() functionality
+static const struct i2c_device_id aw87xxx_i2c_id[] = {
+	{AW87XXX_I2C_NAME, 0},
+	{},
+};
+
+static struct i2c_driver aw87xxx_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = AW87XXX_I2C_NAME,
+		.acpi_match_table = aw87xxx_acpi_match,
+		.pm = &aw87xxx_pm_ops,
+		},
+	.probe = aw87xxx_i2c_probe,
+	.remove = aw87xxx_i2c_remove,
+	.shutdown = aw87xxx_i2c_shutdown,
+	.id_table = aw87xxx_i2c_id,
+};
+
+module_i2c_driver(aw87xxx_i2c_driver)
+
+MODULE_AUTHOR("<zhaozhongbo@awinic.com>");
+MODULE_DESCRIPTION("awinic aw87xxx pa driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx.h b/sound/soc/codecs/aw87xxx/aw87xxx.h
new file mode 100644
index 000000000..9638819cd
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx.h
@@ -0,0 +1,130 @@
+#ifndef __AW87XXX_H__
+#define __AW87XXX_H__
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+
+#include "aw87xxx_device.h"
+#include "aw87xxx_monitor.h"
+#include "aw87xxx_acf_bin.h"
+
+#define AW_CFG_UPDATE_DELAY
+#define AW_CFG_UPDATE_DELAY_TIMER	(3000)
+
+#define AW87XXX_NO_OFF_BIN		(0)
+#define AW87XXX_OFF_BIN_OK		(1)
+
+#define AW87XXX_PRIVATE_KCONTROL_NUM	(3)
+#define AW87XXX_PUBLIC_KCONTROL_NUM	(1)
+
+#define AW_I2C_RETRIES			(5)
+#define AW_I2C_RETRY_DELAY		(2)
+#define AW_I2C_READ_MSG_NUM		(2)
+
+#define AW87XXX_FW_NAME_MAX		(64)
+#define AW_NAME_BUF_MAX			(64)
+#define AW_LOAD_FW_RETRIES		(3)
+
+#define AW_DEV_REG_RD_ACCESS		(1 << 0)
+#define AW_DEV_REG_WR_ACCESS		(1 << 1)
+
+#define AWRW_ADDR_BYTES			(1)
+#define AWRW_DATA_BYTES			(1)
+#define AWRW_HDR_LEN			(24)
+
+/***********************************************************
+ *
+ * aw87xxx codec control compatible with kernel 4.19
+ *
+ ***********************************************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 16, 1)
+#define AW_KERNEL_VER_OVER_6_16_1
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 1)
+#define AW_KERNEL_VER_OVER_4_19_1
+#endif
+
+#ifdef AW_KERNEL_VER_OVER_4_19_1
+typedef struct snd_soc_component aw_snd_soc_codec_t;
+#else
+typedef struct snd_soc_codec aw_snd_soc_codec_t;
+#endif
+
+struct aw_componet_codec_ops {
+	int (*add_codec_controls)(aw_snd_soc_codec_t *codec,
+		const struct snd_kcontrol_new *controls, unsigned int num_controls);
+	void (*unregister_codec)(struct device *dev);
+};
+
+
+/********************************************
+ *
+ * aw87xxx devices attributes
+ *
+ *******************************************/
+enum {
+	AWRW_FLAG_WRITE = 0,
+	AWRW_FLAG_READ,
+};
+
+enum {
+	AWRW_I2C_ST_NONE = 0,
+	AWRW_I2C_ST_READ,
+	AWRW_I2C_ST_WRITE,
+};
+
+enum {
+	AWRW_HDR_WR_FLAG = 0,
+	AWRW_HDR_ADDR_BYTES,
+	AWRW_HDR_DATA_BYTES,
+	AWRW_HDR_REG_NUM,
+	AWRW_HDR_REG_ADDR,
+	AWRW_HDR_MAX,
+};
+
+struct aw_i2c_packet {
+	char status;
+	unsigned int reg_num;
+	unsigned int reg_addr;
+	char *reg_data;
+};
+
+
+/********************************************
+ *
+ * aw87xxx device struct
+ *
+ *******************************************/
+struct aw87xxx {
+	char fw_name[AW87XXX_FW_NAME_MAX];
+	int32_t dev_index;
+	char *current_profile;
+	char prof_off_name[AW_PROFILE_STR_MAX];
+	uint32_t off_bin_status;
+	struct device *dev;
+
+	struct mutex reg_lock;
+	struct aw_device aw_dev;
+	struct aw_i2c_packet i2c_packet;
+
+	struct delayed_work fw_load_work;
+	struct acf_bin_info acf_info;
+
+	aw_snd_soc_codec_t *codec;
+
+	struct list_head list;
+
+	struct aw_monitor monitor;
+};
+
+int aw87xxx_update_profile(struct aw87xxx *aw87xxx, char *profile);
+int aw87xxx_update_profile_esd(struct aw87xxx *aw87xxx, char *profile);
+
+char *aw87xxx_show_current_profile(int dev_index);
+int aw87xxx_set_profile(int dev_index, char *profile);
+int aw87xxx_set_profile_by_id(int dev_index, int profile_id);
+int aw87xxx_add_codec_controls(void *codec);
+int aw87xxx_awrw_write(struct aw87xxx *aw87xxx, const char *buf, size_t count);
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.c b/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.c
new file mode 100644
index 000000000..0de7085cb
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.c
@@ -0,0 +1,1558 @@
+/*
+ * aw87xxx_acf_bin.c
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: Barry <zhaozhongbo@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include "aw87xxx.h"
+#include "aw87xxx_acf_bin.h"
+#include "aw87xxx_monitor.h"
+#include "aw87xxx_log.h"
+#include "aw87xxx_bin_parse.h"
+
+/*************************************************************************
+ *
+ *Table corresponding to customized profile ids to profile names
+ *
+ *************************************************************************/
+enum aw_customers_profile_id {
+	AW_CTOS_PROFILE_OFF = 0,
+	AW_CTOS_PROFILE_MUSIC,
+	AW_CTOS_PROFILE_VOICE,
+	AW_CTOS_PROFILE_VOIP,
+	AW_CTOS_PROFILE_RINGTONE,
+	AW_CTOS_PROFILE_RINGTONE_HS,
+	AW_CTOS_PROFILE_LOWPOWER,
+	AW_CTOS_PROFILE_BYPASS,
+	AW_CTOS_PROFILE_MMI,
+	AW_CTOS_PROFILE_FM,
+	AW_CTOS_PROFILE_NOTIFICATION,
+	AW_CTOS_PROFILE_RECEIVER,
+	AW_CTOS_PROFILE_MAX,
+};
+
+static char *g_ctos_profile_name[AW_PROFILE_MAX] = {
+	[AW_CTOS_PROFILE_OFF] = "Off",
+	[AW_CTOS_PROFILE_MUSIC] = "Music",
+	[AW_CTOS_PROFILE_VOICE] = "Voice",
+	[AW_CTOS_PROFILE_VOIP] = "Voip",
+	[AW_CTOS_PROFILE_RINGTONE] = "Ringtone",
+	[AW_CTOS_PROFILE_RINGTONE_HS] = "Ringtone_hs",
+	[AW_CTOS_PROFILE_LOWPOWER] = "Lowpower",
+	[AW_CTOS_PROFILE_BYPASS] = "Bypass",
+	[AW_CTOS_PROFILE_MMI] = "Mmi",
+	[AW_CTOS_PROFILE_FM] = "Fm",
+	[AW_CTOS_PROFILE_NOTIFICATION] = "Notification",
+	[AW_CTOS_PROFILE_RECEIVER] = "Receiver",
+};
+
+
+char *aw87xxx_ctos_get_prof_name(int profile_id)
+{
+	if (profile_id < 0 || profile_id >= AW_CTOS_PROFILE_MAX)
+		return NULL;
+	else
+		return g_ctos_profile_name[profile_id];
+}
+
+
+static char *g_profile_name[] = {"Music", "Voice", "Voip",
+		"Ringtone", "Ringtone_hs", "Lowpower", "Bypass", "Mmi",
+		"Fm", "Notification", "Receiver", "Off"};
+
+static char *g_power_off_name[] = {"Off", "OFF", "off", "oFF", "power_down"};
+
+static char *aw_get_prof_name(int profile)
+{
+	if (profile < 0 || profile >= AW_PROFILE_MAX)
+		return "NULL";
+	else
+		return g_profile_name[profile];
+}
+
+/*************************************************************************
+ *
+ *acf check
+ *
+ *************************************************************************/
+static int aw_crc8_check(const unsigned char *data, unsigned int data_size)
+
+{
+	unsigned char crc_value = 0x00;
+	unsigned char *pdata;
+	int i;
+	unsigned char pdatabuf = 0;
+
+	pdata = (unsigned char *)data;
+
+	while (data_size--) {
+		pdatabuf = *pdata++;
+		for (i = 0; i < 8; i++) {
+			if ((crc_value ^ (pdatabuf)) & 0x01) {
+				crc_value ^= 0x18;
+				crc_value >>= 1;
+				crc_value |= 0x80;
+			} else {
+				crc_value >>= 1;
+			}
+			pdatabuf >>= 1;
+		}
+	}
+
+	return (int)crc_value;
+}
+
+static int aw_check_file_id(struct device *dev,
+		char *fw_data, int32_t file_id)
+{
+	int32_t *acf_file_id = NULL;
+
+	acf_file_id = (int32_t *)fw_data;
+	if (*acf_file_id != file_id) {
+		AW_DEV_LOGE(dev, "file id [%x] check failed", *acf_file_id);
+		return -ENFILE;
+	}
+
+	return 0;
+}
+
+static int aw_check_header_size(struct device *dev,
+			char *fw_data, size_t fw_size)
+{
+	if (fw_size < sizeof(struct aw_acf_hdr)) {
+		AW_DEV_LOGE(dev, "acf size check failed,size less-than aw_acf_hdr");
+		return -ENOEXEC;
+	}
+
+	return 0;
+}
+
+/***************************************************************************
+ * V0.0.0.1 version acf check
+ **************************************************************************/
+static int aw_check_ddt_size_v_0_0_0_1(struct device *dev, char *fw_data)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)fw_data;
+	struct aw_acf_dde *acf_dde = NULL;
+
+	acf_dde = (struct aw_acf_dde *)(fw_data + acf_hdr->ddt_offset);
+
+	/* check ddt_size in acf_header is aqual to ddt_num multiply by dde_size */
+	if (acf_hdr->ddt_size != acf_hdr->dde_num * sizeof(struct aw_acf_dde)) {
+		AW_DEV_LOGE(dev, "acf ddt size check failed");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_check_data_size_v_0_0_0_1(struct device *dev,
+		char *fw_data, size_t fw_size)
+{
+	int i = 0;
+	size_t data_size = 0;
+	struct aw_acf_hdr *acf_hdr = NULL;
+	struct aw_acf_dde *acf_dde = NULL;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	acf_dde = (struct aw_acf_dde *)(fw_data + acf_hdr->ddt_offset);
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (acf_dde[i].data_size % 2) {
+			AW_DEV_LOGE(dev, "acf dde[%d].data_size[%d],dev_name[%s],data_type[%d], data_size check failed",
+				i, acf_dde[i].data_size, acf_dde[i].dev_name,
+				acf_dde[i].data_type);
+			return -EINVAL;
+		}
+		data_size += acf_dde[i].data_size;
+	}
+
+	/* Verify that the file size is equal to the header size plus */
+	/* the table size and data size */
+	if (fw_size != data_size + sizeof(struct aw_acf_hdr) + acf_hdr->ddt_size) {
+		AW_DEV_LOGE(dev, "acf size check failed");
+		AW_DEV_LOGE(dev, "fw_size=%ld,hdr_size and ddt size and data size =%ld",
+			(u_long)fw_size, (u_long)(data_size + sizeof(struct aw_acf_hdr) +
+			acf_hdr->ddt_size));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_check_data_crc_v_0_0_0_1(struct device *dev, char *fw_data)
+{
+	int i = 0;
+	size_t crc_val = 0;
+	char *data = NULL;
+	struct aw_acf_hdr *acf_hdr = NULL;
+	struct aw_acf_dde *acf_dde = NULL;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	acf_dde = (struct aw_acf_dde *)(fw_data + acf_hdr->ddt_offset);
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		data = fw_data + acf_dde[i].data_offset;
+		crc_val = aw_crc8_check(data, acf_dde[i].data_size);
+		if (crc_val != acf_dde[i].data_crc) {
+			AW_DEV_LOGE(dev, "acf dde_crc check failed");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int aw_check_profile_id_v_0_0_0_1(struct device *dev, char *fw_data)
+{
+	int i = 0;
+	struct aw_acf_hdr *acf_hdr = NULL;
+	struct aw_acf_dde *acf_dde = NULL;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	acf_dde = (struct aw_acf_dde *)(fw_data + acf_hdr->ddt_offset);
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (acf_dde[i].data_type == AW_MONITOR)
+			continue;
+		if (acf_dde[i].dev_profile > AW_PROFILE_MAX) {
+			AW_DEV_LOGE(dev, "parse profile_id[%d] failed", acf_dde[i].dev_profile);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+static int aw_check_data_v_0_0_0_1(struct device *dev,
+			char *fw_data, size_t size)
+{
+	int ret = -1;
+
+	/* check file type id is awinic acf file */
+	ret = aw_check_file_id(dev, fw_data, AW_ACF_FILE_ID);
+	if (ret < 0)
+		return ret;
+
+	/* check ddt_size in header is equal to all ddt aize */
+	ret = aw_check_ddt_size_v_0_0_0_1(dev, fw_data);
+	if (ret < 0)
+		return ret;
+
+	/* Verify that the file size is equal to the header size plus */
+	/* the table size and data size */
+	ret = aw_check_data_size_v_0_0_0_1(dev, fw_data, size);
+	if (ret < 0)
+		return ret;
+
+	/* check crc in is equal to dde data crc */
+	ret = aw_check_data_crc_v_0_0_0_1(dev, fw_data);
+	if (ret < 0)
+		return ret;
+
+	/* check profile id is in profile_id_max */
+	ret = aw_check_profile_id_v_0_0_0_1(dev, fw_data);
+	if (ret < 0)
+		return ret;
+
+	AW_DEV_LOGI(dev, "acf fimware check succeed");
+
+	return 0;
+}
+
+/***************************************************************************
+ * V1.0.0.0 version acf chack
+ **************************************************************************/
+static int aw_check_ddt_size_v_1_0_0_0(struct device *dev, char *fw_data)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)fw_data;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde = NULL;
+
+	acf_dde = (struct aw_acf_dde_v_1_0_0_0 *)(fw_data + acf_hdr->ddt_offset);
+
+	/* check ddt_size in acf_header is aqual to ddt_num multiply by dde_size */
+	if (acf_hdr->ddt_size != acf_hdr->dde_num * sizeof(struct aw_acf_dde_v_1_0_0_0)) {
+		AW_DEV_LOGE(dev, "acf ddt size check failed");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_check_data_size_v_1_0_0_0(struct device *dev,
+		char *fw_data, size_t fw_size)
+{
+	int i = 0;
+	size_t data_size = 0;
+	struct aw_acf_hdr *acf_hdr = NULL;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde = NULL;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	acf_dde = (struct aw_acf_dde_v_1_0_0_0 *)(fw_data + acf_hdr->ddt_offset);
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (acf_dde[i].data_size % 2) {
+			AW_DEV_LOGE(dev, "acf dde[%d].data_size[%d],dev_name[%s],data_type[%d], data_size check failed",
+				i, acf_dde[i].data_size, acf_dde[i].dev_name,
+				acf_dde[i].data_type);
+			return -EINVAL;
+		}
+		data_size += acf_dde[i].data_size;
+	}
+
+	/* Verify that the file size is equal to the header size plus */
+	/* the table size and data size */
+	if (fw_size != data_size + sizeof(struct aw_acf_hdr) + acf_hdr->ddt_size) {
+		AW_DEV_LOGE(dev, "acf size check failed");
+		AW_DEV_LOGE(dev, "fw_size=%ld,hdr_size and ddt size and data size =%ld",
+			(u_long)fw_size, (u_long)(data_size + sizeof(struct aw_acf_hdr) +
+			acf_hdr->ddt_size));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_check_data_crc_v_1_0_0_0(struct device *dev, char *fw_data)
+{
+	int i = 0;
+	size_t crc_val = 0;
+	char *data = NULL;
+	struct aw_acf_hdr *acf_hdr = NULL;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde = NULL;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	acf_dde = (struct aw_acf_dde_v_1_0_0_0 *)(fw_data + acf_hdr->ddt_offset);
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		data = fw_data + acf_dde[i].data_offset;
+		crc_val = aw_crc8_check(data, acf_dde[i].data_size);
+		if (crc_val != acf_dde[i].data_crc) {
+			AW_DEV_LOGE(dev, "acf dde_crc check failed");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int aw_check_data_v_1_0_0_0(struct device *dev,
+			char *fw_data, size_t size)
+{
+	int ret = -1;
+
+	/* check file type id is awinic acf file */
+	ret = aw_check_file_id(dev, fw_data, AW_ACF_FILE_ID);
+	if (ret < 0)
+		return ret;
+
+	/* check ddt_size in header is equal to all ddt aize */
+	ret = aw_check_ddt_size_v_1_0_0_0(dev, fw_data);
+	if (ret < 0)
+		return ret;
+
+	/* Verify that the file size is equal to the header size plus */
+	/* the table size and data size */
+	ret = aw_check_data_size_v_1_0_0_0(dev, fw_data, size);
+	if (ret < 0)
+		return ret;
+
+	/* check crc in is equal to dde data crc */
+	ret = aw_check_data_crc_v_1_0_0_0(dev, fw_data);
+	if (ret < 0)
+		return ret;
+
+	AW_DEV_LOGI(dev, "acf fimware check succeed");
+
+	return 0;
+}
+
+/***************************************************************************
+ * acf chack API
+ **************************************************************************/
+static int aw_check_acf_firmware(struct device *dev,
+			char *fw_data, size_t size)
+{
+	int ret = -1;
+	struct aw_acf_hdr *acf_hdr = NULL;
+
+	if (fw_data == NULL) {
+		AW_DEV_LOGE(dev, "fw_data is NULL,fw_data check failed");
+		return -ENODATA;
+	}
+
+	/* check file size is less-than header size */
+	ret = aw_check_header_size(dev, fw_data, size);
+	if (ret < 0)
+		return ret;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	AW_DEV_LOGI(dev, "project name: [%s]", acf_hdr->project);
+	AW_DEV_LOGI(dev, "custom name: [%s]", acf_hdr->custom);
+	AW_DEV_LOGI(dev, "version name: [%s]", acf_hdr->version);
+	AW_DEV_LOGI(dev, "author_id: [%d]", acf_hdr->author_id);
+
+	switch (acf_hdr->hdr_version) {
+	case AW_ACF_HDR_VER_0_0_0_1:
+		return aw_check_data_v_0_0_0_1(dev, fw_data, size);
+	case AW_ACF_HDR_VER_1_0_0_0:
+		return aw_check_data_v_1_0_0_0(dev, fw_data, size);
+	default:
+		AW_DEV_LOGE(dev, "unsupported hdr_version [0x%x]",
+			acf_hdr->hdr_version);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+
+
+/*************************************************************************
+ *
+ *acf parse
+ *
+ *************************************************************************/
+static int aw_parse_raw_reg(struct device *dev, uint8_t *data,
+		uint32_t data_len, struct aw_prof_desc *prof_desc)
+{
+	AW_DEV_LOGD(dev, "data_size:%d enter", data_len);
+
+	prof_desc->data_container.data = data;
+	prof_desc->data_container.len = data_len;
+
+	prof_desc->prof_st = AW_PROFILE_OK;
+
+	return 0;
+}
+
+static int aw_parse_reg_with_hdr(struct device *dev, uint8_t *data,
+			 uint32_t data_len, struct aw_prof_desc *prof_desc)
+{
+	struct aw_bin *aw_bin = NULL;
+	int ret = -1;
+
+	AW_DEV_LOGD(dev, "data_size:%d enter", data_len);
+
+	aw_bin = kzalloc(data_len + sizeof(struct aw_bin), GFP_KERNEL);
+	if (aw_bin == NULL) {
+		AW_DEV_LOGE(dev, "devm_kzalloc aw_bin failed");
+		return -ENOMEM;
+	}
+
+	aw_bin->info.len = data_len;
+	memcpy(aw_bin->info.data, data, data_len);
+
+	ret = aw87xxx_parsing_bin_file(aw_bin);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "parse bin failed");
+		goto parse_bin_failed;
+	}
+
+	if ((aw_bin->all_bin_parse_num != 1) ||
+		(aw_bin->header_info[0].bin_data_type != DATA_TYPE_REGISTER)) {
+		AW_DEV_LOGE(dev, "bin num or type error");
+		goto parse_bin_failed;
+	}
+
+	prof_desc->data_container.data =
+				data + aw_bin->header_info[0].valid_data_addr;
+	prof_desc->data_container.len = aw_bin->header_info[0].valid_data_len;
+	prof_desc->prof_st = AW_PROFILE_OK;
+
+	kfree(aw_bin);
+	aw_bin = NULL;
+
+	return 0;
+
+parse_bin_failed:
+	kfree(aw_bin);
+	aw_bin = NULL;
+	return ret;
+}
+
+static int aw_parse_monitor_config(struct device *dev,
+				char *monitor_data, uint32_t data_len)
+{
+	int ret = -1;
+
+	if (monitor_data == NULL || data_len == 0) {
+		AW_DEV_LOGE(dev, "no data to parse");
+		return -EBFONT;
+	}
+
+	ret = aw87xxx_monitor_bin_parse(dev, monitor_data, data_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "monitor_config parse failed");
+		return ret;
+	}
+
+	AW_DEV_LOGI(dev, "monitor_bin parse succeed");
+
+	return 0;
+}
+
+static int aw_check_prof_str_is_off(char *profile_name)
+{
+	int i = 0;
+
+	for (i = 0; i < AW_POWER_OFF_NAME_SUPPORT_COUNT; i++) {
+		if (strnstr(profile_name, g_power_off_name[i],
+				strlen(profile_name) + 1))
+			return 0;
+	}
+
+	return -EINVAL;
+}
+
+/***************************************************************************
+ * V0.0.0.1 version acf paese
+ **************************************************************************/
+static int aw_check_product_name_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_acf_dde *prof_hdr)
+{
+	int i = 0;
+
+	for (i = 0; i < acf_info->product_cnt; i++) {
+		if (0 == strcmp(acf_info->product_tab[i], prof_hdr->dev_name)) {
+			AW_DEV_LOGD(dev, "bin_dev_name:%s",
+				prof_hdr->dev_name);
+			return 0;
+		}
+	}
+
+	return -ENXIO;
+}
+
+static int aw_check_data_type_is_monitor_v_0_0_0_1(struct device *dev,
+				struct aw_acf_dde *prof_hdr)
+{
+	if (prof_hdr->data_type == AW_MONITOR) {
+		AW_DEV_LOGD(dev, "bin data is monitor");
+		return 0;
+	}
+
+	return -ENXIO;
+}
+
+static int aw_parse_data_by_sec_type_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_acf_dde *prof_hdr,
+				struct aw_prof_desc *profile_prof_desc)
+{
+	int ret = -1;
+	char *cfg_data = acf_info->fw_data + prof_hdr->data_offset;
+
+	switch (prof_hdr->data_type) {
+	case AW_BIN_TYPE_REG:
+		snprintf(profile_prof_desc->dev_name, sizeof(prof_hdr->dev_name),
+			"%s", prof_hdr->dev_name);
+		profile_prof_desc->prof_name = aw_get_prof_name(prof_hdr->dev_profile);
+		AW_DEV_LOGD(dev, "parse reg type data enter,profile=%s",
+			aw_get_prof_name(prof_hdr->dev_profile));
+		ret =  aw_parse_raw_reg(dev, cfg_data, prof_hdr->data_size,
+					profile_prof_desc);
+		break;
+	case AW_BIN_TYPE_HDR_REG:
+		snprintf(profile_prof_desc->dev_name, sizeof(prof_hdr->dev_name),
+			"%s", prof_hdr->dev_name);
+		profile_prof_desc->prof_name = aw_get_prof_name(prof_hdr->dev_profile);
+		AW_DEV_LOGD(dev, "parse hdr_reg type data enter,profile=%s",
+			aw_get_prof_name(prof_hdr->dev_profile));
+		ret = aw_parse_reg_with_hdr(dev, cfg_data,
+					prof_hdr->data_size,
+					profile_prof_desc);
+		break;
+	}
+
+	return ret;
+}
+
+static int aw_parse_dev_type_v_0_0_0_1(struct device *dev,
+		struct acf_bin_info *acf_info, struct aw_all_prof_info *all_prof_info)
+{
+	int i = 0;
+	int ret = -1;
+	int sec_num = 0;
+	char *cfg_data = NULL;
+	struct aw_prof_desc *prof_desc = NULL;
+	struct aw_acf_dde *acf_dde =
+		(struct aw_acf_dde *)(acf_info->fw_data + acf_info->acf_hdr.ddt_offset);
+
+	AW_DEV_LOGD(dev, "enter");
+
+	for (i = 0; i < acf_info->acf_hdr.dde_num; i++) {
+		if ((acf_info->aw_dev->i2c_bus == acf_dde[i].dev_bus) &&
+			(acf_info->aw_dev->i2c_addr == acf_dde[i].dev_addr) &&
+			(acf_dde[i].type == AW_DDE_DEV_TYPE_ID)) {
+
+			ret = aw_check_product_name_v_0_0_0_1(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			ret = aw_check_data_type_is_monitor_v_0_0_0_1(dev, &acf_dde[i]);
+			if (ret == 0) {
+				cfg_data = acf_info->fw_data + acf_dde[i].data_offset;
+				ret = aw_parse_monitor_config(dev, cfg_data, acf_dde[i].data_size);
+				if (ret < 0)
+					return ret;
+				continue;
+			}
+
+			prof_desc = &all_prof_info->prof_desc[acf_dde[i].dev_profile];
+			ret = aw_parse_data_by_sec_type_v_0_0_0_1(dev, acf_info, &acf_dde[i],
+				prof_desc);
+			if (ret < 0) {
+				AW_DEV_LOGE(dev, "parse dev type data failed");
+				return ret;
+			}
+			sec_num++;
+		}
+	}
+
+	if (sec_num == 0) {
+		AW_DEV_LOGD(dev, "get dev type num is %d, please use default",
+			sec_num);
+		return AW_DEV_TYPE_NONE;
+	}
+
+	return AW_DEV_TYPE_OK;
+}
+
+static int aw_parse_default_type_v_0_0_0_1(struct device *dev,
+	struct acf_bin_info *acf_info, struct aw_all_prof_info *all_prof_info)
+{
+	int i = 0;
+	int ret = -1;
+	int sec_num = 0;
+	char *cfg_data = NULL;
+	struct aw_prof_desc *prof_desc = NULL;
+	struct aw_acf_dde *acf_dde =
+		(struct aw_acf_dde *)(acf_info->fw_data + acf_info->acf_hdr.ddt_offset);
+
+	AW_DEV_LOGD(dev, "enter");
+
+	for (i = 0; i < acf_info->acf_hdr.dde_num; i++) {
+		if ((acf_info->dev_index == acf_dde[i].dev_index) &&
+			(acf_dde[i].type == AW_DDE_DEV_DEFAULT_TYPE_ID)) {
+
+			ret = aw_check_product_name_v_0_0_0_1(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			ret = aw_check_data_type_is_monitor_v_0_0_0_1(dev, &acf_dde[i]);
+			if (ret == 0) {
+				cfg_data = acf_info->fw_data + acf_dde[i].data_offset;
+				ret = aw_parse_monitor_config(dev, cfg_data, acf_dde[i].data_size);
+				if (ret < 0)
+					return ret;
+				continue;
+			}
+
+			prof_desc = &all_prof_info->prof_desc[acf_dde[i].dev_profile];
+			ret = aw_parse_data_by_sec_type_v_0_0_0_1(dev, acf_info, &acf_dde[i],
+				prof_desc);
+			if (ret < 0) {
+				AW_DEV_LOGE(dev, "parse default type data failed");
+				return ret;
+			}
+			sec_num++;
+		}
+	}
+
+	if (sec_num == 0) {
+		AW_DEV_LOGE(dev, "get dev default type failed, get num[%d]",
+			sec_num);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_get_prof_count_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_all_prof_info *all_prof_info)
+{
+	int i = 0;
+	int prof_count = 0;
+	struct aw_prof_desc *prof_desc = all_prof_info->prof_desc;
+
+	for (i = 0; i < AW_PROFILE_MAX; i++) {
+		if (prof_desc[i].prof_st == AW_PROFILE_OK) {
+			prof_count++;
+		} else if (i == AW_PROFILE_OFF) {
+			prof_count++;
+			AW_DEV_LOGI(dev, "not found profile [Off], set default");
+		}
+	}
+
+	AW_DEV_LOGI(dev, "get profile count=[%d]", prof_count);
+	return prof_count;
+}
+
+static int aw_set_prof_off_info_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_all_prof_info *all_prof_info,
+				int index)
+{
+	struct aw_prof_desc *prof_desc = all_prof_info->prof_desc;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	if (index >= prof_info->count) {
+		AW_DEV_LOGE(dev, "index[%d] is out of table,profile count[%d]",
+			index, prof_info->count);
+		return -EINVAL;
+	}
+
+	if (prof_desc[AW_PROFILE_OFF].prof_st == AW_PROFILE_OK) {
+		prof_info->prof_desc[index] = prof_desc[AW_PROFILE_OFF];
+		AW_DEV_LOGI(dev, "product=[%s]----profile=[%s]",
+			prof_info->prof_desc[index].dev_name,
+			aw_get_prof_name(AW_PROFILE_OFF));
+	} else {
+		memset(&prof_info->prof_desc[index].data_container, 0,
+			sizeof(struct aw_data_container));
+		prof_info->prof_desc[index].prof_st = AW_PROFILE_WAIT;
+		prof_info->prof_desc[index].prof_name = aw_get_prof_name(AW_PROFILE_OFF);
+		AW_DEV_LOGI(dev, "set default power_off with no data to profile");
+	}
+
+	return 0;
+}
+
+
+static int aw_get_vaild_prof_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_all_prof_info *all_prof_info)
+{
+	int i = 0;
+	int ret = 0;
+	int index = 0;
+	struct aw_prof_desc *prof_desc = all_prof_info->prof_desc;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	prof_info->count = 0;
+	ret = aw_get_prof_count_v_0_0_0_1(dev, acf_info, all_prof_info);
+	if (ret < 0)
+		return ret;
+	prof_info->count = ret;
+	prof_info->prof_desc = devm_kzalloc(dev,
+			prof_info->count * sizeof(struct aw_prof_desc),
+			GFP_KERNEL);
+	if (prof_info->prof_desc == NULL) {
+		AW_DEV_LOGE(dev, "prof_desc kzalloc failed");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < AW_PROFILE_MAX; i++) {
+		if (i != AW_PROFILE_OFF && prof_desc[i].prof_st == AW_PROFILE_OK) {
+			if (index >= prof_info->count) {
+				AW_DEV_LOGE(dev, "get profile index[%d] overflow count[%d]",
+						index, prof_info->count);
+				return -ENOMEM;
+			}
+			prof_info->prof_desc[index] = prof_desc[i];
+			AW_DEV_LOGI(dev, "product=[%s]----profile=[%s]",
+				prof_info->prof_desc[index].dev_name,
+				aw_get_prof_name(i));
+			index++;
+		}
+	}
+
+	ret = aw_set_prof_off_info_v_0_0_0_1(dev, acf_info, all_prof_info, index);
+	if (ret < 0)
+		return ret;
+
+	AW_DEV_LOGD(dev, "get vaild profile succeed");
+	return 0;
+}
+
+static int aw_set_prof_name_list_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	int i = 0;
+	int count = acf_info->prof_info.count;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	prof_info->prof_name_list = (char (*)[AW_PROFILE_STR_MAX])devm_kzalloc(dev,
+		count * (AW_PROFILE_STR_MAX), GFP_KERNEL);
+	if (prof_info->prof_name_list == NULL) {
+		AW_DEV_LOGE(dev, "prof_name_list devm_kzalloc failed");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < count; ++i) {
+		snprintf(prof_info->prof_name_list[i], AW_PROFILE_STR_MAX, "%s",
+			prof_info->prof_desc[i].prof_name);
+		AW_DEV_LOGI(dev, "index=[%d], profile_name=[%s]",
+				i, prof_info->prof_name_list[i]);
+	}
+
+	return 0;
+}
+
+static int aw_parse_acf_v_0_0_0_1(struct device *dev,
+		struct acf_bin_info *acf_info)
+
+{
+	int ret = 0;
+	struct aw_all_prof_info all_prof_info;
+
+	AW_DEV_LOGD(dev, "enter");
+	acf_info->prof_info.status = AW_ACF_WAIT;
+
+	memset(&all_prof_info, 0, sizeof(struct aw_all_prof_info));
+
+	ret = aw_parse_dev_type_v_0_0_0_1(dev, acf_info, &all_prof_info);
+	if (ret < 0) {
+		return ret;
+	} else if (ret == AW_DEV_TYPE_NONE) {
+		AW_DEV_LOGD(dev, "get dev type num is 0, parse default dev type");
+		ret = aw_parse_default_type_v_0_0_0_1(dev, acf_info, &all_prof_info);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = aw_get_vaild_prof_v_0_0_0_1(dev, acf_info, &all_prof_info);
+	if (ret < 0) {
+		aw87xxx_acf_profile_free(dev, acf_info);
+		AW_DEV_LOGE(dev,  "hdr_cersion[0x%x] parse failed",
+					acf_info->acf_hdr.hdr_version);
+		return ret;
+	}
+
+	ret = aw_set_prof_name_list_v_0_0_0_1(dev, acf_info);
+	if (ret < 0) {
+		aw87xxx_acf_profile_free(dev, acf_info);
+		AW_DEV_LOGE(dev,  "creat prof_id_and_name_list failed");
+		return ret;
+	}
+
+	acf_info->prof_info.status = AW_ACF_UPDATE;
+	AW_DEV_LOGI(dev, "acf parse success");
+	return 0;
+}
+
+/***************************************************************************
+ * V1.0.0.0 version acf paese
+ **************************************************************************/
+static int aw_check_product_name_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_acf_dde_v_1_0_0_0 *prof_hdr)
+{
+	int i = 0;
+
+	for (i = 0; i < acf_info->product_cnt; i++) {
+		if (0 == strcmp(acf_info->product_tab[i], prof_hdr->dev_name)) {
+			AW_DEV_LOGI(dev, "bin_dev_name:%s", prof_hdr->dev_name);
+			return 0;
+		}
+	}
+
+	return -ENXIO;
+}
+
+static int aw_get_dde_type_info_v_1_0_0_0(struct device *dev,
+					struct acf_bin_info *acf_info)
+{
+	int i;
+	int dev_num = 0;
+	int default_num = 0;
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)acf_info->fw_data;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_hdr->ddt_offset);
+
+	prof_info->prof_type = AW_DEV_NONE_TYPE_ID;
+	for (i = 0; i < acf_hdr->dde_num; i++) {
+		if (acf_dde[i].type == AW_DDE_DEV_TYPE_ID)
+			dev_num++;
+		if (acf_dde[i].type == AW_DDE_DEV_DEFAULT_TYPE_ID)
+			default_num++;
+	}
+
+	if (!(dev_num || default_num)) {
+		AW_DEV_LOGE(dev, "can't find scene");
+		return -EINVAL;
+	}
+
+	if (dev_num != 0)
+		prof_info->prof_type = AW_DDE_DEV_TYPE_ID;
+	else if (default_num != 0)
+		prof_info->prof_type = AW_DDE_DEV_DEFAULT_TYPE_ID;
+
+	return 0;
+}
+
+
+static int aw_parse_get_dev_type_prof_count_v_1_0_0_0(struct device *dev,
+						struct acf_bin_info *acf_info)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)acf_info->fw_data;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_hdr->ddt_offset);
+	int i = 0;
+	int ret = 0;
+	int found_off_prof_flag = 0;
+	int count = acf_info->prof_info.count;
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (((acf_dde[i].data_type == AW_BIN_TYPE_REG) ||
+		(acf_dde[i].data_type == AW_BIN_TYPE_HDR_REG)) &&
+		((acf_info->aw_dev->i2c_bus == acf_dde[i].dev_bus) &&
+		(acf_info->aw_dev->i2c_addr == acf_dde[i].dev_addr)) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			ret = aw_check_prof_str_is_off(acf_dde[i].dev_profile_str);
+			if (ret == 0) {
+				found_off_prof_flag = AW_PROFILE_OK;
+			}
+			count++;
+		}
+	}
+
+	if (count == 0) {
+		AW_DEV_LOGE(dev, "can't find profile");
+		return -EINVAL;
+	}
+
+	if (!found_off_prof_flag) {
+		count++;
+		AW_DEV_LOGD(dev, "set no config power off profile in count");
+	}
+
+	acf_info->prof_info.count = count;
+	AW_DEV_LOGI(dev, "profile dev_type profile count is %d", acf_info->prof_info.count);
+	return 0;
+}
+
+static int aw_parse_get_default_type_prof_count_v_1_0_0_0(struct device *dev,
+						struct acf_bin_info *acf_info)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)acf_info->fw_data;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_hdr->ddt_offset);
+	int i = 0;
+	int ret = 0;
+	int found_off_prof_flag = 0;
+	int count = acf_info->prof_info.count;
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (((acf_dde[i].data_type == AW_BIN_TYPE_REG) ||
+		(acf_dde[i].data_type == AW_BIN_TYPE_HDR_REG)) &&
+		(acf_info->dev_index == acf_dde[i].dev_index) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			ret = aw_check_prof_str_is_off(acf_dde[i].dev_profile_str);
+			if (ret == 0) {
+				found_off_prof_flag = AW_PROFILE_OK;
+			}
+			count++;
+		}
+	}
+
+	if (count == 0) {
+		AW_DEV_LOGE(dev, "can't find profile");
+		return -EINVAL;
+	}
+
+	if (!found_off_prof_flag) {
+		count++;
+		AW_DEV_LOGD(dev, "set no config power off profile in count");
+	}
+
+	acf_info->prof_info.count = count;
+	AW_DEV_LOGI(dev, "profile default_type profile count is %d", acf_info->prof_info.count);
+	return 0;
+}
+
+static int aw_parse_get_profile_count_v_1_0_0_0(struct device *dev,
+						struct acf_bin_info *acf_info)
+{
+	int ret = 0;
+
+	ret = aw_get_dde_type_info_v_1_0_0_0(dev, acf_info);
+	if (ret < 0)
+		return ret;
+
+	if (acf_info->prof_info.prof_type == AW_DDE_DEV_TYPE_ID) {
+		ret = aw_parse_get_dev_type_prof_count_v_1_0_0_0(dev, acf_info);
+		if (ret < 0) {
+			AW_DEV_LOGE(dev, "parse dev_type profile count failed");
+			return ret;
+		}
+	} else if (acf_info->prof_info.prof_type == AW_DDE_DEV_DEFAULT_TYPE_ID) {
+		ret = aw_parse_get_default_type_prof_count_v_1_0_0_0(dev, acf_info);
+		if (ret < 0) {
+			AW_DEV_LOGE(dev, "parse default_type profile count failed");
+			return ret;
+		}
+	} else {
+		AW_DEV_LOGE(dev, "unsupport prof_type[0x%x]",
+			acf_info->prof_info.prof_type);
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGI(dev, "profile count is %d", acf_info->prof_info.count);
+	return 0;
+}
+
+static int aw_parse_dev_type_prof_name_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)acf_info->fw_data;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_hdr->ddt_offset);
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+	int i, ret, list_index = 0;
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (((acf_dde[i].data_type == AW_BIN_TYPE_REG) ||
+		(acf_dde[i].data_type == AW_BIN_TYPE_HDR_REG)) &&
+		(acf_info->aw_dev->i2c_bus == acf_dde[i].dev_bus) &&
+		(acf_info->aw_dev->i2c_addr == acf_dde[i].dev_addr) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+			if (list_index > prof_info->count) {
+				AW_DEV_LOGE(dev, "%s:Alrealdy set list_index [%d], redundant profile [%s]exist\n",
+					__func__, list_index,
+					acf_dde[i].dev_profile_str);
+				return -EINVAL;
+			}
+
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			snprintf(prof_info->prof_name_list[list_index], AW_PROFILE_STR_MAX, "%s",
+				acf_dde[i].dev_profile_str);
+			AW_DEV_LOGI(dev, "profile_name=[%s]",
+					prof_info->prof_name_list[list_index]);
+			list_index++;
+		}
+	}
+
+	return 0;
+}
+
+static int aw_parse_default_type_prof_name_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)acf_info->fw_data;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_hdr->ddt_offset);
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+	int i, ret, list_index = 0;
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (((acf_dde[i].data_type == AW_BIN_TYPE_REG) ||
+		(acf_dde[i].data_type == AW_BIN_TYPE_HDR_REG)) &&
+		(acf_info->dev_index == acf_dde[i].dev_index) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+			if (list_index > prof_info->count) {
+				AW_DEV_LOGE(dev, "%s:Alrealdy set list_index [%d], redundant profile [%s]exist\n",
+					__func__, list_index,
+					acf_dde[i].dev_profile_str);
+				return -EINVAL;
+			}
+
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			snprintf(prof_info->prof_name_list[list_index], AW_PROFILE_STR_MAX, "%s",
+				acf_dde[i].dev_profile_str);
+			AW_DEV_LOGI(dev, "profile_name=[%s]",
+					prof_info->prof_name_list[list_index]);
+			list_index++;
+		}
+	}
+
+	return 0;
+}
+
+static int aw_parse_prof_name_v_1_0_0_0(struct device *dev,
+						struct acf_bin_info *acf_info)
+{
+	int ret = 0;
+	int count = acf_info->prof_info.count;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	prof_info->prof_name_list = (char (*)[AW_PROFILE_STR_MAX])devm_kzalloc(dev,
+		count * (AW_PROFILE_STR_MAX), GFP_KERNEL);
+	if (prof_info->prof_name_list == NULL) {
+		AW_DEV_LOGE(dev, "prof_name_list devm_kzalloc failed");
+		return -ENOMEM;
+	}
+
+	if (acf_info->prof_info.prof_type == AW_DDE_DEV_TYPE_ID) {
+		ret = aw_parse_dev_type_prof_name_v_1_0_0_0(dev, acf_info);
+		if (ret < 0) {
+			AW_DEV_LOGE(dev, "parse dev_type profile count failed");
+			return ret;
+		}
+	} else if (acf_info->prof_info.prof_type == AW_DDE_DEV_DEFAULT_TYPE_ID) {
+		ret = aw_parse_default_type_prof_name_v_1_0_0_0(dev, acf_info);
+		if (ret < 0) {
+			AW_DEV_LOGE(dev, "parse default_type profile count failed");
+			return ret;
+		}
+	} else {
+		AW_DEV_LOGE(dev, "unsupport prof_type[0x%x]",
+			acf_info->prof_info.prof_type);
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGI(dev, "profile name parse succeed");
+	return 0;
+}
+
+
+static int aw_search_prof_index_from_list_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_prof_desc **prof_desc,
+				struct aw_acf_dde_v_1_0_0_0 *prof_hdr)
+{
+	int i = 0;
+	int count = acf_info->prof_info.count;
+	char (*prof_name_list)[AW_PROFILE_STR_MAX] = acf_info->prof_info.prof_name_list;
+
+	for (i = 0; i < count; i++) {
+		if (!strncmp(prof_name_list[i], prof_hdr->dev_profile_str, AW_PROFILE_STR_MAX)) {
+			*prof_desc = &(acf_info->prof_info.prof_desc[i]);
+			return 0;
+		}
+	}
+
+	if (i == count)
+		AW_DEV_LOGE(dev, "not find prof_id and prof_name in list");
+
+	return -EINVAL;
+}
+
+static int aw_parse_data_by_sec_type_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_acf_dde_v_1_0_0_0 *prof_hdr)
+{
+	int ret = -1;
+	char *cfg_data = acf_info->fw_data + prof_hdr->data_offset;
+	struct aw_prof_desc *prof_desc = NULL;
+
+	ret = aw_search_prof_index_from_list_v_1_0_0_0(dev, acf_info, &prof_desc, prof_hdr);
+	if (ret < 0)
+		return ret;
+
+	switch (prof_hdr->data_type) {
+	case AW_BIN_TYPE_REG:
+		snprintf(prof_desc->dev_name, sizeof(prof_hdr->dev_name),
+			"%s", prof_hdr->dev_name);
+		AW_DEV_LOGI(dev, "parse reg type data enter,product=[%s],prof_id=[%d],prof_name=[%s]",
+			prof_hdr->dev_name, prof_hdr->dev_profile,
+			prof_hdr->dev_profile_str);
+		prof_desc->prof_name = prof_hdr->dev_profile_str;
+		ret =  aw_parse_raw_reg(dev, cfg_data, prof_hdr->data_size,
+					prof_desc);
+		break;
+	case AW_BIN_TYPE_HDR_REG:
+		snprintf(prof_desc->dev_name, sizeof(prof_hdr->dev_name),
+			"%s", prof_hdr->dev_name);
+		AW_DEV_LOGI(dev, "parse hdr_reg type data enter,product=[%s],prof_id=[%d],prof_name=[%s]",
+			prof_hdr->dev_name, prof_hdr->dev_profile,
+			prof_hdr->dev_profile_str);
+		prof_desc->prof_name = prof_hdr->dev_profile_str;
+		ret = aw_parse_reg_with_hdr(dev, cfg_data,
+				prof_hdr->data_size, prof_desc);
+		break;
+	}
+
+	return ret;
+}
+
+static int aw_parse_dev_type_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	int i = 0;
+	int ret;
+	int parse_prof_count = 0;
+	char *cfg_data = NULL;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_info->acf_hdr.ddt_offset);
+
+	AW_DEV_LOGD(dev, "enter");
+
+	for (i = 0; i < acf_info->acf_hdr.dde_num; i++) {
+		if ((acf_dde[i].type == AW_DDE_DEV_TYPE_ID) &&
+		(acf_info->aw_dev->i2c_bus == acf_dde[i].dev_bus) &&
+		(acf_info->aw_dev->i2c_addr == acf_dde[i].dev_addr) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			if (acf_dde[i].data_type == AW_MONITOR) {
+				cfg_data = acf_info->fw_data + acf_dde[i].data_offset;
+				AW_DEV_LOGD(dev, "parse monitor type data enter");
+				ret = aw_parse_monitor_config(dev, cfg_data,
+					acf_dde[i].data_size);
+			} else {
+				ret = aw_parse_data_by_sec_type_v_1_0_0_0(dev, acf_info,
+					&acf_dde[i]);
+				if (ret < 0)
+					AW_DEV_LOGE(dev, "parse dev type data failed");
+				else
+					parse_prof_count++;
+			}
+		}
+	}
+
+	if (parse_prof_count == 0) {
+		AW_DEV_LOGE(dev, "get dev type num is %d, parse failed", parse_prof_count);
+		return -EINVAL;
+	}
+
+	return AW_DEV_TYPE_OK;
+}
+
+static int aw_parse_default_type_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	int i = 0;
+	int ret;
+	int parse_prof_count = 0;
+	char *cfg_data = NULL;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_info->acf_hdr.ddt_offset);
+
+	AW_DEV_LOGD(dev, "enter");
+
+	for (i = 0; i < acf_info->acf_hdr.dde_num; i++) {
+		if ((acf_dde[i].type == AW_DDE_DEV_DEFAULT_TYPE_ID) &&
+		(acf_info->dev_index == acf_dde[i].dev_index) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			if (acf_dde[i].data_type == AW_MONITOR) {
+				cfg_data = acf_info->fw_data + acf_dde[i].data_offset;
+				AW_DEV_LOGD(dev, "parse monitor type data enter");
+				ret = aw_parse_monitor_config(dev, cfg_data,
+					acf_dde[i].data_size);
+			} else {
+				ret = aw_parse_data_by_sec_type_v_1_0_0_0(dev, acf_info,
+					&acf_dde[i]);
+				if (ret < 0)
+					AW_DEV_LOGE(dev, "parse default type data failed");
+				else
+					parse_prof_count++;
+			}
+		}
+	}
+
+	if (parse_prof_count == 0) {
+		AW_DEV_LOGE(dev, "get default type num is %d,parse failed", parse_prof_count);
+		return -EINVAL;
+	}
+
+	return AW_DEV_TYPE_OK;
+}
+
+static int aw_parse_by_hdr_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	int ret;
+
+	if (acf_info->prof_info.prof_type == AW_DDE_DEV_TYPE_ID) {
+		ret = aw_parse_dev_type_v_1_0_0_0(dev, acf_info);
+		if (ret < 0)
+			return ret;
+	} else if (acf_info->prof_info.prof_type == AW_DDE_DEV_DEFAULT_TYPE_ID) {
+		ret = aw_parse_default_type_v_1_0_0_0(dev, acf_info);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int aw_set_prof_off_info_v_1_0_0_0(struct device *dev,
+						struct acf_bin_info *acf_info)
+{
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+	int i = 0;
+	int ret = 0;
+
+	for (i = 0; i < prof_info->count; ++i) {
+		if (!(prof_info->prof_desc[i].prof_st)) {
+			snprintf(prof_info->prof_name_list[i], AW_PROFILE_STR_MAX, "%s",
+					g_power_off_name[0]);
+			prof_info->prof_desc[i].prof_name = prof_info->prof_name_list[i];
+			prof_info->prof_desc[i].prof_st = AW_PROFILE_WAIT;
+			memset(&prof_info->prof_desc[i].data_container, 0,
+					sizeof(struct aw_data_container));
+			return 0;
+		}
+
+		ret = aw_check_prof_str_is_off(prof_info->prof_name_list[i]);
+		if (ret == 0) {
+			AW_DEV_LOGD(dev, "found profile off,data_len=[%d]",
+				prof_info->prof_desc[i].data_container.len);
+			return 0;
+		}
+	}
+
+	AW_DEV_LOGE(dev, "index[%d] is out of table,profile count[%d]",
+		i, prof_info->count);
+	return -EINVAL;
+}
+
+static int aw_parse_acf_v_1_0_0_0(struct device *dev,
+		struct acf_bin_info *acf_info)
+
+{
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+	int ret;
+
+	ret = aw_parse_get_profile_count_v_1_0_0_0(dev, acf_info);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "get profile count failed");
+		return ret;
+	}
+
+	ret = aw_parse_prof_name_v_1_0_0_0(dev, acf_info);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "get profile count failed");
+		return ret;
+	}
+
+	acf_info->prof_info.prof_desc = devm_kzalloc(dev,
+		prof_info->count * sizeof(struct aw_prof_desc), GFP_KERNEL);
+	if (acf_info->prof_info.prof_desc == NULL) {
+		AW_DEV_LOGE(dev, "prof_desc devm_kzalloc failed");
+		return -ENOMEM;
+	}
+
+	ret = aw_parse_by_hdr_v_1_0_0_0(dev, acf_info);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "parse data failed");
+		return ret;
+	}
+
+	ret = aw_set_prof_off_info_v_1_0_0_0(dev, acf_info);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "set profile off info failed");
+		return ret;
+	}
+
+	prof_info->status = AW_ACF_UPDATE;
+	AW_DEV_LOGI(dev, "acf paese succeed");
+	return 0;
+}
+
+
+/*************************************************************************
+ *
+ *acf parse API
+ *
+ *************************************************************************/
+void aw87xxx_acf_profile_free(struct device *dev, struct acf_bin_info *acf_info)
+{
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	prof_info->count = 0;
+	prof_info->status = AW_ACF_WAIT;
+	memset(&acf_info->acf_hdr, 0, sizeof(struct aw_acf_hdr));
+
+	if (prof_info->prof_desc) {
+		devm_kfree(dev, prof_info->prof_desc);
+		prof_info->prof_desc = NULL;
+	}
+
+	if (prof_info->prof_name_list) {
+		devm_kfree(dev, prof_info->prof_name_list);
+		prof_info->prof_name_list = NULL;
+	}
+
+	if (acf_info->fw_data) {
+		vfree(acf_info->fw_data);
+		acf_info->fw_data = NULL;
+	}
+}
+
+int aw87xxx_acf_parse(struct device *dev, struct acf_bin_info *acf_info)
+{
+	int ret = 0;
+
+	AW_DEV_LOGD(dev, "enter");
+	acf_info->prof_info.status = AW_ACF_WAIT;
+	ret = aw_check_acf_firmware(dev, acf_info->fw_data,
+					acf_info->fw_size);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "load firmware check failed");
+		return -EINVAL;
+	}
+
+	memcpy(&acf_info->acf_hdr, acf_info->fw_data,
+		sizeof(struct aw_acf_hdr));
+
+	switch (acf_info->acf_hdr.hdr_version) {
+	case AW_ACF_HDR_VER_0_0_0_1:
+		return aw_parse_acf_v_0_0_0_1(dev, acf_info);
+	case AW_ACF_HDR_VER_1_0_0_0:
+		return aw_parse_acf_v_1_0_0_0(dev, acf_info);
+	default:
+		AW_DEV_LOGE(dev, "unsupported hdr_version [0x%x]",
+			acf_info->acf_hdr.hdr_version);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+struct aw_prof_desc *aw87xxx_acf_get_prof_desc_form_name(struct device *dev,
+			struct acf_bin_info *acf_info, char *profile_name)
+{
+	int i = 0;
+	struct aw_prof_desc *prof_desc = NULL;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	AW_DEV_LOGD(dev, "enter");
+
+	if (!acf_info->prof_info.status) {
+		AW_DEV_LOGE(dev, "profile_cfg not load");
+		return NULL;
+	}
+
+	for (i = 0; i < prof_info->count; i++) {
+		if (!strncmp(profile_name, prof_info->prof_desc[i].prof_name,
+				AW_PROFILE_STR_MAX)) {
+			prof_desc = &prof_info->prof_desc[i];
+			break;
+		}
+	}
+
+	if (i == prof_info->count) {
+		AW_DEV_LOGE(dev, "profile not found");
+		return NULL;
+	}
+
+	AW_DEV_LOGI(dev, "get prof desc down");
+	return prof_desc;
+}
+
+int aw87xxx_acf_get_prof_index_form_name(struct device *dev,
+			struct acf_bin_info *acf_info, char *profile_name)
+{
+	int i = 0;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	if (!acf_info->prof_info.status) {
+		AW_DEV_LOGE(dev, "profile_cfg not load");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < prof_info->count; i++) {
+		if (!strncmp(profile_name, prof_info->prof_name_list[i],
+				AW_PROFILE_STR_MAX)) {
+			return i;
+		}
+	}
+
+	AW_DEV_LOGE(dev, "profile_index not found");
+	return -EINVAL;
+}
+
+char *aw87xxx_acf_get_prof_name_form_index(struct device *dev,
+			struct acf_bin_info *acf_info, int index)
+{
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	if (!acf_info->prof_info.status) {
+		AW_DEV_LOGE(dev, "profile_cfg not load");
+		return NULL;
+	}
+
+	if (index >= prof_info->count  || index < 0) {
+		AW_DEV_LOGE(dev, "profile_index out of table");
+		return NULL;
+	}
+
+	return prof_info->prof_desc[index].prof_name;
+}
+
+
+int aw87xxx_acf_get_profile_count(struct device *dev,
+			struct acf_bin_info *acf_info)
+{
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	if (!acf_info->prof_info.status) {
+		AW_DEV_LOGE(dev, "profile_cfg not load");
+		return -EINVAL;
+	}
+
+	if (prof_info->count > 0) {
+		return prof_info->count;
+	}
+
+	return -EINVAL;
+}
+
+char *aw87xxx_acf_get_prof_off_name(struct device *dev,
+			struct acf_bin_info *acf_info)
+{
+	int i = 0;
+	int ret = 0;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	if (!acf_info->prof_info.status) {
+		AW_DEV_LOGE(dev, "profile_cfg not load");
+		return NULL;
+	}
+
+	for (i = 0; i < prof_info->count; i++) {
+		ret  = aw_check_prof_str_is_off(prof_info->prof_name_list[i]);
+		if (ret == 0)
+			return prof_info->prof_name_list[i];
+	}
+
+	return NULL;
+}
+
+void aw87xxx_acf_init(struct aw_device *aw_dev, struct acf_bin_info *acf_info, int index)
+{
+
+	acf_info->load_count = 0;
+	acf_info->prof_info.status = AW_ACF_WAIT;
+	acf_info->dev_index = index;
+	acf_info->aw_dev = aw_dev;
+	acf_info->product_cnt = aw_dev->product_cnt;
+	acf_info->product_tab = aw_dev->product_tab;
+	acf_info->prof_info.prof_desc = NULL;
+	acf_info->fw_data = NULL;
+	acf_info->fw_size = 0;
+}
+
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.h b/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.h
new file mode 100644
index 000000000..3a14d9b8a
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.h
@@ -0,0 +1,191 @@
+#ifndef __AW87XXX_ACF_BIN_H__
+#define __AW87XXX_ACF_BIN_H__
+
+#include "aw87xxx_device.h"
+
+#define AW_PROJECT_NAME_MAX		(24)
+#define AW_CUSTOMER_NAME_MAX		(16)
+#define AW_CFG_VERSION_MAX		(4)
+#define AW_TBL_VERSION_MAX		(4)
+#define AW_DDE_DEVICE_TYPE		(0)
+#define AW_DDE_SKT_TYPE			(1)
+#define AW_DDE_DEFAULT_TYPE		(2)
+
+#define AW_REG_ADDR_BYTE		(1)
+#define AW_REG_DATA_BYTE		(1)
+
+#define AW_ACF_FILE_ID			(0xa15f908)
+#define AW_PROFILE_STR_MAX 		(32)
+#define AW_POWER_OFF_NAME_SUPPORT_COUNT	(5)
+
+enum aw_cfg_hdr_version {
+	AW_ACF_HDR_VER_0_0_0_1 = 0x00000001,
+	AW_ACF_HDR_VER_1_0_0_0 = 0x01000000,
+};
+
+enum aw_acf_dde_type_id {
+	AW_DEV_NONE_TYPE_ID = 0xFFFFFFFF,
+	AW_DDE_DEV_TYPE_ID = 0x00000000,
+	AW_DDE_SKT_TYPE_ID = 0x00000001,
+	AW_DDE_DEV_DEFAULT_TYPE_ID = 0x00000002,
+	AW_DDE_TYPE_MAX,
+};
+
+enum aw_raw_data_type_id {
+	AW_BIN_TYPE_REG = 0x00000000,
+	AW_BIN_TYPE_DSP,
+	AW_BIN_TYPE_DSP_CFG,
+	AW_BIN_TYPE_DSP_FW,
+	AW_BIN_TYPE_HDR_REG,
+	AW_BIN_TYPE_HDR_DSP_CFG,
+	AW_BIN_TYPE_HDR_DSP_FW,
+	AW_BIN_TYPE_MUTLBIN,
+	AW_SKT_UI_PROJECT,
+	AW_DSP_CFG,
+	AW_MONITOR,
+	AW_BIN_TYPE_MAX,
+};
+
+enum {
+	AW_DEV_TYPE_OK = 0,
+	AW_DEV_TYPE_NONE = 1,
+};
+
+enum aw_profile_status {
+	AW_PROFILE_WAIT = 0,
+	AW_PROFILE_OK,
+};
+
+enum aw_acf_load_status {
+	AW_ACF_WAIT = 0,
+	AW_ACF_UPDATE,
+};
+
+enum aw_bin_dev_profile_id {
+	AW_PROFILE_MUSIC = 0x0000,
+	AW_PROFILE_VOICE,
+	AW_PROFILE_VOIP,
+	AW_PROFILE_RINGTONE,
+	AW_PROFILE_RINGTONE_HS,
+	AW_PROFILE_LOWPOWER,
+	AW_PROFILE_BYPASS,
+	AW_PROFILE_MMI,
+	AW_PROFILE_FM,
+	AW_PROFILE_NOTIFICATION,
+	AW_PROFILE_RECEIVER,
+	AW_PROFILE_OFF,
+	AW_PROFILE_MAX,
+};
+
+struct aw_acf_hdr {
+	int32_t a_id;				/* acf file ID 0xa15f908 */
+	char project[AW_PROJECT_NAME_MAX];	/* project name */
+	char custom[AW_CUSTOMER_NAME_MAX];	/* custom name :huawei xiaomi vivo oppo */
+	uint8_t version[AW_CFG_VERSION_MAX];	/* author update version */
+	int32_t author_id;			/* author id */
+	int32_t ddt_size;			/* sub section table entry size */
+	int32_t dde_num;			/* sub section table entry num */
+	int32_t ddt_offset;			/* sub section table offset in file */
+	int32_t hdr_version;			/* sub section table version */
+	int32_t reserve[3];			/* Reserved Bits */
+};
+
+struct aw_acf_dde {
+	int32_t type;				/* dde type id */
+	char dev_name[AW_CUSTOMER_NAME_MAX];	/* customer dev name */
+	int16_t dev_index;			/* dev id */
+	int16_t dev_bus;			/* dev bus id */
+	int16_t dev_addr;			/* dev addr id */
+	int16_t dev_profile;			/* dev profile id */
+	int32_t data_type;			/* data type id */
+	int32_t data_size;			/* dde data size in block */
+	int32_t data_offset;			/* dde data offset in block */
+	int32_t data_crc;			/* dde data crc checkout */
+	int32_t reserve[5];			/* Reserved Bits */
+};
+
+struct aw_acf_dde_v_1_0_0_0 {
+	uint32_t type;				/* DDE type id */
+	char dev_name[AW_CUSTOMER_NAME_MAX];	/* customer dev name */
+	uint16_t dev_index;			/* dev id */
+	uint16_t dev_bus;			/* dev bus id */
+	uint16_t dev_addr;			/* dev addr id */
+	uint16_t dev_profile;			/* dev profile id*/
+	uint32_t data_type;			/* data type id */
+	uint32_t data_size;			/* dde data size in block */
+	uint32_t data_offset;			/* dde data offset in block */
+	uint32_t data_crc;			/* dde data crc checkout */
+	char dev_profile_str[AW_PROFILE_STR_MAX];	/* dde custom profile name */
+	uint32_t chip_id;			/* dde custom product chip id */
+	uint32_t reserve[4];
+};
+
+struct aw_data_with_header {
+	uint32_t check_sum;
+	uint32_t header_ver;
+	uint32_t bin_data_type;
+	uint32_t bin_data_ver;
+	uint32_t bin_data_size;
+	uint32_t ui_ver;
+	char product[8];
+	uint32_t addr_byte_len;
+	uint32_t data_byte_len;
+	uint32_t device_addr;
+	uint32_t reserve[4];
+};
+
+struct aw_data_container {
+	uint32_t len;
+	uint8_t *data;
+};
+
+struct aw_prof_desc {
+	uint32_t prof_st;
+	char *prof_name;
+	char dev_name[AW_CUSTOMER_NAME_MAX];
+	struct aw_data_container data_container;
+};
+
+struct aw_all_prof_info {
+	struct aw_prof_desc prof_desc[AW_PROFILE_MAX];
+};
+
+struct aw_prof_info {
+	int count;
+	int status;
+	int prof_type;
+	char (*prof_name_list)[AW_PROFILE_STR_MAX];
+	struct aw_prof_desc *prof_desc;
+};
+
+struct acf_bin_info {
+	int load_count;
+	int fw_size;
+	int16_t dev_index;
+	char *fw_data;
+	int product_cnt;
+	const char **product_tab;
+	struct aw_device *aw_dev;
+
+	struct aw_acf_hdr acf_hdr;
+	struct aw_prof_info prof_info;
+};
+
+char *aw87xxx_ctos_get_prof_name(int profile_id);
+void aw87xxx_acf_profile_free(struct device *dev,
+		struct acf_bin_info *acf_info);
+int aw87xxx_acf_parse(struct device *dev, struct acf_bin_info *acf_info);
+struct aw_prof_desc *aw87xxx_acf_get_prof_desc_form_name(struct device *dev,
+			struct acf_bin_info *acf_info, char *profile_name);
+int aw87xxx_acf_get_prof_index_form_name(struct device *dev,
+			struct acf_bin_info *acf_info, char *profile_name);
+char *aw87xxx_acf_get_prof_name_form_index(struct device *dev,
+			struct acf_bin_info *acf_info, int index);
+int aw87xxx_acf_get_profile_count(struct device *dev,
+			struct acf_bin_info *acf_info);
+char *aw87xxx_acf_get_prof_off_name(struct device *dev,
+			struct acf_bin_info *acf_info);
+void aw87xxx_acf_init(struct aw_device *aw_dev, struct acf_bin_info *acf_info, int index);
+
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.c b/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.c
new file mode 100644
index 000000000..c40055460
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.c
@@ -0,0 +1,515 @@
+/*
+* aw87xxx_bin_parse.c
+*
+* Copyright (c) 2020 AWINIC Technology CO., LTD
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/debugfs.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#include <linux/regmap.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/list.h>
+#include <linux/string.h>
+#include "aw87xxx_bin_parse.h"
+
+#define AWINIC_CODE_VERSION "V0.0.7-V1.0.4"	/* "code version"-"excel version" */
+
+#define DEBUG_LOG_LEVEL
+#ifdef DEBUG_LOG_LEVEL
+#define DBG(fmt, arg...)   do {\
+printk("AWINIC_BIN %s,line= %d,"fmt, __func__, __LINE__, ##arg);\
+} while (0)
+#define DBG_ERR(fmt, arg...)   do {\
+printk("AWINIC_BIN_ERR %s,line= %d,"fmt, __func__, __LINE__, ##arg);\
+} while (0)
+#else
+#define DBG(fmt, arg...) do {} while (0)
+#define DBG_ERR(fmt, arg...) do {} while (0)
+#endif
+
+#define printing_data_code
+
+typedef unsigned short int aw_uint16;
+typedef unsigned long int aw_uint32;
+
+#define BigLittleSwap16(A)	((((aw_uint16)(A) & 0xff00) >> 8) | \
+				 (((aw_uint16)(A) & 0x00ff) << 8))
+
+#define BigLittleSwap32(A)	((((aw_uint32)(A) & 0xff000000) >> 24) | \
+				(((aw_uint32)(A) & 0x00ff0000) >> 8) | \
+				(((aw_uint32)(A) & 0x0000ff00) << 8) | \
+				(((aw_uint32)(A) & 0x000000ff) << 24))
+
+
+static int aw_parse_bin_header_1_0_0(struct aw_bin *bin);
+
+/**
+*
+* Interface function
+*
+* return value:
+*       value = 0 :success;
+*       value = -1 :check bin header version
+*       value = -2 :check bin data type
+*       value = -3 :check sum or check bin data len error
+*       value = -4 :check data version
+*       value = -5 :check register num
+*       value = -6 :check dsp reg num
+*       value = -7 :check soc app num
+*       value = -8 :bin is NULL point
+*
+**/
+
+/********************************************************
+*
+* check sum data
+*
+********************************************************/
+static int aw_check_sum(struct aw_bin *bin, int bin_num)
+{
+	unsigned int i = 0;
+	unsigned int sum_data = 0;
+	unsigned int check_sum = 0;
+	unsigned char *p_check_sum = NULL;
+
+	DBG("enter\n");
+
+	p_check_sum =
+	    &(bin->info.data[(bin->header_info[bin_num].valid_data_addr -
+			      bin->header_info[bin_num].header_len)]);
+	DBG("aw_bin_parse p_check_sum = %p\n", p_check_sum);
+	check_sum = GET_32_DATA(*(p_check_sum + 3),
+				*(p_check_sum + 2),
+				*(p_check_sum + 1), *(p_check_sum));
+
+	for (i = 4;
+	     i <
+	     bin->header_info[bin_num].bin_data_len +
+	     bin->header_info[bin_num].header_len; i++) {
+		sum_data += *(p_check_sum + i);
+	}
+	DBG("aw_bin_parse bin_num=%d, check_sum = 0x%x, sum_data = 0x%x\n",
+		bin_num, check_sum, sum_data);
+	if (sum_data != check_sum) {
+		p_check_sum = NULL;
+		DBG_ERR("aw_bin_parse check sum or check bin data len error\n");
+		DBG_ERR("aw_bin_parse bin_num=%d, check_sum = 0x%x, sum_data = 0x%x\n", bin_num, check_sum, sum_data);
+		return -3;
+	}
+	p_check_sum = NULL;
+
+	return 0;
+}
+
+static int aw_check_data_version(struct aw_bin *bin, int bin_num)
+{
+	int i = 0;
+	DBG("enter\n");
+
+	for (i = DATA_VERSION_V1; i < DATA_VERSION_MAX; i++) {
+		if (bin->header_info[bin_num].bin_data_ver == i) {
+			return 0;
+		}
+	}
+	DBG_ERR("aw_bin_parse Unrecognized this bin data version\n");
+	return -4;
+}
+
+static int aw_check_register_num_v1(struct aw_bin *bin, int bin_num)
+{
+	unsigned int check_register_num = 0;
+	unsigned int parse_register_num = 0;
+	unsigned char *p_check_sum = NULL;
+
+	DBG("enter\n");
+
+	p_check_sum =
+	    &(bin->info.data[(bin->header_info[bin_num].valid_data_addr)]);
+	DBG("aw_bin_parse p_check_sum = %p\n", p_check_sum);
+	parse_register_num = GET_32_DATA(*(p_check_sum + 3),
+					 *(p_check_sum + 2),
+					 *(p_check_sum + 1), *(p_check_sum));
+	check_register_num = (bin->header_info[bin_num].bin_data_len - 4) /
+	    (bin->header_info[bin_num].reg_byte_len +
+	     bin->header_info[bin_num].data_byte_len);
+	DBG
+	    ("aw_bin_parse bin_num=%d, parse_register_num = 0x%x, check_register_num = 0x%x\n",
+	     bin_num, parse_register_num, check_register_num);
+	if (parse_register_num != check_register_num) {
+		p_check_sum = NULL;
+		DBG_ERR("aw_bin_parse register num is error\n");
+		DBG_ERR("aw_bin_parse bin_num=%d, parse_register_num = 0x%x, check_register_num = 0x%x\n", bin_num, parse_register_num, check_register_num);
+		return -5;
+	}
+	bin->header_info[bin_num].reg_num = parse_register_num;
+	bin->header_info[bin_num].valid_data_len =
+	    bin->header_info[bin_num].bin_data_len - 4;
+	p_check_sum = NULL;
+	bin->header_info[bin_num].valid_data_addr =
+	    bin->header_info[bin_num].valid_data_addr + 4;
+	return 0;
+}
+
+static int aw_check_dsp_reg_num_v1(struct aw_bin *bin, int bin_num)
+{
+	unsigned int check_dsp_reg_num = 0;
+	unsigned int parse_dsp_reg_num = 0;
+	unsigned char *p_check_sum = NULL;
+
+	DBG("enter\n");
+
+	p_check_sum =
+	    &(bin->info.data[(bin->header_info[bin_num].valid_data_addr)]);
+	DBG("aw_bin_parse p_check_sum = %p\n", p_check_sum);
+	parse_dsp_reg_num = GET_32_DATA(*(p_check_sum + 7),
+					*(p_check_sum + 6),
+					*(p_check_sum + 5), *(p_check_sum + 4));
+	bin->header_info[bin_num].reg_data_byte_len =
+	    GET_32_DATA(*(p_check_sum + 11), *(p_check_sum + 10),
+			*(p_check_sum + 9), *(p_check_sum + 8));
+	check_dsp_reg_num =
+	    (bin->header_info[bin_num].bin_data_len -
+	     12) / bin->header_info[bin_num].reg_data_byte_len;
+	DBG
+	    ("aw_bin_parse bin_num=%d, parse_dsp_reg_num = 0x%x, check_dsp_reg_num = 0x%x\n",
+	     bin_num, parse_dsp_reg_num, check_dsp_reg_num);
+	if (parse_dsp_reg_num != check_dsp_reg_num) {
+		p_check_sum = NULL;
+		DBG_ERR("aw_bin_parse dsp reg num is error\n");
+		DBG_ERR("aw_bin_parse bin_num=%d, parse_dsp_reg_num = 0x%x, check_dsp_reg_num = 0x%x\n", bin_num, parse_dsp_reg_num, check_dsp_reg_num);
+		return -6;
+	}
+	bin->header_info[bin_num].download_addr =
+	    GET_32_DATA(*(p_check_sum + 3), *(p_check_sum + 2),
+			*(p_check_sum + 1), *(p_check_sum));
+	bin->header_info[bin_num].reg_num = parse_dsp_reg_num;
+	bin->header_info[bin_num].valid_data_len =
+	    bin->header_info[bin_num].bin_data_len - 12;
+	p_check_sum = NULL;
+	bin->header_info[bin_num].valid_data_addr =
+	    bin->header_info[bin_num].valid_data_addr + 12;
+	return 0;
+}
+
+static int aw_check_soc_app_num_v1(struct aw_bin *bin, int bin_num)
+{
+	unsigned int check_soc_app_num = 0;
+	unsigned int parse_soc_app_num = 0;
+	unsigned char *p_check_sum = NULL;
+
+	DBG("enter\n");
+
+	p_check_sum =
+	    &(bin->info.data[(bin->header_info[bin_num].valid_data_addr)]);
+	DBG("aw_bin_parse p_check_sum = %p\n", p_check_sum);
+	bin->header_info[bin_num].app_version = GET_32_DATA(*(p_check_sum + 3),
+							    *(p_check_sum + 2),
+							    *(p_check_sum + 1),
+							    *(p_check_sum));
+	parse_soc_app_num = GET_32_DATA(*(p_check_sum + 11),
+					*(p_check_sum + 10),
+					*(p_check_sum + 9), *(p_check_sum + 8));
+	check_soc_app_num = bin->header_info[bin_num].bin_data_len - 12;
+	DBG
+	    ("aw_bin_parse bin_num=%d, parse_soc_app_num = 0x%x, check_soc_app_num = 0x%x\n",
+	     bin_num, parse_soc_app_num, check_soc_app_num);
+	if (parse_soc_app_num != check_soc_app_num) {
+		p_check_sum = NULL;
+		DBG_ERR("aw_bin_parse soc app num is error\n");
+		DBG_ERR("aw_bin_parse bin_num=%d, parse_soc_app_num = 0x%x, check_soc_app_num = 0x%x\n", bin_num, parse_soc_app_num, check_soc_app_num);
+		return -7;
+	}
+	bin->header_info[bin_num].reg_num = parse_soc_app_num;
+	bin->header_info[bin_num].download_addr =
+	    GET_32_DATA(*(p_check_sum + 7), *(p_check_sum + 6),
+			*(p_check_sum + 5), *(p_check_sum + 4));
+	bin->header_info[bin_num].valid_data_len =
+	    bin->header_info[bin_num].bin_data_len - 12;
+	p_check_sum = NULL;
+	bin->header_info[bin_num].valid_data_addr =
+	    bin->header_info[bin_num].valid_data_addr + 12;
+	return 0;
+}
+
+/************************
+***
+***bin header 1_0_0
+***
+************************/
+static void aw_get_single_bin_header_1_0_0(struct aw_bin *bin)
+{
+	int i;
+	DBG("enter %s\n", __func__);
+	bin->header_info[bin->all_bin_parse_num].header_len = 60;
+	bin->header_info[bin->all_bin_parse_num].check_sum =
+	    GET_32_DATA(*(bin->p_addr + 3), *(bin->p_addr + 2),
+			*(bin->p_addr + 1), *(bin->p_addr));
+	bin->header_info[bin->all_bin_parse_num].header_ver =
+	    GET_32_DATA(*(bin->p_addr + 7), *(bin->p_addr + 6),
+			*(bin->p_addr + 5), *(bin->p_addr + 4));
+	bin->header_info[bin->all_bin_parse_num].bin_data_type =
+	    GET_32_DATA(*(bin->p_addr + 11), *(bin->p_addr + 10),
+			*(bin->p_addr + 9), *(bin->p_addr + 8));
+	bin->header_info[bin->all_bin_parse_num].bin_data_ver =
+	    GET_32_DATA(*(bin->p_addr + 15), *(bin->p_addr + 14),
+			*(bin->p_addr + 13), *(bin->p_addr + 12));
+	bin->header_info[bin->all_bin_parse_num].bin_data_len =
+	    GET_32_DATA(*(bin->p_addr + 19), *(bin->p_addr + 18),
+			*(bin->p_addr + 17), *(bin->p_addr + 16));
+	bin->header_info[bin->all_bin_parse_num].ui_ver =
+	    GET_32_DATA(*(bin->p_addr + 23), *(bin->p_addr + 22),
+			*(bin->p_addr + 21), *(bin->p_addr + 20));
+	bin->header_info[bin->all_bin_parse_num].reg_byte_len =
+	    GET_32_DATA(*(bin->p_addr + 35), *(bin->p_addr + 34),
+			*(bin->p_addr + 33), *(bin->p_addr + 32));
+	bin->header_info[bin->all_bin_parse_num].data_byte_len =
+	    GET_32_DATA(*(bin->p_addr + 39), *(bin->p_addr + 38),
+			*(bin->p_addr + 37), *(bin->p_addr + 36));
+	bin->header_info[bin->all_bin_parse_num].device_addr =
+	    GET_32_DATA(*(bin->p_addr + 43), *(bin->p_addr + 42),
+			*(bin->p_addr + 41), *(bin->p_addr + 40));
+	for (i = 0; i < 8; i++) {
+		bin->header_info[bin->all_bin_parse_num].chip_type[i] =
+		    *(bin->p_addr + 24 + i);
+	}
+	bin->header_info[bin->all_bin_parse_num].reg_num = 0x00000000;
+	bin->header_info[bin->all_bin_parse_num].reg_data_byte_len = 0x00000000;
+	bin->header_info[bin->all_bin_parse_num].download_addr = 0x00000000;
+	bin->header_info[bin->all_bin_parse_num].app_version = 0x00000000;
+	bin->header_info[bin->all_bin_parse_num].valid_data_len = 0x00000000;
+	bin->all_bin_parse_num += 1;
+}
+
+static int aw_parse_each_of_multi_bins_1_0_0(unsigned int bin_num, int bin_serial_num,
+				      struct aw_bin *bin)
+{
+	int ret = 0;
+	unsigned int bin_start_addr = 0;
+	unsigned int valid_data_len = 0;
+	DBG("aw_bin_parse enter multi bin branch -- %s\n", __func__);
+	if (!bin_serial_num) {
+		bin_start_addr = GET_32_DATA(*(bin->p_addr + 67),
+					     *(bin->p_addr + 66),
+					     *(bin->p_addr + 65),
+					     *(bin->p_addr + 64));
+		bin->p_addr += (60 + bin_start_addr);
+		bin->header_info[bin->all_bin_parse_num].valid_data_addr =
+		    bin->header_info[bin->all_bin_parse_num -
+				     1].valid_data_addr + 4 + 8 * bin_num + 60;
+	} else {
+		valid_data_len =
+		    bin->header_info[bin->all_bin_parse_num - 1].bin_data_len;
+		bin->p_addr += (60 + valid_data_len);
+		bin->header_info[bin->all_bin_parse_num].valid_data_addr =
+		    bin->header_info[bin->all_bin_parse_num -
+				     1].valid_data_addr +
+		    bin->header_info[bin->all_bin_parse_num - 1].bin_data_len +
+		    60;
+	}
+
+	ret = aw_parse_bin_header_1_0_0(bin);
+	return ret;
+}
+
+/* Get the number of bins in multi bins, and set a for loop, loop processing each bin data */
+static int aw_get_multi_bin_header_1_0_0(struct aw_bin *bin)
+{
+	int i = 0;
+	int ret = 0;
+	unsigned int bin_num = 0;
+	DBG("aw_bin_parse enter multi bin branch -- %s\n", __func__);
+	bin_num = GET_32_DATA(*(bin->p_addr + 63),
+			      *(bin->p_addr + 62),
+			      *(bin->p_addr + 61), *(bin->p_addr + 60));
+	if (bin->multi_bin_parse_num == 1) {
+		bin->header_info[bin->all_bin_parse_num].valid_data_addr = 60;
+	}
+	aw_get_single_bin_header_1_0_0(bin);
+
+	for (i = 0; i < bin_num; i++) {
+		DBG("aw_bin_parse enter multi bin for is %d\n", i);
+		ret = aw_parse_each_of_multi_bins_1_0_0(bin_num, i, bin);
+		if (ret < 0) {
+			return ret;
+		}
+	}
+	return 0;
+}
+
+/********************************************************
+*
+* If the bin framework header version is 1.0.0,
+  determine the data type of bin, and then perform different processing
+  according to the data type
+  If it is a single bin data type, write the data directly into the structure array
+  If it is a multi-bin data type, first obtain the number of bins,
+  and then recursively call the bin frame header processing function
+  according to the bin number to process the frame header information of each bin separately
+*
+********************************************************/
+static int aw_parse_bin_header_1_0_0(struct aw_bin *bin)
+{
+	int ret = 0;
+	unsigned int bin_data_type;
+	DBG("enter %s\n", __func__);
+	bin_data_type = GET_32_DATA(*(bin->p_addr + 11),
+				    *(bin->p_addr + 10),
+				    *(bin->p_addr + 9), *(bin->p_addr + 8));
+	DBG("aw_bin_parse bin_data_type 0x%x\n", bin_data_type);
+	switch (bin_data_type) {
+	case DATA_TYPE_REGISTER:
+	case DATA_TYPE_DSP_REG:
+	case DATA_TYPE_SOC_APP:
+		/* Divided into two processing methods,
+		   one is single bin processing,
+		   and the other is single bin processing in multi bin */
+		DBG("aw_bin_parse enter single bin branch\n");
+		bin->single_bin_parse_num += 1;
+		DBG("%s bin->single_bin_parse_num is %d\n", __func__,
+			bin->single_bin_parse_num);
+		if (!bin->multi_bin_parse_num) {
+			bin->header_info[bin->
+					 all_bin_parse_num].valid_data_addr =
+			    60;
+		}
+		aw_get_single_bin_header_1_0_0(bin);
+		break;
+	case DATA_TYPE_MULTI_BINS:
+		/* Get the number of times to enter multi bins */
+		DBG("aw_bin_parse enter multi bin branch\n");
+		bin->multi_bin_parse_num += 1;
+		DBG("%s bin->multi_bin_parse_num is %d\n", __func__,
+			bin->multi_bin_parse_num);
+		ret = aw_get_multi_bin_header_1_0_0(bin);
+		if (ret < 0) {
+			return ret;
+		}
+		break;
+	default:
+		DBG_ERR("aw_bin_parse Unrecognized this bin data type\n");
+		return -2;
+	}
+	return 0;
+}
+
+/* get the bin's header version */
+static int aw_check_bin_header_version(struct aw_bin *bin)
+{
+	int ret = 0;
+	unsigned int header_version = 0;
+
+	header_version = GET_32_DATA(*(bin->p_addr + 7),
+				     *(bin->p_addr + 6),
+				     *(bin->p_addr + 5), *(bin->p_addr + 4));
+
+	DBG("aw_bin_parse header_version 0x%x\n", header_version);
+
+	/* Write data to the corresponding structure array
+	   according to different formats of the bin frame header version */
+	switch (header_version) {
+	case HEADER_VERSION_1_0_0:
+		ret = aw_parse_bin_header_1_0_0(bin);
+		return ret;
+	default:
+		DBG_ERR("aw_bin_parse Unrecognized this bin header version \n");
+		return -1;
+	}
+}
+
+int aw87xxx_parsing_bin_file(struct aw_bin *bin)
+{
+	int i = 0;
+	int ret = 0;
+
+	DBG("aw_bin_parse code version:%s\n", AWINIC_CODE_VERSION);
+	if (!bin) {
+		DBG_ERR("aw_bin_parse bin is NULL\n");
+		return -8;
+	}
+	bin->p_addr = bin->info.data;
+	bin->all_bin_parse_num = 0;
+	bin->multi_bin_parse_num = 0;
+	bin->single_bin_parse_num = 0;
+
+	/* filling bins header info */
+	ret = aw_check_bin_header_version(bin);
+	if (ret < 0) {
+		DBG_ERR("aw_bin_parse check bin header version error\n");
+		return ret;
+	}
+	bin->p_addr = NULL;
+
+	/* check bin header info */
+	for (i = 0; i < bin->all_bin_parse_num; i++) {
+		/* check sum */
+		ret = aw_check_sum(bin, i);
+		if (ret < 0) {
+			DBG_ERR("aw_bin_parse check sum data error\n");
+			return ret;
+		}
+		/* check bin data version */
+		ret = aw_check_data_version(bin, i);
+		if (ret < 0) {
+			DBG_ERR("aw_bin_parse check data version error\n");
+			return ret;
+		}
+		/* check valid data */
+		if (bin->header_info[i].bin_data_ver == DATA_VERSION_V1) {
+			/* check register num */
+			if (bin->header_info[i].bin_data_type ==
+			    DATA_TYPE_REGISTER) {
+				ret = aw_check_register_num_v1(bin, i);
+				if (ret < 0) {
+					DBG_ERR
+					    ("aw_bin_parse check register num error\n");
+					return ret;
+				}
+				/* check dsp reg num */
+			} else if (bin->header_info[i].bin_data_type ==
+				   DATA_TYPE_DSP_REG) {
+				ret = aw_check_dsp_reg_num_v1(bin, i);
+				if (ret < 0) {
+					DBG_ERR
+					    ("aw_bin_parse check dsp reg num error\n");
+					return ret;
+				}
+				/* check soc app num */
+			} else if (bin->header_info[i].bin_data_type ==
+				   DATA_TYPE_SOC_APP) {
+				ret = aw_check_soc_app_num_v1(bin, i);
+				if (ret < 0) {
+					DBG_ERR
+					    ("aw_bin_parse check soc app num error\n");
+					return ret;
+				}
+			} else {
+				bin->header_info[i].valid_data_len =
+				    bin->header_info[i].bin_data_len;
+			}
+		}
+	}
+	DBG("aw_bin_parse parsing success\n");
+
+	return 0;
+}
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.h b/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.h
new file mode 100644
index 000000000..a99c2409e
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.h
@@ -0,0 +1,73 @@
+#ifndef __AW87XXX_BIN_PARSE_H__
+#define __AW87XXX_BIN_PARSE_H__
+
+#define NULL    ((void *)0)
+#define GET_32_DATA(w, x, y, z) ((unsigned int)(((w) << 24) | ((x) << 16) | ((y) << 8) | (z)))
+#define BIN_NUM_MAX   100
+#define HEADER_LEN    60
+/*********************************************************
+ *
+ * header information
+ *
+ ********************************************************/
+enum bin_header_version_enum {
+	HEADER_VERSION_1_0_0 = 0x01000000,
+};
+
+enum data_type_enum {
+	DATA_TYPE_REGISTER = 0x00000000,
+	DATA_TYPE_DSP_REG = 0x00000010,
+	DATA_TYPE_DSP_CFG = 0x00000011,
+	DATA_TYPE_SOC_REG = 0x00000020,
+	DATA_TYPE_SOC_APP = 0x00000021,
+	DATA_TYPE_MULTI_BINS = 0x00002000,
+	DATA_TYPE_MONITOR_ANALOG = 0x00020000,
+};
+
+enum data_version_enum {
+	DATA_VERSION_V1 = 0X00000001,	/*default little edian */
+	DATA_VERSION_MAX,
+};
+
+struct bin_header_info {
+	unsigned int header_len; /* Frame header length */
+	unsigned int check_sum; /* Frame header information-Checksum */
+	unsigned int header_ver; /* Frame header information-Frame header version */
+	unsigned int bin_data_type; /* Frame header information-Data type */
+	unsigned int bin_data_ver; /* Frame header information-Data version */
+	unsigned int bin_data_len; /* Frame header information-Data length */
+	unsigned int ui_ver; /* Frame header information-ui version */
+	unsigned char chip_type[8]; /* Frame header information-chip type */
+	unsigned int reg_byte_len; /* Frame header information-reg byte len */
+	unsigned int data_byte_len; /* Frame header information-data byte len */
+	unsigned int device_addr; /* Frame header information-device addr */
+	unsigned int valid_data_len; /* Length of valid data obtained after parsing */
+	unsigned int valid_data_addr; /* The offset address of the valid data obtained after parsing relative to info */
+
+	unsigned int reg_num; /* The number of registers obtained after parsing */
+	unsigned int reg_data_byte_len; /* The byte length of the register obtained after parsing */
+	unsigned int download_addr; /* The starting address or download address obtained after parsing */
+	unsigned int app_version; /* The software version number obtained after parsing */
+};
+
+/************************************************************
+*
+* function define
+*
+************************************************************/
+struct bin_container {
+	unsigned int len; /* The size of the bin file obtained from the firmware */
+	unsigned char data[]; /* Store the bin file obtained from the firmware */
+};
+
+struct aw_bin {
+	unsigned char *p_addr; /* Offset pointer (backward offset pointer to obtain frame header information and important information) */
+	unsigned int all_bin_parse_num; /* The number of all bin files */
+	unsigned int multi_bin_parse_num; /* The number of single bin files */
+	unsigned int single_bin_parse_num; /* The number of multiple bin files */
+	struct bin_header_info header_info[BIN_NUM_MAX]; /* Frame header information and other important data obtained after parsing */
+	struct bin_container info; /* Obtained bin file data that needs to be parsed */
+};
+
+extern int aw87xxx_parsing_bin_file(struct aw_bin *bin);
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_device.c b/sound/soc/codecs/aw87xxx/aw87xxx_device.c
new file mode 100644
index 000000000..a4c9ad7d9
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_device.c
@@ -0,0 +1,977 @@
+/*
+ * aw87xxx_device.c  aw87xxx pa module
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: Barry <zhaozhongbo@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include "aw87xxx.h"
+#include "aw87xxx_device.h"
+#include "aw87xxx_log.h"
+#include "aw87xxx_pid_9b_reg.h"
+#include "aw87xxx_pid_18_reg.h"
+#include "aw87xxx_pid_39_reg.h"
+#include "aw87xxx_pid_59_3x9_reg.h"
+#include "aw87xxx_pid_59_5x9_reg.h"
+#include "aw87xxx_pid_5a_reg.h"
+#include "aw87xxx_pid_76_reg.h"
+#include "aw87xxx_pid_60_reg.h"
+
+/*************************************************************************
+ * aw87xxx variable
+ ************************************************************************/
+const char *g_aw_pid_9b_product[] = {
+	"aw87319",
+};
+const char *g_aw_pid_18_product[] = {
+	"aw87418",
+};
+
+const char *g_aw_pid_39_product[] = {
+	"aw87329",
+	"aw87339",
+	"aw87349",
+};
+
+const char *g_aw_pid_59_3x9_product[] = {
+	"aw87359",
+	"aw87389",
+};
+
+const char *g_aw_pid_59_5x9_product[] = {
+	"aw87509",
+	"aw87519",
+	"aw87529",
+	"aw87539",
+};
+
+const char *g_aw_pid_5a_product[] = {
+	"aw87549",
+	"aw87559",
+	"aw87569",
+	"aw87579",
+	"aw81509",
+};
+
+const char *g_aw_pid_76_product[] = {
+	"aw87390",
+	"aw87320",
+	"aw87401",
+	"aw87360",
+};
+
+const char *g_aw_pid_60_product[] = {
+	"aw87560",
+	"aw87561",
+	"aw87562",
+	"aw87501",
+	"aw87550",
+};
+
+static int aw87xxx_dev_get_chipid(struct aw_device *aw_dev);
+
+/***************************************************************************
+ *
+ * reading and writing of I2C bus
+ *
+ ***************************************************************************/
+int aw87xxx_dev_i2c_write_byte(struct aw_device *aw_dev,
+			uint8_t reg_addr, uint8_t reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_write_byte_data(aw_dev->i2c, reg_addr, reg_data);
+		if (ret < 0)
+			AW_DEV_LOGE(aw_dev->dev, "i2c_write cnt=%d error=%d i2c_bus=%u i2c_addr=%X chipid=%X",
+				cnt, ret, aw_dev->i2c_bus, aw_dev->i2c_addr, aw_dev->chipid);
+		else
+			break;
+
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+int aw87xxx_dev_i2c_read_byte(struct aw_device *aw_dev,
+			uint8_t reg_addr, uint8_t *reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_read_byte_data(aw_dev->i2c, reg_addr);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw_dev->dev, "i2c_read cnt=%d error=%d i2c_bus=%u i2c_addr=%X chipid=%X",
+				cnt, ret, aw_dev->i2c_bus, aw_dev->i2c_addr, aw_dev->chipid);
+		} else {
+			*reg_data = ret;
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+int aw87xxx_dev_i2c_read_msg(struct aw_device *aw_dev,
+	uint8_t reg_addr, uint8_t *data_buf, uint32_t data_len)
+{
+	int ret = -1;
+
+	struct i2c_msg msg[] = {
+	[0] = {
+		.addr = aw_dev->i2c_addr,
+		.flags = 0,
+		.len = sizeof(uint8_t),
+		.buf = &reg_addr,
+		},
+	[1] = {
+		.addr = aw_dev->i2c_addr,
+		.flags = I2C_M_RD,
+		.len = data_len,
+		.buf = data_buf,
+		},
+	};
+
+	ret = i2c_transfer(aw_dev->i2c->adapter, msg, ARRAY_SIZE(msg));
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "transfer failed");
+		return ret;
+	} else if (ret != AW_I2C_READ_MSG_NUM) {
+		AW_DEV_LOGE(aw_dev->dev, "transfer failed(size error)");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+int aw87xxx_dev_i2c_write_bits(struct aw_device *aw_dev,
+	uint8_t reg_addr, uint8_t mask, uint8_t reg_data)
+{
+	int ret = -1;
+	unsigned char reg_val = 0;
+
+	ret = aw87xxx_dev_i2c_read_byte(aw_dev, reg_addr, &reg_val);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "i2c read error, ret=%d", ret);
+		return ret;
+	}
+	reg_val &= mask;
+	reg_val |= (reg_data & (~mask));
+	ret = aw87xxx_dev_i2c_write_byte(aw_dev, reg_addr, reg_val);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "i2c write error, ret=%d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/************************************************************************
+ *
+ * aw87xxx device update profile data to registers
+ *
+ ************************************************************************/
+static int aw87xxx_dev_reg_update(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data)
+{
+	int i = 0;
+	int ret = -1;
+
+	if (profile_data == NULL)
+		return -EINVAL;
+
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGE(aw_dev->dev, "dev is pwr_off,can not update reg");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < profile_data->len; i = i + 2) {
+		AW_DEV_LOGI(aw_dev->dev, "reg=0x%02x, val = 0x%02x",
+			profile_data->data[i], profile_data->data[i + 1]);
+
+		ret = aw87xxx_dev_i2c_write_byte(aw_dev, profile_data->data[i],
+				profile_data->data[i + 1]);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void aw87xxx_dev_reg_mute_bits_set(struct aw_device *aw_dev,
+				uint8_t *reg_val, bool enable)
+{
+	if (enable) {
+		*reg_val &= aw_dev->mute_desc.mask;
+		*reg_val |= aw_dev->mute_desc.enable;
+	} else {
+		*reg_val &= aw_dev->mute_desc.mask;
+		*reg_val |= aw_dev->mute_desc.disable;
+	}
+}
+
+static int aw87xxx_dev_reg_update_mute(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data)
+{
+	int i = 0;
+	int ret = -1;
+	uint8_t reg_val = 0;
+
+	if (profile_data == NULL)
+		return -EINVAL;
+
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGE(aw_dev->dev, "hwen is off,can not update reg");
+		return -EINVAL;
+	}
+
+	if (aw_dev->mute_desc.mask == AW_DEV_REG_INVALID_MASK) {
+		AW_DEV_LOGE(aw_dev->dev, "mute ctrl mask invalid");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < profile_data->len; i = i + 2) {
+		AW_DEV_LOGI(aw_dev->dev, "reg=0x%02x, val = 0x%02x",
+			profile_data->data[i], profile_data->data[i + 1]);
+
+		reg_val = profile_data->data[i + 1];
+		if (profile_data->data[i] == aw_dev->mute_desc.addr) {
+			aw87xxx_dev_reg_mute_bits_set(aw_dev, &reg_val, true);
+			AW_DEV_LOGD(aw_dev->dev, "change mute_mask, val = 0x%02x",
+				reg_val);
+		}
+
+		ret = aw87xxx_dev_i2c_write_byte(aw_dev, profile_data->data[i], reg_val);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+/************************************************************************
+ *
+ * aw87xxx device hadware and soft contols
+ *
+ ************************************************************************/
+static bool aw87xxx_dev_gpio_is_valid(struct aw_device *aw_dev)
+{
+	if (gpio_is_valid(aw_dev->rst_gpio))
+		return true;
+	else
+		return false;
+}
+
+void aw87xxx_dev_hw_pwr_ctrl(struct aw_device *aw_dev, bool enable)
+{
+	if (aw_dev->hwen_status == AW_DEV_HWEN_INVALID) {
+		AW_DEV_LOGD(aw_dev->dev, "product not have reset-pin,hardware pwd control invalid");
+		return;
+	}
+	if (enable) {
+		if (aw87xxx_dev_gpio_is_valid(aw_dev)) {
+			gpio_set_value_cansleep(aw_dev->rst_gpio, AW_GPIO_LOW_LEVEL);
+			mdelay(2);
+			gpio_set_value_cansleep(aw_dev->rst_gpio, AW_GPIO_HIGHT_LEVEL);
+			mdelay(2);
+			aw_dev->hwen_status = AW_DEV_HWEN_ON;
+			AW_DEV_LOGI(aw_dev->dev, "hw power on");
+		} else {
+			AW_DEV_LOGI(aw_dev->dev, "hw already power on");
+		}
+	} else {
+		if (aw87xxx_dev_gpio_is_valid(aw_dev)) {
+			gpio_set_value_cansleep(aw_dev->rst_gpio, AW_GPIO_LOW_LEVEL);
+			mdelay(2);
+			aw_dev->hwen_status = AW_DEV_HWEN_OFF;
+			AW_DEV_LOGI(aw_dev->dev, "hw power off");
+		} else {
+			AW_DEV_LOGI(aw_dev->dev, "hw already power off");
+		}
+	}
+}
+
+static int aw87xxx_dev_mute_ctrl(struct aw_device *aw_dev, bool enable)
+{
+	int ret = 0;
+
+	if (enable) {
+		ret = aw87xxx_dev_i2c_write_bits(aw_dev, aw_dev->mute_desc.addr,
+				aw_dev->mute_desc.mask, aw_dev->mute_desc.enable);
+		if (ret < 0)
+			return ret;
+		AW_DEV_LOGI(aw_dev->dev, "set mute down");
+	} else {
+		ret = aw87xxx_dev_i2c_write_bits(aw_dev, aw_dev->mute_desc.addr,
+				aw_dev->mute_desc.mask, aw_dev->mute_desc.disable);
+		if (ret < 0)
+			return ret;
+		AW_DEV_LOGI(aw_dev->dev, "close mute down");
+	}
+
+	return 0;
+}
+
+void aw87xxx_dev_soft_reset(struct aw_device *aw_dev)
+{
+	int i = 0;
+	int ret = -1;
+	struct aw_soft_rst_desc *soft_rst = &aw_dev->soft_rst_desc;
+
+	AW_DEV_LOGD(aw_dev->dev, "enter");
+
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGE(aw_dev->dev, "hw is off,can not softrst");
+		return;
+	}
+
+	if (aw_dev->soft_rst_enable == AW_DEV_SOFT_RST_DISENABLE) {
+		AW_DEV_LOGD(aw_dev->dev, "softrst is disenable");
+		return;
+	}
+
+	if (soft_rst->access == NULL || soft_rst->len == 0) {
+		AW_DEV_LOGE(aw_dev->dev, "softrst_info not init");
+		return;
+	}
+
+	if (soft_rst->len % 2) {
+		AW_DEV_LOGE(aw_dev->dev, "softrst data_len[%d] is odd number,data not available",
+			aw_dev->soft_rst_desc.len);
+		return;
+	}
+
+	for (i = 0; i < soft_rst->len; i += 2) {
+		AW_DEV_LOGD(aw_dev->dev, "softrst_reg=0x%02x, val = 0x%02x",
+			soft_rst->access[i], soft_rst->access[i + 1]);
+
+		ret = aw87xxx_dev_i2c_write_byte(aw_dev, soft_rst->access[i],
+				soft_rst->access[i + 1]);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw_dev->dev, "write failed,ret = %d,cnt=%d",
+				ret, i);
+			return;
+		}
+	}
+	AW_DEV_LOGD(aw_dev->dev, "down");
+}
+
+
+int aw87xxx_dev_default_pwr_off(struct aw_device *aw_dev,
+		struct aw_data_container *profile_data)
+{
+	int ret = 0;
+
+	AW_DEV_LOGD(aw_dev->dev, "enter");
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGE(aw_dev->dev, "hwen is already off");
+		return 0;
+	}
+
+	if (aw_dev->soft_off_enable && profile_data) {
+		ret = aw87xxx_dev_reg_update(aw_dev, profile_data);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw_dev->dev, "update profile[Off] fw config failed");
+			goto reg_off_update_failed;
+		}
+	}
+
+	aw87xxx_dev_hw_pwr_ctrl(aw_dev, false);
+	AW_DEV_LOGD(aw_dev->dev, "down");
+	return 0;
+
+reg_off_update_failed:
+	aw87xxx_dev_hw_pwr_ctrl(aw_dev, false);
+	return ret;
+}
+
+
+/************************************************************************
+ *
+ * aw87xxx device power on process function
+ *
+ ************************************************************************/
+
+int aw87xxx_dev_default_pwr_on(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data)
+{
+	int ret = 0;
+
+	/*hw power on*/
+	aw87xxx_dev_hw_pwr_ctrl(aw_dev, true);
+
+	ret = aw87xxx_dev_reg_update(aw_dev, profile_data);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/****************************************************************************
+ *
+ * aw87xxx chip esd status check
+ *
+ ****************************************************************************/
+int aw87xxx_dev_esd_reg_status_check(struct aw_device *aw_dev)
+{
+	int ret;
+	unsigned char reg_val = 0;
+	struct aw_esd_check_desc *esd_desc = &aw_dev->esd_desc;
+
+	AW_DEV_LOGD(aw_dev->dev, "enter");
+
+	if (!esd_desc->first_update_reg_addr) {
+		AW_DEV_LOGE(aw_dev->dev, "esd check info if not init,please check");
+		return -EINVAL;
+	}
+
+	ret = aw87xxx_dev_i2c_read_byte(aw_dev, esd_desc->first_update_reg_addr,
+			&reg_val);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "read reg 0x%02x failed",
+			esd_desc->first_update_reg_addr);
+		return ret;
+	}
+
+	AW_DEV_LOGD(aw_dev->dev, "0x%02x:default val=0x%02x real val=0x%02x",
+		esd_desc->first_update_reg_addr,
+		esd_desc->first_update_reg_val, reg_val);
+
+	if (reg_val == esd_desc->first_update_reg_val) {
+		AW_DEV_LOGE(aw_dev->dev, "reg status check failed");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int aw87xxx_dev_check_reg_is_rec_mode(struct aw_device *aw_dev)
+{
+	int ret;
+	unsigned char reg_val = 0;
+	struct aw_rec_mode_desc *rec_desc = &aw_dev->rec_desc;
+
+	if (!rec_desc->addr) {
+		AW_DEV_LOGE(aw_dev->dev, "rec check info if not init,please check");
+		return -EINVAL;
+	}
+
+	ret = aw87xxx_dev_i2c_read_byte(aw_dev, rec_desc->addr, &reg_val);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "read reg 0x%02x failed",
+			rec_desc->addr);
+		return ret;
+	}
+
+	if (rec_desc->enable) {
+		if (reg_val & ~(rec_desc->mask)) {
+			AW_DEV_LOGI(aw_dev->dev, "reg status is receiver mode");
+			aw_dev->is_rec_mode = AW_IS_REC_MODE;
+		} else {
+			aw_dev->is_rec_mode = AW_NOT_REC_MODE;
+		}
+	} else {
+		if (!(reg_val & ~(rec_desc->mask))) {
+			AW_DEV_LOGI(aw_dev->dev, "reg status is receiver mode");
+			aw_dev->is_rec_mode = AW_IS_REC_MODE;
+		} else {
+			aw_dev->is_rec_mode = AW_NOT_REC_MODE;
+		}
+	}
+	return 0;
+}
+
+
+/****************************************************************************
+ *
+ * aw87xxx product attributes init info
+ *
+ ****************************************************************************/
+
+/********************** aw87xxx_pid_9A attributes ***************************/
+
+static int aw_dev_pid_9b_reg_update(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data)
+{
+	int i = 0;
+	int ret = -1;
+	uint8_t reg_val = 0;
+
+	if (profile_data == NULL)
+		return -EINVAL;
+
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGE(aw_dev->dev, "dev is pwr_off,can not update reg");
+		return -EINVAL;
+	}
+
+	if (profile_data->len != AW_PID_9B_BIN_REG_CFG_COUNT) {
+		AW_DEV_LOGE(aw_dev->dev, "reg_config count of bin is error,can not update reg");
+		return -EINVAL;
+	}
+	ret = aw87xxx_dev_i2c_write_byte(aw_dev, AW87XXX_PID_9B_ENCRYPTION_REG,
+		AW87XXX_PID_9B_ENCRYPTION_BOOST_OUTPUT_SET);
+	if (ret < 0)
+		return ret;
+
+	for (i = 1; i < AW_PID_9B_BIN_REG_CFG_COUNT; i++) {
+		AW_DEV_LOGI(aw_dev->dev, "reg=0x%02x, val = 0x%02x",
+			i, profile_data->data[i]);
+		reg_val = profile_data->data[i];
+		if (i == AW87XXX_PID_9B_SYSCTRL_REG) {
+			aw87xxx_dev_reg_mute_bits_set(aw_dev, &reg_val, true);
+			AW_DEV_LOGD(aw_dev->dev, "change mute_mask, val = 0x%02x",
+				reg_val);
+		}
+
+		ret = aw87xxx_dev_i2c_write_byte(aw_dev, i, reg_val);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int aw_dev_pid_9b_pwr_on(struct aw_device *aw_dev, struct aw_data_container *data)
+{
+	int ret = 0;
+
+	/*hw power on*/
+	aw87xxx_dev_hw_pwr_ctrl(aw_dev, true);
+
+	/* open the mute */
+	ret = aw87xxx_dev_mute_ctrl(aw_dev, true);
+	if (ret < 0)
+		return ret;
+
+	/* Update scene parameters in mute mode */
+	ret = aw_dev_pid_9b_reg_update(aw_dev, data);
+	if (ret < 0)
+		return ret;
+
+	/* close the mute */
+	ret = aw87xxx_dev_mute_ctrl(aw_dev, false);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void aw_dev_pid_9b_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_9B_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_9b_reg_access;
+
+	aw_dev->mute_desc.addr = AW87XXX_PID_9B_SYSCTRL_REG;
+	aw_dev->mute_desc.mask = AW87XXX_PID_9B_REG_EN_SW_MASK;
+	aw_dev->mute_desc.enable = AW87XXX_PID_9B_REG_EN_SW_DISABLE_VALUE;
+	aw_dev->mute_desc.disable = AW87XXX_PID_9B_REG_EN_SW_ENABLE_VALUE;
+	aw_dev->ops.pwr_on_func = aw_dev_pid_9b_pwr_on;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_9b_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_9b_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_DISENABLE;
+
+	aw_dev->product_tab = g_aw_pid_9b_product;
+	aw_dev->product_cnt = AW87XXX_PID_9B_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_9B_SYSCTRL_REG;
+	aw_dev->rec_desc.disable = AW87XXX_PID_9B_SPK_MODE_ENABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_9B_SPK_MODE_DISABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_9B_SPK_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_9B_SYSCTRL_REG;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_9B_SYSCTRL_DEFAULT;
+}
+
+static int aw_dev_pid_9a_init(struct aw_device *aw_dev)
+{
+	int ret = 0;
+
+	ret = aw87xxx_dev_i2c_write_byte(aw_dev, AW87XXX_PID_9B_ENCRYPTION_REG,
+		AW87XXX_PID_9B_ENCRYPTION_BOOST_OUTPUT_SET);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "write 0x64=0x2C error");
+		return -EINVAL;
+	}
+
+	ret = aw87xxx_dev_get_chipid(aw_dev);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "read chipid is failed,ret=%d", ret);
+		return ret;
+	}
+
+	if (aw_dev->chipid == AW_DEV_CHIPID_9B) {
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_9B class");
+		aw_dev_pid_9b_init(aw_dev);
+	} else {
+		AW_DEV_LOGE(aw_dev->dev, "product is not pid_9B classnot support");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/********************** aw87xxx_pid_9b attributes end ***********************/
+
+/********************** aw87xxx_pid_18 attributes ***************************/
+static int aw_dev_pid_18_pwr_on(struct aw_device *aw_dev, struct aw_data_container *data)
+{
+	int ret = 0;
+
+	/*hw power on*/
+	aw87xxx_dev_hw_pwr_ctrl(aw_dev, true);
+
+	/* open the mute */
+	ret = aw87xxx_dev_mute_ctrl(aw_dev, true);
+	if (ret < 0)
+		return ret;
+
+	/* Update scene parameters in mute mode */
+	ret = aw87xxx_dev_reg_update_mute(aw_dev, data);
+	if (ret < 0)
+		return ret;
+
+	/* close the mute */
+	ret = aw87xxx_dev_mute_ctrl(aw_dev, false);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void aw_dev_chipid_18_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_18_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_18_reg_access;
+
+	aw_dev->mute_desc.addr = AW87XXX_PID_18_SYSCTRL_REG;
+	aw_dev->mute_desc.mask = AW87XXX_PID_18_REG_EN_SW_MASK;
+	aw_dev->mute_desc.enable = AW87XXX_PID_18_REG_EN_SW_DISABLE_VALUE;
+	aw_dev->mute_desc.disable = AW87XXX_PID_18_REG_EN_SW_ENABLE_VALUE;
+	aw_dev->ops.pwr_on_func = aw_dev_pid_18_pwr_on;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_18_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_18_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_18_product;
+	aw_dev->product_cnt = AW87XXX_PID_18_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_18_SYSCTRL_REG;
+	aw_dev->rec_desc.disable = AW87XXX_PID_18_REG_REC_MODE_DISABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_18_REG_REC_MODE_ENABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_18_REG_REC_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_18_CLASSD_REG;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_18_CLASSD_DEFAULT;
+}
+/********************** aw87xxx_pid_18 attributes end ***********************/
+
+/********************** aw87xxx_pid_39 attributes ***************************/
+static void aw_dev_chipid_39_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_39_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_39_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_39_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_39_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_39_product;
+	aw_dev->product_cnt = AW87XXX_PID_39_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_39_REG_MODECTRL;
+	aw_dev->rec_desc.disable = AW87XXX_PID_39_REC_MODE_DISABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_39_REC_MODE_ENABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_39_REC_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_39_REG_MODECTRL;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_39_MODECTRL_DEFAULT;
+}
+/********************* aw87xxx_pid_39 attributes end *************************/
+
+
+/********************* aw87xxx_pid_59_5x9 attributes *************************/
+static void aw_dev_chipid_59_5x9_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_59_5X9_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_59_5x9_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_59_5x9_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_59_5x9_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_59_5x9_product;
+	aw_dev->product_cnt = AW87XXX_PID_59_5X9_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_59_5X9_REG_SYSCTRL;
+	aw_dev->rec_desc.disable = AW87XXX_PID_59_5X9_REC_MODE_DISABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_59_5X9_REC_MODE_ENABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_59_5X9_REC_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_59_5X9_REG_ENCR;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_59_5X9_ENCRY_DEFAULT;
+}
+/******************* aw87xxx_pid_59_5x9 attributes end ***********************/
+
+/********************* aw87xxx_pid_59_3x9 attributes *************************/
+static void aw_dev_chipid_59_3x9_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_59_3X9_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_59_3x9_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_59_3x9_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_59_3x9_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_59_3x9_product;
+	aw_dev->product_cnt = AW87XXX_PID_59_3X9_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_59_3X9_REG_MDCRTL;
+	aw_dev->rec_desc.disable = AW87XXX_PID_59_3X9_SPK_MODE_ENABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_59_3X9_SPK_MODE_DISABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_59_3X9_SPK_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_59_3X9_REG_ENCR;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_59_3X9_ENCR_DEFAULT;
+}
+/******************* aw87xxx_pid_59_3x9 attributes end ***********************/
+
+/********************** aw87xxx_pid_5a attributes ****************************/
+static void aw_dev_chipid_5a_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_5A_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_5a_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_5a_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_5a_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_5a_product;
+	aw_dev->product_cnt = AW87XXX_PID_5A_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_5A_REG_SYSCTRL_REG;
+	aw_dev->rec_desc.disable = AW87XXX_PID_5A_REG_RCV_MODE_DISABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_5A_REG_RCV_MODE_ENABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_5A_REG_RCV_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_5A_REG_DFT3R_REG;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_5A_DFT3R_DEFAULT;
+}
+/********************** aw87xxx_pid_5a attributes end ************************/
+
+/********************** aw87xxx_pid_76 attributes ****************************/
+static void aw_dev_chipid_76_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_76_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_76_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_76_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_76_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* software power off control info */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_76_product;
+	aw_dev->product_cnt = AW87XXX_PID_76_PROFUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_76_MDCTRL_REG;
+	aw_dev->rec_desc.disable = AW87XXX_PID_76_EN_SPK_ENABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_76_EN_SPK_DISABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_76_EN_SPK_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_76_DFT_ADP1_REG;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_76_DFT_ADP1_CHECK;
+}
+/********************** aw87xxx_pid_76 attributes end ************************/
+
+/********************** aw87xxx_pid_60 attributes ****************************/
+static void aw_dev_chipid_60_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_60_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_60_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_60_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_60_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* software power off control info */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_60_product;
+	aw_dev->product_cnt = AW87XXX_PID_60_PROFUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_60_SYSCTRL_REG;
+	aw_dev->rec_desc.disable = AW87XXX_PID_60_RCV_MODE_DISABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_60_RCV_MODE_ENABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_60_RCV_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_60_NG3_REG;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_60_ESD_REG_VAL;
+}
+/********************** aw87xxx_pid_60 attributes end ************************/
+
+static int aw_dev_chip_init(struct aw_device *aw_dev)
+{
+	int ret  = 0;
+
+	/*get info by chipid*/
+	switch (aw_dev->chipid) {
+	case AW_DEV_CHIPID_9A:
+		ret = aw_dev_pid_9a_init(aw_dev);
+		if (ret < 0)
+			AW_DEV_LOGE(aw_dev->dev, "product is pid_9B init failed");
+		break;
+	case AW_DEV_CHIPID_9B:
+		aw_dev_pid_9b_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_9B class");
+		break;
+	case AW_DEV_CHIPID_18:
+		aw_dev_chipid_18_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_18 class");
+		break;
+	case AW_DEV_CHIPID_39:
+		aw_dev_chipid_39_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_39 class");
+		break;
+	case AW_DEV_CHIPID_59:
+		if (aw87xxx_dev_gpio_is_valid(aw_dev)) {
+			aw_dev_chipid_59_5x9_init(aw_dev);
+			AW_DEV_LOGI(aw_dev->dev, "product is pid_59_5x9 class");
+		} else {
+			aw_dev_chipid_59_3x9_init(aw_dev);
+			AW_DEV_LOGI(aw_dev->dev, "product is pid_59_3x9 class");
+		}
+		break;
+	case AW_DEV_CHIPID_5A:
+		aw_dev_chipid_5a_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_5A class");
+		break;
+	case AW_DEV_CHIPID_76:
+		aw_dev_chipid_76_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_76 class");
+		break;
+	case AW_DEV_CHIPID_60:
+		aw_dev_chipid_60_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_60 class");
+		break;
+	default:
+		AW_DEV_LOGE(aw_dev->dev, "unsupported device revision [0x%x]",
+			aw_dev->chipid);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw87xxx_dev_get_chipid(struct aw_device *aw_dev)
+{
+	int ret = -1;
+	unsigned int cnt = 0;
+	unsigned char reg_val = 0;
+
+	for (cnt = 0; cnt < AW_READ_CHIPID_RETRIES; cnt++) {
+		ret = aw87xxx_dev_i2c_read_byte(aw_dev, AW_DEV_REG_CHIPID, &reg_val);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw_dev->dev, "[%d] read chip is failed, ret=%d",
+				cnt, ret);
+			continue;
+		}
+		break;
+	}
+
+
+	if (cnt == AW_READ_CHIPID_RETRIES) {
+		AW_DEV_LOGE(aw_dev->dev, "read chip is failed,cnt=%d", cnt);
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGI(aw_dev->dev, "read chipid[0x%x] succeed", reg_val);
+	aw_dev->chipid = reg_val;
+
+	return 0;
+}
+
+int aw87xxx_dev_init(struct aw_device *aw_dev)
+{
+	int ret = -1;
+
+	ret = aw87xxx_dev_get_chipid(aw_dev);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "read chipid is failed,ret=%d", ret);
+		return ret;
+	}
+
+	ret = aw_dev_chip_init(aw_dev);
+
+	return ret;
+}
+
+
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_device.h b/sound/soc/codecs/aw87xxx/aw87xxx_device.h
new file mode 100644
index 000000000..7c85f80a9
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_device.h
@@ -0,0 +1,149 @@
+#ifndef __AW87XXX_DEVICE_H__
+#define __AW87XXX_DEVICE_H__
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include "aw87xxx_acf_bin.h"
+
+#define AW87XXX_PID_9B_PRODUCT_MAX	(1)
+#define AW87XXX_PID_18_PRODUCT_MAX	(1)
+#define AW87XXX_PID_39_PRODUCT_MAX	(3)
+#define AW87XXX_PID_59_3X9_PRODUCT_MAX	(2)
+#define AW87XXX_PID_59_5X9_PRODUCT_MAX	(4)
+#define AW87XXX_PID_5A_PRODUCT_MAX	(5)
+#define AW87XXX_PID_76_PROFUCT_MAX	(4)
+#define AW87XXX_PID_60_PROFUCT_MAX	(5)
+#define AW_PRODUCT_NAME_LEN		(8)
+
+#define AW_GPIO_HIGHT_LEVEL		(1)
+#define AW_GPIO_LOW_LEVEL		(0)
+
+#define AW_I2C_RETRIES			(5)
+#define AW_I2C_RETRY_DELAY		(2)
+#define AW_I2C_READ_MSG_NUM		(2)
+
+#define AW_READ_CHIPID_RETRIES		(5)
+#define AW_READ_CHIPID_RETRY_DELAY	(2)
+#define AW_DEV_REG_CHIPID		(0x00)
+
+#define AW_DEV_REG_INVALID_MASK		(0xff)
+
+#define AW_NO_RESET_GPIO		(-1)
+
+#define AW_PID_9B_BIN_REG_CFG_COUNT	(10)
+
+/********************************************
+ *
+ * aw87xxx devices attributes
+ *
+ *******************************************/
+struct aw_device;
+
+struct aw_device_ops {
+	int (*pwr_on_func)(struct aw_device *aw_dev, struct aw_data_container *data);
+	int (*pwr_off_func)(struct aw_device *aw_dev, struct aw_data_container *data);
+};
+
+enum aw_dev_chipid {
+	AW_DEV_CHIPID_18 = 0x18,
+	AW_DEV_CHIPID_39 = 0x39,
+	AW_DEV_CHIPID_59 = 0x59,
+	AW_DEV_CHIPID_69 = 0x69,
+	AW_DEV_CHIPID_5A = 0x5A,
+	AW_DEV_CHIPID_9A = 0x9A,
+	AW_DEV_CHIPID_9B = 0x9B,
+	AW_DEV_CHIPID_76 = 0x76,
+	AW_DEV_CHIPID_60 = 0x60,
+};
+
+enum aw_dev_hw_status {
+	AW_DEV_HWEN_OFF = 0,
+	AW_DEV_HWEN_ON,
+	AW_DEV_HWEN_INVALID,
+	AW_DEV_HWEN_STATUS_MAX,
+};
+
+enum aw_dev_soft_off_enable {
+	AW_DEV_SOFT_OFF_DISENABLE = 0,
+	AW_DEV_SOFT_OFF_ENABLE = 1,
+};
+
+enum aw_dev_soft_rst_enable {
+	AW_DEV_SOFT_RST_DISENABLE = 0,
+	AW_DEV_SOFT_RST_ENABLE = 1,
+};
+
+enum aw_reg_receiver_mode {
+	AW_NOT_REC_MODE = 0,
+	AW_IS_REC_MODE = 1,
+};
+
+struct aw_mute_desc {
+	uint8_t addr;
+	uint8_t enable;
+	uint8_t disable;
+	uint16_t mask;
+};
+
+struct aw_soft_rst_desc {
+	int len;
+	unsigned char *access;
+};
+
+struct aw_esd_check_desc {
+	uint8_t first_update_reg_addr;
+	uint8_t first_update_reg_val;
+};
+
+struct aw_rec_mode_desc {
+	uint8_t addr;
+	uint8_t enable;
+	uint8_t disable;
+	uint8_t mask;
+};
+
+struct aw_device {
+	uint8_t i2c_addr;
+	uint8_t chipid;
+	uint8_t soft_rst_enable;
+	uint8_t soft_off_enable;
+	uint8_t is_rec_mode;
+	int hwen_status;
+	int i2c_bus;
+	int rst_gpio;
+	int reg_max_addr;
+	int product_cnt;
+	const char **product_tab;
+	const unsigned char *reg_access;
+
+	struct device *dev;
+	struct i2c_client *i2c;
+	struct aw_mute_desc mute_desc;
+	struct aw_soft_rst_desc soft_rst_desc;
+	struct aw_esd_check_desc esd_desc;
+	struct aw_rec_mode_desc rec_desc;
+
+	struct aw_device_ops ops;
+};
+
+
+int aw87xxx_dev_i2c_write_byte(struct aw_device *aw_dev,
+			uint8_t reg_addr, uint8_t reg_data);
+int aw87xxx_dev_i2c_read_byte(struct aw_device *aw_dev,
+			uint8_t reg_addr, uint8_t *reg_data);
+int aw87xxx_dev_i2c_read_msg(struct aw_device *aw_dev,
+	uint8_t reg_addr, uint8_t *data_buf, uint32_t data_len);
+int aw87xxx_dev_i2c_write_bits(struct aw_device *aw_dev,
+	uint8_t reg_addr, uint8_t mask, uint8_t reg_data);
+void aw87xxx_dev_soft_reset(struct aw_device *aw_dev);
+void aw87xxx_dev_hw_pwr_ctrl(struct aw_device *aw_dev, bool enable);
+int aw87xxx_dev_default_pwr_on(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data);
+int aw87xxx_dev_default_pwr_off(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data);
+int aw87xxx_dev_esd_reg_status_check(struct aw_device *aw_dev);
+int aw87xxx_dev_check_reg_is_rec_mode(struct aw_device *aw_dev);
+int aw87xxx_dev_init(struct aw_device *aw_dev);
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_dsp.c b/sound/soc/codecs/aw87xxx/aw87xxx_dsp.c
new file mode 100644
index 000000000..93b02e301
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_dsp.c
@@ -0,0 +1,355 @@
+/*
+ * aw87xxx_dsp.c
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: Barry <zhaozhongbo@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include "aw87xxx_log.h"
+#include "aw87xxx_dsp.h"
+
+static DEFINE_MUTEX(g_dsp_lock);
+static unsigned int g_spin_value = 0;
+
+static int g_rx_topo_id = AW_RX_DEFAULT_TOPO_ID;
+static int g_rx_port_id = AW_RX_DEFAULT_PORT_ID;
+
+#ifdef AW_MTK_OPEN_DSP_PLATFORM
+extern int mtk_spk_send_ipi_buf_to_dsp(void *data_buffer,
+				uint32_t data_size);
+extern int mtk_spk_recv_ipi_buf_from_dsp(int8_t *buffer,
+				int16_t size, uint32_t *buf_len);
+/*
+static int mtk_spk_send_ipi_buf_to_dsp(void *data_buffer,
+				uint32_t data_size)
+{
+	AW_LOGI("enter");
+	return 0;
+}
+
+static int mtk_spk_recv_ipi_buf_from_dsp(int8_t *buffer,
+				int16_t size, uint32_t *buf_len)
+{
+	AW_LOGI("enter");
+	return 0;
+}
+*/
+#elif defined AW_QCOM_OPEN_DSP_PLATFORM
+extern int afe_get_topology(int port_id);
+extern int aw_send_afe_cal_apr(uint32_t param_id,
+	void *buf, int cmd_size, bool write);
+/*
+static int afe_get_topology(int port_id)
+{
+	return -EPERM;
+}
+
+static int aw_send_afe_cal_apr(uint32_t param_id,
+	void *buf, int cmd_size, bool write)
+{
+	AW_LOGI("enter, no define AWINIC_ADSP_ENABLE", __func__);
+	return 0;
+}
+*/
+#endif
+
+#ifdef AW_QCOM_OPEN_DSP_PLATFORM
+extern void aw_set_port_id(int rx_port_id);
+#else
+static void aw_set_port_id(int rx_port_id)
+{
+	return;
+}
+#endif
+
+uint8_t aw87xxx_dsp_isEnable(void)
+{
+#if (defined AW_QCOM_OPEN_DSP_PLATFORM) || (defined AW_MTK_OPEN_DSP_PLATFORM)
+	return true;
+#else
+	return false;
+#endif
+}
+
+/*****************mtk dsp communication function start**********************/
+#ifdef AW_MTK_OPEN_DSP_PLATFORM
+static int aw_mtk_write_data_to_dsp(int32_t param_id,
+			void *data, int size)
+{
+	int32_t *dsp_data = NULL;
+	mtk_dsp_hdr_t *hdr = NULL;
+	int ret;
+
+	dsp_data = kzalloc(sizeof(mtk_dsp_hdr_t) + size, GFP_KERNEL);
+	if (!dsp_data) {
+		AW_LOGE("kzalloc dsp_msg error");
+		return -ENOMEM;
+	}
+
+	hdr = (mtk_dsp_hdr_t *)dsp_data;
+	hdr->type = DSP_MSG_TYPE_DATA;
+	hdr->opcode_id = param_id;
+	hdr->version = AW_DSP_MSG_HDR_VER;
+
+	memcpy(((char *)dsp_data) + sizeof(mtk_dsp_hdr_t),
+		data, size);
+
+	ret = mtk_spk_send_ipi_buf_to_dsp(dsp_data,
+				sizeof(mtk_dsp_hdr_t) + size);
+	if (ret < 0) {
+		AW_LOGE("write data failed");
+		kfree(dsp_data);
+		dsp_data = NULL;
+		return ret;
+	}
+
+	kfree(dsp_data);
+	dsp_data = NULL;
+	return 0;
+}
+
+static int aw_mtk_read_data_from_dsp(int32_t param_id, void *data,
+					int data_size)
+{
+	int ret;
+	mtk_dsp_hdr_t hdr;
+
+	mutex_lock(&g_dsp_lock);
+	hdr.type = DSP_MSG_TYPE_CMD;
+	hdr.opcode_id = param_id;
+	hdr.version = AW_DSP_MSG_HDR_VER;
+
+	ret = mtk_spk_send_ipi_buf_to_dsp(&hdr, sizeof(mtk_dsp_hdr_t));
+	if (ret < 0)
+		goto failed;
+
+	ret = mtk_spk_recv_ipi_buf_from_dsp(data, data_size, &data_size);
+	if (ret < 0)
+		goto failed;
+
+	mutex_unlock(&g_dsp_lock);
+	return 0;
+
+failed:
+	mutex_unlock(&g_dsp_lock);
+	return ret;
+}
+
+#endif
+/********************mtk dsp communication function end***********************/
+
+/******************qcom dsp communication function start**********************/
+#ifdef AW_QCOM_OPEN_DSP_PLATFORM
+static void aw_check_dsp_ready(void)
+{
+	int ret;
+
+	ret = afe_get_topology(g_rx_port_id);
+	AW_LOGD("topo_id 0x%x", ret);
+
+	if (ret != g_rx_topo_id)
+		AW_LOGE("topo id 0x%x", ret);
+
+}
+
+static int aw_qcom_write_data_to_dsp(int32_t param_id,
+				void *data, int data_size)
+{
+	int ret = 0;
+
+	AW_LOGI("enter");
+	mutex_lock(&g_dsp_lock);
+	aw_check_dsp_ready();
+	ret = aw_send_afe_cal_apr(param_id, data,
+		data_size, true);
+	mutex_unlock(&g_dsp_lock);
+	return ret;
+}
+
+static int aw_qcom_read_data_from_dsp(int32_t param_id,
+				void *data, int data_size)
+{
+	int ret = 0;
+
+	AW_LOGI("enter");
+	mutex_lock(&g_dsp_lock);
+	aw_check_dsp_ready();
+	ret = aw_send_afe_cal_apr(param_id, data,
+			data_size, false);
+	mutex_unlock(&g_dsp_lock);
+	return ret;
+}
+
+#endif
+/*****************qcom dsp communication function end*********************/
+
+/*****************read/write msg communication function*********************/
+static int aw_write_data_to_dsp(int32_t param_id, void *data, int data_size)
+{
+#if defined AW_QCOM_OPEN_DSP_PLATFORM
+	return aw_qcom_write_data_to_dsp(param_id, data, data_size);
+#elif defined AW_MTK_OPEN_DSP_PLATFORM
+	return aw_mtk_write_data_to_dsp(param_id, data, data_size);
+#else
+	return -EINVAL;
+#endif
+}
+
+static int aw_read_data_from_dsp(int32_t param_id, void *data, int data_size)
+{
+#if defined AW_QCOM_OPEN_DSP_PLATFORM
+	return aw_qcom_read_data_from_dsp(param_id, data, data_size);
+#elif defined AW_MTK_OPEN_DSP_PLATFORM
+	return aw_mtk_read_data_from_dsp(param_id, data, data_size);
+#else
+	return -EINVAL;
+#endif
+}
+
+/***************read/write msg communication function end*******************/
+
+int aw87xxx_dsp_get_rx_module_enable(int *enable)
+{
+	if (!enable) {
+		AW_LOGE("enable is NULL");
+		return -EINVAL;
+	}
+
+	return aw_read_data_from_dsp(AWDSP_RX_SET_ENABLE,
+			(void *)enable, sizeof(uint32_t));
+}
+
+int aw87xxx_dsp_set_rx_module_enable(int enable)
+{
+	switch (enable) {
+	case AW_RX_MODULE_DISENABLE:
+		AW_LOGD("set enable=%d", enable);
+		break;
+	case AW_RX_MODULE_ENABLE:
+		AW_LOGD("set enable=%d", enable);
+		break;
+	default:
+		AW_LOGE("unsupport enable=%d", enable);
+		return -EINVAL;
+	}
+
+	return aw_write_data_to_dsp(AWDSP_RX_SET_ENABLE,
+			&enable, sizeof(uint32_t));
+}
+
+
+int aw87xxx_dsp_get_vmax(uint32_t *vmax, int dev_index)
+{
+	int32_t param_id = 0;
+
+	switch (dev_index % AW_DSP_CHANNEL_MAX) {
+	case AW_DSP_CHANNEL_0:
+		param_id = AWDSP_RX_VMAX_0;
+		break;
+	case AW_DSP_CHANNEL_1:
+		param_id = AWDSP_RX_VMAX_1;
+		break;
+	default:
+		AW_LOGE("algo only support double PA channel:%d unsupport",
+			dev_index);
+		return -EINVAL;
+	}
+
+	return aw_read_data_from_dsp(param_id,
+			(void *)vmax, sizeof(uint32_t));
+}
+
+int aw87xxx_dsp_set_vmax(uint32_t vmax, int dev_index)
+{
+	int32_t param_id = 0;
+
+	switch (dev_index % AW_DSP_CHANNEL_MAX) {
+	case AW_DSP_CHANNEL_0:
+		param_id = AWDSP_RX_VMAX_0;
+		break;
+	case AW_DSP_CHANNEL_1:
+		param_id = AWDSP_RX_VMAX_1;
+		break;
+	default:
+		AW_LOGE("algo only support double PA channel:%d unsupport",
+			dev_index);
+		return -EINVAL;
+	}
+
+	return aw_write_data_to_dsp(param_id, &vmax, sizeof(uint32_t));
+}
+
+int aw87xxx_dsp_set_spin(uint32_t ctrl_value)
+{
+	int ret = 0;
+
+	if (ctrl_value >= AW_SPIN_MAX) {
+		AW_LOGE("spin [%d] unsupported ", ctrl_value);
+		return -EINVAL;
+	}
+	ret = aw_write_data_to_dsp(AW_MSG_ID_SPIN, &ctrl_value,
+		sizeof(uint32_t));
+	if (ret) {
+		AW_LOGE("spin [%d] set failed ", ctrl_value);
+		return ret;
+	}
+
+	g_spin_value = ctrl_value;
+	return 0;
+}
+
+int aw87xxx_dsp_get_spin(void)
+{
+	return g_spin_value;
+}
+
+int aw87xxx_spin_set_record_val(void)
+{
+	AW_LOGD("record write spin enter");
+
+	return aw87xxx_dsp_set_spin(g_spin_value);
+}
+EXPORT_SYMBOL(aw87xxx_spin_set_record_val);
+
+void aw87xxx_device_parse_topo_id_dt(struct aw_device *aw_dev)
+{
+	int ret;
+
+	ret = of_property_read_u32(aw_dev->dev->of_node, "aw-rx-topo-id", &g_rx_topo_id);
+	if (ret < 0) {
+		g_rx_topo_id = AW_RX_DEFAULT_TOPO_ID;
+		AW_DEV_LOGI(aw_dev->dev, "read aw-rx-topo-id failed,use default");
+	}
+
+	AW_DEV_LOGI(aw_dev->dev, "rx-topo-id: 0x%x",  g_rx_topo_id);
+}
+
+void aw87xxx_device_parse_port_id_dt(struct aw_device *aw_dev)
+{
+	int ret;
+
+	ret = of_property_read_u32(aw_dev->dev->of_node, "aw-rx-port-id", &g_rx_port_id);
+	if (ret < 0) {
+		g_rx_port_id = AW_RX_DEFAULT_PORT_ID;
+		AW_DEV_LOGI(aw_dev->dev, "read aw-rx-port-id failed,use default");
+	}
+
+	aw_set_port_id(g_rx_port_id);
+	AW_DEV_LOGI(aw_dev->dev, "rx-port-id: 0x%x", g_rx_port_id);
+}
+
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_dsp.h b/sound/soc/codecs/aw87xxx/aw87xxx_dsp.h
new file mode 100644
index 000000000..7acc4dc0d
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_dsp.h
@@ -0,0 +1,65 @@
+#ifndef __AW87XXX_DSP_H__
+#define __AW87XXX_DSP_H__
+
+#include "aw87xxx_device.h"
+
+/*#define AW_MTK_OPEN_DSP_PLATFORM*/
+/*#define AW_QCOM_OPEN_DSP_PLATFORM*/
+
+/*Note: The pord_ID is configured according to different platforms*/
+#define AW_DSP_SLEEP_TIME	(10)
+
+#define AW_DSP_MSG_HDR_VER (1)
+
+#define AW_RX_DEFAULT_TOPO_ID		(0x1000FF01)
+#define AW_RX_DEFAULT_PORT_ID		(0x4000)
+
+#define AWDSP_RX_SET_ENABLE		(0x10013D11)
+#define AWDSP_RX_PARAMS			(0x10013D12)
+#define AWDSP_RX_VMAX_0			(0X10013D17)
+#define AWDSP_RX_VMAX_1			(0X10013D18)
+#define AW_MSG_ID_SPIN 			(0x10013D2E)
+
+enum {
+	AW_SPIN_0 = 0,
+	AW_SPIN_90,
+	AW_SPIN_180,
+	AW_SPIN_270,
+	AW_SPIN_MAX,
+};
+
+typedef struct mtk_dsp_msg_header {
+	int32_t type;
+	int32_t opcode_id;
+	int32_t version;
+	int32_t reserver[3];
+} mtk_dsp_hdr_t;
+
+enum aw_rx_module_enable {
+	AW_RX_MODULE_DISENABLE = 0,
+	AW_RX_MODULE_ENABLE,
+};
+
+enum aw_dsp_msg_type {
+	DSP_MSG_TYPE_DATA = 0,
+	DSP_MSG_TYPE_CMD = 1,
+};
+
+enum aw_dsp_channel {
+	AW_DSP_CHANNEL_0 = 0,
+	AW_DSP_CHANNEL_1,
+	AW_DSP_CHANNEL_MAX,
+};
+
+uint8_t aw87xxx_dsp_isEnable(void);
+int aw87xxx_dsp_get_rx_module_enable(int *enable);
+int aw87xxx_dsp_set_rx_module_enable(int enable);
+int aw87xxx_dsp_get_vmax(uint32_t *vmax, int channel);
+int aw87xxx_dsp_set_vmax(uint32_t vmax, int channel);
+int aw87xxx_dsp_set_spin(uint32_t ctrl_value);
+int aw87xxx_dsp_get_spin(void);
+int aw87xxx_spin_set_record_val(void);
+void aw87xxx_device_parse_port_id_dt(struct aw_device *aw_dev);
+void aw87xxx_device_parse_topo_id_dt(struct aw_device *aw_dev);
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_log.h b/sound/soc/codecs/aw87xxx/aw87xxx_log.h
new file mode 100644
index 000000000..b3bde38a2
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_log.h
@@ -0,0 +1,33 @@
+#ifndef __AW87XXX_LOG_H__
+#define __AW87XXX_LOG_H__
+
+#include <linux/kernel.h>
+
+
+/********************************************
+ *
+ * print information control
+ *
+ *******************************************/
+#define AW_LOGI(fmt, ...)\
+	pr_info("[Awinic] %s:" fmt "\n", __func__, ##__VA_ARGS__)
+
+#define AW_LOGD(fmt, ...)\
+	pr_debug("[Awinic] %s:" fmt "\n", __func__, ##__VA_ARGS__)
+
+#define AW_LOGE(fmt, ...)\
+	pr_err("[Awinic] %s:" fmt "\n", __func__, ##__VA_ARGS__)
+
+
+#define AW_DEV_LOGI(dev, fmt, ...)\
+	pr_info("[Awinic] [%s]%s: " fmt "\n", dev_name(dev), __func__, ##__VA_ARGS__)
+
+#define AW_DEV_LOGD(dev, fmt, ...)\
+	pr_debug("[Awinic] [%s]%s: " fmt "\n", dev_name(dev), __func__, ##__VA_ARGS__)
+
+#define AW_DEV_LOGE(dev, fmt, ...)\
+	pr_err("[Awinic] [%s]%s: " fmt "\n", dev_name(dev), __func__, ##__VA_ARGS__)
+
+
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_monitor.c b/sound/soc/codecs/aw87xxx/aw87xxx_monitor.c
new file mode 100644
index 000000000..f580506b2
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_monitor.c
@@ -0,0 +1,1208 @@
+/*
+ * aw87xxx_monitor.c
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: Barry <zhaozhongbo@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/power_supply.h>
+#include <linux/of.h>
+#include <linux/power_supply.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/firmware.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/gameport.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include "aw87xxx.h"
+#include "aw87xxx_log.h"
+#include "aw87xxx_monitor.h"
+#include "aw87xxx_dsp.h"
+#include "aw87xxx_bin_parse.h"
+#include "aw87xxx_device.h"
+
+#define AW_MONITOT_BIN_PARSE_VERSION	"V0.1.0"
+
+#define AW_GET_32_DATA(w, x, y, z) \
+	((uint32_t)((((uint8_t)w) << 24) | (((uint8_t)x) << 16) | \
+	(((uint8_t)y) << 8) | ((uint8_t)z)))
+
+/****************************************************************************
+ *
+ * aw87xxx monitor bin check
+ *
+ ****************************************************************************/
+static int aw_monitor_check_header_v_1_0_0(struct device *dev,
+				char *data, uint32_t data_len)
+{
+	int i = 0;
+	struct aw_bin_header *header = (struct aw_bin_header *)data;
+
+	if (header->bin_data_type != DATA_TYPE_MONITOR_ANALOG) {
+		AW_DEV_LOGE(dev, "monitor data_type check error!");
+		return -EINVAL;
+	}
+
+	if (header->bin_data_size != AW_MONITOR_HDR_DATA_SIZE) {
+		AW_DEV_LOGE(dev, "monitor data_size error!");
+		return -EINVAL;
+	}
+
+	if (header->data_byte_len != AW_MONITOR_HDR_DATA_BYTE_LEN) {
+		AW_DEV_LOGE(dev, "monitor data_byte_len error!");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < AW_MONITOR_DATA_VER_MAX; i++) {
+		if (header->bin_data_ver == i) {
+			AW_LOGD("monitor bin_data_ver[0x%x]", i);
+			break;
+		}
+	}
+	if (i == AW_MONITOR_DATA_VER_MAX)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int aw_monitor_check_data_v1_size(struct device *dev,
+				char *data, int32_t data_len)
+{
+	int32_t bin_header_len  = sizeof(struct aw_bin_header);
+	int32_t monitor_header_len = sizeof(struct aw_monitor_header);
+	int32_t monitor_data_len = sizeof(struct vmax_step_config);
+	int32_t len = 0;
+	struct aw_monitor_header *monitor_header = NULL;
+
+	AW_DEV_LOGD(dev, "enter");
+
+	if (data_len < bin_header_len + monitor_header_len) {
+		AW_DEV_LOGE(dev, "bin len is less than aw_bin_header and monitoor_header,check failed");
+		return -EINVAL;
+	}
+
+	monitor_header = (struct aw_monitor_header *)(data + bin_header_len);
+	len = data_len - bin_header_len - monitor_header_len;
+	if (len < monitor_header->step_count * monitor_data_len) {
+		AW_DEV_LOGE(dev, "bin data len is not enough,check failed");
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGD(dev, "succeed");
+
+	return 0;
+}
+
+static int aw_monitor_check_data_size(struct device *dev,
+			char *data, int32_t data_len)
+{
+	int ret = -1;
+	struct aw_bin_header *header = (struct aw_bin_header *)data;
+
+	switch (header->bin_data_ver) {
+	case AW_MONITOR_DATA_VER:
+		ret = aw_monitor_check_data_v1_size(dev, data, data_len);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		AW_DEV_LOGE(dev, "bin data_ver[0x%x] non support",
+			header->bin_data_ver);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int aw_monitor_check_bin_header(struct device *dev,
+				char *data, int32_t data_len)
+{
+	int ret = -1;
+	struct aw_bin_header *header = NULL;
+
+	if (data_len < sizeof(struct aw_bin_header)) {
+		AW_DEV_LOGE(dev, "bin len is less than aw_bin_header,check failed");
+		return -EINVAL;
+	}
+	header = (struct aw_bin_header *)data;
+
+	switch (header->header_ver) {
+	case HEADER_VERSION_1_0_0:
+		ret = aw_monitor_check_header_v_1_0_0(dev, data, data_len);
+		if (ret < 0) {
+			AW_DEV_LOGE(dev, "monitor bin haeder info check error!");
+			return ret;
+		}
+		break;
+	default:
+		AW_DEV_LOGE(dev, "bin version[0x%x] non support",
+			header->header_ver);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_monitor_bin_check_sum(struct device *dev,
+			char *data, int32_t data_len)
+{
+	int i, data_sum = 0;
+	uint32_t *check_sum = (uint32_t *)data;
+
+	for (i = 4; i < data_len; i++)
+		data_sum += data[i];
+
+	if (*check_sum != data_sum) {
+		AW_DEV_LOGE(dev, "check_sum[%d] is not equal to data_sum[%d]",
+				*check_sum, data_sum);
+		return -ENOMEM;
+	}
+
+	AW_DEV_LOGD(dev, "succeed");
+
+	return 0;
+}
+
+static int aw_monitor_bin_check(struct device *dev,
+				char *monitor_data, uint32_t data_len)
+{
+	int ret = -1;
+
+	if (monitor_data == NULL || data_len == 0) {
+		AW_DEV_LOGE(dev, "none data to parse");
+		return -EINVAL;
+	}
+
+	ret = aw_monitor_bin_check_sum(dev, monitor_data, data_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "bin data check sum failed");
+		return ret;
+	}
+
+	ret = aw_monitor_check_bin_header(dev, monitor_data, data_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "bin data len check failed");
+		return ret;
+	}
+
+	ret = aw_monitor_check_data_size(dev, monitor_data, data_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "bin header info check failed");
+		return ret;
+	}
+
+	return 0;
+}
+
+/*****************************************************************************
+ *
+ * aw87xxx monitor header bin parse
+ *
+ *****************************************************************************/
+static void aw_monitor_write_to_table_v1(struct device *dev,
+			struct vmax_step_config *vmax_step,
+			char *vmax_data, uint32_t step_count)
+{
+	int i = 0;
+	int index = 0;
+	int vmax_step_size = (int)sizeof(struct vmax_step_config);
+
+	for (i = 0; i < step_count; i++) {
+		index = vmax_step_size * i;
+		vmax_step[i].vbat_min =
+			AW_GET_32_DATA(vmax_data[index + 3],
+					vmax_data[index + 2],
+					vmax_data[index + 1],
+					vmax_data[index + 0]);
+		vmax_step[i].vbat_max =
+			AW_GET_32_DATA(vmax_data[index + 7],
+					vmax_data[index + 6],
+					vmax_data[index + 5],
+					vmax_data[index + 4]);
+		vmax_step[i].vmax_vol =
+			AW_GET_32_DATA(vmax_data[index + 11],
+					vmax_data[index + 10],
+					vmax_data[index + 9],
+					vmax_data[index + 8]);
+	}
+
+	for (i = 0; i < step_count; i++)
+		AW_DEV_LOGI(dev, "vbat_min:%d, vbat_max%d, vmax_vol:0x%x",
+			vmax_step[i].vbat_min,
+			vmax_step[i].vbat_max,
+			vmax_step[i].vmax_vol);
+}
+
+static int aw_monitor_parse_vol_data_v1(struct device *dev,
+			struct aw_monitor *monitor, char *monitor_data)
+{
+	uint32_t step_count = 0;
+	char *vmax_data = NULL;
+	struct vmax_step_config *vmax_step = NULL;
+
+	AW_DEV_LOGD(dev, "enter");
+
+	step_count = monitor->monitor_hdr.step_count;
+	if (step_count) {
+		vmax_step = devm_kzalloc(dev, sizeof(struct vmax_step_config) * step_count,
+					GFP_KERNEL);
+		if (vmax_step == NULL) {
+			AW_DEV_LOGE(dev, "vmax_cfg vmalloc failed");
+			return -ENOMEM;
+		}
+		memset(vmax_step, 0,
+			sizeof(struct vmax_step_config) * step_count);
+	}
+
+	vmax_data = monitor_data + sizeof(struct aw_bin_header) +
+		sizeof(struct aw_monitor_header);
+	aw_monitor_write_to_table_v1(dev, vmax_step, vmax_data, step_count);
+	monitor->vmax_cfg = vmax_step;
+
+	AW_DEV_LOGI(dev, "vmax_data parse succeed");
+
+	return 0;
+}
+
+static int aw_monitor_parse_data_v1(struct device *dev,
+			struct aw_monitor *monitor, char *monitor_data)
+{
+	int ret = -1;
+	int header_len = 0;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	header_len = sizeof(struct aw_bin_header);
+	memcpy(monitor_hdr, monitor_data + header_len,
+		sizeof(struct aw_monitor_header));
+
+	AW_DEV_LOGI(dev, "monitor_switch:%d, monitor_time:%d (ms), monitor_count:%d, step_count:%d",
+		monitor_hdr->monitor_switch, monitor_hdr->monitor_time,
+		monitor_hdr->monitor_count, monitor_hdr->step_count);
+
+	ret = aw_monitor_parse_vol_data_v1(dev, monitor, monitor_data);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "vmax_data parse failed");
+		return ret;
+	}
+
+	monitor->bin_status = AW_MONITOR_CFG_OK;
+
+	return 0;
+}
+
+
+static int aw_monitor_parse_v_1_0_0(struct device *dev,
+			struct aw_monitor *monitor, char *monitor_data)
+{
+	int ret = -1;
+	struct aw_bin_header *header = (struct aw_bin_header *)monitor_data;
+
+	switch (header->bin_data_ver) {
+	case AW_MONITOR_DATA_VER:
+		ret = aw_monitor_parse_data_v1(dev, monitor, monitor_data);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void aw87xxx_monitor_cfg_free(struct aw_monitor *monitor)
+{
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+
+	monitor->bin_status = AW_MONITOR_CFG_WAIT;
+	memset(&monitor->monitor_hdr, 0,
+		sizeof(struct aw_monitor_header));
+	if (monitor->vmax_cfg) {
+		devm_kfree(aw87xxx->dev, monitor->vmax_cfg);
+		monitor->vmax_cfg = NULL;
+	}
+}
+
+int aw87xxx_monitor_bin_parse(struct device *dev,
+				char *monitor_data, uint32_t data_len)
+{
+	int ret = -1;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = NULL;
+	struct aw_bin_header *bin_header = NULL;
+
+	if (aw87xxx == NULL) {
+		AW_DEV_LOGE(dev, "get struct aw87xxx failed");
+		return -EINVAL;
+	}
+
+	monitor = &aw87xxx->monitor;
+	monitor->bin_status = AW_MONITOR_CFG_WAIT;
+
+	AW_DEV_LOGI(dev, "monitor bin parse version: %s",
+			AW_MONITOT_BIN_PARSE_VERSION);
+
+	ret = aw_monitor_bin_check(dev, monitor_data, data_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "monitor bin check failed");
+		return ret;
+	}
+
+	bin_header = (struct aw_bin_header *)monitor_data;
+	switch (bin_header->bin_data_ver) {
+	case DATA_VERSION_V1:
+		ret = aw_monitor_parse_v_1_0_0(dev, monitor,
+				monitor_data);
+		if (ret < 0) {
+			aw87xxx_monitor_cfg_free(monitor);
+			return ret;
+		}
+		break;
+	default:
+		AW_DEV_LOGE(dev, "Unrecognized this bin data version[0x%x]",
+			bin_header->bin_data_ver);
+	}
+
+	return 0;
+}
+
+/***************************************************************************
+ *
+ * aw87xxx monitor get adjustment vmax of power
+ *
+ ***************************************************************************/
+static int aw_monitor_get_battery_capacity(struct device *dev,
+				struct aw_monitor *monitor, int *vbat_capacity)
+{
+	char name[] = "battery";
+	int ret = -1;
+	union power_supply_propval prop = { 0 };
+	struct power_supply *psy = NULL;
+
+	psy = power_supply_get_by_name(name);
+	if (psy == NULL) {
+		AW_DEV_LOGE(dev, "no struct power supply name:%s", name);
+		return -EINVAL;
+	}
+
+	ret = power_supply_get_property(psy, POWER_SUPPLY_PROP_CAPACITY, &prop);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "get vbat capacity failed");
+		return -EINVAL;
+	}
+	*vbat_capacity = prop.intval;
+	AW_DEV_LOGI(dev, "The percentage is %d",
+		*vbat_capacity);
+
+	return 0;
+}
+
+static int aw_search_vmax_from_table(struct device *dev,
+				struct aw_monitor *monitor,
+				const int vbat_vol, int *vmax_vol)
+{
+	int i = 0;
+	int vmax_set = 0;
+	uint32_t vmax_flag = 0;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+	struct vmax_step_config *vmax_cfg = monitor->vmax_cfg;
+
+	if (monitor->bin_status == AW_MONITOR_CFG_WAIT) {
+		AW_DEV_LOGE(dev, "vmax_cfg not loaded or parse failed");
+		return -ENODATA;
+	}
+
+	for (i = 0; i < monitor_hdr->step_count; i++) {
+		if (vbat_vol == AW_VBAT_MAX) {
+			vmax_set = AW_VMAX_MAX;
+			vmax_flag = 1;
+			AW_DEV_LOGD(dev, "vbat=%d, setting vmax=0x%x",
+				vbat_vol, vmax_set);
+			break;
+		}
+
+		if (vbat_vol >= vmax_cfg[i].vbat_min &&
+			vbat_vol < vmax_cfg[i].vbat_max) {
+			vmax_set = vmax_cfg[i].vmax_vol;
+			vmax_flag = 1;
+			AW_DEV_LOGD(dev, "read setting vmax=0x%x, step[%d]: vbat_min=%d,vbat_max=%d",
+				vmax_set, i,
+				vmax_cfg[i].vbat_min,
+				vmax_cfg[i].vbat_max);
+			break;
+		}
+	}
+
+	if (!vmax_flag) {
+		AW_DEV_LOGE(dev, "vmax_cfg not found");
+		return -ENODATA;
+	}
+
+	*vmax_vol = vmax_set;
+	return 0;
+}
+
+
+/***************************************************************************
+ *
+ *monitor_esd_func
+ *
+ ***************************************************************************/
+static int aw_chip_status_recover(struct aw87xxx *aw87xxx)
+{
+	int ret = -1;
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	char *profile = aw87xxx->current_profile;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+
+	ret = aw87xxx_update_profile_esd(aw87xxx, profile);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "load profile[%s] failed ",
+			profile);
+		return ret;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "current prof[%s], dev_index[%d] ",
+			profile, aw87xxx->dev_index);
+
+	monitor->pre_vmax = AW_VMAX_INIT_VAL;
+	monitor->first_entry = AW_FIRST_ENTRY;
+	monitor->timer_cnt = 0;
+	monitor->vbat_sum = 0;
+
+	return 0;
+}
+
+static int aw_monitor_chip_esd_check_work(struct aw87xxx *aw87xxx)
+{
+	int ret = 0;
+	int i = 0;
+
+	for (i = 0; i < REG_STATUS_CHECK_MAX; i++) {
+		AW_DEV_LOGD(aw87xxx->dev, "reg_status_check[%d]", i);
+
+		ret = aw87xxx_dev_esd_reg_status_check(&aw87xxx->aw_dev);
+		if (ret < 0) {
+			aw_chip_status_recover(aw87xxx);
+		} else {
+			AW_DEV_LOGD(aw87xxx->dev, "chip status check succeed");
+			break;
+		}
+		msleep(AW_ESD_CHECK_DELAY);
+	}
+
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "chip status recover failed,chip off");
+		aw87xxx_update_profile_esd(aw87xxx, aw87xxx->prof_off_name);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+/***************************************************************************
+ *
+ * aw87xxx monitor work with dsp
+ *
+ ***************************************************************************/
+static int aw_monitor_update_vmax_to_dsp(struct device *dev,
+				struct aw_monitor *monitor, int vmax_set)
+{
+	int ret = -1;
+	uint32_t enable = 0;
+
+	if (monitor->pre_vmax != vmax_set) {
+		ret = aw87xxx_dsp_get_rx_module_enable(&enable);
+		if (!enable || ret < 0) {
+			AW_DEV_LOGE(dev, "get rx failed or rx disable, ret=%d, enable=%d",
+				ret, enable);
+			return -EPERM;
+		}
+
+		ret = aw87xxx_dsp_set_vmax(vmax_set, monitor->dev_index);
+		if (ret) {
+			AW_DEV_LOGE(dev, "set dsp msg fail, ret=%d", ret);
+			return ret;
+		}
+
+		AW_DEV_LOGI(dev, "set dsp vmax=0x%x sucess", vmax_set);
+		monitor->pre_vmax = vmax_set;
+	} else {
+		AW_DEV_LOGI(dev, "vmax=0x%x no change", vmax_set);
+	}
+
+	return 0;
+}
+
+static void aw_monitor_with_dsp_vmax_work(struct device *dev,
+					struct aw_monitor *monitor)
+{
+	int ret = -1;
+	int vmax_set = 0;
+	int vbat_capacity = 0;
+	int ave_capacity = 0;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	AW_DEV_LOGD(dev, "enter with dsp monitor");
+
+	ret = aw_monitor_get_battery_capacity(dev, monitor, &vbat_capacity);
+	if (ret < 0)
+		return;
+
+	if (monitor->timer_cnt < monitor_hdr->monitor_count) {
+		monitor->timer_cnt++;
+		monitor->vbat_sum += vbat_capacity;
+			AW_DEV_LOGI(dev, "timer_cnt = %d",
+			monitor->timer_cnt);
+	}
+	if ((monitor->timer_cnt >= monitor_hdr->monitor_count) ||
+	    (monitor->first_entry == AW_FIRST_ENTRY)) {
+		if (monitor->first_entry == AW_FIRST_ENTRY)
+			monitor->first_entry = AW_NOT_FIRST_ENTRY;
+		ave_capacity = monitor->vbat_sum / monitor->timer_cnt;
+
+		if (monitor->custom_capacity)
+			ave_capacity = monitor->custom_capacity;
+
+		AW_DEV_LOGI(dev, "get average capacity = %d", ave_capacity);
+
+		ret = aw_search_vmax_from_table(dev, monitor,
+				ave_capacity, &vmax_set);
+		if (ret < 0)
+			AW_DEV_LOGE(dev, "not find vmax_vol");
+		else
+			aw_monitor_update_vmax_to_dsp(dev, monitor, vmax_set);
+
+		monitor->timer_cnt = 0;
+		monitor->vbat_sum = 0;
+	}
+}
+
+static void aw_monitor_work_func(struct work_struct *work)
+{
+	int ret = 0;
+	struct aw87xxx *aw87xxx = container_of(work,
+				struct aw87xxx, monitor.with_dsp_work.work);
+	struct device *dev = aw87xxx->dev;
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	AW_DEV_LOGD(dev, "enter");
+
+	if (monitor->esd_enable) {
+		ret = aw_monitor_chip_esd_check_work(aw87xxx);
+		if (ret < 0)
+			return;
+	}
+
+	if (monitor_hdr->monitor_switch && !(aw87xxx->aw_dev.is_rec_mode) &&
+		monitor->open_dsp_en && monitor->bin_status == AW_ACF_UPDATE) {
+		AW_DEV_LOGD(dev, "start low power protection");
+		aw_monitor_with_dsp_vmax_work(dev, monitor);
+	}
+
+	if (monitor->esd_enable || (monitor_hdr->monitor_switch &&
+		!(aw87xxx->aw_dev.is_rec_mode) && monitor->open_dsp_en &&
+		monitor->bin_status == AW_ACF_UPDATE)) {
+		schedule_delayed_work(&monitor->with_dsp_work,
+			msecs_to_jiffies(monitor_hdr->monitor_time));
+	}
+}
+
+void aw87xxx_monitor_stop(struct aw_monitor *monitor)
+{
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+	cancel_delayed_work_sync(&monitor->with_dsp_work);
+}
+
+void aw87xxx_monitor_start(struct aw_monitor *monitor)
+{
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+	int ret = 0;
+
+	ret = aw87xxx_dev_check_reg_is_rec_mode(&aw87xxx->aw_dev);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "get reg current mode failed");
+		return;
+	}
+
+	if (monitor->esd_enable || (monitor->monitor_hdr.monitor_switch &&
+			!(aw87xxx->aw_dev.is_rec_mode) && monitor->open_dsp_en
+			&& monitor->bin_status == AW_ACF_UPDATE)) {
+
+		AW_DEV_LOGD(aw87xxx->dev, "enter");
+		monitor->pre_vmax = AW_VMAX_INIT_VAL;
+		monitor->first_entry = AW_FIRST_ENTRY;
+		monitor->timer_cnt = 0;
+		monitor->vbat_sum = 0;
+
+		schedule_delayed_work(&monitor->with_dsp_work,
+				msecs_to_jiffies(monitor->monitor_hdr.monitor_time));
+	}
+}
+/***************************************************************************
+ *
+ * aw87xxx no dsp monitor func
+ *
+ ***************************************************************************/
+int aw87xxx_monitor_no_dsp_get_vmax(struct aw_monitor *monitor, int32_t *vmax)
+{
+	int vbat_capacity = 0;
+	int ret = -1;
+	int vmax_vol = 0;
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+	struct device *dev = aw87xxx->dev;
+
+	ret = aw_monitor_get_battery_capacity(dev, monitor, &vbat_capacity);
+	if (ret < 0)
+		return ret;
+
+	if (monitor->custom_capacity)
+		vbat_capacity = monitor->custom_capacity;
+	AW_DEV_LOGI(dev, "get_battery_capacity is[%d]", vbat_capacity);
+
+	ret = aw_search_vmax_from_table(dev, monitor,
+				vbat_capacity, &vmax_vol);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "not find vmax_vol");
+		return ret;
+	}
+
+	*vmax = vmax_vol;
+	return 0;
+}
+
+
+/***************************************************************************
+ *
+ * aw87xxx monitor sysfs nodes
+ *
+ ***************************************************************************/
+static ssize_t aw_attr_get_esd_enable(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	if (monitor->esd_enable) {
+		AW_DEV_LOGI(aw87xxx->dev, "esd-enable=true");
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"esd-enable=true\n");
+	} else {
+		AW_DEV_LOGI(aw87xxx->dev, "esd-enable=false");
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"esd-enable=false\n");
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_set_esd_enable(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	char esd_enable[AW_ESD_ENABLE_STRLEN] = {0};
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	if (strlen(buf) > AW_ESD_ENABLE_STRLEN) {
+		AW_DEV_LOGE(aw87xxx->dev, "input esd_enable_str_len is out of max[%d]",
+				AW_ESD_ENABLE_STRLEN);
+		return -EINVAL;
+	}
+
+	if (sscanf(buf, "%s", esd_enable) == 1) {
+		AW_DEV_LOGD(aw87xxx->dev, "input esd-enable=[%s]", esd_enable);
+		if (!strcmp(esd_enable, "true"))
+			monitor->esd_enable = AW_ESD_ENABLE;
+		else
+			monitor->esd_enable = AW_ESD_DISABLE;
+		AW_DEV_LOGI(dev, "set esd-enable=[%s]",
+				monitor->esd_enable ? "true" : "false");
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "input esd-enable error");
+		return -EINVAL;
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_get_vbat(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	int ret = -1;
+	int vbat_capacity = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	if (monitor->custom_capacity == 0) {
+		ret = aw_monitor_get_battery_capacity(dev, monitor,
+					&vbat_capacity);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "get battery_capacity failed");
+			return ret;
+		}
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"vbat capacity=%d\n", vbat_capacity);
+	} else {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"vbat capacity=%d\n",
+				monitor->custom_capacity);
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_set_vbat(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	int ret = -1;
+	int capacity = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	ret = kstrtouint(buf, 0, &capacity);
+	if (ret < 0)
+		return ret;
+	AW_DEV_LOGI(aw87xxx->dev, "set capacity = %d", capacity);
+	if (capacity >= AW_VBAT_CAPACITY_MIN &&
+			capacity <= AW_VBAT_CAPACITY_MAX){
+		monitor->custom_capacity = capacity;
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "vbat_set=invalid,please input value [%d-%d]",
+			AW_VBAT_CAPACITY_MIN, AW_VBAT_CAPACITY_MAX);
+		return -EINVAL;
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_get_vmax(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	int ret = -1;
+	int vbat_capacity = 0;
+	int vmax_get = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	if (monitor->open_dsp_en) {
+		ret = aw87xxx_dsp_get_vmax(&vmax_get, aw87xxx->dev_index);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev,
+				"get dsp vmax fail, ret=%d", ret);
+			return ret;
+		}
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"get_vmax=%d\n", vmax_get);
+	} else {
+		ret = aw_monitor_get_battery_capacity(dev, monitor,
+						&vbat_capacity);
+		if (ret < 0)
+			return ret;
+		AW_DEV_LOGI(aw87xxx->dev, "get_battery_capacity is [%d]",
+			vbat_capacity);
+
+		if (monitor->custom_capacity) {
+			vbat_capacity = monitor->custom_capacity;
+			AW_DEV_LOGI(aw87xxx->dev, "get custom_capacity is [%d]",
+				vbat_capacity);
+		}
+
+		ret = aw_search_vmax_from_table(aw87xxx->dev, monitor,
+					vbat_capacity, &vmax_get);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "not find vmax_vol");
+			len += snprintf(buf + len, PAGE_SIZE - len,
+				"not_find_vmax_vol\n");
+			return len;
+		}
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"0x%x\n", vmax_get);
+		AW_DEV_LOGI(aw87xxx->dev, "0x%x", vmax_get);
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_set_vmax(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t vmax_set = 0;
+	int ret = -1;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	ret = kstrtouint(buf, 0, &vmax_set);
+	if (ret < 0)
+		return ret;
+
+	AW_DEV_LOGI(aw87xxx->dev, "vmax_set=0x%x", vmax_set);
+
+	if (monitor->open_dsp_en) {
+		ret = aw87xxx_dsp_set_vmax(vmax_set, aw87xxx->dev_index);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "send dsp_msg error, ret = %d",
+				ret);
+			return ret;
+		}
+		msleep(2);
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "no_dsp system,vmax_set invalid");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t aw_attr_get_monitor_switch(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw87xxx monitor switch: %u\n",
+			monitor_hdr->monitor_switch);
+	return len;
+}
+
+
+int aw87xxx_dev_monitor_switch_set(struct aw_monitor *monitor, uint32_t enable)
+{
+	struct aw87xxx *aw87xxx =
+			container_of(monitor, struct aw87xxx, monitor);
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	AW_DEV_LOGI(aw87xxx->dev, "monitor switch set =%d", enable);
+
+	if (!monitor->bin_status) {
+		AW_DEV_LOGE(aw87xxx->dev, "bin parse faile or not loaded,set invalid");
+		return -EINVAL;
+	}
+
+	if (monitor_hdr->monitor_switch == enable)
+		return 0;
+
+	if (enable > 0) {
+		monitor_hdr->monitor_switch = 1;
+		if (monitor->open_dsp_en) {
+			monitor->pre_vmax = AW_VMAX_INIT_VAL;
+			monitor->first_entry = AW_FIRST_ENTRY;
+			monitor->timer_cnt = 0;
+			monitor->vbat_sum = 0;
+		}
+	} else {
+		monitor_hdr->monitor_switch = 0;
+	}
+
+	return 0;
+}
+
+static ssize_t aw_attr_set_monitor_switch(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t enable = 0;
+	int ret = -1;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	ret = kstrtouint(buf, 0, &enable);
+	if (ret < 0)
+		return ret;
+
+	ret = aw87xxx_dev_monitor_switch_set(monitor, enable);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t aw_attr_get_monitor_time(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw_monitor_timer = %u(ms)\n",
+			monitor_hdr->monitor_time);
+	return len;
+}
+
+static ssize_t aw_attr_set_monitor_time(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int timer_val = 0;
+	int ret = -1;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	ret = kstrtouint(buf, 0, &timer_val);
+	if (ret < 0)
+		return ret;
+
+	AW_DEV_LOGI(aw87xxx->dev, "input monitor timer=%d(ms)", timer_val);
+
+	if (!monitor->bin_status) {
+		AW_DEV_LOGE(aw87xxx->dev, "bin parse faile or not loaded,set invalid");
+		return -EINVAL;
+	}
+
+	if (timer_val != monitor_hdr->monitor_time)
+		monitor_hdr->monitor_time = timer_val;
+	else
+		AW_DEV_LOGI(aw87xxx->dev, "no_change monitor_time");
+
+	return count;
+}
+
+static ssize_t aw_attr_get_monitor_count(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw_monitor_count = %u\n",
+			monitor_hdr->monitor_count);
+	return len;
+}
+
+static ssize_t aw_attr_set_monitor_count(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int monitor_count = 0;
+	int ret = -1;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	ret = kstrtouint(buf, 0, &monitor_count);
+	if (ret < 0)
+		return ret;
+	AW_DEV_LOGI(aw87xxx->dev, "input monitor count=%d", monitor_count);
+
+	if (!monitor->bin_status) {
+		AW_DEV_LOGE(aw87xxx->dev, "bin parse faile or not loaded,set invalid");
+		return -EINVAL;
+	}
+
+	if (monitor_count != monitor_hdr->monitor_count)
+		monitor_hdr->monitor_count = monitor_count;
+	else
+		AW_DEV_LOGI(aw87xxx->dev, "no_change monitor_count");
+
+	return count;
+}
+
+
+static ssize_t aw_attr_get_rx(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	ssize_t len = 0;
+	int ret = -1;
+	uint32_t enable = 0;
+
+	if (monitor->open_dsp_en) {
+		ret = aw87xxx_dsp_get_rx_module_enable(&enable);
+		if (ret) {
+			AW_DEV_LOGE(aw87xxx->dev, "dsp_msg error, ret=%d", ret);
+			return ret;
+		}
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw87xxx rx: %u\n", enable);
+	} else {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"command is invalid\n");
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_set_rx(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	int ret = -1;
+	uint32_t enable;
+
+	ret = kstrtouint(buf, 0, &enable);
+	if (ret < 0)
+		return ret;
+
+	if (monitor->open_dsp_en) {
+		AW_DEV_LOGI(aw87xxx->dev, "set rx enable=%d", enable);
+
+		ret = aw87xxx_dsp_set_rx_module_enable(enable);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "dsp_msg error, ret=%d",
+				ret);
+			return ret;
+		}
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "command is invalid");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+
+static DEVICE_ATTR(esd_enable, S_IWUSR | S_IRUGO,
+	aw_attr_get_esd_enable, aw_attr_set_esd_enable);
+static DEVICE_ATTR(vbat, S_IWUSR | S_IRUGO,
+	aw_attr_get_vbat, aw_attr_set_vbat);
+static DEVICE_ATTR(vmax, S_IWUSR | S_IRUGO,
+	aw_attr_get_vmax, aw_attr_set_vmax);
+
+static DEVICE_ATTR(monitor_switch, S_IWUSR | S_IRUGO,
+	aw_attr_get_monitor_switch, aw_attr_set_monitor_switch);
+static DEVICE_ATTR(monitor_time, S_IWUSR | S_IRUGO,
+	aw_attr_get_monitor_time, aw_attr_set_monitor_time);
+static DEVICE_ATTR(monitor_count, S_IWUSR | S_IRUGO,
+	aw_attr_get_monitor_count, aw_attr_set_monitor_count);
+static DEVICE_ATTR(rx, S_IWUSR | S_IRUGO,
+	aw_attr_get_rx, aw_attr_set_rx);
+
+static struct attribute *aw_monitor_vol_adjust[] = {
+	&dev_attr_esd_enable.attr,
+	&dev_attr_vbat.attr,
+	&dev_attr_vmax.attr,
+	NULL
+};
+
+static struct attribute_group aw_monitor_vol_adjust_group = {
+	.attrs = aw_monitor_vol_adjust,
+};
+
+static struct attribute *aw_monitor_control[] = {
+	&dev_attr_monitor_switch.attr,
+	&dev_attr_monitor_time.attr,
+	&dev_attr_monitor_count.attr,
+	&dev_attr_rx.attr,
+	NULL
+};
+
+static struct attribute_group aw_monitor_control_group = {
+	.attrs = aw_monitor_control,
+};
+
+/***************************************************************************
+ *
+ * aw87xxx monitor init
+ *
+ ***************************************************************************/
+static void aw_monitor_dtsi_parse(struct device *dev,
+				struct aw_monitor *monitor,
+				struct device_node *dev_node)
+{
+	int ret = -1;
+	const char *esd_enable;
+
+	ret = of_property_read_string(dev_node, "esd-enable", &esd_enable);
+	if (ret < 0) {
+		AW_DEV_LOGI(dev, "esd_enable parse failed, user default[disable]");
+		monitor->esd_enable = AW_ESD_DISABLE;
+	} else {
+		if (!strcmp(esd_enable, "true"))
+			monitor->esd_enable = AW_ESD_ENABLE;
+		else
+			monitor->esd_enable = AW_ESD_DISABLE;
+
+		AW_DEV_LOGI(dev, "parse esd-enable=[%s]",
+				monitor->esd_enable ? "true" : "false");
+	}
+}
+
+void aw87xxx_monitor_init(struct device *dev, struct aw_monitor *monitor,
+				struct device_node *dev_node)
+{
+	int ret = -1;
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+
+	monitor->dev_index = aw87xxx->dev_index;
+	monitor->monitor_hdr.monitor_time = AW_DEFAULT_MONITOR_TIME;
+
+	aw_monitor_dtsi_parse(dev, monitor, dev_node);
+
+	/* get platform open dsp type */
+	monitor->open_dsp_en = aw87xxx_dsp_isEnable();
+
+	ret = sysfs_create_group(&dev->kobj, &aw_monitor_vol_adjust_group);
+	if (ret < 0)
+		AW_DEV_LOGE(dev, "failed to create monitor vol_adjust sysfs nodes");
+
+	INIT_DELAYED_WORK(&monitor->with_dsp_work, aw_monitor_work_func);
+
+	if (monitor->open_dsp_en) {
+		ret = sysfs_create_group(&dev->kobj, &aw_monitor_control_group);
+		if (ret < 0)
+			AW_DEV_LOGE(dev, "failed to create monitor dsp control sysfs nodes");
+	}
+
+	if (!ret)
+		AW_DEV_LOGI(dev, "monitor init succeed");
+}
+
+void aw87xxx_monitor_exit(struct aw_monitor *monitor)
+{
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+	/*rm attr node*/
+	sysfs_remove_group(&aw87xxx->dev->kobj,
+			&aw_monitor_vol_adjust_group);
+
+	aw87xxx_monitor_stop(monitor);
+
+	if (monitor->open_dsp_en) {
+		sysfs_remove_group(&aw87xxx->dev->kobj,
+				&aw_monitor_control_group);
+	}
+}
+
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_monitor.h b/sound/soc/codecs/aw87xxx/aw87xxx_monitor.h
new file mode 100644
index 000000000..daf9f2bfa
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_monitor.h
@@ -0,0 +1,96 @@
+#ifndef __AW87XXX_MONITOR_H__
+#define __AW87XXX_MONITOR_H__
+
+#define AW_WAIT_DSP_OPEN_TIME			(3000)
+#define AW_VBAT_CAPACITY_MIN			(0)
+#define AW_VBAT_CAPACITY_MAX			(100)
+#define AW_VMAX_INIT_VAL			(0xFFFFFFFF)
+#define AW_VBAT_MAX				(100)
+#define AW_VMAX_MAX				(0)
+#define AW_DEFAULT_MONITOR_TIME			(3000)
+#define AW_WAIT_TIME				(3000)
+#define REG_STATUS_CHECK_MAX			(10)
+#define AW_ESD_CHECK_DELAY			(1)
+
+#define AW_ESD_ENABLE				(true)
+#define AW_ESD_DISABLE				(false)
+#define AW_ESD_ENABLE_STRLEN			(16)
+
+enum aw_monitor_init {
+	AW_MONITOR_CFG_WAIT = 0,
+	AW_MONITOR_CFG_OK = 1,
+};
+
+enum aw_monitor_hdr_info {
+	AW_MONITOR_HDR_DATA_SIZE = 0x00000004,
+	AW_MONITOR_HDR_DATA_BYTE_LEN = 0x00000004,
+};
+
+enum aw_monitor_data_ver {
+	AW_MONITOR_DATA_VER = 0x00000001,
+	AW_MONITOR_DATA_VER_MAX,
+};
+
+enum aw_monitor_first_enter {
+	AW_FIRST_ENTRY = 0,
+	AW_NOT_FIRST_ENTRY = 1,
+};
+
+struct aw_bin_header {
+	uint32_t check_sum;
+	uint32_t header_ver;
+	uint32_t bin_data_type;
+	uint32_t bin_data_ver;
+	uint32_t bin_data_size;
+	uint32_t ui_ver;
+	char product[8];
+	uint32_t addr_byte_len;
+	uint32_t data_byte_len;
+	uint32_t device_addr;
+	uint32_t reserve[4];
+};
+
+struct aw_monitor_header {
+	uint32_t monitor_switch;
+	uint32_t monitor_time;
+	uint32_t monitor_count;
+	uint32_t step_count;
+	uint32_t reserve[4];
+};
+
+struct vmax_step_config {
+	uint32_t vbat_min;
+	uint32_t vbat_max;
+	int vmax_vol;
+};
+
+struct aw_monitor {
+	bool open_dsp_en;
+	bool esd_enable;
+	int32_t dev_index;
+	uint8_t first_entry;
+	uint8_t timer_cnt;
+	uint32_t vbat_sum;
+	int32_t custom_capacity;
+	uint32_t pre_vmax;
+
+	int bin_status;
+	struct aw_monitor_header monitor_hdr;
+	struct vmax_step_config *vmax_cfg;
+
+	struct delayed_work with_dsp_work;
+};
+
+void aw87xxx_monitor_cfg_free(struct aw_monitor *monitor);
+int aw87xxx_monitor_bin_parse(struct device *dev,
+			char *monitor_data, uint32_t data_len);
+void aw87xxx_monitor_stop(struct aw_monitor *monitor);
+void aw87xxx_monitor_start(struct aw_monitor *monitor);
+int aw87xxx_monitor_no_dsp_get_vmax(struct aw_monitor *monitor,
+					int32_t *vmax);
+void aw87xxx_monitor_init(struct device *dev, struct aw_monitor *monitor,
+				struct device_node *dev_node);
+void aw87xxx_monitor_exit(struct aw_monitor *monitor);
+int aw87xxx_dev_monitor_switch_set(struct aw_monitor *monitor, uint32_t enable);
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_18_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_18_reg.h
new file mode 100644
index 000000000..74d6548db
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_18_reg.h
@@ -0,0 +1,2315 @@
+#ifndef __AW87XXX_PID_18_REG_H__
+#define __AW87XXX_PID_18_REG_H__
+
+/* registers list */
+#define AW87XXX_PID_18_CHIPID_REG		(0x00)
+#define AW87XXX_PID_18_SYSST_REG		(0x01)
+#define AW87XXX_PID_18_SYSINT_REG		(0x02)
+#define AW87XXX_PID_18_SYSCTRL_REG		(0x03)
+#define AW87XXX_PID_18_CPOC_REG			(0x04)
+#define AW87XXX_PID_18_CLASSD_REG		(0x05)
+#define AW87XXX_PID_18_MADPVTH_REG		(0x06)
+#define AW87XXX_PID_18_A3PARAM_REG		(0x07)
+#define AW87XXX_PID_18_A3A2PO_REG		(0x08)
+#define AW87XXX_PID_18_A2PARAM_REG		(0x09)
+#define AW87XXX_PID_18_A1PARAM_REG		(0x0A)
+#define AW87XXX_PID_18_POPCLK_REG		(0x0B)
+#define AW87XXX_PID_18_GTDRCPSS_REG		(0x0C)
+#define AW87XXX_PID_18_MULTI_REG		(0x0D)
+#define AW87XXX_PID_18_DFT1_REG			(0x61)
+#define AW87XXX_PID_18_DFT2_REG			(0x62)
+#define AW87XXX_PID_18_DFT3_REG			(0x63)
+#define AW87XXX_PID_18_DFT4_REG			(0x64)
+#define AW87XXX_PID_18_DFT5_REG			(0x65)
+#define AW87XXX_PID_18_DFT6_REG			(0x66)
+
+#define AW87XXX_PID_18_CLASSD_DEFAULT		(0x10)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_18_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_18_REG_MAX			(0x67)
+
+#define REG_NONE_ACCESS					(0)
+#define REG_RD_ACCESS					(1 << 0)
+#define REG_WR_ACCESS					(1 << 1)
+
+const unsigned char aw87xxx_pid_18_reg_access[AW87XXX_PID_18_REG_MAX] = {
+	[AW87XXX_PID_18_CHIPID_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_18_SYSST_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_18_SYSINT_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_18_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_CPOC_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_CLASSD_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_MADPVTH_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_A3PARAM_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_A3A2PO_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_A2PARAM_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_A1PARAM_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_POPCLK_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_GTDRCPSS_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_MULTI_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT3_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT4_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT5_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT6_REG]	= (REG_RD_ACCESS),
+};
+
+/* detail information of registers begin */
+/* CHIPID (0x00) detail */
+/* IDCODE bit 7:0 (CHIPID 0x00) */
+#define AW87XXX_PID_18_IDCODE_START_BIT	(0)
+#define AW87XXX_PID_18_IDCODE_BITS_LEN	(8)
+#define AW87XXX_PID_18_IDCODE_MASK		\
+	(~(((1<<AW87XXX_PID_18_IDCODE_BITS_LEN)-1) << AW87XXX_PID_18_IDCODE_START_BIT))
+
+#define AW87XXX_PID_18_IDCODE_DEFAULT_VALUE	(0x18)
+#define AW87XXX_PID_18_IDCODE_DEFAULT	\
+	(AW87XXX_PID_18_IDCODE_DEFAULT_VALUE << AW87XXX_PID_18_IDCODE_START_BIT)
+
+/* default value of CHIPID (0x00) */
+/* #define AW87XXX_PID_18_CHIPID_DEFAULT		(0x18) */
+
+/* SYSST (0x01) detail */
+/* UVLOS bit 7 (SYSST 0x01) */
+#define AW87XXX_PID_18_UVLOS_START_BIT	(7)
+#define AW87XXX_PID_18_UVLOS_BITS_LEN	(1)
+#define AW87XXX_PID_18_UVLOS_MASK		\
+	(~(((1<<AW87XXX_PID_18_UVLOS_BITS_LEN)-1) << AW87XXX_PID_18_UVLOS_START_BIT))
+
+#define AW87XXX_PID_18_UVLOS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_18_UVLOS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_UVLOS_NORMAL_OPERATION << AW87XXX_PID_18_UVLOS_START_BIT)
+
+#define AW87XXX_PID_18_UVLOS_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_18_UVLOS_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_18_UVLOS_VBAT_UNDER_VOLTAGE << AW87XXX_PID_18_UVLOS_START_BIT)
+
+#define AW87XXX_PID_18_UVLOS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_UVLOS_DEFAULT	\
+	(AW87XXX_PID_18_UVLOS_DEFAULT_VALUE << AW87XXX_PID_18_UVLOS_START_BIT)
+
+/* OTNS bit 6 (SYSST 0x01) */
+#define AW87XXX_PID_18_OTNS_START_BIT	(6)
+#define AW87XXX_PID_18_OTNS_BITS_LEN	(1)
+#define AW87XXX_PID_18_OTNS_MASK		\
+	(~(((1<<AW87XXX_PID_18_OTNS_BITS_LEN)-1) << AW87XXX_PID_18_OTNS_START_BIT))
+
+#define AW87XXX_PID_18_OTNS_PA_OVER_TEMPRETURE_PROTECTION_DETECTED	(0)
+#define AW87XXX_PID_18_OTNS_PA_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OTNS_PA_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_18_OTNS_START_BIT)
+
+#define AW87XXX_PID_18_OTNS_NORMAL_OPERATION	(1)
+#define AW87XXX_PID_18_OTNS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_OTNS_NORMAL_OPERATION << AW87XXX_PID_18_OTNS_START_BIT)
+
+#define AW87XXX_PID_18_OTNS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OTNS_DEFAULT		\
+	(AW87XXX_PID_18_OTNS_DEFAULT_VALUE << AW87XXX_PID_18_OTNS_START_BIT)
+
+/* OC_FLAGS bit 5 (SYSST 0x01) */
+#define AW87XXX_PID_18_OC_FLAGS_START_BIT	(5)
+#define AW87XXX_PID_18_OC_FLAGS_BITS_LEN	(1)
+#define AW87XXX_PID_18_OC_FLAGS_MASK	\
+	(~(((1<<AW87XXX_PID_18_OC_FLAGS_BITS_LEN)-1) << AW87XXX_PID_18_OC_FLAGS_START_BIT))
+
+#define AW87XXX_PID_18_OC_FLAGS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_18_OC_FLAGS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_OC_FLAGS_NORMAL_OPERATION << AW87XXX_PID_18_OC_FLAGS_START_BIT)
+
+#define AW87XXX_PID_18_OC_FLAGS_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_18_OC_FLAGS_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OC_FLAGS_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_18_OC_FLAGS_START_BIT)
+
+#define AW87XXX_PID_18_OC_FLAGS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OC_FLAGS_DEFAULT	\
+	(AW87XXX_PID_18_OC_FLAGS_DEFAULT_VALUE << AW87XXX_PID_18_OC_FLAGS_START_BIT)
+
+/* VOUTDECTS bit 4 (SYSST 0x01) */
+#define AW87XXX_PID_18_VOUTDECTS_START_BIT	(4)
+#define AW87XXX_PID_18_VOUTDECTS_BITS_LEN	(1)
+#define AW87XXX_PID_18_VOUTDECTS_MASK	\
+	(~(((1<<AW87XXX_PID_18_VOUTDECTS_BITS_LEN)-1) << AW87XXX_PID_18_VOUTDECTS_START_BIT))
+
+#define AW87XXX_PID_18_VOUTDECTS_PVDDBELOWVDD	(0)
+#define AW87XXX_PID_18_VOUTDECTS_PVDDBELOWVDD_VALUE	\
+	(AW87XXX_PID_18_VOUTDECTS_PVDDBELOWVDD << AW87XXX_PID_18_VOUTDECTS_START_BIT)
+
+#define AW87XXX_PID_18_VOUTDECTS_PVDDABOVEVDD	(1)
+#define AW87XXX_PID_18_VOUTDECTS_PVDDABOVEVDD_VALUE	\
+	(AW87XXX_PID_18_VOUTDECTS_PVDDABOVEVDD << AW87XXX_PID_18_VOUTDECTS_START_BIT)
+
+#define AW87XXX_PID_18_VOUTDECTS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_VOUTDECTS_DEFAULT	\
+	(AW87XXX_PID_18_VOUTDECTS_DEFAULT_VALUE << AW87XXX_PID_18_VOUTDECTS_START_BIT)
+
+/* STARTOKS bit 3 (SYSST 0x01) */
+#define AW87XXX_PID_18_STARTOKS_START_BIT	(3)
+#define AW87XXX_PID_18_STARTOKS_BITS_LEN	(1)
+#define AW87XXX_PID_18_STARTOKS_MASK	\
+	(~(((1<<AW87XXX_PID_18_STARTOKS_BITS_LEN)-1) << AW87XXX_PID_18_STARTOKS_START_BIT))
+
+#define AW87XXX_PID_18_STARTOKS_CP_START_FAIL_DECTECTED	(0)
+#define AW87XXX_PID_18_STARTOKS_CP_START_FAIL_DECTECTED_VALUE	\
+	(AW87XXX_PID_18_STARTOKS_CP_START_FAIL_DECTECTED << AW87XXX_PID_18_STARTOKS_START_BIT)
+
+#define AW87XXX_PID_18_STARTOKS_NORMAL_OPERATION	(1)
+#define AW87XXX_PID_18_STARTOKS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_STARTOKS_NORMAL_OPERATION << AW87XXX_PID_18_STARTOKS_START_BIT)
+
+#define AW87XXX_PID_18_STARTOKS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_STARTOKS_DEFAULT	\
+	(AW87XXX_PID_18_STARTOKS_DEFAULT_VALUE << AW87XXX_PID_18_STARTOKS_START_BIT)
+
+/* VBGOKN1S bit 2 (SYSST 0x01) */
+#define AW87XXX_PID_18_VBGOKN1S_START_BIT	(2)
+#define AW87XXX_PID_18_VBGOKN1S_BITS_LEN	(1)
+#define AW87XXX_PID_18_VBGOKN1S_MASK	\
+	(~(((1<<AW87XXX_PID_18_VBGOKN1S_BITS_LEN)-1) << AW87XXX_PID_18_VBGOKN1S_START_BIT))
+
+#define AW87XXX_PID_18_VBGOKN1S_NORMAL_WORKS	(0)
+#define AW87XXX_PID_18_VBGOKN1S_NORMAL_WORKS_VALUE	\
+	(AW87XXX_PID_18_VBGOKN1S_NORMAL_WORKS << AW87XXX_PID_18_VBGOKN1S_START_BIT)
+
+#define AW87XXX_PID_18_VBGOKN1S_ABNORMAL_WORKS	(1)
+#define AW87XXX_PID_18_VBGOKN1S_ABNORMAL_WORKS_VALUE	\
+	(AW87XXX_PID_18_VBGOKN1S_ABNORMAL_WORKS << AW87XXX_PID_18_VBGOKN1S_START_BIT)
+
+#define AW87XXX_PID_18_VBGOKN1S_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_VBGOKN1S_DEFAULT	\
+	(AW87XXX_PID_18_VBGOKN1S_DEFAULT_VALUE << AW87XXX_PID_18_VBGOKN1S_START_BIT)
+
+/* OVPS bit 1 (SYSST 0x01) */
+#define AW87XXX_PID_18_OVPS_START_BIT	(1)
+#define AW87XXX_PID_18_OVPS_BITS_LEN	(1)
+#define AW87XXX_PID_18_OVPS_MASK		\
+	(~(((1<<AW87XXX_PID_18_OVPS_BITS_LEN)-1) << AW87XXX_PID_18_OVPS_START_BIT))
+
+#define AW87XXX_PID_18_OVPS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_18_OVPS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_OVPS_NORMAL_OPERATION << AW87XXX_PID_18_OVPS_START_BIT)
+
+#define AW87XXX_PID_18_OVPS_CP_OVP_DETECTED	(1)
+#define AW87XXX_PID_18_OVPS_CP_OVP_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OVPS_CP_OVP_DETECTED << AW87XXX_PID_18_OVPS_START_BIT)
+
+#define AW87XXX_PID_18_OVPS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OVPS_DEFAULT		\
+	(AW87XXX_PID_18_OVPS_DEFAULT_VALUE << AW87XXX_PID_18_OVPS_START_BIT)
+
+/* CP_2PS bit 0 (SYSST 0x01) */
+#define AW87XXX_PID_18_CP_2PS_START_BIT	(0)
+#define AW87XXX_PID_18_CP_2PS_BITS_LEN	(1)
+#define AW87XXX_PID_18_CP_2PS_MASK		\
+	(~(((1<<AW87XXX_PID_18_CP_2PS_BITS_LEN)-1) << AW87XXX_PID_18_CP_2PS_START_BIT))
+
+#define AW87XXX_PID_18_CP_2PS_WEAK_SIGNAL	(0)
+#define AW87XXX_PID_18_CP_2PS_WEAK_SIGNAL_VALUE	\
+	(AW87XXX_PID_18_CP_2PS_WEAK_SIGNAL << AW87XXX_PID_18_CP_2PS_START_BIT)
+
+#define AW87XXX_PID_18_CP_2PS_STRONG_SIGNAL	(1)
+#define AW87XXX_PID_18_CP_2PS_STRONG_SIGNAL_VALUE	\
+	(AW87XXX_PID_18_CP_2PS_STRONG_SIGNAL << AW87XXX_PID_18_CP_2PS_START_BIT)
+
+#define AW87XXX_PID_18_CP_2PS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_CP_2PS_DEFAULT	\
+	(AW87XXX_PID_18_CP_2PS_DEFAULT_VALUE << AW87XXX_PID_18_CP_2PS_START_BIT)
+
+/* default value of SYSST (0x01) */
+/* #define AW87XXX_PID_18_SYSST_DEFAULT		(0x00) */
+
+/* SYSINT (0x02) detail */
+/* UVLOI bit 7 (SYSINT 0x02) */
+#define AW87XXX_PID_18_UVLOI_START_BIT	(7)
+#define AW87XXX_PID_18_UVLOI_BITS_LEN	(1)
+#define AW87XXX_PID_18_UVLOI_MASK		\
+	(~(((1<<AW87XXX_PID_18_UVLOI_BITS_LEN)-1) << AW87XXX_PID_18_UVLOI_START_BIT))
+
+#define AW87XXX_PID_18_UVLOI_SIGNAL_STATUS_DO_NOT_CHANGE	(0)
+#define AW87XXX_PID_18_UVLOI_SIGNAL_STATUS_DO_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_18_UVLOI_SIGNAL_STATUS_DO_NOT_CHANGE << AW87XXX_PID_18_UVLOI_START_BIT)
+
+#define AW87XXX_PID_18_UVLOI_UNDER_VOLTAGE_LOCK_OUT_DETECTED	(1)
+#define AW87XXX_PID_18_UVLOI_UNDER_VOLTAGE_LOCK_OUT_DETECTED_VALUE	\
+	(AW87XXX_PID_18_UVLOI_UNDER_VOLTAGE_LOCK_OUT_DETECTED << AW87XXX_PID_18_UVLOI_START_BIT)
+
+#define AW87XXX_PID_18_UVLOI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_UVLOI_DEFAULT	\
+	(AW87XXX_PID_18_UVLOI_DEFAULT_VALUE << AW87XXX_PID_18_UVLOI_START_BIT)
+
+/* OTNI bit 6 (SYSINT 0x02) */
+#define AW87XXX_PID_18_OTNI_START_BIT	(6)
+#define AW87XXX_PID_18_OTNI_BITS_LEN	(1)
+#define AW87XXX_PID_18_OTNI_MASK		\
+	(~(((1<<AW87XXX_PID_18_OTNI_BITS_LEN)-1) << AW87XXX_PID_18_OTNI_START_BIT))
+
+#define AW87XXX_PID_18_OTNI_SIGNAL_STATUS_DO_NOT_CHANGE	(0)
+#define AW87XXX_PID_18_OTNI_SIGNAL_STATUS_DO_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_18_OTNI_SIGNAL_STATUS_DO_NOT_CHANGE << AW87XXX_PID_18_OTNI_START_BIT)
+
+#define AW87XXX_PID_18_OTNI_OVER_TEMPRETURE_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_18_OTNI_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OTNI_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_18_OTNI_START_BIT)
+
+#define AW87XXX_PID_18_OTNI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OTNI_DEFAULT		\
+	(AW87XXX_PID_18_OTNI_DEFAULT_VALUE << AW87XXX_PID_18_OTNI_START_BIT)
+
+/* OC_FLAGI bit 5 (SYSINT 0x02) */
+#define AW87XXX_PID_18_OC_FLAGI_START_BIT	(5)
+#define AW87XXX_PID_18_OC_FLAGI_BITS_LEN	(1)
+#define AW87XXX_PID_18_OC_FLAGI_MASK	\
+	(~(((1<<AW87XXX_PID_18_OC_FLAGI_BITS_LEN)-1) << AW87XXX_PID_18_OC_FLAGI_START_BIT))
+
+#define AW87XXX_PID_18_OC_FLAGI_SIGNAL_STATUS_DO_NOT_CHANGE	(0)
+#define AW87XXX_PID_18_OC_FLAGI_SIGNAL_STATUS_DO_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_18_OC_FLAGI_SIGNAL_STATUS_DO_NOT_CHANGE << AW87XXX_PID_18_OC_FLAGI_START_BIT)
+
+#define AW87XXX_PID_18_OC_FLAGI_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_18_OC_FLAGI_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OC_FLAGI_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_18_OC_FLAGI_START_BIT)
+
+#define AW87XXX_PID_18_OC_FLAGI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OC_FLAGI_DEFAULT	\
+	(AW87XXX_PID_18_OC_FLAGI_DEFAULT_VALUE << AW87XXX_PID_18_OC_FLAGI_START_BIT)
+
+/* VOUTDECTI bit 4 (SYSINT 0x02) */
+#define AW87XXX_PID_18_VOUTDECTI_START_BIT	(4)
+#define AW87XXX_PID_18_VOUTDECTI_BITS_LEN	(1)
+#define AW87XXX_PID_18_VOUTDECTI_MASK	\
+	(~(((1<<AW87XXX_PID_18_VOUTDECTI_BITS_LEN)-1) << AW87XXX_PID_18_VOUTDECTI_START_BIT))
+
+#define AW87XXX_PID_18_VOUTDECTI_PVDDBELOWVDD	(0)
+#define AW87XXX_PID_18_VOUTDECTI_PVDDBELOWVDD_VALUE	\
+	(AW87XXX_PID_18_VOUTDECTI_PVDDBELOWVDD << AW87XXX_PID_18_VOUTDECTI_START_BIT)
+
+#define AW87XXX_PID_18_VOUTDECTI_PVDDABOVEVDD	(1)
+#define AW87XXX_PID_18_VOUTDECTI_PVDDABOVEVDD_VALUE	\
+	(AW87XXX_PID_18_VOUTDECTI_PVDDABOVEVDD << AW87XXX_PID_18_VOUTDECTI_START_BIT)
+
+#define AW87XXX_PID_18_VOUTDECTI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_VOUTDECTI_DEFAULT	\
+	(AW87XXX_PID_18_VOUTDECTI_DEFAULT_VALUE << AW87XXX_PID_18_VOUTDECTI_START_BIT)
+
+/* STARTOKI bit 3 (SYSINT 0x02) */
+#define AW87XXX_PID_18_STARTOKI_START_BIT	(3)
+#define AW87XXX_PID_18_STARTOKI_BITS_LEN	(1)
+#define AW87XXX_PID_18_STARTOKI_MASK	\
+	(~(((1<<AW87XXX_PID_18_STARTOKI_BITS_LEN)-1) << AW87XXX_PID_18_STARTOKI_START_BIT))
+
+#define AW87XXX_PID_18_STARTOKI_SIGNAL_STATUS_DO_NOT_CHANGE	(0)
+#define AW87XXX_PID_18_STARTOKI_SIGNAL_STATUS_DO_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_18_STARTOKI_SIGNAL_STATUS_DO_NOT_CHANGE << AW87XXX_PID_18_STARTOKI_START_BIT)
+
+#define AW87XXX_PID_18_STARTOKI_CHARGEPUMB_START_UP_OK_DECTECTED	(1)
+#define AW87XXX_PID_18_STARTOKI_CHARGEPUMB_START_UP_OK_DECTECTED_VALUE	\
+	(AW87XXX_PID_18_STARTOKI_CHARGEPUMB_START_UP_OK_DECTECTED << AW87XXX_PID_18_STARTOKI_START_BIT)
+
+#define AW87XXX_PID_18_STARTOKI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_STARTOKI_DEFAULT	\
+	(AW87XXX_PID_18_STARTOKI_DEFAULT_VALUE << AW87XXX_PID_18_STARTOKI_START_BIT)
+
+/* VBGOKN1I bit 2 (SYSINT 0x02) */
+#define AW87XXX_PID_18_VBGOKN1I_START_BIT	(2)
+#define AW87XXX_PID_18_VBGOKN1I_BITS_LEN	(1)
+#define AW87XXX_PID_18_VBGOKN1I_MASK	\
+	(~(((1<<AW87XXX_PID_18_VBGOKN1I_BITS_LEN)-1) << AW87XXX_PID_18_VBGOKN1I_START_BIT))
+
+#define AW87XXX_PID_18_VBGOKN1I_NORMAL_WORKS	(0)
+#define AW87XXX_PID_18_VBGOKN1I_NORMAL_WORKS_VALUE	\
+	(AW87XXX_PID_18_VBGOKN1I_NORMAL_WORKS << AW87XXX_PID_18_VBGOKN1I_START_BIT)
+
+#define AW87XXX_PID_18_VBGOKN1I_ABNORMAL_WORKS	(1)
+#define AW87XXX_PID_18_VBGOKN1I_ABNORMAL_WORKS_VALUE	\
+	(AW87XXX_PID_18_VBGOKN1I_ABNORMAL_WORKS << AW87XXX_PID_18_VBGOKN1I_START_BIT)
+
+#define AW87XXX_PID_18_VBGOKN1I_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_VBGOKN1I_DEFAULT	\
+	(AW87XXX_PID_18_VBGOKN1I_DEFAULT_VALUE << AW87XXX_PID_18_VBGOKN1I_START_BIT)
+
+/* OVPI bit 1 (SYSINT 0x02) */
+#define AW87XXX_PID_18_OVPI_START_BIT	(1)
+#define AW87XXX_PID_18_OVPI_BITS_LEN	(1)
+#define AW87XXX_PID_18_OVPI_MASK		\
+	(~(((1<<AW87XXX_PID_18_OVPI_BITS_LEN)-1) << AW87XXX_PID_18_OVPI_START_BIT))
+
+#define AW87XXX_PID_18_OVPI_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_18_OVPI_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_OVPI_NORMAL_OPERATION << AW87XXX_PID_18_OVPI_START_BIT)
+
+#define AW87XXX_PID_18_OVPI_CP_OVP_DETECTED	(1)
+#define AW87XXX_PID_18_OVPI_CP_OVP_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OVPI_CP_OVP_DETECTED << AW87XXX_PID_18_OVPI_START_BIT)
+
+#define AW87XXX_PID_18_OVPI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OVPI_DEFAULT		\
+	(AW87XXX_PID_18_OVPI_DEFAULT_VALUE << AW87XXX_PID_18_OVPI_START_BIT)
+
+/* CP_2PI bit 0 (SYSINT 0x02) */
+#define AW87XXX_PID_18_CP_2PI_START_BIT	(0)
+#define AW87XXX_PID_18_CP_2PI_BITS_LEN	(1)
+#define AW87XXX_PID_18_CP_2PI_MASK		\
+	(~(((1<<AW87XXX_PID_18_CP_2PI_BITS_LEN)-1) << AW87XXX_PID_18_CP_2PI_START_BIT))
+
+#define AW87XXX_PID_18_CP_2PI_WEAK_SIGNAL	(0)
+#define AW87XXX_PID_18_CP_2PI_WEAK_SIGNAL_VALUE	\
+	(AW87XXX_PID_18_CP_2PI_WEAK_SIGNAL << AW87XXX_PID_18_CP_2PI_START_BIT)
+
+#define AW87XXX_PID_18_CP_2PI_STRONG_SIGNAL	(1)
+#define AW87XXX_PID_18_CP_2PI_STRONG_SIGNAL_VALUE	\
+	(AW87XXX_PID_18_CP_2PI_STRONG_SIGNAL << AW87XXX_PID_18_CP_2PI_START_BIT)
+
+#define AW87XXX_PID_18_CP_2PI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_CP_2PI_DEFAULT	\
+	(AW87XXX_PID_18_CP_2PI_DEFAULT_VALUE << AW87XXX_PID_18_CP_2PI_START_BIT)
+
+/* default value of SYSINT (0x02) */
+/* #define AW87XXX_PID_18_SYSINT_DEFAULT		(0x00) */
+
+/* SYSCTRL (0x03) detail */
+/* EN_SS bit 7 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_EN_SS_START_BIT	(7)
+#define AW87XXX_PID_18_EN_SS_BITS_LEN	(1)
+#define AW87XXX_PID_18_EN_SS_MASK		\
+	(~(((1<<AW87XXX_PID_18_EN_SS_BITS_LEN)-1) << AW87XXX_PID_18_EN_SS_START_BIT))
+
+#define AW87XXX_PID_18_EN_SS_DISABLE_REG_FSS11001P6MHZ	(0)
+#define AW87XXX_PID_18_EN_SS_DISABLE_REG_FSS11001P6MHZ_VALUE	\
+	(AW87XXX_PID_18_EN_SS_DISABLE_REG_FSS11001P6MHZ << AW87XXX_PID_18_EN_SS_START_BIT)
+
+#define AW87XXX_PID_18_EN_SS_ENABLE		(1)
+#define AW87XXX_PID_18_EN_SS_ENABLE_VALUE	\
+	(AW87XXX_PID_18_EN_SS_ENABLE << AW87XXX_PID_18_EN_SS_START_BIT)
+
+#define AW87XXX_PID_18_EN_SS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_EN_SS_DEFAULT	\
+	(AW87XXX_PID_18_EN_SS_DEFAULT_VALUE << AW87XXX_PID_18_EN_SS_START_BIT)
+
+/* REG_EN_SW bit 6 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_EN_SW_START_BIT	(6)
+#define AW87XXX_PID_18_REG_EN_SW_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_SW_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_SW_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_SW_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_SW_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_SW_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_SW_DISABLE << AW87XXX_PID_18_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_SW_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_SW_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_SW_ENABLE << AW87XXX_PID_18_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_SW_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_SW_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_SW_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_SW_START_BIT)
+
+/* REG_EN_PA bit 5 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_EN_PA_START_BIT	(5)
+#define AW87XXX_PID_18_REG_EN_PA_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_PA_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_PA_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_PA_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_PA_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_PA_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_PA_DISABLE << AW87XXX_PID_18_REG_EN_PA_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_PA_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_PA_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_PA_ENABLE << AW87XXX_PID_18_REG_EN_PA_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_PA_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_PA_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_PA_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_PA_START_BIT)
+
+/* REG_EN_ADAP bit 4 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_EN_ADAP_START_BIT	(4)
+#define AW87XXX_PID_18_REG_EN_ADAP_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_ADAP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_ADAP_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_ADAP_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_ADAP_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_ADAP_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_ADAP_DISABLE << AW87XXX_PID_18_REG_EN_ADAP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_ADAP_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_ADAP_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_ADAP_ENABLE << AW87XXX_PID_18_REG_EN_ADAP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_ADAP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_ADAP_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_ADAP_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_ADAP_START_BIT)
+
+/* REG_EN_MPD bit 3 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_EN_MPD_START_BIT	(3)
+#define AW87XXX_PID_18_REG_EN_MPD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_MPD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_MPD_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_MPD_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_MPD_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_MPD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_MPD_DISABLE << AW87XXX_PID_18_REG_EN_MPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_MPD_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_MPD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_MPD_ENABLE << AW87XXX_PID_18_REG_EN_MPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_MPD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_MPD_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_MPD_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_MPD_START_BIT)
+
+/* REG_EN_CP bit 2 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_EN_CP_START_BIT	(2)
+#define AW87XXX_PID_18_REG_EN_CP_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_CP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_CP_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_CP_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_CP_DISABLE_PVDDVBAT_DIRECT_TROUGH_MODE	(0)
+#define AW87XXX_PID_18_REG_EN_CP_DISABLE_PVDDVBAT_DIRECT_TROUGH_MODE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_CP_DISABLE_PVDDVBAT_DIRECT_TROUGH_MODE << AW87XXX_PID_18_REG_EN_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_CP_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_CP_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_CP_ENABLE << AW87XXX_PID_18_REG_EN_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_CP_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_CP_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_CP_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_CP_START_BIT)
+
+/* REG_REC_MODE bit 1 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_REC_MODE_START_BIT	(1)
+#define AW87XXX_PID_18_REG_REC_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_REC_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_REC_MODE_BITS_LEN)-1) << AW87XXX_PID_18_REG_REC_MODE_START_BIT))
+
+#define AW87XXX_PID_18_REG_REC_MODE_DISABLE	(0)
+#define AW87XXX_PID_18_REG_REC_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_REC_MODE_DISABLE << AW87XXX_PID_18_REG_REC_MODE_START_BIT)
+
+#define AW87XXX_PID_18_REG_REC_MODE_ENABLE	(1)
+#define AW87XXX_PID_18_REG_REC_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_REC_MODE_ENABLE << AW87XXX_PID_18_REG_REC_MODE_START_BIT)
+
+#define AW87XXX_PID_18_REG_REC_MODE_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_REC_MODE_DEFAULT	\
+	(AW87XXX_PID_18_REG_REC_MODE_DEFAULT_VALUE << AW87XXX_PID_18_REG_REC_MODE_START_BIT)
+
+/* REG_FORCE_2X bit 0 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_FORCE_2X_START_BIT	(0)
+#define AW87XXX_PID_18_REG_FORCE_2X_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_FORCE_2X_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_FORCE_2X_BITS_LEN)-1) << AW87XXX_PID_18_REG_FORCE_2X_START_BIT))
+
+#define AW87XXX_PID_18_REG_FORCE_2X_DISABLE_CPS_WORKING_STATUS_DEPENDS_ON_THE_SYSTEM	(0)
+#define AW87XXX_PID_18_REG_FORCE_2X_DISABLE_CPS_WORKING_STATUS_DEPENDS_ON_THE_SYSTEM_VALUE	\
+	(AW87XXX_PID_18_REG_FORCE_2X_DISABLE_CPS_WORKING_STATUS_DEPENDS_ON_THE_SYSTEM << AW87XXX_PID_18_REG_FORCE_2X_START_BIT)
+
+#define AW87XXX_PID_18_REG_FORCE_2X_ENABLE_FORCE_THE_CP_WORKS_IN_X2_MODE	(1)
+#define AW87XXX_PID_18_REG_FORCE_2X_ENABLE_FORCE_THE_CP_WORKS_IN_X2_MODE_VALUE	\
+	(AW87XXX_PID_18_REG_FORCE_2X_ENABLE_FORCE_THE_CP_WORKS_IN_X2_MODE << AW87XXX_PID_18_REG_FORCE_2X_START_BIT)
+
+#define AW87XXX_PID_18_REG_FORCE_2X_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_FORCE_2X_DEFAULT	\
+	(AW87XXX_PID_18_REG_FORCE_2X_DEFAULT_VALUE << AW87XXX_PID_18_REG_FORCE_2X_START_BIT)
+
+/* default value of SYSCTRL (0x03) */
+/* #define AW87XXX_PID_18_SYSCTRL_DEFAULT		(0xE5) */
+
+/* CPOC (0x04) detail */
+/* REG_CP_OVP bit 5:2 (CPOC 0x04) */
+#define AW87XXX_PID_18_REG_CP_OVP_START_BIT	(2)
+#define AW87XXX_PID_18_REG_CP_OVP_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_CP_OVP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_OVP_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_OVP_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_OVP_8P5V	(8)
+#define AW87XXX_PID_18_REG_CP_OVP_8P5V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_8P5V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_8P25V	(7)
+#define AW87XXX_PID_18_REG_CP_OVP_8P25V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_8P25V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_8V	(6)
+#define AW87XXX_PID_18_REG_CP_OVP_8V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_8V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_7P75V	(5)
+#define AW87XXX_PID_18_REG_CP_OVP_7P75V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_7P75V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_7P5V	(4)
+#define AW87XXX_PID_18_REG_CP_OVP_7P5V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_7P5V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_7P25V	(3)
+#define AW87XXX_PID_18_REG_CP_OVP_7P25V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_7P25V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_7V	(2)
+#define AW87XXX_PID_18_REG_CP_OVP_7V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_7V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_6P75V	(1)
+#define AW87XXX_PID_18_REG_CP_OVP_6P75V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_6P75V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_6P5V	(0)
+#define AW87XXX_PID_18_REG_CP_OVP_6P5V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_6P5V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_DEFAULT_VALUE	(0x6)
+#define AW87XXX_PID_18_REG_CP_OVP_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_OVP_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+/* REG_OC_DELAY bit 1:0 (CPOC 0x04) */
+#define AW87XXX_PID_18_REG_OC_DELAY_START_BIT	(0)
+#define AW87XXX_PID_18_REG_OC_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_OC_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_OC_DELAY_BITS_LEN)-1) << AW87XXX_PID_18_REG_OC_DELAY_START_BIT))
+
+#define AW87XXX_PID_18_REG_OC_DELAY_60NS	(0)
+#define AW87XXX_PID_18_REG_OC_DELAY_60NS_VALUE	\
+	(AW87XXX_PID_18_REG_OC_DELAY_60NS << AW87XXX_PID_18_REG_OC_DELAY_START_BIT)
+
+#define AW87XXX_PID_18_REG_OC_DELAY_80NS	(1)
+#define AW87XXX_PID_18_REG_OC_DELAY_80NS_VALUE	\
+	(AW87XXX_PID_18_REG_OC_DELAY_80NS << AW87XXX_PID_18_REG_OC_DELAY_START_BIT)
+
+#define AW87XXX_PID_18_REG_OC_DELAY_90NS	(2)
+#define AW87XXX_PID_18_REG_OC_DELAY_90NS_VALUE	\
+	(AW87XXX_PID_18_REG_OC_DELAY_90NS << AW87XXX_PID_18_REG_OC_DELAY_START_BIT)
+
+#define AW87XXX_PID_18_REG_OC_DELAY_110NS	(3)
+#define AW87XXX_PID_18_REG_OC_DELAY_110NS_VALUE	\
+	(AW87XXX_PID_18_REG_OC_DELAY_110NS << AW87XXX_PID_18_REG_OC_DELAY_START_BIT)
+
+#define AW87XXX_PID_18_REG_OC_DELAY_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_OC_DELAY_DEFAULT	\
+	(AW87XXX_PID_18_REG_OC_DELAY_DEFAULT_VALUE << AW87XXX_PID_18_REG_OC_DELAY_START_BIT)
+
+/* default value of CPOC (0x04) */
+/* #define AW87XXX_PID_18_CPOC_DEFAULT		(0x18) */
+
+/* CLASSD (0x05) detail */
+/* REG_BK1 bit 7 (CLASSD 0x05) */
+#define AW87XXX_PID_18_REG_BK1_START_BIT	(7)
+#define AW87XXX_PID_18_REG_BK1_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_BK1_MASK		\
+	(~(((1<<AW87XXX_PID_18_REG_BK1_BITS_LEN)-1) << AW87XXX_PID_18_REG_BK1_START_BIT))
+
+#define AW87XXX_PID_18_REG_BK1_22MV		(0)
+#define AW87XXX_PID_18_REG_BK1_22MV_VALUE	\
+	(AW87XXX_PID_18_REG_BK1_22MV << AW87XXX_PID_18_REG_BK1_START_BIT)
+
+#define AW87XXX_PID_18_REG_BK1_15MV		(1)
+#define AW87XXX_PID_18_REG_BK1_15MV_VALUE	\
+	(AW87XXX_PID_18_REG_BK1_15MV << AW87XXX_PID_18_REG_BK1_START_BIT)
+
+#define AW87XXX_PID_18_REG_BK1_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_BK1_DEFAULT	\
+	(AW87XXX_PID_18_REG_BK1_DEFAULT_VALUE << AW87XXX_PID_18_REG_BK1_START_BIT)
+
+/* REG_BK2 bit 6 (CLASSD 0x05) */
+#define AW87XXX_PID_18_REG_BK2_START_BIT	(6)
+#define AW87XXX_PID_18_REG_BK2_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_BK2_MASK		\
+	(~(((1<<AW87XXX_PID_18_REG_BK2_BITS_LEN)-1) << AW87XXX_PID_18_REG_BK2_START_BIT))
+
+#define AW87XXX_PID_18_REG_BK2_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_BK2_DEFAULT	\
+	(AW87XXX_PID_18_REG_BK2_DEFAULT_VALUE << AW87XXX_PID_18_REG_BK2_START_BIT)
+
+/* REG_BK3 bit 5 (CLASSD 0x05) */
+#define AW87XXX_PID_18_REG_BK3_START_BIT	(5)
+#define AW87XXX_PID_18_REG_BK3_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_BK3_MASK		\
+	(~(((1<<AW87XXX_PID_18_REG_BK3_BITS_LEN)-1) << AW87XXX_PID_18_REG_BK3_START_BIT))
+
+#define AW87XXX_PID_18_REG_BK3_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_BK3_DEFAULT	\
+	(AW87XXX_PID_18_REG_BK3_DEFAULT_VALUE << AW87XXX_PID_18_REG_BK3_START_BIT)
+
+/* REG_D_GAIN bit 4:0 (CLASSD 0x05) */
+#define AW87XXX_PID_18_REG_D_GAIN_START_BIT	(0)
+#define AW87XXX_PID_18_REG_D_GAIN_BITS_LEN	(5)
+#define AW87XXX_PID_18_REG_D_GAIN_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_D_GAIN_BITS_LEN)-1) << AW87XXX_PID_18_REG_D_GAIN_START_BIT))
+
+#define AW87XXX_PID_18_REG_D_GAIN_0DB	(0)
+#define AW87XXX_PID_18_REG_D_GAIN_0DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_0DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_1P5DB	(1)
+#define AW87XXX_PID_18_REG_D_GAIN_1P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_1P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_3DB	(2)
+#define AW87XXX_PID_18_REG_D_GAIN_3DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_3DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_4P5DB	(3)
+#define AW87XXX_PID_18_REG_D_GAIN_4P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_4P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_6DB	(4)
+#define AW87XXX_PID_18_REG_D_GAIN_6DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_6DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_7P5DB	(5)
+#define AW87XXX_PID_18_REG_D_GAIN_7P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_7P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_9DB	(6)
+#define AW87XXX_PID_18_REG_D_GAIN_9DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_9DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_10P5DB	(7)
+#define AW87XXX_PID_18_REG_D_GAIN_10P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_10P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_12DB	(8)
+#define AW87XXX_PID_18_REG_D_GAIN_12DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_12DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_13P5DB	(9)
+#define AW87XXX_PID_18_REG_D_GAIN_13P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_13P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_15DB	(10)
+#define AW87XXX_PID_18_REG_D_GAIN_15DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_15DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_16P5DB	(11)
+#define AW87XXX_PID_18_REG_D_GAIN_16P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_16P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_18DB	(12)
+#define AW87XXX_PID_18_REG_D_GAIN_18DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_18DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_19P5DB	(13)
+#define AW87XXX_PID_18_REG_D_GAIN_19P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_19P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_21DB	(14)
+#define AW87XXX_PID_18_REG_D_GAIN_21DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_21DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_22P5DB	(15)
+#define AW87XXX_PID_18_REG_D_GAIN_22P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_22P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_24DB	(16)
+#define AW87XXX_PID_18_REG_D_GAIN_24DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_24DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_25P5DB	(17)
+#define AW87XXX_PID_18_REG_D_GAIN_25P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_25P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_27DB	(18)
+#define AW87XXX_PID_18_REG_D_GAIN_27DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_27DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_DEFAULT_VALUE	(0x10)
+#define AW87XXX_PID_18_REG_D_GAIN_DEFAULT	\
+	(AW87XXX_PID_18_REG_D_GAIN_DEFAULT_VALUE << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+/* default value of CLASSD (0x05) */
+/* #define AW87XXX_PID_18_CLASSD_DEFAULT		(0x10) */
+
+/* MADPVTH (0x06) detail */
+/* REG_ADAP_VTH bit 3:2 (MADPVTH 0x06) */
+#define AW87XXX_PID_18_REG_ADAP_VTH_START_BIT	(2)
+#define AW87XXX_PID_18_REG_ADAP_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_ADAP_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_ADAP_VTH_BITS_LEN)-1) << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT))
+
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P1W0P05W	(0)
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P1W0P05W_VALUE	\
+	(AW87XXX_PID_18_REG_ADAP_VTH_0P1W0P05W << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P2W0P15W	(1)
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P2W0P15W_VALUE	\
+	(AW87XXX_PID_18_REG_ADAP_VTH_0P2W0P15W << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P3W0P25W	(2)
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P3W0P25W_VALUE	\
+	(AW87XXX_PID_18_REG_ADAP_VTH_0P3W0P25W << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P4W0P35W	(3)
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P4W0P35W_VALUE	\
+	(AW87XXX_PID_18_REG_ADAP_VTH_0P4W0P35W << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_ADAP_VTH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_ADAP_VTH_DEFAULT	\
+	(AW87XXX_PID_18_REG_ADAP_VTH_DEFAULT_VALUE << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT)
+
+/* REG_MPD_VTH bit 1:0 (MADPVTH 0x06) */
+#define AW87XXX_PID_18_REG_MPD_VTH_START_BIT	(0)
+#define AW87XXX_PID_18_REG_MPD_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_MPD_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_MPD_VTH_BITS_LEN)-1) << AW87XXX_PID_18_REG_MPD_VTH_START_BIT))
+
+#define AW87XXX_PID_18_REG_MPD_VTH_8P1MW3P6MW	(0)
+#define AW87XXX_PID_18_REG_MPD_VTH_8P1MW3P6MW_VALUE	\
+	(AW87XXX_PID_18_REG_MPD_VTH_8P1MW3P6MW << AW87XXX_PID_18_REG_MPD_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_MPD_VTH_11MW5P6MW	(1)
+#define AW87XXX_PID_18_REG_MPD_VTH_11MW5P6MW_VALUE	\
+	(AW87XXX_PID_18_REG_MPD_VTH_11MW5P6MW << AW87XXX_PID_18_REG_MPD_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_MPD_VTH_14P4MW8P1MW	(2)
+#define AW87XXX_PID_18_REG_MPD_VTH_14P4MW8P1MW_VALUE	\
+	(AW87XXX_PID_18_REG_MPD_VTH_14P4MW8P1MW << AW87XXX_PID_18_REG_MPD_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_MPD_VTH_18P2MW11W	(3)
+#define AW87XXX_PID_18_REG_MPD_VTH_18P2MW11W_VALUE	\
+	(AW87XXX_PID_18_REG_MPD_VTH_18P2MW11W << AW87XXX_PID_18_REG_MPD_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_MPD_VTH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_MPD_VTH_DEFAULT	\
+	(AW87XXX_PID_18_REG_MPD_VTH_DEFAULT_VALUE << AW87XXX_PID_18_REG_MPD_VTH_START_BIT)
+
+/* default value of MADPVTH (0x06) */
+/* #define AW87XXX_PID_18_MADPVTH_DEFAULT		(0x05) */
+
+/* A3PARAM (0x07) detail */
+/* REG_AGC3_RT bit 7:5 (A3PARAM 0x07) */
+#define AW87XXX_PID_18_REG_AGC3_RT_START_BIT	(5)
+#define AW87XXX_PID_18_REG_AGC3_RT_BITS_LEN	(3)
+#define AW87XXX_PID_18_REG_AGC3_RT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC3_RT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC3_RT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC3_RT_69P12MS	(0)
+#define AW87XXX_PID_18_REG_AGC3_RT_69P12MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_69P12MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_138P24MS	(1)
+#define AW87XXX_PID_18_REG_AGC3_RT_138P24MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_138P24MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_276P48MS	(2)
+#define AW87XXX_PID_18_REG_AGC3_RT_276P48MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_276P48MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_552P96MS	(3)
+#define AW87XXX_PID_18_REG_AGC3_RT_552P96MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_552P96MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_1107MS	(4)
+#define AW87XXX_PID_18_REG_AGC3_RT_1107MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_1107MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_2160MS	(5)
+#define AW87XXX_PID_18_REG_AGC3_RT_2160MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_2160MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_4320MS	(6)
+#define AW87XXX_PID_18_REG_AGC3_RT_4320MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_4320MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_18_REG_AGC3_RT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC3_RT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+/* REG_AGC3_AT bit 4:2 (A3PARAM 0x07) */
+#define AW87XXX_PID_18_REG_AGC3_AT_START_BIT	(2)
+#define AW87XXX_PID_18_REG_AGC3_AT_BITS_LEN	(3)
+#define AW87XXX_PID_18_REG_AGC3_AT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC3_AT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC3_AT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC3_AT_5P76MS_0P32MSSTEP	(0)
+#define AW87XXX_PID_18_REG_AGC3_AT_5P76MS_0P32MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_5P76MS_0P32MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_11P52MS_0P64MSSTEP	(1)
+#define AW87XXX_PID_18_REG_AGC3_AT_11P52MS_0P64MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_11P52MS_0P64MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_23P04MS_1P28MSSTEP	(2)
+#define AW87XXX_PID_18_REG_AGC3_AT_23P04MS_1P28MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_23P04MS_1P28MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_92P16MS_5P12MSSTEP	(3)
+#define AW87XXX_PID_18_REG_AGC3_AT_92P16MS_5P12MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_92P16MS_5P12MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_368P64MS_20P48MSSTEP	(4)
+#define AW87XXX_PID_18_REG_AGC3_AT_368P64MS_20P48MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_368P64MS_20P48MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_738MS_41MSSTEP	(5)
+#define AW87XXX_PID_18_REG_AGC3_AT_738MS_41MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_738MS_41MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_1476MS_82MSSTEP	(6)
+#define AW87XXX_PID_18_REG_AGC3_AT_1476MS_82MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_1476MS_82MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_2952MS_164MSSTEP	(7)
+#define AW87XXX_PID_18_REG_AGC3_AT_2952MS_164MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_2952MS_164MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_18_REG_AGC3_AT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC3_AT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+/* REG_AGC3_1ST_AT bit 1:0 (A3PARAM 0x07) */
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT	(0)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC3_1ST_AT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_5P12MS	(0)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_5P12MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_1ST_AT_5P12MS << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_10P24MS	(1)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_10P24MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_1ST_AT_10P24MS << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_20P48MS	(2)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_20P48MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_1ST_AT_20P48MS << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_41MS	(3)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_41MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_1ST_AT_41MS << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC3_1ST_AT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT)
+
+/* default value of A3PARAM (0x07) */
+/* #define AW87XXX_PID_18_A3PARAM_DEFAULT		(0x52) */
+
+/* A3A2PO (0x08) detail */
+/* REG_AGC3_PO bit 7:4 (A3A2PO 0x08) */
+#define AW87XXX_PID_18_REG_AGC3_PO_START_BIT	(4)
+#define AW87XXX_PID_18_REG_AGC3_PO_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_AGC3_PO_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC3_PO_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC3_PO_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P2W8_OHM_0P27W6_OHM_0P05W32_OHM	(0)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P2W8_OHM_0P27W6_OHM_0P05W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P2W8_OHM_0P27W6_OHM_0P05W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P3W8_OHM_0P4W6_OHM_0P075W32_OHM	(1)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P3W8_OHM_0P4W6_OHM_0P075W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P3W8_OHM_0P4W6_OHM_0P075W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM	(2)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P5W8_OHM_0P67W6_OHM_0P125W32_OHM	(3)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P5W8_OHM_0P67W6_OHM_0P125W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P5W8_OHM_0P67W6_OHM_0P125W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM	(4)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P7W8_OHM_0P93W6_OHM_0P175W32_OHM	(5)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P7W8_OHM_0P93W6_OHM_0P175W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P7W8_OHM_0P93W6_OHM_0P175W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM	(6)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P9W8_OHM_1P2W6_OHM_0P225W32_OHM	(7)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P9W8_OHM_1P2W6_OHM_0P225W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P9W8_OHM_1P2W6_OHM_0P225W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM	(8)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P1W8_OHM_1P46W6_OHM_0P275W32_OHM	(9)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P1W8_OHM_1P46W6_OHM_0P275W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P1W8_OHM_1P46W6_OHM_0P275W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P2W8_OHM_1P6W6_OHM_0P30W32_OHM	(10)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P2W8_OHM_1P6W6_OHM_0P30W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P2W8_OHM_1P6W6_OHM_0P30W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P3W8_OHM_1P73W6_OHM_0P325W32_OHM	(11)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P3W8_OHM_1P73W6_OHM_0P325W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P3W8_OHM_1P73W6_OHM_0P325W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM	(12)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P5W8_OHM_2W6_OHM_0P375W32_OHM	(13)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P5W8_OHM_2W6_OHM_0P375W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P5W8_OHM_2W6_OHM_0P375W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM	(14)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_AGC3_OFF	(15)
+#define AW87XXX_PID_18_REG_AGC3_PO_AGC3_OFF_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_AGC3_OFF << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_DEFAULT_VALUE	(0xA)
+#define AW87XXX_PID_18_REG_AGC3_PO_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC3_PO_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+/* REG_AGC2_PO bit 3:0 (A3A2PO 0x08) */
+#define AW87XXX_PID_18_REG_AGC2_PO_START_BIT	(0)
+#define AW87XXX_PID_18_REG_AGC2_PO_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_AGC2_PO_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC2_PO_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC2_PO_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC2_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM	(0)
+#define AW87XXX_PID_18_REG_AGC2_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM	(1)
+#define AW87XXX_PID_18_REG_AGC2_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM	(2)
+#define AW87XXX_PID_18_REG_AGC2_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM	(3)
+#define AW87XXX_PID_18_REG_AGC2_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_1P2W8_OHM_1P6W6_OHM_0P3W32_OHM	(4)
+#define AW87XXX_PID_18_REG_AGC2_PO_1P2W8_OHM_1P6W6_OHM_0P3W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_1P2W8_OHM_1P6W6_OHM_0P3W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM	(5)
+#define AW87XXX_PID_18_REG_AGC2_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM	(6)
+#define AW87XXX_PID_18_REG_AGC2_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_1P8W8_OHM_2P4W6_OHM_0P45W32_OHM	(7)
+#define AW87XXX_PID_18_REG_AGC2_PO_1P8W8_OHM_2P4W6_OHM_0P45W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_1P8W8_OHM_2P4W6_OHM_0P45W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_2P0W8_OHM_2P66W6_OHM_0P5W32_OHM	(8)
+#define AW87XXX_PID_18_REG_AGC2_PO_2P0W8_OHM_2P66W6_OHM_0P5W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_2P0W8_OHM_2P66W6_OHM_0P5W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_AGC2_OFF	(9)
+#define AW87XXX_PID_18_REG_AGC2_PO_AGC2_OFF_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_AGC2_OFF << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_DEFAULT_VALUE	(0x6)
+#define AW87XXX_PID_18_REG_AGC2_PO_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC2_PO_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+/* default value of A3A2PO (0x08) */
+/* #define AW87XXX_PID_18_A3A2PO_DEFAULT		(0xA6) */
+
+/* A2PARAM (0x09) detail */
+/* REG_TEDGE bit 5 (A2PARAM 0x09) */
+#define AW87XXX_PID_18_REG_TEDGE_START_BIT	(5)
+#define AW87XXX_PID_18_REG_TEDGE_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_TEDGE_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_TEDGE_BITS_LEN)-1) << AW87XXX_PID_18_REG_TEDGE_START_BIT))
+
+#define AW87XXX_PID_18_REG_TEDGE_4NS	(0)
+#define AW87XXX_PID_18_REG_TEDGE_4NS_VALUE	\
+	(AW87XXX_PID_18_REG_TEDGE_4NS << AW87XXX_PID_18_REG_TEDGE_START_BIT)
+
+#define AW87XXX_PID_18_REG_TEDGE_12NS	(1)
+#define AW87XXX_PID_18_REG_TEDGE_12NS_VALUE	\
+	(AW87XXX_PID_18_REG_TEDGE_12NS << AW87XXX_PID_18_REG_TEDGE_START_BIT)
+
+#define AW87XXX_PID_18_REG_TEDGE_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_TEDGE_DEFAULT	\
+	(AW87XXX_PID_18_REG_TEDGE_DEFAULT_VALUE << AW87XXX_PID_18_REG_TEDGE_START_BIT)
+
+/* REG_AGC2_AT bit 4:2 (A2PARAM 0x09) */
+#define AW87XXX_PID_18_REG_AGC2_AT_START_BIT	(2)
+#define AW87XXX_PID_18_REG_AGC2_AT_BITS_LEN	(3)
+#define AW87XXX_PID_18_REG_AGC2_AT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC2_AT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC2_AT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC2_AT_1P44MS_0P08MSSTEP	(0)
+#define AW87XXX_PID_18_REG_AGC2_AT_1P44MS_0P08MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_1P44MS_0P08MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_2P88MS_0P16MSSTEP	(1)
+#define AW87XXX_PID_18_REG_AGC2_AT_2P88MS_0P16MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_2P88MS_0P16MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_5P76MS_0P32MSSTEP	(2)
+#define AW87XXX_PID_18_REG_AGC2_AT_5P76MS_0P32MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_5P76MS_0P32MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_23P04MS_1P28MSSTEP	(3)
+#define AW87XXX_PID_18_REG_AGC2_AT_23P04MS_1P28MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_23P04MS_1P28MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_92P16MS_5P12MSSTEP	(4)
+#define AW87XXX_PID_18_REG_AGC2_AT_92P16MS_5P12MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_92P16MS_5P12MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_368P64MS_20P48MSSTEP	(5)
+#define AW87XXX_PID_18_REG_AGC2_AT_368P64MS_20P48MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_368P64MS_20P48MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_737P28MS_41MSSTEP	(6)
+#define AW87XXX_PID_18_REG_AGC2_AT_737P28MS_41MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_737P28MS_41MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_1474P56MS_82MSSTEP	(7)
+#define AW87XXX_PID_18_REG_AGC2_AT_1474P56MS_82MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_1474P56MS_82MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_18_REG_AGC2_AT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC2_AT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+/* REG_AGC2_1ST_AT bit 1:0 (A2PARAM 0x09) */
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT	(0)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC2_1ST_AT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_0P08MS	(0)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_0P08MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_1ST_AT_0P08MS << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_0P32MS	(1)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_0P32MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_1ST_AT_0P32MS << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_1P28MS	(2)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_1P28MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_1ST_AT_1P28MS << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_5P12MS	(3)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_5P12MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_1ST_AT_5P12MS << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC2_1ST_AT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT)
+
+/* default value of A2PARAM (0x09) */
+/* #define AW87XXX_PID_18_A2PARAM_DEFAULT		(0x08) */
+
+/* A1PARAM (0x0A) detail */
+/* REG_AGC1_PO bit 6:3 (A1PARAM 0x0A) */
+#define AW87XXX_PID_18_REG_AGC1_PO_START_BIT	(3)
+#define AW87XXX_PID_18_REG_AGC1_PO_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_AGC1_PO_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC1_PO_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC1_PO_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC1_PO_5V	(0)
+#define AW87XXX_PID_18_REG_AGC1_PO_5V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_5V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_5P2V	(1)
+#define AW87XXX_PID_18_REG_AGC1_PO_5P2V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_5P2V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_5P4V	(2)
+#define AW87XXX_PID_18_REG_AGC1_PO_5P4V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_5P4V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_5P6V	(3)
+#define AW87XXX_PID_18_REG_AGC1_PO_5P6V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_5P6V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_5P8V	(4)
+#define AW87XXX_PID_18_REG_AGC1_PO_5P8V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_5P8V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_6P0V	(5)
+#define AW87XXX_PID_18_REG_AGC1_PO_6P0V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_6P0V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_6P2V	(6)
+#define AW87XXX_PID_18_REG_AGC1_PO_6P2V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_6P2V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_6P4V	(7)
+#define AW87XXX_PID_18_REG_AGC1_PO_6P4V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_6P4V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_6P6V	(8)
+#define AW87XXX_PID_18_REG_AGC1_PO_6P6V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_6P6V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_6P8V	(9)
+#define AW87XXX_PID_18_REG_AGC1_PO_6P8V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_6P8V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_7V	(10)
+#define AW87XXX_PID_18_REG_AGC1_PO_7V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_7V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_7P2V	(11)
+#define AW87XXX_PID_18_REG_AGC1_PO_7P2V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_7P2V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_7P4V	(12)
+#define AW87XXX_PID_18_REG_AGC1_PO_7P4V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_7P4V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_7P6V	(13)
+#define AW87XXX_PID_18_REG_AGC1_PO_7P6V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_7P6V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_7P8V	(14)
+#define AW87XXX_PID_18_REG_AGC1_PO_7P8V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_7P8V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_8V	(15)
+#define AW87XXX_PID_18_REG_AGC1_PO_8V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_8V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_DEFAULT_VALUE	(0x9)
+#define AW87XXX_PID_18_REG_AGC1_PO_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC1_PO_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+/* REG_AGC1_AT bit 2:1 (A1PARAM 0x0A) */
+#define AW87XXX_PID_18_REG_AGC1_AT_START_BIT	(1)
+#define AW87XXX_PID_18_REG_AGC1_AT_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_AGC1_AT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC1_AT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC1_AT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC1_AT_0P48MS_0P02MSSTEP	(0)
+#define AW87XXX_PID_18_REG_AGC1_AT_0P48MS_0P02MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_AT_0P48MS_0P02MSSTEP << AW87XXX_PID_18_REG_AGC1_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_AT_0P96MS_0P04MSSTEP	(1)
+#define AW87XXX_PID_18_REG_AGC1_AT_0P96MS_0P04MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_AT_0P96MS_0P04MSSTEP << AW87XXX_PID_18_REG_AGC1_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_AT_1P92MS_0P08MSSTEP	(2)
+#define AW87XXX_PID_18_REG_AGC1_AT_1P92MS_0P08MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_AT_1P92MS_0P08MSSTEP << AW87XXX_PID_18_REG_AGC1_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_AT_3P84MS_0P16MSSTEP	(3)
+#define AW87XXX_PID_18_REG_AGC1_AT_3P84MS_0P16MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_AT_3P84MS_0P16MSSTEP << AW87XXX_PID_18_REG_AGC1_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_AT_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_AGC1_AT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC1_AT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC1_AT_START_BIT)
+
+/* REG_PD_AGC1 bit 0 (A1PARAM 0x0A) */
+#define AW87XXX_PID_18_REG_PD_AGC1_START_BIT	(0)
+#define AW87XXX_PID_18_REG_PD_AGC1_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_PD_AGC1_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_PD_AGC1_BITS_LEN)-1) << AW87XXX_PID_18_REG_PD_AGC1_START_BIT))
+
+#define AW87XXX_PID_18_REG_PD_AGC1_ENABLE_FASTEST_LEVEL_AGC	(0)
+#define AW87XXX_PID_18_REG_PD_AGC1_ENABLE_FASTEST_LEVEL_AGC_VALUE	\
+	(AW87XXX_PID_18_REG_PD_AGC1_ENABLE_FASTEST_LEVEL_AGC << AW87XXX_PID_18_REG_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_AGC1_DISABLE_FASTEST_LEVEL_AGC	(1)
+#define AW87XXX_PID_18_REG_PD_AGC1_DISABLE_FASTEST_LEVEL_AGC_VALUE	\
+	(AW87XXX_PID_18_REG_PD_AGC1_DISABLE_FASTEST_LEVEL_AGC << AW87XXX_PID_18_REG_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_AGC1_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_PD_AGC1_DEFAULT	\
+	(AW87XXX_PID_18_REG_PD_AGC1_DEFAULT_VALUE << AW87XXX_PID_18_REG_PD_AGC1_START_BIT)
+
+/* default value of A1PARAM (0x0A) */
+/* #define AW87XXX_PID_18_A1PARAM_DEFAULT		(0x4A) */
+
+/* POPCLK (0x0B) detail */
+/* REG_DCLK_L bit 7 (POPCLK 0x0B) */
+#define AW87XXX_PID_18_REG_DCLK_L_START_BIT	(7)
+#define AW87XXX_PID_18_REG_DCLK_L_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_DCLK_L_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_DCLK_L_BITS_LEN)-1) << AW87XXX_PID_18_REG_DCLK_L_START_BIT))
+
+#define AW87XXX_PID_18_REG_DCLK_L_30NS	(0)
+#define AW87XXX_PID_18_REG_DCLK_L_30NS_VALUE	\
+	(AW87XXX_PID_18_REG_DCLK_L_30NS << AW87XXX_PID_18_REG_DCLK_L_START_BIT)
+
+#define AW87XXX_PID_18_REG_DCLK_L_45NS	(1)
+#define AW87XXX_PID_18_REG_DCLK_L_45NS_VALUE	\
+	(AW87XXX_PID_18_REG_DCLK_L_45NS << AW87XXX_PID_18_REG_DCLK_L_START_BIT)
+
+#define AW87XXX_PID_18_REG_DCLK_L_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_DCLK_L_DEFAULT	\
+	(AW87XXX_PID_18_REG_DCLK_L_DEFAULT_VALUE << AW87XXX_PID_18_REG_DCLK_L_START_BIT)
+
+/* REG_CLK_MAPD bit 6:5 (POPCLK 0x0B) */
+#define AW87XXX_PID_18_REG_CLK_MAPD_START_BIT	(5)
+#define AW87XXX_PID_18_REG_CLK_MAPD_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CLK_MAPD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CLK_MAPD_BITS_LEN)-1) << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT))
+
+#define AW87XXX_PID_18_REG_CLK_MAPD_40MS	(0)
+#define AW87XXX_PID_18_REG_CLK_MAPD_40MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_MAPD_40MS << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_MAPD_80MS	(1)
+#define AW87XXX_PID_18_REG_CLK_MAPD_80MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_MAPD_80MS << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_MAPD_160MS	(2)
+#define AW87XXX_PID_18_REG_CLK_MAPD_160MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_MAPD_160MS << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_MAPD_320MS	(3)
+#define AW87XXX_PID_18_REG_CLK_MAPD_320MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_MAPD_320MS << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_MAPD_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_CLK_MAPD_DEFAULT	\
+	(AW87XXX_PID_18_REG_CLK_MAPD_DEFAULT_VALUE << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT)
+
+/* REG_CLK_POP bit 4:3 (POPCLK 0x0B) */
+#define AW87XXX_PID_18_REG_CLK_POP_START_BIT	(3)
+#define AW87XXX_PID_18_REG_CLK_POP_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CLK_POP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CLK_POP_BITS_LEN)-1) << AW87XXX_PID_18_REG_CLK_POP_START_BIT))
+
+#define AW87XXX_PID_18_REG_CLK_POP_40MS	(0)
+#define AW87XXX_PID_18_REG_CLK_POP_40MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_POP_40MS << AW87XXX_PID_18_REG_CLK_POP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_POP_10MS	(1)
+#define AW87XXX_PID_18_REG_CLK_POP_10MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_POP_10MS << AW87XXX_PID_18_REG_CLK_POP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_POP_5MS	(2)
+#define AW87XXX_PID_18_REG_CLK_POP_5MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_POP_5MS << AW87XXX_PID_18_REG_CLK_POP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_POP_2P5MS	(3)
+#define AW87XXX_PID_18_REG_CLK_POP_2P5MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_POP_2P5MS << AW87XXX_PID_18_REG_CLK_POP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_POP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_CLK_POP_DEFAULT	\
+	(AW87XXX_PID_18_REG_CLK_POP_DEFAULT_VALUE << AW87XXX_PID_18_REG_CLK_POP_START_BIT)
+
+/* REG_CLK_OC bit 2:1 (POPCLK 0x0B) */
+#define AW87XXX_PID_18_REG_CLK_OC_START_BIT	(1)
+#define AW87XXX_PID_18_REG_CLK_OC_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CLK_OC_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CLK_OC_BITS_LEN)-1) << AW87XXX_PID_18_REG_CLK_OC_START_BIT))
+
+#define AW87XXX_PID_18_REG_CLK_OC_160MS	(0)
+#define AW87XXX_PID_18_REG_CLK_OC_160MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_OC_160MS << AW87XXX_PID_18_REG_CLK_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_OC_640MS	(1)
+#define AW87XXX_PID_18_REG_CLK_OC_640MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_OC_640MS << AW87XXX_PID_18_REG_CLK_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_OC_1280MS	(2)
+#define AW87XXX_PID_18_REG_CLK_OC_1280MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_OC_1280MS << AW87XXX_PID_18_REG_CLK_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_OC_SHUTDOWN_OUTPUT	(3)
+#define AW87XXX_PID_18_REG_CLK_OC_SHUTDOWN_OUTPUT_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_OC_SHUTDOWN_OUTPUT << AW87XXX_PID_18_REG_CLK_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_OC_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_CLK_OC_DEFAULT	\
+	(AW87XXX_PID_18_REG_CLK_OC_DEFAULT_VALUE << AW87XXX_PID_18_REG_CLK_OC_START_BIT)
+
+/* REG_AGC1_VTH bit 0 (POPCLK 0x0B) */
+#define AW87XXX_PID_18_REG_AGC1_VTH_START_BIT	(0)
+#define AW87XXX_PID_18_REG_AGC1_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_AGC1_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC1_VTH_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC1_VTH_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_SELECT_ONLY_FROM_RAMP_GEN	(0)
+#define AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_SELECT_ONLY_FROM_RAMP_GEN_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_SELECT_ONLY_FROM_RAMP_GEN << AW87XXX_PID_18_REG_AGC1_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_ADAPTIVELY_SELECT_FROM_RAMP_GEN_AND_THGEN	(1)
+#define AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_ADAPTIVELY_SELECT_FROM_RAMP_GEN_AND_THGEN_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_ADAPTIVELY_SELECT_FROM_RAMP_GEN_AND_THGEN << AW87XXX_PID_18_REG_AGC1_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_VTH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_AGC1_VTH_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC1_VTH_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC1_VTH_START_BIT)
+
+/* default value of POPCLK (0x0B) */
+/* #define AW87XXX_PID_18_POPCLK_DEFAULT		(0x21) */
+
+/* GTDRCPSS (0x0C) detail */
+/* REG_TDEAD bit 5 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_REG_TDEAD_START_BIT	(5)
+#define AW87XXX_PID_18_REG_TDEAD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_TDEAD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_TDEAD_BITS_LEN)-1) << AW87XXX_PID_18_REG_TDEAD_START_BIT))
+
+#define AW87XXX_PID_18_REG_TDEAD_17NS	(0)
+#define AW87XXX_PID_18_REG_TDEAD_17NS_VALUE	\
+	(AW87XXX_PID_18_REG_TDEAD_17NS << AW87XXX_PID_18_REG_TDEAD_START_BIT)
+
+#define AW87XXX_PID_18_REG_TDEAD_25NS	(1)
+#define AW87XXX_PID_18_REG_TDEAD_25NS_VALUE	\
+	(AW87XXX_PID_18_REG_TDEAD_25NS << AW87XXX_PID_18_REG_TDEAD_START_BIT)
+
+#define AW87XXX_PID_18_REG_TDEAD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_TDEAD_DEFAULT	\
+	(AW87XXX_PID_18_REG_TDEAD_DEFAULT_VALUE << AW87XXX_PID_18_REG_TDEAD_START_BIT)
+
+/* REG_CZ_35MV bit 4 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_REG_CZ_35MV_START_BIT	(4)
+#define AW87XXX_PID_18_REG_CZ_35MV_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_CZ_35MV_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CZ_35MV_BITS_LEN)-1) << AW87XXX_PID_18_REG_CZ_35MV_START_BIT))
+
+#define AW87XXX_PID_18_REG_CZ_35MV_25MV	(0)
+#define AW87XXX_PID_18_REG_CZ_35MV_25MV_VALUE	\
+	(AW87XXX_PID_18_REG_CZ_35MV_25MV << AW87XXX_PID_18_REG_CZ_35MV_START_BIT)
+
+#define AW87XXX_PID_18_REG_CZ_35MV_35MV	(1)
+#define AW87XXX_PID_18_REG_CZ_35MV_35MV_VALUE	\
+	(AW87XXX_PID_18_REG_CZ_35MV_35MV << AW87XXX_PID_18_REG_CZ_35MV_START_BIT)
+
+#define AW87XXX_PID_18_REG_CZ_35MV_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_CZ_35MV_DEFAULT	\
+	(AW87XXX_PID_18_REG_CZ_35MV_DEFAULT_VALUE << AW87XXX_PID_18_REG_CZ_35MV_START_BIT)
+
+/* BIT_CTRL bit 3 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_BIT_CTRL_START_BIT	(3)
+#define AW87XXX_PID_18_BIT_CTRL_BITS_LEN	(1)
+#define AW87XXX_PID_18_BIT_CTRL_MASK	\
+	(~(((1<<AW87XXX_PID_18_BIT_CTRL_BITS_LEN)-1) << AW87XXX_PID_18_BIT_CTRL_START_BIT))
+
+#define AW87XXX_PID_18_BIT_CTRL_32_STEP_SPREAD_SPECTRUM	(0)
+#define AW87XXX_PID_18_BIT_CTRL_32_STEP_SPREAD_SPECTRUM_VALUE	\
+	(AW87XXX_PID_18_BIT_CTRL_32_STEP_SPREAD_SPECTRUM << AW87XXX_PID_18_BIT_CTRL_START_BIT)
+
+#define AW87XXX_PID_18_BIT_CTRL_14_STEP_SPREAD_SPECTRUM	(1)
+#define AW87XXX_PID_18_BIT_CTRL_14_STEP_SPREAD_SPECTRUM_VALUE	\
+	(AW87XXX_PID_18_BIT_CTRL_14_STEP_SPREAD_SPECTRUM << AW87XXX_PID_18_BIT_CTRL_START_BIT)
+
+#define AW87XXX_PID_18_BIT_CTRL_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_BIT_CTRL_DEFAULT	\
+	(AW87XXX_PID_18_BIT_CTRL_DEFAULT_VALUE << AW87XXX_PID_18_BIT_CTRL_START_BIT)
+
+/* SS_EXCH bit 2 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_SS_EXCH_START_BIT	(2)
+#define AW87XXX_PID_18_SS_EXCH_BITS_LEN	(1)
+#define AW87XXX_PID_18_SS_EXCH_MASK		\
+	(~(((1<<AW87XXX_PID_18_SS_EXCH_BITS_LEN)-1) << AW87XXX_PID_18_SS_EXCH_START_BIT))
+
+#define AW87XXX_PID_18_SS_EXCH_12_RANGE	(0)
+#define AW87XXX_PID_18_SS_EXCH_12_RANGE_VALUE	\
+	(AW87XXX_PID_18_SS_EXCH_12_RANGE << AW87XXX_PID_18_SS_EXCH_START_BIT)
+
+#define AW87XXX_PID_18_SS_EXCH_6_RANGE	(1)
+#define AW87XXX_PID_18_SS_EXCH_6_RANGE_VALUE	\
+	(AW87XXX_PID_18_SS_EXCH_6_RANGE << AW87XXX_PID_18_SS_EXCH_START_BIT)
+
+#define AW87XXX_PID_18_SS_EXCH_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_SS_EXCH_DEFAULT	\
+	(AW87XXX_PID_18_SS_EXCH_DEFAULT_VALUE << AW87XXX_PID_18_SS_EXCH_START_BIT)
+
+/* REG_ISTART bit 1 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_REG_ISTART_START_BIT	(1)
+#define AW87XXX_PID_18_REG_ISTART_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_ISTART_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_ISTART_BITS_LEN)-1) << AW87XXX_PID_18_REG_ISTART_START_BIT))
+
+#define AW87XXX_PID_18_REG_ISTART_IBIAS_WI_46P8NA	(0)
+#define AW87XXX_PID_18_REG_ISTART_IBIAS_WI_46P8NA_VALUE	\
+	(AW87XXX_PID_18_REG_ISTART_IBIAS_WI_46P8NA << AW87XXX_PID_18_REG_ISTART_START_BIT)
+
+#define AW87XXX_PID_18_REG_ISTART_IBIAS_WI_62P5NA	(1)
+#define AW87XXX_PID_18_REG_ISTART_IBIAS_WI_62P5NA_VALUE	\
+	(AW87XXX_PID_18_REG_ISTART_IBIAS_WI_62P5NA << AW87XXX_PID_18_REG_ISTART_START_BIT)
+
+#define AW87XXX_PID_18_REG_ISTART_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_ISTART_DEFAULT	\
+	(AW87XXX_PID_18_REG_ISTART_DEFAULT_VALUE << AW87XXX_PID_18_REG_ISTART_START_BIT)
+
+/* REG_PD_OVPICTRL bit 0 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_START_BIT	(0)
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_PD_OVPICTRL_BITS_LEN)-1) << AW87XXX_PID_18_REG_PD_OVPICTRL_START_BIT))
+
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_DISABLE	(0)
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_OVPICTRL_DISABLE << AW87XXX_PID_18_REG_PD_OVPICTRL_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_ENABLE	(1)
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_OVPICTRL_ENABLE << AW87XXX_PID_18_REG_PD_OVPICTRL_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_DEFAULT	\
+	(AW87XXX_PID_18_REG_PD_OVPICTRL_DEFAULT_VALUE << AW87XXX_PID_18_REG_PD_OVPICTRL_START_BIT)
+
+/* default value of GTDRCPSS (0x0C) */
+/* #define AW87XXX_PID_18_GTDRCPSS_DEFAULT		(0x08) */
+
+/* MULTI (0x0D) detail */
+/* REG_CP_FREQ bit 7:6 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_CP_FREQ_START_BIT	(6)
+#define AW87XXX_PID_18_REG_CP_FREQ_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CP_FREQ_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_FREQ_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_FREQ_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_FREQ_1P8MHZ	(0)
+#define AW87XXX_PID_18_REG_CP_FREQ_1P8MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_CP_FREQ_1P8MHZ << AW87XXX_PID_18_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_FREQ_1P6MHZ	(1)
+#define AW87XXX_PID_18_REG_CP_FREQ_1P6MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_CP_FREQ_1P6MHZ << AW87XXX_PID_18_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_FREQ_1P4MHZ	(2)
+#define AW87XXX_PID_18_REG_CP_FREQ_1P4MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_CP_FREQ_1P4MHZ << AW87XXX_PID_18_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_FREQ_2P1MHZ	(3)
+#define AW87XXX_PID_18_REG_CP_FREQ_2P1MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_CP_FREQ_2P1MHZ << AW87XXX_PID_18_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_FREQ_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_CP_FREQ_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_FREQ_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_FREQ_START_BIT)
+
+/* REG_EN_OT150 bit 5 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_OT150_START_BIT	(5)
+#define AW87XXX_PID_18_REG_EN_OT150_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_OT150_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_OT150_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_OT150_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_OT150_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_OT150_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_OT150_DISABLE << AW87XXX_PID_18_REG_EN_OT150_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_OT150_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_OT150_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_OT150_ENABLE << AW87XXX_PID_18_REG_EN_OT150_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_OT150_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_OT150_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_OT150_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_OT150_START_BIT)
+
+/* REG_EN_TEST bit 4 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_TEST_START_BIT	(4)
+#define AW87XXX_PID_18_REG_EN_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_TEST_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_TEST_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_TEST_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_TEST_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_TEST_DISABLE << AW87XXX_PID_18_REG_EN_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_TEST_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_TEST_ENABLE << AW87XXX_PID_18_REG_EN_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_TEST_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_TEST_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_TEST_START_BIT)
+
+/* REG_EN_CLASSD bit 3 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_CLASSD_START_BIT	(3)
+#define AW87XXX_PID_18_REG_EN_CLASSD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_CLASSD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_CLASSD_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_CLASSD_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_CLASSD_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_CLASSD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_CLASSD_DISABLE << AW87XXX_PID_18_REG_EN_CLASSD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_CLASSD_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_CLASSD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_CLASSD_ENABLE << AW87XXX_PID_18_REG_EN_CLASSD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_CLASSD_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_CLASSD_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_CLASSD_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_CLASSD_START_BIT)
+
+/* REG_EN_DEFAULT bit 2 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_DEFAULT_START_BIT	(2)
+#define AW87XXX_PID_18_REG_EN_DEFAULT_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_DEFAULT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_DEFAULT_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_DEFAULT_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_DEFAULT_SELF_DEFINE_THE_SETTINGS	(0)
+#define AW87XXX_PID_18_REG_EN_DEFAULT_SELF_DEFINE_THE_SETTINGS_VALUE	\
+	(AW87XXX_PID_18_REG_EN_DEFAULT_SELF_DEFINE_THE_SETTINGS << AW87XXX_PID_18_REG_EN_DEFAULT_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_DEFAULT_USE_THE_DEFAULT_SETTING_IN_THE_SYSCTRL_BLOCK	(1)
+#define AW87XXX_PID_18_REG_EN_DEFAULT_USE_THE_DEFAULT_SETTING_IN_THE_SYSCTRL_BLOCK_VALUE	\
+	(AW87XXX_PID_18_REG_EN_DEFAULT_USE_THE_DEFAULT_SETTING_IN_THE_SYSCTRL_BLOCK << AW87XXX_PID_18_REG_EN_DEFAULT_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_DEFAULT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_DEFAULT_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_DEFAULT_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_DEFAULT_START_BIT)
+
+/* REG_EN_ESD bit 1 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_ESD_START_BIT	(1)
+#define AW87XXX_PID_18_REG_EN_ESD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_ESD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_ESD_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_ESD_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_ESD_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_ESD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_ESD_DISABLE << AW87XXX_PID_18_REG_EN_ESD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_ESD_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_ESD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_ESD_ENABLE << AW87XXX_PID_18_REG_EN_ESD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_ESD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_ESD_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_ESD_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_ESD_START_BIT)
+
+/* REG_EN_MT bit 0 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_MT_START_BIT	(0)
+#define AW87XXX_PID_18_REG_EN_MT_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_MT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_MT_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_MT_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_MT_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_MT_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_MT_DISABLE << AW87XXX_PID_18_REG_EN_MT_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_MT_ENBLAE	(1)
+#define AW87XXX_PID_18_REG_EN_MT_ENBLAE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_MT_ENBLAE << AW87XXX_PID_18_REG_EN_MT_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_MT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_MT_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_MT_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_MT_START_BIT)
+
+/* default value of MULTI (0x0D) */
+/* #define AW87XXX_PID_18_MULTI_DEFAULT		(0x68) */
+
+/* DFT1 (0x61) detail */
+/* REG_SET_R2 bit 7 (DFT1 0x61) */
+#define AW87XXX_PID_18_REG_SET_R2_START_BIT	(7)
+#define AW87XXX_PID_18_REG_SET_R2_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_SET_R2_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_SET_R2_BITS_LEN)-1) << AW87XXX_PID_18_REG_SET_R2_START_BIT))
+
+#define AW87XXX_PID_18_REG_SET_R2_NOT_LIMIT_THE_HIGH_LEVEL_VTH	(0)
+#define AW87XXX_PID_18_REG_SET_R2_NOT_LIMIT_THE_HIGH_LEVEL_VTH_VALUE	\
+	(AW87XXX_PID_18_REG_SET_R2_NOT_LIMIT_THE_HIGH_LEVEL_VTH << AW87XXX_PID_18_REG_SET_R2_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_R2_LIMIT_THE_HIGH_LEVEL_VTH	(1)
+#define AW87XXX_PID_18_REG_SET_R2_LIMIT_THE_HIGH_LEVEL_VTH_VALUE	\
+	(AW87XXX_PID_18_REG_SET_R2_LIMIT_THE_HIGH_LEVEL_VTH << AW87XXX_PID_18_REG_SET_R2_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_R2_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_SET_R2_DEFAULT	\
+	(AW87XXX_PID_18_REG_SET_R2_DEFAULT_VALUE << AW87XXX_PID_18_REG_SET_R2_START_BIT)
+
+/* REG_CP_ISOFT bit 6:5 (DFT1 0x61) */
+#define AW87XXX_PID_18_REG_CP_ISOFT_START_BIT	(5)
+#define AW87XXX_PID_18_REG_CP_ISOFT_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CP_ISOFT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_ISOFT_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P2A	(0)
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P2A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_ISOFT_0P2A << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P3A	(1)
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P3A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_ISOFT_0P3A << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P4A	(2)
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P4A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_ISOFT_0P4A << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P5A	(3)
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P5A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_ISOFT_0P5A << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_ISOFT_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_CP_ISOFT_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_ISOFT_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT)
+
+/* REG_CP_IPEAK bit 4:2 (DFT1 0x61) */
+#define AW87XXX_PID_18_REG_CP_IPEAK_START_BIT	(2)
+#define AW87XXX_PID_18_REG_CP_IPEAK_BITS_LEN	(3)
+#define AW87XXX_PID_18_REG_CP_IPEAK_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_IPEAK_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_2A	(0)
+#define AW87XXX_PID_18_REG_CP_IPEAK_2A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_2A << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_2P5A	(1)
+#define AW87XXX_PID_18_REG_CP_IPEAK_2P5A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_2P5A << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_3A	(2)
+#define AW87XXX_PID_18_REG_CP_IPEAK_3A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_3A << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_3P5A	(3)
+#define AW87XXX_PID_18_REG_CP_IPEAK_3P5A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_3P5A << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_4A	(4)
+#define AW87XXX_PID_18_REG_CP_IPEAK_4A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_4A << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_CP_IPEAK_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+/* REG_SET_OCDT bit 1:0 (DFT1 0x61) */
+#define AW87XXX_PID_18_REG_SET_OCDT_START_BIT	(0)
+#define AW87XXX_PID_18_REG_SET_OCDT_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_SET_OCDT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_SET_OCDT_BITS_LEN)-1) << AW87XXX_PID_18_REG_SET_OCDT_START_BIT))
+
+#define AW87XXX_PID_18_REG_SET_OCDT_4P1A	(0)
+#define AW87XXX_PID_18_REG_SET_OCDT_4P1A_VALUE	\
+	(AW87XXX_PID_18_REG_SET_OCDT_4P1A << AW87XXX_PID_18_REG_SET_OCDT_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_OCDT_4P5A	(1)
+#define AW87XXX_PID_18_REG_SET_OCDT_4P5A_VALUE	\
+	(AW87XXX_PID_18_REG_SET_OCDT_4P5A << AW87XXX_PID_18_REG_SET_OCDT_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_OCDT_4P9A	(2)
+#define AW87XXX_PID_18_REG_SET_OCDT_4P9A_VALUE	\
+	(AW87XXX_PID_18_REG_SET_OCDT_4P9A << AW87XXX_PID_18_REG_SET_OCDT_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_OCDT_5P3A	(3)
+#define AW87XXX_PID_18_REG_SET_OCDT_5P3A_VALUE	\
+	(AW87XXX_PID_18_REG_SET_OCDT_5P3A << AW87XXX_PID_18_REG_SET_OCDT_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_OCDT_DEFAULT_VALUE	(0X2)
+#define AW87XXX_PID_18_REG_SET_OCDT_DEFAULT	\
+	(AW87XXX_PID_18_REG_SET_OCDT_DEFAULT_VALUE << AW87XXX_PID_18_REG_SET_OCDT_START_BIT)
+
+/* default value of DFT1 (0x61) */
+/* #define AW87XXX_PID_18_DFT1_DEFAULT		(0xA6) */
+
+/* DFT2 (0x62) detail */
+/* REG_CP_TEST bit 7 (DFT2 0x62) */
+#define AW87XXX_PID_18_REG_CP_TEST_START_BIT	(7)
+#define AW87XXX_PID_18_REG_CP_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_CP_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_TEST_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_TEST_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_TEST_DISABLE	(0)
+#define AW87XXX_PID_18_REG_CP_TEST_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_CP_TEST_DISABLE << AW87XXX_PID_18_REG_CP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_TEST_ENABLE	(1)
+#define AW87XXX_PID_18_REG_CP_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_CP_TEST_ENABLE << AW87XXX_PID_18_REG_CP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_CP_TEST_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_TEST_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_TEST_START_BIT)
+
+/* REG_VFAGC bit 6:4 (DFT2 0x62) */
+#define AW87XXX_PID_18_REG_VFAGC_START_BIT	(4)
+#define AW87XXX_PID_18_REG_VFAGC_BITS_LEN	(3)
+#define AW87XXX_PID_18_REG_VFAGC_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_VFAGC_BITS_LEN)-1) << AW87XXX_PID_18_REG_VFAGC_START_BIT))
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P775VDDVREF_FAGC_VHYS0P7VDD	(0)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P775VDDVREF_FAGC_VHYS0P7VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P775VDDVREF_FAGC_VHYS0P7VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P8VDDVREF_FAGC_VHYS0P725VDD	(1)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P8VDDVREF_FAGC_VHYS0P725VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P8VDDVREF_FAGC_VHYS0P725VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P825VDDVREF_FAGC_VHYS0P75VDD	(2)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P825VDDVREF_FAGC_VHYS0P75VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P825VDDVREF_FAGC_VHYS0P75VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P85VDDVREF_FAGC_VHYS0P775VDD	(3)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P85VDDVREF_FAGC_VHYS0P775VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P85VDDVREF_FAGC_VHYS0P775VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P875VDDVREF_FAGC_VHYS0P8VDD	(4)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P875VDDVREF_FAGC_VHYS0P8VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P875VDDVREF_FAGC_VHYS0P8VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P9VDDVREF_FAGC_VHYS0P825VDD	(5)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P9VDDVREF_FAGC_VHYS0P825VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P9VDDVREF_FAGC_VHYS0P825VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P925VDDVREF_FAGC_VHYS0P85VDD	(6)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P925VDDVREF_FAGC_VHYS0P85VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P925VDDVREF_FAGC_VHYS0P85VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_001	(7)
+#define AW87XXX_PID_18_REG_VFAGC_001_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_001 << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_VFAGC_DEFAULT	\
+	(AW87XXX_PID_18_REG_VFAGC_DEFAULT_VALUE << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+/* REG_CP_OVP_TEST bit 3:2 (DFT2 0x62) */
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT	(2)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_OVP_TEST_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_8P7V	(0)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_8P7V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_TEST_8P7V << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P0V	(1)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P0V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_TEST_9P0V << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P20V	(2)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P20V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_TEST_9P20V << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P5V	(3)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P5V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_TEST_9P5V << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_OVP_TEST_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT)
+
+/* REG_PAVG bit 1:0 (DFT2 0x62) */
+#define AW87XXX_PID_18_REG_PAVG_START_BIT	(0)
+#define AW87XXX_PID_18_REG_PAVG_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_PAVG_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_PAVG_BITS_LEN)-1) << AW87XXX_PID_18_REG_PAVG_START_BIT))
+
+#define AW87XXX_PID_18_REG_PAVG_PO0P94	(0)
+#define AW87XXX_PID_18_REG_PAVG_PO0P94_VALUE	\
+	(AW87XXX_PID_18_REG_PAVG_PO0P94 << AW87XXX_PID_18_REG_PAVG_START_BIT)
+
+#define AW87XXX_PID_18_REG_PAVG_PO1		(1)
+#define AW87XXX_PID_18_REG_PAVG_PO1_VALUE	\
+	(AW87XXX_PID_18_REG_PAVG_PO1 << AW87XXX_PID_18_REG_PAVG_START_BIT)
+
+#define AW87XXX_PID_18_REG_PAVG_PO1P06	(2)
+#define AW87XXX_PID_18_REG_PAVG_PO1P06_VALUE	\
+	(AW87XXX_PID_18_REG_PAVG_PO1P06 << AW87XXX_PID_18_REG_PAVG_START_BIT)
+
+#define AW87XXX_PID_18_REG_PAVG_TURN_TO_10	(3)
+#define AW87XXX_PID_18_REG_PAVG_TURN_TO_10_VALUE	\
+	(AW87XXX_PID_18_REG_PAVG_TURN_TO_10 << AW87XXX_PID_18_REG_PAVG_START_BIT)
+
+#define AW87XXX_PID_18_REG_PAVG_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_PAVG_DEFAULT	\
+	(AW87XXX_PID_18_REG_PAVG_DEFAULT_VALUE << AW87XXX_PID_18_REG_PAVG_START_BIT)
+
+/* default value of DFT2 (0x62) */
+/* #define AW87XXX_PID_18_DFT2_DEFAULT		(0x11) */
+
+/* DFT3 (0x63) detail */
+/* REG_TDEAD_CP bit 7 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_TDEAD_CP_START_BIT	(7)
+#define AW87XXX_PID_18_REG_TDEAD_CP_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_TDEAD_CP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_TDEAD_CP_BITS_LEN)-1) << AW87XXX_PID_18_REG_TDEAD_CP_START_BIT))
+
+#define AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT_SETTIG	(0)
+#define AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT_SETTIG_VALUE	\
+	(AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT_SETTIG << AW87XXX_PID_18_REG_TDEAD_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_TDEAD_CP_ENLARGE_THE_DEAD_TIME	(1)
+#define AW87XXX_PID_18_REG_TDEAD_CP_ENLARGE_THE_DEAD_TIME_VALUE	\
+	(AW87XXX_PID_18_REG_TDEAD_CP_ENLARGE_THE_DEAD_TIME << AW87XXX_PID_18_REG_TDEAD_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT	\
+	(AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT_VALUE << AW87XXX_PID_18_REG_TDEAD_CP_START_BIT)
+
+/* REG_EN_EXPVDD bit 6 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_EN_EXPVDD_START_BIT	(6)
+#define AW87XXX_PID_18_REG_EN_EXPVDD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_EXPVDD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_EXPVDD_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_EXPVDD_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_EXPVDD_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_EXPVDD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_EXPVDD_DISABLE << AW87XXX_PID_18_REG_EN_EXPVDD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_EXPVDD_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_EXPVDD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_EXPVDD_ENABLE << AW87XXX_PID_18_REG_EN_EXPVDD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_EXPVDD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_EXPVDD_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_EXPVDD_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_EXPVDD_START_BIT)
+
+/* REG_TM_MADP bit 5 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_TM_MADP_START_BIT	(5)
+#define AW87XXX_PID_18_REG_TM_MADP_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_TM_MADP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_TM_MADP_BITS_LEN)-1) << AW87XXX_PID_18_REG_TM_MADP_START_BIT))
+
+#define AW87XXX_PID_18_REG_TM_MADP_DISABLE	(0)
+#define AW87XXX_PID_18_REG_TM_MADP_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_TM_MADP_DISABLE << AW87XXX_PID_18_REG_TM_MADP_START_BIT)
+
+#define AW87XXX_PID_18_REG_TM_MADP_ENABLE	(1)
+#define AW87XXX_PID_18_REG_TM_MADP_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_TM_MADP_ENABLE << AW87XXX_PID_18_REG_TM_MADP_START_BIT)
+
+#define AW87XXX_PID_18_REG_TM_MADP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_TM_MADP_DEFAULT	\
+	(AW87XXX_PID_18_REG_TM_MADP_DEFAULT_VALUE << AW87XXX_PID_18_REG_TM_MADP_START_BIT)
+
+/* REG_PD_UVLO bit 4 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_PD_UVLO_START_BIT	(4)
+#define AW87XXX_PID_18_REG_PD_UVLO_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_PD_UVLO_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_PD_UVLO_BITS_LEN)-1) << AW87XXX_PID_18_REG_PD_UVLO_START_BIT))
+
+#define AW87XXX_PID_18_REG_PD_UVLO_ENABLE	(0)
+#define AW87XXX_PID_18_REG_PD_UVLO_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_UVLO_ENABLE << AW87XXX_PID_18_REG_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_UVLO_DISABLE	(1)
+#define AW87XXX_PID_18_REG_PD_UVLO_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_UVLO_DISABLE << AW87XXX_PID_18_REG_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_UVLO_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_PD_UVLO_DEFAULT	\
+	(AW87XXX_PID_18_REG_PD_UVLO_DEFAULT_VALUE << AW87XXX_PID_18_REG_PD_UVLO_START_BIT)
+
+/* REG_UVLO_VTH bit 3:2 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_UVLO_VTH_START_BIT	(2)
+#define AW87XXX_PID_18_REG_UVLO_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_UVLO_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_UVLO_VTH_BITS_LEN)-1) << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT))
+
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P6V2P5V	(0)
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P6V2P5V_VALUE	\
+	(AW87XXX_PID_18_REG_UVLO_VTH_2P6V2P5V << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P7V2P6V	(1)
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P7V2P6V_VALUE	\
+	(AW87XXX_PID_18_REG_UVLO_VTH_2P7V2P6V << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P5V2P4V	(2)
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P5V2P4V_VALUE	\
+	(AW87XXX_PID_18_REG_UVLO_VTH_2P5V2P4V << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_UVLO_VTH_TURN_TO_00	(3)
+#define AW87XXX_PID_18_REG_UVLO_VTH_TURN_TO_00_VALUE	\
+	(AW87XXX_PID_18_REG_UVLO_VTH_TURN_TO_00 << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_UVLO_VTH_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_UVLO_VTH_DEFAULT	\
+	(AW87XXX_PID_18_REG_UVLO_VTH_DEFAULT_VALUE << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT)
+
+/* REG_PD_CRS0 bit 1:0 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_PD_CRS0_START_BIT	(0)
+#define AW87XXX_PID_18_REG_PD_CRS0_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_PD_CRS0_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_PD_CRS0_BITS_LEN)-1) << AW87XXX_PID_18_REG_PD_CRS0_START_BIT))
+
+#define AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_ENABLE	(0)
+#define AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_ENABLE << AW87XXX_PID_18_REG_PD_CRS0_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_CRS0_BOTH_AGC2_AND_AGC3_CROSS_ZERO_ENABLE_AGC1_CROSS_ZERO_DISABLE	(1)
+#define AW87XXX_PID_18_REG_PD_CRS0_BOTH_AGC2_AND_AGC3_CROSS_ZERO_ENABLE_AGC1_CROSS_ZERO_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_CRS0_BOTH_AGC2_AND_AGC3_CROSS_ZERO_ENABLE_AGC1_CROSS_ZERO_DISABLE << AW87XXX_PID_18_REG_PD_CRS0_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_CRS0_ONLY_AGC3_CROSS_ZERO_ENABLE_AGC1_AND_AGC2_CROSS_ZERO_DISABLE	(2)
+#define AW87XXX_PID_18_REG_PD_CRS0_ONLY_AGC3_CROSS_ZERO_ENABLE_AGC1_AND_AGC2_CROSS_ZERO_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_CRS0_ONLY_AGC3_CROSS_ZERO_ENABLE_AGC1_AND_AGC2_CROSS_ZERO_DISABLE << AW87XXX_PID_18_REG_PD_CRS0_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_DISABLE	(3)
+#define AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_DISABLE << AW87XXX_PID_18_REG_PD_CRS0_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_CRS0_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_PD_CRS0_DEFAULT	\
+	(AW87XXX_PID_18_REG_PD_CRS0_DEFAULT_VALUE << AW87XXX_PID_18_REG_PD_CRS0_START_BIT)
+
+/* default value of DFT3 (0x63) */
+/* #define AW87XXX_PID_18_DFT3_DEFAULT		(0x00) */
+
+/* DFT4 (0x64) detail */
+/* REG_DEGLITCH_CP bit 7:6 (DFT4 0x64) */
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT	(6)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_DEGLITCH_CP_BITS_LEN)-1) << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT))
+
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_3NS	(0)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_3NS_VALUE	\
+	(AW87XXX_PID_18_REG_DEGLITCH_CP_3NS << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_5NS	(1)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_5NS_VALUE	\
+	(AW87XXX_PID_18_REG_DEGLITCH_CP_5NS << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_1NS	(2)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_1NS_VALUE	\
+	(AW87XXX_PID_18_REG_DEGLITCH_CP_1NS << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_0NS	(3)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_0NS_VALUE	\
+	(AW87XXX_PID_18_REG_DEGLITCH_CP_0NS << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_DEFAULT	\
+	(AW87XXX_PID_18_REG_DEGLITCH_CP_DEFAULT_VALUE << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT)
+
+/* REG_EDGE_CP bit 5:4 (DFT4 0x64) */
+#define AW87XXX_PID_18_REG_EDGE_CP_START_BIT	(4)
+#define AW87XXX_PID_18_REG_EDGE_CP_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_EDGE_CP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EDGE_CP_BITS_LEN)-1) << AW87XXX_PID_18_REG_EDGE_CP_START_BIT))
+
+#define AW87XXX_PID_18_REG_EDGE_CP_DEFAULT_14P8NS	(0)
+#define AW87XXX_PID_18_REG_EDGE_CP_DEFAULT_14P8NS_VALUE	\
+	(AW87XXX_PID_18_REG_EDGE_CP_DEFAULT_14P8NS << AW87XXX_PID_18_REG_EDGE_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EDGE_CP_MODERATE_13P5NS	(1)
+#define AW87XXX_PID_18_REG_EDGE_CP_MODERATE_13P5NS_VALUE	\
+	(AW87XXX_PID_18_REG_EDGE_CP_MODERATE_13P5NS << AW87XXX_PID_18_REG_EDGE_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EDGE_CP_SLOWEST_19P3NS	(2)
+#define AW87XXX_PID_18_REG_EDGE_CP_SLOWEST_19P3NS_VALUE	\
+	(AW87XXX_PID_18_REG_EDGE_CP_SLOWEST_19P3NS << AW87XXX_PID_18_REG_EDGE_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EDGE_CP_FASTEST_4P6NS00	(3)
+#define AW87XXX_PID_18_REG_EDGE_CP_FASTEST_4P6NS00_VALUE	\
+	(AW87XXX_PID_18_REG_EDGE_CP_FASTEST_4P6NS00 << AW87XXX_PID_18_REG_EDGE_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EDGE_CP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EDGE_CP_DEFAULT	\
+	(AW87XXX_PID_18_REG_EDGE_CP_DEFAULT_VALUE << AW87XXX_PID_18_REG_EDGE_CP_START_BIT)
+
+/* REG_TESTSEL bit 3:0 (DFT4 0x64) */
+#define AW87XXX_PID_18_REG_TESTSEL_START_BIT	(0)
+#define AW87XXX_PID_18_REG_TESTSEL_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_TESTSEL_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_TESTSEL_BITS_LEN)-1) << AW87XXX_PID_18_REG_TESTSEL_START_BIT))
+
+#define AW87XXX_PID_18_REG_TESTSEL_VBG_FROM_BIAS	(0)
+#define AW87XXX_PID_18_REG_TESTSEL_VBG_FROM_BIAS_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_VBG_FROM_BIAS << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_VCOM1_FROM_PREAMP	(1)
+#define AW87XXX_PID_18_REG_TESTSEL_VCOM1_FROM_PREAMP_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_VCOM1_FROM_PREAMP << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_VREF_AGC_FROM_RAMP	(2)
+#define AW87XXX_PID_18_REG_TESTSEL_VREF_AGC_FROM_RAMP_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_VREF_AGC_FROM_RAMP << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_VREF_ADP_FROM_THGEN	(3)
+#define AW87XXX_PID_18_REG_TESTSEL_VREF_ADP_FROM_THGEN_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_VREF_ADP_FROM_THGEN << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_OC	(4)
+#define AW87XXX_PID_18_REG_TESTSEL_OC_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_OC << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_OT160	(5)
+#define AW87XXX_PID_18_REG_TESTSEL_OT160_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_OT160 << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_UVLO	(6)
+#define AW87XXX_PID_18_REG_TESTSEL_UVLO_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_UVLO << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_GT_P_TEST_FROM_GATEDRIVER	(7)
+#define AW87XXX_PID_18_REG_TESTSEL_GT_P_TEST_FROM_GATEDRIVER_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_GT_P_TEST_FROM_GATEDRIVER << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_GT_N_TEST_FROM_GATEDRIVER	(8)
+#define AW87XXX_PID_18_REG_TESTSEL_GT_N_TEST_FROM_GATEDRIVER_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_GT_N_TEST_FROM_GATEDRIVER << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_GT1_P_TEST_FROM_GATEDRIVER	(9)
+#define AW87XXX_PID_18_REG_TESTSEL_GT1_P_TEST_FROM_GATEDRIVER_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_GT1_P_TEST_FROM_GATEDRIVER << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_GT1_N_TEST_FROM_GATEDRIVER	(10)
+#define AW87XXX_PID_18_REG_TESTSEL_GT1_N_TEST_FROM_GATEDRIVER_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_GT1_N_TEST_FROM_GATEDRIVER << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_OVP0_TEST_FROM_OVP	(11)
+#define AW87XXX_PID_18_REG_TESTSEL_OVP0_TEST_FROM_OVP_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_OVP0_TEST_FROM_OVP << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_OVP1_TEST_FROM_OVP	(12)
+#define AW87XXX_PID_18_REG_TESTSEL_OVP1_TEST_FROM_OVP_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_OVP1_TEST_FROM_OVP << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_PORN_TEST_FROM_PORN	(13)
+#define AW87XXX_PID_18_REG_TESTSEL_PORN_TEST_FROM_PORN_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_PORN_TEST_FROM_PORN << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_TESTSEL_DEFAULT	\
+	(AW87XXX_PID_18_REG_TESTSEL_DEFAULT_VALUE << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+/* default value of DFT4 (0x64) */
+/* #define AW87XXX_PID_18_DFT4_DEFAULT		(0x00) */
+
+/* DFT5 (0x65) detail */
+/* FCLK_CS bit 5 (DFT5 0x65) */
+#define AW87XXX_PID_18_FCLK_CS_START_BIT	(5)
+#define AW87XXX_PID_18_FCLK_CS_BITS_LEN	(1)
+#define AW87XXX_PID_18_FCLK_CS_MASK		\
+	(~(((1<<AW87XXX_PID_18_FCLK_CS_BITS_LEN)-1) << AW87XXX_PID_18_FCLK_CS_START_BIT))
+
+#define AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNALCLK_PA_FROM_THE_ANALOG_PART	(0)
+#define AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNALCLK_PA_FROM_THE_ANALOG_PART_VALUE	\
+	(AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNALCLK_PA_FROM_THE_ANALOG_PART << AW87XXX_PID_18_FCLK_CS_START_BIT)
+
+#define AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNAL_GENERATED_BY_DIGITAL_PART_THEN_WRITE_0XA5_TO_THE_0X66_REGISTORGENERATE_A_PULSE_AFTER_EACH_WRITING	(1)
+#define AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNAL_GENERATED_BY_DIGITAL_PART_THEN_WRITE_0XA5_TO_THE_0X66_REGISTORGENERATE_A_PULSE_AFTER_EACH_WRITING_VALUE	\
+	(AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNAL_GENERATED_BY_DIGITAL_PART_THEN_WRITE_0XA5_TO_THE_0X66_REGISTORGENERATE_A_PULSE_AFTER_EACH_WRITING << AW87XXX_PID_18_FCLK_CS_START_BIT)
+
+#define AW87XXX_PID_18_FCLK_CS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_FCLK_CS_DEFAULT	\
+	(AW87XXX_PID_18_FCLK_CS_DEFAULT_VALUE << AW87XXX_PID_18_FCLK_CS_START_BIT)
+
+/* REG_OT_TEST bit 4 (DFT5 0x65) */
+#define AW87XXX_PID_18_REG_OT_TEST_START_BIT	(4)
+#define AW87XXX_PID_18_REG_OT_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_OT_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_OT_TEST_BITS_LEN)-1) << AW87XXX_PID_18_REG_OT_TEST_START_BIT))
+
+#define AW87XXX_PID_18_REG_OT_TEST_DISABLE_NOT_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK	(0)
+#define AW87XXX_PID_18_REG_OT_TEST_DISABLE_NOT_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK_VALUE	\
+	(AW87XXX_PID_18_REG_OT_TEST_DISABLE_NOT_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK << AW87XXX_PID_18_REG_OT_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_OT_TEST_ENABLE_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK	(1)
+#define AW87XXX_PID_18_REG_OT_TEST_ENABLE_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK_VALUE	\
+	(AW87XXX_PID_18_REG_OT_TEST_ENABLE_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK << AW87XXX_PID_18_REG_OT_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_OT_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_OT_TEST_DEFAULT	\
+	(AW87XXX_PID_18_REG_OT_TEST_DEFAULT_VALUE << AW87XXX_PID_18_REG_OT_TEST_START_BIT)
+
+/* REG_EN_OC bit 3 (DFT5 0x65) */
+#define AW87XXX_PID_18_REG_EN_OC_START_BIT	(3)
+#define AW87XXX_PID_18_REG_EN_OC_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_OC_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_OC_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_OC_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_OC_TURN_OFF_THE_OC_BLOCK_FORCE_0C0	(0)
+#define AW87XXX_PID_18_REG_EN_OC_TURN_OFF_THE_OC_BLOCK_FORCE_0C0_VALUE	\
+	(AW87XXX_PID_18_REG_EN_OC_TURN_OFF_THE_OC_BLOCK_FORCE_0C0 << AW87XXX_PID_18_REG_EN_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_OC_TURN_ON_THE_OC_BLOCK_FUNCTION	(1)
+#define AW87XXX_PID_18_REG_EN_OC_TURN_ON_THE_OC_BLOCK_FUNCTION_VALUE	\
+	(AW87XXX_PID_18_REG_EN_OC_TURN_ON_THE_OC_BLOCK_FUNCTION << AW87XXX_PID_18_REG_EN_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_OC_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_OC_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_OC_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_OC_START_BIT)
+
+/* EN_RD bit 2 (DFT5 0x65) */
+#define AW87XXX_PID_18_EN_RD_START_BIT	(2)
+#define AW87XXX_PID_18_EN_RD_BITS_LEN	(1)
+#define AW87XXX_PID_18_EN_RD_MASK		\
+	(~(((1<<AW87XXX_PID_18_EN_RD_BITS_LEN)-1) << AW87XXX_PID_18_EN_RD_START_BIT))
+
+#define AW87XXX_PID_18_EN_RD_DISABLE	(0)
+#define AW87XXX_PID_18_EN_RD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_EN_RD_DISABLE << AW87XXX_PID_18_EN_RD_START_BIT)
+
+#define AW87XXX_PID_18_EN_RD_ENABLE		(1)
+#define AW87XXX_PID_18_EN_RD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_EN_RD_ENABLE << AW87XXX_PID_18_EN_RD_START_BIT)
+
+#define AW87XXX_PID_18_EN_RD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_EN_RD_DEFAULT	\
+	(AW87XXX_PID_18_EN_RD_DEFAULT_VALUE << AW87XXX_PID_18_EN_RD_START_BIT)
+
+/* REG_FAST_VFAGC bit 1 (DFT5 0x65) */
+#define AW87XXX_PID_18_REG_FAST_VFAGC_START_BIT	(1)
+#define AW87XXX_PID_18_REG_FAST_VFAGC_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_FAST_VFAGC_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_FAST_VFAGC_BITS_LEN)-1) << AW87XXX_PID_18_REG_FAST_VFAGC_START_BIT))
+
+#define AW87XXX_PID_18_REG_FAST_VFAGC_DISABLE	(0)
+#define AW87XXX_PID_18_REG_FAST_VFAGC_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_FAST_VFAGC_DISABLE << AW87XXX_PID_18_REG_FAST_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_FAST_VFAGC_ENABLE	(1)
+#define AW87XXX_PID_18_REG_FAST_VFAGC_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_FAST_VFAGC_ENABLE << AW87XXX_PID_18_REG_FAST_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_FAST_VFAGC_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_FAST_VFAGC_DEFAULT	\
+	(AW87XXX_PID_18_REG_FAST_VFAGC_DEFAULT_VALUE << AW87XXX_PID_18_REG_FAST_VFAGC_START_BIT)
+
+/* REG_FAST_HVDD bit 0 (DFT5 0x65) */
+#define AW87XXX_PID_18_REG_FAST_HVDD_START_BIT	(0)
+#define AW87XXX_PID_18_REG_FAST_HVDD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_FAST_HVDD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_FAST_HVDD_BITS_LEN)-1) << AW87XXX_PID_18_REG_FAST_HVDD_START_BIT))
+
+#define AW87XXX_PID_18_REG_FAST_HVDD_DISABLE	(0)
+#define AW87XXX_PID_18_REG_FAST_HVDD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_FAST_HVDD_DISABLE << AW87XXX_PID_18_REG_FAST_HVDD_START_BIT)
+
+#define AW87XXX_PID_18_REG_FAST_HVDD_ENABLE	(1)
+#define AW87XXX_PID_18_REG_FAST_HVDD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_FAST_HVDD_ENABLE << AW87XXX_PID_18_REG_FAST_HVDD_START_BIT)
+
+#define AW87XXX_PID_18_REG_FAST_HVDD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_FAST_HVDD_DEFAULT	\
+	(AW87XXX_PID_18_REG_FAST_HVDD_DEFAULT_VALUE << AW87XXX_PID_18_REG_FAST_HVDD_START_BIT)
+
+/* default value of DFT5 (0x65) */
+/* #define AW87XXX_PID_18_DFT5_DEFAULT		(0x08) */
+
+/* DFT6 (0x66) detail */
+/* Q_SHDN bit 7:4 (DFT6 0x66) */
+#define AW87XXX_PID_18_Q_SHDN_START_BIT	(4)
+#define AW87XXX_PID_18_Q_SHDN_BITS_LEN	(4)
+#define AW87XXX_PID_18_Q_SHDN_MASK		\
+	(~(((1<<AW87XXX_PID_18_Q_SHDN_BITS_LEN)-1) << AW87XXX_PID_18_Q_SHDN_START_BIT))
+
+#define AW87XXX_PID_18_Q_SHDN_MODE1		(0)
+#define AW87XXX_PID_18_Q_SHDN_MODE1_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE1 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE2		(1)
+#define AW87XXX_PID_18_Q_SHDN_MODE2_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE2 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE3		(2)
+#define AW87XXX_PID_18_Q_SHDN_MODE3_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE3 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE4		(3)
+#define AW87XXX_PID_18_Q_SHDN_MODE4_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE4 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE5		(4)
+#define AW87XXX_PID_18_Q_SHDN_MODE5_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE5 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE6		(5)
+#define AW87XXX_PID_18_Q_SHDN_MODE6_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE6 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE7		(6)
+#define AW87XXX_PID_18_Q_SHDN_MODE7_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE7 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE8		(7)
+#define AW87XXX_PID_18_Q_SHDN_MODE8_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE8 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE9		(8)
+#define AW87XXX_PID_18_Q_SHDN_MODE9_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE9 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE10	(9)
+#define AW87XXX_PID_18_Q_SHDN_MODE10_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE10 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_Q_SHDN_DEFAULT	\
+	(AW87XXX_PID_18_Q_SHDN_DEFAULT_VALUE << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+/* REG_FSS bit 3:0 (DFT6 0x66) */
+#define AW87XXX_PID_18_REG_FSS_START_BIT	(0)
+#define AW87XXX_PID_18_REG_FSS_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_FSS_MASK		\
+	(~(((1<<AW87XXX_PID_18_REG_FSS_BITS_LEN)-1) << AW87XXX_PID_18_REG_FSS_START_BIT))
+
+#define AW87XXX_PID_18_REG_FSS_1P408MHZ	(0)
+#define AW87XXX_PID_18_REG_FSS_1P408MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P408MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P432MHZ	(1)
+#define AW87XXX_PID_18_REG_FSS_1P432MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P432MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P456MHZ	(3)
+#define AW87XXX_PID_18_REG_FSS_1P456MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P456MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P48MHZ	(2)
+#define AW87XXX_PID_18_REG_FSS_1P48MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P48MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P504MHZ	(6)
+#define AW87XXX_PID_18_REG_FSS_1P504MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P504MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P528MHZ	(7)
+#define AW87XXX_PID_18_REG_FSS_1P528MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P528MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P552MHZ	(5)
+#define AW87XXX_PID_18_REG_FSS_1P552MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P552MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P576MHZ	(4)
+#define AW87XXX_PID_18_REG_FSS_1P576MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P576MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P6MHZ	(12)
+#define AW87XXX_PID_18_REG_FSS_1P6MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P6MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P627MHZ	(13)
+#define AW87XXX_PID_18_REG_FSS_1P627MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P627MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P655MHZ	(15)
+#define AW87XXX_PID_18_REG_FSS_1P655MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P655MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P682MHZ	(14)
+#define AW87XXX_PID_18_REG_FSS_1P682MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P682MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P71MHZ	(10)
+#define AW87XXX_PID_18_REG_FSS_1P71MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P71MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P737MHZ	(11)
+#define AW87XXX_PID_18_REG_FSS_1P737MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P737MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P765MHZ	(9)
+#define AW87XXX_PID_18_REG_FSS_1P765MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P765MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P792MHZ	(8)
+#define AW87XXX_PID_18_REG_FSS_1P792MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P792MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_DEFAULT_VALUE	(0x0C)
+#define AW87XXX_PID_18_REG_FSS_DEFAULT	\
+	(AW87XXX_PID_18_REG_FSS_DEFAULT_VALUE << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+/* default value of DFT6 (0x66) */
+/* #define AW87XXX_PID_18_DFT6_DEFAULT		(0x0C) */
+
+/* detail information of registers end */
+
+#endif  /* #ifndef  __AW87XXX_PID_18_REG_H__ */
\ No newline at end of file
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_39_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_39_reg.h
new file mode 100644
index 000000000..0dfd9751c
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_39_reg.h
@@ -0,0 +1,67 @@
+#ifndef __AW87XXX_PID_39_REG_H__
+#define __AW87XXX_PID_39_REG_H__
+
+#define AW87XXX_PID_39_REG_CHIPID		(0x00)
+#define AW87XXX_PID_39_REG_SYSCTRL		(0x01)
+#define AW87XXX_PID_39_REG_MODECTRL		(0x02)
+#define AW87XXX_PID_39_REG_CPOVP		(0x03)
+#define AW87XXX_PID_39_REG_CPP			(0x04)
+#define AW87XXX_PID_39_REG_GAIN			(0x05)
+#define AW87XXX_PID_39_REG_AGC3_PO		(0x06)
+#define AW87XXX_PID_39_REG_AGC3			(0x07)
+#define AW87XXX_PID_39_REG_AGC2_PO		(0x08)
+#define AW87XXX_PID_39_REG_AGC2			(0x09)
+#define AW87XXX_PID_39_REG_AGC1			(0x0A)
+#define AW87XXX_PID_39_REG_DFT1			(0x62)
+#define AW87XXX_PID_39_REG_DFT2			(0x63)
+#define AW87XXX_PID_39_REG_ENCRY		(0x64)
+
+#define AW87XXX_PID_39_MODECTRL_DEFAULT		(0xa0)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_39_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_39_REG_MAX			(0x65)
+
+#define REG_NONE_ACCESS		(0)
+#define REG_RD_ACCESS		(1 << 0)
+#define REG_WR_ACCESS		(1 << 1)
+
+const unsigned char aw87xxx_pid_39_reg_access[AW87XXX_PID_39_REG_MAX] = {
+	[AW87XXX_PID_39_REG_CHIPID]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_39_REG_SYSCTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_MODECTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_CPOVP]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_CPP]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_GAIN]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_AGC3_PO]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_AGC3]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_AGC2_PO]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_AGC2]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_AGC1]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_DFT1]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_39_REG_DFT2]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_39_REG_ENCRY]	= (REG_RD_ACCESS),
+};
+
+/* RCV_MODE bit 3 (MODECTRL 0x02) */
+#define AW87XXX_PID_39_REC_MODE_START_BIT	(3)
+#define AW87XXX_PID_39_REC_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_39_REC_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_39_REC_MODE_BITS_LEN)-1) << AW87XXX_PID_39_REC_MODE_START_BIT))
+
+#define AW87XXX_PID_39_REC_MODE_DISABLE	(0)
+#define AW87XXX_PID_39_REC_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_39_REC_MODE_DISABLE << AW87XXX_PID_39_REC_MODE_START_BIT)
+
+#define AW87XXX_PID_39_REC_MODE_ENABLE	(1)
+#define AW87XXX_PID_39_REC_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_39_REC_MODE_ENABLE << AW87XXX_PID_39_REC_MODE_START_BIT)
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_3x9_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_3x9_reg.h
new file mode 100644
index 000000000..67f73477b
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_3x9_reg.h
@@ -0,0 +1,93 @@
+/*
+ * @Descripttion: Header file of AW87XXX_PID_59_3X9_REG
+ * @version: V1.33
+ * @Author: zhaozhongbo
+ * @Date: 2021-03-10
+ * @LastEditors: Please set LastEditors
+ * @LastEditTime: 2021-03-10
+ */
+#ifndef __AW87XXX_PID_59_3X9_REG_H__
+#define __AW87XXX_PID_59_3X9_REG_H__
+
+#define AW87XXX_PID_59_3X9_REG_CHIPID		(0x00)
+#define AW87XXX_PID_59_3X9_REG_SYSCTRL		(0x01)
+#define AW87XXX_PID_59_3X9_REG_MDCRTL		(0x02)
+#define AW87XXX_PID_59_3X9_REG_CPOVP		(0x03)
+#define AW87XXX_PID_59_3X9_REG_CPP		(0x04)
+#define AW87XXX_PID_59_3X9_REG_PAG		(0x05)
+#define AW87XXX_PID_59_3X9_REG_AGC3PO		(0x06)
+#define AW87XXX_PID_59_3X9_REG_AGC3PA		(0x07)
+#define AW87XXX_PID_59_3X9_REG_AGC2PO		(0x08)
+#define AW87XXX_PID_59_3X9_REG_AGC2PA		(0x09)
+#define AW87XXX_PID_59_3X9_REG_AGC1PA		(0x0A)
+#define AW87XXX_PID_59_3X9_REG_SYSST		(0x59)
+#define AW87XXX_PID_59_3X9_REG_SYSINT		(0x60)
+#define AW87XXX_PID_59_3X9_REG_DFT_SYSCTRL	(0x61)
+#define AW87XXX_PID_59_3X9_REG_DFT_MDCTRL	(0x62)
+#define AW87XXX_PID_59_3X9_REG_DFT_CPOVP2	(0x63)
+#define AW87XXX_PID_59_3X9_REG_DFT_AGCPA	(0x64)
+#define AW87XXX_PID_59_3X9_REG_DFT_POFR		(0x65)
+#define AW87XXX_PID_59_3X9_REG_DFT_OC		(0x66)
+#define AW87XXX_PID_59_3X9_REG_DFT_OTA		(0x67)
+#define AW87XXX_PID_59_3X9_REG_DFT_REF		(0x68)
+#define AW87XXX_PID_59_3X9_REG_DFT_LDO		(0x69)
+#define AW87XXX_PID_59_3X9_REG_ENCR		(0x70)
+
+#define AW87XXX_PID_59_3X9_ENCR_DEFAULT		(0x00)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_59_3x9_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_59_3X9_REG_MAX			(0x71)
+
+#define REG_NONE_ACCESS		(0)
+#define REG_RD_ACCESS		(1 << 0)
+#define REG_WR_ACCESS		(1 << 1)
+
+const unsigned char aw87xxx_pid_59_3x9_reg_access[AW87XXX_PID_59_3X9_REG_MAX] = {
+	[AW87XXX_PID_59_3X9_REG_CHIPID]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_SYSCTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_MDCRTL]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_CPOVP]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_CPP]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_PAG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_AGC3PO]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_AGC3PA]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_AGC2PO]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_AGC2PA]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_AGC1PA]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_SYSST]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_SYSINT]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_SYSCTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_MDCTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_CPOVP2]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_AGCPA]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_POFR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_OC]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_OTA]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_REF]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_LDO]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_ENCR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+/* SPK_MODE bit 2 (MDCRTL 0x02) */
+#define AW87XXX_PID_59_3X9_SPK_MODE_START_BIT	(2)
+#define AW87XXX_PID_59_3X9_SPK_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_59_3X9_SPK_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_59_3X9_SPK_MODE_BITS_LEN)-1) << AW87XXX_PID_59_3X9_SPK_MODE_START_BIT))
+
+#define AW87XXX_PID_59_3X9_SPK_MODE_DISABLE	(0)
+#define AW87XXX_PID_59_3X9_SPK_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_59_3X9_SPK_MODE_DISABLE << AW87XXX_PID_59_3X9_SPK_MODE_START_BIT)
+
+#define AW87XXX_PID_59_3X9_SPK_MODE_ENABLE	(1)
+#define AW87XXX_PID_59_3X9_SPK_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_59_3X9_SPK_MODE_ENABLE << AW87XXX_PID_59_3X9_SPK_MODE_START_BIT)
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_5x9_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_5x9_reg.h
new file mode 100644
index 000000000..6a0cae4c4
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_5x9_reg.h
@@ -0,0 +1,94 @@
+/*
+ * @Descripttion: Header file of AW87XXX_PID_59_5X9_REG
+ * @version: V1.33
+ * @Author: zhaozhongbo
+ * @Date: 2021-03-10
+ * @LastEditors: Please set LastEditors
+ * @LastEditTime: 2021-03-10
+ */
+#ifndef __AW87XXX_PID_59_5X9_REG_H__
+#define __AW87XXX_PID_59_5X9_REG_H__
+
+
+#define AW87XXX_PID_59_5X9_REG_CHIPID		(0x00)
+#define AW87XXX_PID_59_5X9_REG_SYSCTRL		(0x01)
+#define AW87XXX_PID_59_5X9_REG_BATSAFE		(0x02)
+#define AW87XXX_PID_59_5X9_REG_BSTOVR		(0x03)
+#define AW87XXX_PID_59_5X9_REG_BSTVPR		(0x04)
+#define AW87XXX_PID_59_5X9_REG_PAGR		(0x05)
+#define AW87XXX_PID_59_5X9_REG_PAGC3OPR		(0x06)
+#define AW87XXX_PID_59_5X9_REG_PAGC3PR		(0x07)
+#define AW87XXX_PID_59_5X9_REG_PAGC2OPR		(0x08)
+#define AW87XXX_PID_59_5X9_REG_PAGC2PR		(0x09)
+#define AW87XXX_PID_59_5X9_REG_PAGC1PR		(0x0A)
+#define AW87XXX_PID_59_5X9_REG_SYSST		(0x58)
+#define AW87XXX_PID_59_5X9_REG_SYSINT		(0x59)
+#define AW87XXX_PID_59_5X9_REG_CPCR		(0x60)
+#define AW87XXX_PID_59_5X9_REG_DFT1R		(0x61)
+#define AW87XXX_PID_59_5X9_REG_DFT2R		(0x62)
+#define AW87XXX_PID_59_5X9_REG_DFT3R		(0x63)
+#define AW87XXX_PID_59_5X9_REG_DFT4R		(0x64)
+#define AW87XXX_PID_59_5X9_REG_DFT5R		(0x65)
+#define AW87XXX_PID_59_5X9_REG_DFT6R		(0x66)
+#define AW87XXX_PID_59_5X9_REG_DFT7R		(0x67)
+#define AW87XXX_PID_59_5X9_REG_DFT8R		(0x68)
+#define AW87XXX_PID_59_5X9_REG_ENCR		(0x69)
+
+#define AW87XXX_PID_59_5X9_ENCRY_DEFAULT	(0x00)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_59_5x9_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_59_5X9_REG_MAX			(0x70)
+
+#define REG_NONE_ACCESS		(0)
+#define REG_RD_ACCESS		(1 << 0)
+#define REG_WR_ACCESS		(1 << 1)
+
+const unsigned char aw87xxx_pid_59_5x9_reg_access[AW87XXX_PID_59_5X9_REG_MAX] = {
+	[AW87XXX_PID_59_5X9_REG_CHIPID]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_SYSCTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_BATSAFE]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_BSTOVR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_BSTVPR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGC3OPR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGC3PR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGC2OPR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGC2PR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGC1PR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_SYSST]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_SYSINT]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_CPCR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT1R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT2R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT3R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT4R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT5R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT6R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT7R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT8R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_ENCR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+/* RCV_MODE bit 3 (SYSCTRL 0x01) */
+#define AW87XXX_PID_59_5X9_REC_MODE_START_BIT	(3)
+#define AW87XXX_PID_59_5X9_REC_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_59_5X9_REC_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_59_5X9_REC_MODE_BITS_LEN)-1) << AW87XXX_PID_59_5X9_REC_MODE_START_BIT))
+
+#define AW87XXX_PID_59_5X9_REC_MODE_DISABLE	(0)
+#define AW87XXX_PID_59_5X9_REC_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_59_5X9_REC_MODE_DISABLE << AW87XXX_PID_59_5X9_REC_MODE_START_BIT)
+
+#define AW87XXX_PID_59_5X9_REC_MODE_ENABLE	(1)
+#define AW87XXX_PID_59_5X9_REC_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_59_5X9_REC_MODE_ENABLE << AW87XXX_PID_59_5X9_REC_MODE_START_BIT)
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_5a_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_5a_reg.h
new file mode 100644
index 000000000..020bf5496
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_5a_reg.h
@@ -0,0 +1,4124 @@
+/*
+ * @Descripttion: Header file of AW87XXX_PID_5A_REG
+ * @version: V1.4
+ * @Author: zhaozhongbo
+ * @Date: 2021-03-10
+ * @LastEditors: Please set LastEditors
+ * @LastEditTime: 2021-03-10
+ */
+#ifndef __AW87XXX_PID_5A_REG_H__
+#define __AW87XXX_PID_5A_REG_H__
+
+/* registers list */
+#define AW87XXX_PID_5A_REG_ID_REG		(0x00)
+#define AW87XXX_PID_5A_REG_SYSCTRL_REG	(0x01)
+#define AW87XXX_PID_5A_REG_BATSAFE_REG	(0x02)
+#define AW87XXX_PID_5A_REG_BSTOVR_REG	(0x03)
+#define AW87XXX_PID_5A_REG_BSTCPR1_REG	(0x04)
+#define AW87XXX_PID_5A_REG_BSTCPR2_REG	(0x05)
+#define AW87XXX_PID_5A_REG_PAGR_REG		(0x06)
+#define AW87XXX_PID_5A_REG_PAGC3OPR_REG	(0x07)
+#define AW87XXX_PID_5A_REG_PAGC3PR_REG	(0x08)
+#define AW87XXX_PID_5A_REG_PAGC2OPR_REG	(0x09)
+#define AW87XXX_PID_5A_REG_PAGC2PR_REG	(0x0A)
+#define AW87XXX_PID_5A_REG_PAGC1PR_REG	(0x0B)
+#define AW87XXX_PID_5A_REG_ADP_MODE_REG	(0x0C)
+#define AW87XXX_PID_5A_REG_ADPBST_TIME1_REG	(0x0D)
+#define AW87XXX_PID_5A_REG_ADPBST_TIME2_REG	(0x0E)
+#define AW87XXX_PID_5A_REG_ADPBST_VTH_REG	(0x0F)
+#define AW87XXX_PID_5A_REG_BOOST_PAR_REG	(0x10)
+#define AW87XXX_PID_5A_REG_BOOST_VOUT_DET_REG	(0x57)
+#define AW87XXX_PID_5A_REG_SYSST_REG	(0x58)
+#define AW87XXX_PID_5A_REG_SYSINT_REG	(0x59)
+#define AW87XXX_PID_5A_REG_DFT1R_REG	(0x60)
+#define AW87XXX_PID_5A_REG_DFT2R_REG	(0x61)
+#define AW87XXX_PID_5A_REG_DFT3R_REG	(0x62)
+#define AW87XXX_PID_5A_REG_DFT4R_REG	(0x63)
+#define AW87XXX_PID_5A_REG_DFT5R_REG	(0x64)
+#define AW87XXX_PID_5A_REG_DFT6R_REG	(0x65)
+#define AW87XXX_PID_5A_REG_DFT7R_REG	(0x66)
+#define AW87XXX_PID_5A_REG_DFT8R_REG	(0x67)
+#define AW87XXX_PID_5A_REG_DFT9R_REG	(0x68)
+#define AW87XXX_PID_5A_REG_DFTAR_REG	(0x69)
+#define AW87XXX_PID_5A_REG_DFTBR_REG	(0x70)
+#define AW87XXX_PID_5A_REG_DFTCR_REG	(0x71)
+#define AW87XXX_PID_5A_REG_DFTDR_REG	(0x72)
+#define AW87XXX_PID_5A_REG_DFTER_REG	(0x73)
+#define AW87XXX_PID_5A_REG_DFTFR_REG	(0x74)
+#define AW87XXX_PID_5A_REG_test1_REG	(0x75)
+#define AW87XXX_PID_5A_REG_test2_REG	(0x76)
+#define AW87XXX_PID_5A_REG_ENCR_REG	(0x77)
+
+#define AW87XXX_PID_5A_DFT3R_DEFAULT	(0x02)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_5a_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_5A_REG_MAX		(0x78)
+
+#define REG_NONE_ACCESS					(0)
+#define REG_RD_ACCESS					(1 << 0)
+#define REG_WR_ACCESS					(1 << 1)
+
+const unsigned char aw87xxx_pid_5a_reg_access[AW87XXX_PID_5A_REG_MAX] = {
+	[AW87XXX_PID_5A_REG_ID_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_5A_REG_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BATSAFE_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BSTOVR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BSTCPR1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BSTCPR2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGC3OPR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGC3PR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGC2OPR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGC2PR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGC1PR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_ADP_MODE_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_ADPBST_TIME1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_ADPBST_TIME2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_ADPBST_VTH_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BOOST_PAR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BOOST_VOUT_DET_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_5A_REG_SYSST_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_5A_REG_SYSINT_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT1R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT2R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT3R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT4R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT5R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT6R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT7R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT8R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT9R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTAR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTBR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTCR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTDR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTER_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTFR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_test1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_test2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_ENCR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+/* detail information of registers begin */
+/* ID (0x00) detail */
+/* IDCODE bit 7:0 (ID 0x00) */
+#define AW87XXX_PID_5A_REG_IDCODE_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_IDCODE_BITS_LEN	(8)
+#define AW87XXX_PID_5A_REG_IDCODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_IDCODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_IDCODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_IDCODE_DEFAULT_VALUE	(0x5A)
+#define AW87XXX_PID_5A_REG_IDCODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_IDCODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_IDCODE_START_BIT)
+
+/* default value of ID (0x00) */
+/* #define AW87XXX_PID_5A_REG_ID_DEFAULT		(0x5A) */
+
+/* SYSCTRL (0x01) detail */
+/* EN_SW bit 6 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_SW_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_EN_SW_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_SW_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_SW_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_SW_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_SW_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_SW_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_SW_DISABLE << AW87XXX_PID_5A_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_SW_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_SW_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_SW_ENABLE << AW87XXX_PID_5A_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_SW_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_SW_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_SW_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_SW_START_BIT)
+
+/* EN_CP bit 5 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_CP_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_EN_CP_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_CP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_CP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_CP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_CP_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_CP_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_CP_DISABLE << AW87XXX_PID_5A_REG_EN_CP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_CP_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_CP_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_CP_ENABLE << AW87XXX_PID_5A_REG_EN_CP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_CP_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_EN_CP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_CP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_CP_START_BIT)
+
+/* EN_BOOST bit 4 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_BOOST_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_EN_BOOST_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_BOOST_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_BOOST_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_BOOST_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_DISABLE << AW87XXX_PID_5A_REG_EN_BOOST_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_ENABLE << AW87XXX_PID_5A_REG_EN_BOOST_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_BOOST_START_BIT)
+
+/* EN_PA bit 3 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_PA_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_EN_PA_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_PA_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_PA_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_PA_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_PA_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_PA_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_PA_DISABLE << AW87XXX_PID_5A_REG_EN_PA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_PA_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_PA_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_PA_ENABLE << AW87XXX_PID_5A_REG_EN_PA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_PA_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_EN_PA_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_PA_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_PA_START_BIT)
+
+/* RCV_MODE bit 2 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_RCV_MODE_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_RCV_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_RCV_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_RCV_MODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_RCV_MODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_RCV_MODE_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_RCV_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_RCV_MODE_DISABLE << AW87XXX_PID_5A_REG_RCV_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RCV_MODE_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_RCV_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_RCV_MODE_ENABLE << AW87XXX_PID_5A_REG_RCV_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RCV_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_RCV_MODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_RCV_MODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_RCV_MODE_START_BIT)
+
+/* EN_OVERLOAD bit 1 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_OVERLOAD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_OVERLOAD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_DISABL	(0)
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_DISABL_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_OVERLOAD_DISABL << AW87XXX_PID_5A_REG_EN_OVERLOAD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_OVERLOAD_ENABLE << AW87XXX_PID_5A_REG_EN_OVERLOAD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_OVERLOAD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_OVERLOAD_START_BIT)
+
+/* EN_HVBAT bit 0 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_HVBAT_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_EN_HVBAT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_HVBAT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_HVBAT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_HVBAT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_HVBAT_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_HVBAT_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HVBAT_DISABLE << AW87XXX_PID_5A_REG_EN_HVBAT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HVBAT_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_HVBAT_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HVBAT_ENABLE << AW87XXX_PID_5A_REG_EN_HVBAT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HVBAT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_HVBAT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_HVBAT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_HVBAT_START_BIT)
+
+/* default value of SYSCTRL (0x01) */
+/* #define AW87XXX_PID_5A_REG_SYSCTRL_DEFAULT		(0x38) */
+
+/* BATSAFE (0x02) detail */
+/* BAT_SFGD_DEGLITCH bit 6:5 (BATSAFE 0x02) */
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_1MS	(0)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_1MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_1MS << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_500US	(1)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_500US_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_500US << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_200US	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_200US_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_200US << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DISABLE	(3)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DISABLE << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT)
+
+/* BAT_SFGD_VTH bit 4:3 (BATSAFE 0x02) */
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BAT_SFGD_VTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P3V	(0)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P3V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P3V << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P4V	(1)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P4V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P4V << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P5V	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P5V << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P6V	(3)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P6V << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_VTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT)
+
+/* EN_BAT_SFGD bit 2 (BATSAFE 0x02) */
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_BAT_SFGD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_BAT_SFGD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BAT_SFGD_DISABLE << AW87XXX_PID_5A_REG_EN_BAT_SFGD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BAT_SFGD_ENABLE << AW87XXX_PID_5A_REG_EN_BAT_SFGD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_BAT_SFGD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_BAT_SFGD_START_BIT)
+
+/* BAT_SFGD_LEVEL bit 1:0 (BATSAFE 0x02) */
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5V	(0)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5V << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5P5V	(1)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5P5V << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6V	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6V << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6P5V	(3)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6P5V << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_DEFAULT_VALUE	(0x01)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT)
+
+/* default value of BATSAFE (0x02) */
+/* #define AW87XXX_PID_5A_REG_BATSAFE_DEFAULT		(0x09) */
+
+/* BSTOVR (0x03) detail */
+/* BST_VOUT bit 4:0 (BSTOVR 0x03) */
+#define AW87XXX_PID_5A_REG_BST_VOUT_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_VOUT_BITS_LEN	(5)
+#define AW87XXX_PID_5A_REG_BST_VOUT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_VOUT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_6P5V	(0)
+#define AW87XXX_PID_5A_REG_BST_VOUT_6P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_6P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_6P75V	(1)
+#define AW87XXX_PID_5A_REG_BST_VOUT_6P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_6P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P0V	(2)
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_7P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P25V	(3)
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_7P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P5V	(4)
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_7P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P75V	(5)
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_7P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P0V	(6)
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_8P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P25V	(7)
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_8P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P5V	(8)
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_8P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P75V	(9)
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_8P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P0V	(10)
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_9P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P25V	(11)
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_9P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P5V	(12)
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_9P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P75V	(13)
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_9P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P0V	(14)
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_10P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P25V	(15)
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_10P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P5V	(16)
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_10P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P75V	(17)
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_10P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P0V	(18)
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_11P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P25V	(19)
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_11P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P5V	(20)
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_11P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P75V	(21)
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_11P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P0V	(22)
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_12P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P25V	(23)
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_12P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P5V	(24)
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_12P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_DEFAULT_VALUE	(0x0C)
+#define AW87XXX_PID_5A_REG_BST_VOUT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+/* default value of BSTOVR (0x03) */
+/* #define AW87XXX_PID_5A_REG_BSTOVR_DEFAULT		(0x0C) */
+
+/* BSTCPR1 (0x04) detail */
+/* BURST_HYS_SELA bit 7 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BURST_HYS_SELA_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_3P3MV	(0)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_3P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SELA_3P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_5MV	(1)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_5MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SELA_5MV << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV	(2)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV	(3)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SELA_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT)
+
+/* BST_IPEAK_SS bit 6:5 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_IPEAK_SS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_0P8A	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_0P8A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_SS_0P8A << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_1A	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_1A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_SS_1A << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_1P5A	(2)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_1P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_SS_1P5A << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_2A	(3)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_2A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_SS_2A << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_SS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT)
+
+/* BST_IPEAK_ADJ bit 4 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK << AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK0P5A	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK0P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK0P5A << AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_START_BIT)
+
+/* BST_IPEAK_LOWBAT_EN bit 3 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DISABLE << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_ENABLE << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+/* BST_IPEAK_LOWBAT bit 2 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P5A	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P5A << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P75A	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P75A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P75A << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_START_BIT)
+
+/* BURST_HYS_SEL bit 1 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BURST_HYS_SEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_3P3MV	(0)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_3P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SEL_3P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_5MV	(1)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_5MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SEL_5MV << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV	(2)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV	(3)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT)
+
+/* BURST_MODE bit 0 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BURST_MODE_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BURST_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BURST_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BURST_MODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BURST_MODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BURST_MODE_PVDD_DECIDE	(0)
+#define AW87XXX_PID_5A_REG_BURST_MODE_PVDD_DECIDE_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_MODE_PVDD_DECIDE << AW87XXX_PID_5A_REG_BURST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_MODE_BUEST_PEAK_DECIDE	(1)
+#define AW87XXX_PID_5A_REG_BURST_MODE_BUEST_PEAK_DECIDE_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_MODE_BUEST_PEAK_DECIDE << AW87XXX_PID_5A_REG_BURST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BURST_MODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BURST_MODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BURST_MODE_START_BIT)
+
+/* default value of BSTCPR1 (0x04) */
+/* #define AW87XXX_PID_5A_REG_BSTCPR1_DEFAULT		(0x00) */
+
+/* BSTCPR2 (0x05) detail */
+/* BURST_PEAK bit 5:4 (BSTCPR2 0x05) */
+#define AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BURST_PEAK_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_660MV_HYS_800MV	(0)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_660MV_HYS_800MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_660MV_HYS_800MV << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_730MV_HYS_890MV	(1)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_730MV_HYS_890MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_730MV_HYS_890MV << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_780MV_HYS_930MV	(2)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_780MV_HYS_930MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_780MV_HYS_930MV << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_810MV_HYS_970MV	(3)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_810MV_HYS_970MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_810MV_HYS_970MV << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_PEAK_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BURST_PEAK_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT)
+
+/* BST_IPEAK bit 3:0 (BSTCPR2 0x05) */
+#define AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_IPEAK_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_1P5A	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_1P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_1P5A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_1P75A	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_1P75A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_1P75A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2A	(2)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_2A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P25A	(3)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P25A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_2P25A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P5A	(4)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_2P5A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P75A	(5)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P75A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_2P75A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3A	(6)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_3A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P25	(7)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P25_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_3P25 << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P5A	(8)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_3P5A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P75A	(9)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P75A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_3P75A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4A	(10)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_4A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4P25A	(11)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4P25A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_4P25A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4P5A	(12)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_4P5A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_DEFAULT_VALUE	(0x8)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+/* default value of BSTCPR2 (0x05) */
+/* #define AW87XXX_PID_5A_REG_BSTCPR2_DEFAULT		(0x08) */
+
+/* PAGR (0x06) detail */
+/* PA_GAIN bit 4:0 (PAGR 0x06) */
+#define AW87XXX_PID_5A_REG_PA_GAIN_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PA_GAIN_BITS_LEN	(5)
+#define AW87XXX_PID_5A_REG_PA_GAIN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_GAIN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_0DB	(0)
+#define AW87XXX_PID_5A_REG_PA_GAIN_0DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_0DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_1P5DB	(1)
+#define AW87XXX_PID_5A_REG_PA_GAIN_1P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_1P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_3DB	(2)
+#define AW87XXX_PID_5A_REG_PA_GAIN_3DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_3DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_4P5DB	(3)
+#define AW87XXX_PID_5A_REG_PA_GAIN_4P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_4P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_6DB	(4)
+#define AW87XXX_PID_5A_REG_PA_GAIN_6DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_6DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_7P5DB	(5)
+#define AW87XXX_PID_5A_REG_PA_GAIN_7P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_7P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_9DB	(6)
+#define AW87XXX_PID_5A_REG_PA_GAIN_9DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_9DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_10P5DB	(7)
+#define AW87XXX_PID_5A_REG_PA_GAIN_10P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_10P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_12DB	(8)
+#define AW87XXX_PID_5A_REG_PA_GAIN_12DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_12DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_13P5DB	(9)
+#define AW87XXX_PID_5A_REG_PA_GAIN_13P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_13P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_15DB	(10)
+#define AW87XXX_PID_5A_REG_PA_GAIN_15DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_15DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_16P5DB	(11)
+#define AW87XXX_PID_5A_REG_PA_GAIN_16P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_16P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_18DB	(12)
+#define AW87XXX_PID_5A_REG_PA_GAIN_18DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_18DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_19P5DB	(13)
+#define AW87XXX_PID_5A_REG_PA_GAIN_19P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_19P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_21DB	(14)
+#define AW87XXX_PID_5A_REG_PA_GAIN_21DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_21DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_22P5DB	(15)
+#define AW87XXX_PID_5A_REG_PA_GAIN_22P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_22P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_24DB	(16)
+#define AW87XXX_PID_5A_REG_PA_GAIN_24DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_24DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_25P5DB	(17)
+#define AW87XXX_PID_5A_REG_PA_GAIN_25P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_25P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_27DB	(18)
+#define AW87XXX_PID_5A_REG_PA_GAIN_27DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_27DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_DEFAULT_VALUE	(0x10)
+#define AW87XXX_PID_5A_REG_PA_GAIN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+/* default value of PAGR (0x06) */
+/* #define AW87XXX_PID_5A_REG_PAGR_DEFAULT		(0x10) */
+
+/* PAGC3OPR (0x07) detail */
+/* PAVG_ADJ bit 7:5 (PAGC3OPR 0x07) */
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PAVG_ADJ_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_0P94PO	(0)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_0P94PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_0P94PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_0P97PO	(1)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_0P97PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_0P97PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P0PO	(2)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P0PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_1P0PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P03PO	(3)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P03PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_1P03PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P06PO	(4)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P06PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_1P06PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P09PO	(5)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P09PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_1P09PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+/* PD_AGC3 bit 4 (PAGC3OPR 0x07) */
+#define AW87XXX_PID_5A_REG_PD_AGC3_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_PD_AGC3_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PD_AGC3_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PD_AGC3_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PD_AGC3_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PD_AGC3_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_PD_AGC3_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_AGC3_ENABLE << AW87XXX_PID_5A_REG_PD_AGC3_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_AGC3_DISABLE	(1)
+#define AW87XXX_PID_5A_REG_PD_AGC3_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_AGC3_DISABLE << AW87XXX_PID_5A_REG_PD_AGC3_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_AGC3_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_5A_REG_PD_AGC3_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PD_AGC3_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PD_AGC3_START_BIT)
+
+/* AGC3_OUTPUT_POWER bit 3:0 (PAGC3OPR 0x07) */
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P5W8_OHM	(0)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P5W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P5W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P6W8_OHM	(1)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P6W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P6W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P7W8_OHM	(2)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P7W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P7W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P8W8_OHM	(3)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P8W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P8W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P9W8_OHM	(4)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P9W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P9W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P0W8_OHM	(5)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P0W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P0W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P1W8_OHM	(6)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P1W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P1W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P2W8_OHM	(7)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P2W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P2W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P3W8_OHM	(8)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P3W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P3W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P4W8_OHM	(9)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P4W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P4W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P5W8_OHM	(10)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P5W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P5W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P6W8_OHM	(11)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P6W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P6W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P7W8_OHM	(12)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P7W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P7W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P8W8_OHM	(13)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P8W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P8W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P9W8_OHM	(14)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P9W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P9W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_2P0W8_OHM	(15)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_2P0W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_2P0W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+/* default value of PAGC3OPR (0x07) */
+/* #define AW87XXX_PID_5A_REG_PAGC3OPR_DEFAULT		(0x43) */
+
+/* PAGC3PR (0x08) detail */
+/* AGC3_REL_TIME bit 7:5 (PAGC3PR 0x08) */
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC3_REL_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_5P12MSDB	(0)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_5P12MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_5P12MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_10P24MSDB	(1)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_10P24MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_20P48MSDB	(2)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_20P48MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_20P48MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_40P96MSDB	(3)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_40P96MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_81P92MSDB	(4)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_81P92MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_81P92MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_163P84MSDB	(5)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_163P84MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_163P84MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_327P68MSDB	(6)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_327P68MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_327P68MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_655P36MSDB	(7)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_655P36MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_655P36MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+/* AGC3_ATT_TIME bit 4:2 (PAGC3PR 0x08) */
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC3_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_1P28MSDB	(0)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_1P28MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_1P28MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_2P56MSDB	(1)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_2P56MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_2P56MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_10P24MSDB	(2)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_10P24MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_40P96MSDB	(3)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_40P96MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_82MSDB	(4)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_82MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_82MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_164MSDB	(5)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_164MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_164MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_328MSDB	(6)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_328MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_328MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_656MSDB	(7)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_656MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_656MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+/* AGC3_FIRST_ATT_TIME bit 1:0 (PAGC3PR 0x08) */
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_5P12MS	(0)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_5P12MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_5P12MS << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_10P24MS	(1)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_10P24MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_10P24MS << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_20P48MS	(2)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_20P48MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_20P48MS << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_41MS	(3)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_41MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_41MS << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT)
+
+/* default value of PAGC3PR (0x08) */
+/* #define AW87XXX_PID_5A_REG_PAGC3PR_DEFAULT		(0x4E) */
+
+/* PAGC2OPR (0x09) detail */
+/* AGC2_OUTPUT_POWER bit 3:0 (PAGC2OPR 0x09) */
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P0W8_OHM	(0)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P0W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P0W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P2W8_OHM	(1)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P2W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P2W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P4W8_OHM	(2)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P4W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P4W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P6W8_OHM	(3)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P6W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P6W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P8W8_OHM	(4)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P8W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P8W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P0W8_OHM	(5)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P0W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P0W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P2W8_OHM	(6)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P2W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P2W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P4W8_OHM	(7)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P4W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P4W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P6W8_OHM	(8)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P6W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P6W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P8W8_OHM	(9)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P8W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P8W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_3P0W8_OHM	(10)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_3P0W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_3P0W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_AGC2_OFF	(11)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_AGC2_OFF_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_AGC2_OFF << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+/* default value of PAGC2OPR (0x09) */
+/* #define AW87XXX_PID_5A_REG_PAGC2OPR_DEFAULT		(0x03) */
+
+/* PAGC2PR (0x0A) detail */
+/* AGC2_ATT_TIME bit 4:2 (PAGC2PR 0x0A) */
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC2_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P16MSDB	(0)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P16MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P16MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P32MSDB	(1)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P32MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P32MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P64MSDB	(2)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P64MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P64MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_2P56MSDB	(3)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_2P56MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_2P56MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_10P24MSDB	(4)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_10P24MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_40P96MSDB	(5)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_40P96MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_82MSDB	(6)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_82MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_82MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_164MSDB	(7)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_164MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_164MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+/* AGC2_FIRST_ATT_TIME bit 1:0 (PAGC2PR 0x0A) */
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P08MS	(0)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P08MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P08MS << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P32MS	(1)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P32MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P32MS << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_1P28MS	(2)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_1P28MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_1P28MS << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_5P12MS	(3)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_5P12MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_5P12MS << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT)
+
+/* default value of PAGC2PR (0x0A) */
+/* #define AW87XXX_PID_5A_REG_PAGC2PR_DEFAULT		(0x08) */
+
+/* PAGC1PR (0x0B) detail */
+/* AGC1_OUTPUT_LEVEL bit 6:3 (PAGC1PR 0x0B) */
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5V	(0)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P2V	(1)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P2V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P2V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P4V	(2)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P4V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P4V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P6V	(3)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P6V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P8V	(4)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P8V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P8V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P0V	(5)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P0V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P2V	(6)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P2V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P2V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P4V	(7)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P4V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P4V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P6V	(8)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P6V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P8V	(9)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P8V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P8V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7V	(10)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P2V	(11)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P2V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P2V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P4V	(12)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P4V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P4V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P6V	(13)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P6V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P8V	(14)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P8V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P8V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_8V	(15)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_8V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_8V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_DEFAULT_VALUE	(0x9)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+/* AGC1_ATT_TIME bit 2:1 (PAGC1PR 0x0B) */
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC1_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P04MSDB	(0)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P04MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P04MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P08MSDB	(1)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P08MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P08MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P16MSDB	(2)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P16MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P16MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P32MSDB	(3)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P32MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P32MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P02MSDB	(4)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P02MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P02MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P01MSDB	(5)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P01MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P01MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB	(6)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB	(7)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+/* PD_AGC1 bit 0 (PAGC1PR 0x0B) */
+#define AW87XXX_PID_5A_REG_PD_AGC1_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PD_AGC1_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PD_AGC1_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PD_AGC1_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PD_AGC1_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PD_AGC1_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_PD_AGC1_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_AGC1_ENABLE << AW87XXX_PID_5A_REG_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_AGC1_DISABLE	(1)
+#define AW87XXX_PID_5A_REG_PD_AGC1_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_AGC1_DISABLE << AW87XXX_PID_5A_REG_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_AGC1_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PD_AGC1_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PD_AGC1_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PD_AGC1_START_BIT)
+
+/* default value of PAGC1PR (0x0B) */
+/* #define AW87XXX_PID_5A_REG_PAGC1PR_DEFAULT		(0x4A) */
+
+/* ADP_MODE (0x0C) detail */
+/* AGC1_ATT_TIMEA bit 3 (ADP_MODE 0x0C) */
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P04MSDB	(0)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P04MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P04MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P08MSDB	(1)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P08MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P08MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P16MSDB	(2)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P16MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P16MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P32MSDB	(3)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P32MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P32MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P02MSDB	(4)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P02MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P02MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P01MSDB	(5)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P01MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P01MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB	(6)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB	(7)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+/* ADPBOOST_MODE bit 2:0 (ADP_MODE 0x0C) */
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADPBOOST_MODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_PASS_THROUGH	(0)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_PASS_THROUGH_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_PASS_THROUGH << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_FORCE_BOOST	(1)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_FORCE_BOOST_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_FORCE_BOOST << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD1	(2)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD1_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD1 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2	(3)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD3	(4)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD3_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD3 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD4	(5)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD4_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD4 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD5	(6)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD5_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD5 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2	(7)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+/* default value of ADP_MODE (0x0C) */
+/* #define AW87XXX_PID_5A_REG_ADP_MODE_DEFAULT		(0x03) */
+
+/* ADPBST_TIME1 (0x0D) detail */
+/* ADP_BST_TIME_2W bit 7:4 (ADPBST_TIME1 0x0D) */
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_1P25MS	(0)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_1P25MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_1P25MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_2P5MS	(1)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_2P5MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_2P5MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_5MS	(2)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_5MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_5MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_10MS	(3)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_10MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_10MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_15MS	(4)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_15MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_15MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_20MS	(5)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_20MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_20MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_30MS	(6)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_30MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_30MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_40MS	(7)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_40MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_40MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_65MS	(8)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_65MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_65MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_80MS	(9)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_80MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_80MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_100MS	(10)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_100MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_100MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_120MS	(11)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_120MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_120MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_140MS	(12)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_140MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_140MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_160MS	(13)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_160MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_160MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_320MS	(14)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_320MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_320MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_480MS	(15)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_480MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_480MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_DEFAULT_VALUE	(0xD)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+/* ADP_BST_TIME_0P4W bit 3:0 (ADPBST_TIME1 0x0D) */
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_1P25MS	(0)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_1P25MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_1P25MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_2P5MS	(1)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_2P5MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_2P5MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_5MS	(2)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_5MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_5MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_10MS	(3)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_10MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_10MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_15MS	(4)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_15MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_15MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_20MS	(5)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_20MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_20MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_30MS	(6)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_30MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_30MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_40MS	(7)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_40MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_40MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_65MS	(8)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_65MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_65MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_80MS	(9)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_80MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_80MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_100MS	(10)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_100MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_100MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_120MS	(11)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_120MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_120MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_140MS	(12)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_140MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_140MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_160MS	(13)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_160MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_160MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_320MS	(14)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_320MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_320MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_480MS	(15)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_480MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_480MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_DEFAULT_VALUE	(0xD)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+/* default value of ADPBST_TIME1 (0x0D) */
+/* #define AW87XXX_PID_5A_REG_ADPBST_TIME1_DEFAULT		(0xDD) */
+
+/* ADPBST_TIME2 (0x0E) detail */
+/* BST_UP_DT bit 7:4 (ADPBST_TIME2 0x0E) */
+#define AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_UP_DT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P005MS	(0)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P005MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P005MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P01MS	(1)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P01MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P01MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P015MS	(2)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P015MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P015MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P02MS	(3)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P02MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P02MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P03MS	(4)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P03MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P03MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P04MS	(5)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P04MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P04MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P05MS	(6)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P05MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P05MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P06MS	(7)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P06MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P06MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P07MS	(8)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P07MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P07MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P08MS	(9)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P08MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P08MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P10MS	(10)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P10MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P10MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P16MS	(11)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P16MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P16MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P20MS	(12)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P20MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P20MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P32MS	(13)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P32MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P32MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P64MS	(14)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P64MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P64MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_1P28MS	(15)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_1P28MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_1P28MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_DEFAULT_VALUE	(0x7)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+/* BST_DOWN_TD bit 3:0 (ADPBST_TIME2 0x0E) */
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_DOWN_TD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P01MS	(0)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P01MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P01MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P02MS	(1)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P02MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P02MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P04MS	(2)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P04MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P04MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P08MS	(3)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P08MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P08MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P12MS	(4)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P12MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P12MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P16MS	(5)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P16MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P16MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P24MS	(6)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P24MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P24MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P32MS	(7)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P32MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P32MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P64MS	(8)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P64MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P64MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P96MS	(9)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P96MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P96MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P28MS	(10)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P28MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_1P28MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P60MS	(11)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P60MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_1P60MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P92MS	(12)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P92MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_1P92MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_2P56MS	(13)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_2P56MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_2P56MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_5P12MS	(14)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_5P12MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_5P12MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_10P24MS	(15)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_10P24MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_10P24MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_DEFAULT_VALUE	(0xA)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+/* default value of ADPBST_TIME2 (0x0E) */
+/* #define AW87XXX_PID_5A_REG_ADPBST_TIME2_DEFAULT		(0x7A) */
+
+/* ADPBST_VTH (0x0F) detail */
+/* ADP_LOW_STEP bit 7:6 (ADPBST_VTH 0x0F) */
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_LOW_STEP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00000	(0)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00000_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00000 << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00001	(1)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00001_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00001 << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00010	(2)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00010_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00010 << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00011	(3)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00011_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00011 << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_LOW_STEP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT)
+
+/* SET_BOOST_VTH2 bit 5:3 (ADPBST_VTH 0x0F) */
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SET_BOOST_VTH2_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P2W	(0)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P2W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P2W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P4W	(1)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P4W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P4W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P6W	(2)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P6W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P6W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P8W	(3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P8W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P8W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P0W	(4)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P0W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P0W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P2W	(5)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P2W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P2W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W	(6)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W	(7)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+/* SET_BOOST_VTH1 bit 2:0 (ADPBST_VTH 0x0F) */
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SET_BOOST_VTH1_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P1W	(0)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P1W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P1W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P2W	(1)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P2W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P2W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P3W	(2)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P3W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P3W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P4W	(3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P4W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P4W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P5W	(4)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P5W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P5W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W	(5)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W	(6)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W	(7)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+/* default value of ADPBST_VTH (0x0F) */
+/* #define AW87XXX_PID_5A_REG_ADPBST_VTH_DEFAULT		(0x23) */
+
+/* BOOST_PAR (0x10) detail */
+/* CLKDLY_SELECT bit 7 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CLKDLY_SELECT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CLKDLY_SELECT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_CLK_DLY	(0)
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_CLK_DLY_VALUE	\
+	(AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_CLK_DLY << AW87XXX_PID_5A_REG_CLKDLY_SELECT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_MAXIM_DUTY	(1)
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_MAXIM_DUTY_VALUE	\
+	(AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_MAXIM_DUTY << AW87XXX_PID_5A_REG_CLKDLY_SELECT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CLKDLY_SELECT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CLKDLY_SELECT_START_BIT)
+
+/* CPOK_VBGOK bit 6 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CPOK_VBGOK_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CPOK_VBGOK_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_CPOK	(0)
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_CPOK_VALUE	\
+	(AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_CPOK << AW87XXX_PID_5A_REG_CPOK_VBGOK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_VBGOK	(1)
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_VBGOK_VALUE	\
+	(AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_VBGOK << AW87XXX_PID_5A_REG_CPOK_VBGOK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CPOK_VBGOK_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CPOK_VBGOK_START_BIT)
+
+/* EN_LOWBAT_ADJ bit 5 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DISABLE << AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_ENABLE << AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_START_BIT)
+
+/* EN_ADP_MODE1_DEGLITCH bit 4 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DISABLE << AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_ENABLE << AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+/* EN_VCLAMP_MIN_VTH bit 3 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DISABLE << AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_ENABLE << AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_START_BIT)
+
+/* SS_ADP_BIAS bit 2 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SS_ADP_BIAS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SS_ADP_BIAS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_4UA	(0)
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_4UA_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_4UA << AW87XXX_PID_5A_REG_SS_ADP_BIAS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_8UA	(1)
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_8UA_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_8UA << AW87XXX_PID_5A_REG_SS_ADP_BIAS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SS_ADP_BIAS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SS_ADP_BIAS_START_BIT)
+
+/* BOOST_VTH1_0P1W_0P2W bit 1 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P1W	(0)
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P1W_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P1W << AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P2W	(1)
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P2W_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P2W << AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_START_BIT)
+
+/* EN_LOWBAT_BOOST_VTH1 bit 0 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DISABLE << AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_ENABLE << AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_START_BIT)
+
+/* default value of BOOST_PAR (0x10) */
+/* #define AW87XXX_PID_5A_REG_BOOST_PAR_DEFAULT		(0x08) */
+
+/* BOOST_VOUT_DET (0x57) detail */
+/* ADP_BOOST_VOUT bit 4:0 (BOOST_VOUT_DET 0x57) */
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_BITS_LEN	(5)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P5V	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P75V	(1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P0V	(2)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P25V	(3)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P5V	(4)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P75V	(5)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P0V	(6)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P25V	(7)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P5V	(8)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P75V	(9)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P0V	(10)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P25V	(11)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P5V	(12)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P75V	(13)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P0V	(14)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P25V	(15)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P5V	(16)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P75V	(17)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P0V	(18)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P25V	(19)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P5V	(20)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P75V	(21)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P0V	(22)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P25V	(23)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P5V	(24)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_DEFAULT_VALUE	(0x0C)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+/* default value of BOOST_VOUT_DET (0x57) */
+/* #define AW87XXX_PID_5A_REG_BOOST_VOUT_DET_DEFAULT		(0x0C) */
+
+/* SYSST (0x58) detail */
+/* UVLO_S bit 7 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_UVLO_S_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_UVLO_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_UVLO_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_UVLO_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_UVLO_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_UVLO_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_UVLO_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_UVLO_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_S_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_5A_REG_UVLO_S_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_S_VBAT_UNDER_VOLTAGE << AW87XXX_PID_5A_REG_UVLO_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_UVLO_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_UVLO_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_UVLO_S_START_BIT)
+
+/* LOW_BATT_S bit 6 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_LOW_BATT_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_LOW_BATT_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_LOW_BATT_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_LOW_VBAT_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_LOW_VBAT_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_S_LOW_VBAT_DETECTED << AW87XXX_PID_5A_REG_LOW_BATT_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_LOW_BATT_S_START_BIT)
+
+/* BST_OVP_S bit 5 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_BST_OVP_S_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_BST_OVP_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_OVP_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION << AW87XXX_PID_5A_REG_BST_OVP_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP_S_START_BIT)
+
+/* BST_OVP2_S bit 4 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP2_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP2_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_OVP2_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_BST_OVP2_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP2_S_START_BIT)
+
+/* BST_SCP_S bit 3 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_BST_SCP_S_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_SCP_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_SCP_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SCP_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SCP_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SCP_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_SCP_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SCP_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_SCP_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_BST_SCP_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SCP_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_SCP_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SCP_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SCP_S_START_BIT)
+
+/* PA_OC_S bit 2 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_PA_OC_S_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_PA_OC_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_OC_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_OC_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_OC_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_OC_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_PA_OC_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_PA_OC_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_PA_OC_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_PA_OC_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_OC_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_OC_S_START_BIT)
+
+/* OT160_S bit 1 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_OT160_S_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_OT160_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_OT160_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_OT160_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_OT160_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_OT160_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_OT160_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_OT160_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_OT160_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_OT160_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OT160_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_OT160_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_OT160_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_OT160_S_START_BIT)
+
+/* ADP_BOOST_S bit 0 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_BOOST_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_BOOST_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_DIRECT_MODE	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_DIRECT_MODE_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_S_DIRECT_MODE << AW87XXX_PID_5A_REG_ADP_BOOST_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_BOOST_MODE	(1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_BOOST_MODE_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_S_BOOST_MODE << AW87XXX_PID_5A_REG_ADP_BOOST_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_BOOST_S_START_BIT)
+
+/* default value of SYSST (0x58) */
+/* #define AW87XXX_PID_5A_REG_SYSST_DEFAULT		(0xFF) */
+
+/* SYSINT (0x59) detail */
+/* UVLO_I bit 7 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_UVLO_I_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_UVLO_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_UVLO_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_UVLO_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_UVLO_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_UVLO_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_UVLO_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_UVLO_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_I_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_5A_REG_UVLO_I_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_I_VBAT_UNDER_VOLTAGE << AW87XXX_PID_5A_REG_UVLO_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_UVLO_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_UVLO_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_UVLO_I_START_BIT)
+
+/* LOW_BATT_I bit 6 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_LOW_BATT_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_LOW_BATT_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_LOW_BATT_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_LOW_VBAT_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_LOW_VBAT_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_I_LOW_VBAT_DETECTED << AW87XXX_PID_5A_REG_LOW_BATT_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_LOW_BATT_I_START_BIT)
+
+/* BST_OVP_I bit 5 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_BST_OVP_I_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_BST_OVP_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_OVP_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION << AW87XXX_PID_5A_REG_BST_OVP_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP_I_START_BIT)
+
+/* BST_OVP2_I bit 4 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP2_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP2_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_OVP2_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_BST_OVP2_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP2_I_START_BIT)
+
+/* BST_SCP_I bit 3 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_BST_SCP_I_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_SCP_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_SCP_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SCP_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SCP_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SCP_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_SCP_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SCP_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_SCP_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_BST_SCP_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SCP_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_SCP_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SCP_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SCP_I_START_BIT)
+
+/* PA_OC_I bit 2 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_PA_OC_I_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_PA_OC_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_OC_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_OC_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_OC_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_OC_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_PA_OC_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_PA_OC_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_PA_OC_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_PA_OC_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_OC_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_OC_I_START_BIT)
+
+/* OT160_I bit 1 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_OT160_I_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_OT160_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_OT160_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_OT160_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_OT160_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_OT160_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_OT160_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_OT160_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_OT160_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_OT160_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OT160_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_OT160_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_OT160_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_OT160_I_START_BIT)
+
+/* ADP_BOOST_I bit 0 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_BOOST_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_BOOST_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_DIRECT_MODE	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_DIRECT_MODE_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_I_DIRECT_MODE << AW87XXX_PID_5A_REG_ADP_BOOST_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_BOOST_MODE	(1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_BOOST_MODE_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_I_BOOST_MODE << AW87XXX_PID_5A_REG_ADP_BOOST_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_BOOST_I_START_BIT)
+
+/* default value of SYSINT (0x59) */
+/* #define AW87XXX_PID_5A_REG_SYSINT_DEFAULT		(0xFF) */
+
+/* DFT1R (0x60) detail */
+/* CP_FREQ bit 7:6 (DFT1R 0x60) */
+#define AW87XXX_PID_5A_REG_CP_FREQ_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_CP_FREQ_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_CP_FREQ_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CP_FREQ_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CP_FREQ_4P8MHZ	(0)
+#define AW87XXX_PID_5A_REG_CP_FREQ_4P8MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_FREQ_4P8MHZ << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_FREQ_6P4MHZ	(1)
+#define AW87XXX_PID_5A_REG_CP_FREQ_6P4MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_FREQ_6P4MHZ << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_FREQ_8P0MHZ	(2)
+#define AW87XXX_PID_5A_REG_CP_FREQ_8P0MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_FREQ_8P0MHZ << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_FREQ_9P6MHZ	(3)
+#define AW87XXX_PID_5A_REG_CP_FREQ_9P6MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_FREQ_9P6MHZ << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_FREQ_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_CP_FREQ_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CP_FREQ_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT)
+
+/* CP_LDO bit 5:4 (DFT1R 0x60) */
+#define AW87XXX_PID_5A_REG_CP_LDO_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_CP_LDO_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_CP_LDO_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CP_LDO_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CP_LDO_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CP_LDO_4P75V	(0)
+#define AW87XXX_PID_5A_REG_CP_LDO_4P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_LDO_4P75V << AW87XXX_PID_5A_REG_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_LDO_5V	(1)
+#define AW87XXX_PID_5A_REG_CP_LDO_5V_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_LDO_5V << AW87XXX_PID_5A_REG_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_LDO_5P25V	(2)
+#define AW87XXX_PID_5A_REG_CP_LDO_5P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_LDO_5P25V << AW87XXX_PID_5A_REG_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_LDO_5P5V	(3)
+#define AW87XXX_PID_5A_REG_CP_LDO_5P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_LDO_5P5V << AW87XXX_PID_5A_REG_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_LDO_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_CP_LDO_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CP_LDO_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CP_LDO_START_BIT)
+
+/* CP_VOS bit 3:2 (DFT1R 0x60) */
+#define AW87XXX_PID_5A_REG_CP_VOS_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_CP_VOS_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_CP_VOS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CP_VOS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CP_VOS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CP_VOS_0MV	(0)
+#define AW87XXX_PID_5A_REG_CP_VOS_0MV_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_VOS_0MV << AW87XXX_PID_5A_REG_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_VOS_50MV	(1)
+#define AW87XXX_PID_5A_REG_CP_VOS_50MV_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_VOS_50MV << AW87XXX_PID_5A_REG_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_VOS_100MV	(2)
+#define AW87XXX_PID_5A_REG_CP_VOS_100MV_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_VOS_100MV << AW87XXX_PID_5A_REG_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_VOS_150MV	(3)
+#define AW87XXX_PID_5A_REG_CP_VOS_150MV_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_VOS_150MV << AW87XXX_PID_5A_REG_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_VOS_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_CP_VOS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CP_VOS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CP_VOS_START_BIT)
+
+/* CPOK_TM bit 1 (DFT1R 0x60) */
+#define AW87XXX_PID_5A_REG_CPOK_TM_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_CPOK_TM_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_CPOK_TM_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CPOK_TM_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CPOK_TM_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CPOK_TM_0P6MS	(0)
+#define AW87XXX_PID_5A_REG_CPOK_TM_0P6MS_VALUE	\
+	(AW87XXX_PID_5A_REG_CPOK_TM_0P6MS << AW87XXX_PID_5A_REG_CPOK_TM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CPOK_TM_1MS	(1)
+#define AW87XXX_PID_5A_REG_CPOK_TM_1MS_VALUE	\
+	(AW87XXX_PID_5A_REG_CPOK_TM_1MS << AW87XXX_PID_5A_REG_CPOK_TM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CPOK_TM_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_CPOK_TM_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CPOK_TM_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CPOK_TM_START_BIT)
+
+/* CP_DDT bit 0 (DFT1R 0x60) */
+#define AW87XXX_PID_5A_REG_CP_DDT_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_CP_DDT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_CP_DDT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CP_DDT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CP_DDT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CP_DDT_0NS	(0)
+#define AW87XXX_PID_5A_REG_CP_DDT_0NS_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_DDT_0NS << AW87XXX_PID_5A_REG_CP_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_DDT_10NS	(1)
+#define AW87XXX_PID_5A_REG_CP_DDT_10NS_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_DDT_10NS << AW87XXX_PID_5A_REG_CP_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_DDT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_CP_DDT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CP_DDT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CP_DDT_START_BIT)
+
+/* default value of DFT1R (0x60) */
+/* #define AW87XXX_PID_5A_REG_DFT1R_DEFAULT		(0x66) */
+
+/* DFT2R (0x61) detail */
+/* BOOST_VCLAMP_SS bit 7:6 (DFT2R 0x61) */
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_680MV840MV	(0)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_680MV840MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_680MV840MV << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_780MV930MV	(1)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_780MV930MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_780MV930MV << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1070MV1225MV	(2)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1070MV1225MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1070MV1225MV << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1350MV1500MV	(3)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1350MV1500MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1350MV1500MV << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT)
+
+/* BST_KICK_ITH bit 5:4 (DFT2R 0x61) */
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_KICK_ITH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P5KOHM	(0)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P5KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P5KOHM << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P25KOHM	(1)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P25KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P25KOHM << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P167KOHM	(2)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P167KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P167KOHM << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P125KOHM	(3)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P125KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P125KOHM << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_KICK_ITH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT)
+
+/* BST_EA_CUR bit 3 (DFT2R 0x61) */
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_EA_CUR_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_EA_CUR_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_1UA	(0)
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_1UA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EA_CUR_1UA << AW87XXX_PID_5A_REG_BST_EA_CUR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_4UA	(1)
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_4UA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EA_CUR_4UA << AW87XXX_PID_5A_REG_BST_EA_CUR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_EA_CUR_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_EA_CUR_START_BIT)
+
+/* BST_CK_MODE bit 2 (DFT2R 0x61) */
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_CK_MODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_CK_MODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_1P6MHZ	(0)
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_1P6MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_CK_MODE_1P6MHZ << AW87XXX_PID_5A_REG_BST_CK_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_2P0MHZ	(1)
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_2P0MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_CK_MODE_2P0MHZ << AW87XXX_PID_5A_REG_BST_CK_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_CK_MODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_CK_MODE_START_BIT)
+
+/* BST_COMPMAX bit 1:0 (DFT2R 0x61) */
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_COMPMAX_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P2V	(0)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P2V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_COMPMAX_2P2V << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P4V	(1)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P4V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_COMPMAX_2P4V << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P6V	(2)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_COMPMAX_2P6V << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P8V	(3)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P8V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_COMPMAX_2P8V << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_COMPMAX_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT)
+
+/* default value of DFT2R (0x61) */
+/* #define AW87XXX_PID_5A_REG_DFT2R_DEFAULT		(0x18) */
+
+/* DFT3R (0x62) detail */
+/* BST_PWM_SHORT bit 7 (DFT3R 0x62) */
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_PWM_SHORT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_PWM_SHORT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDD	(0)
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDD_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDD << AW87XXX_PID_5A_REG_BST_PWM_SHORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDDMINUS_VTH	(1)
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDDMINUS_VTH_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDDMINUS_VTH << AW87XXX_PID_5A_REG_BST_PWM_SHORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_PWM_SHORT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_PWM_SHORT_START_BIT)
+
+/* BST_SLOPE bit 6:5 (DFT3R 0x62) */
+#define AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SLOPE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE	(0)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P25	(1)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P25_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P25 << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P5	(2)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P5_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P5 << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P75	(3)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P75_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P75 << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT)
+
+/* BST_LOOPC bit 4 (DFT3R 0x62) */
+#define AW87XXX_PID_5A_REG_BST_LOOPC_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_LOOPC_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_LOOPC_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_LOOPC_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_LOOPC_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_LOOPC_28PF	(0)
+#define AW87XXX_PID_5A_REG_BST_LOOPC_28PF_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPC_28PF << AW87XXX_PID_5A_REG_BST_LOOPC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LOOPC_50PF	(1)
+#define AW87XXX_PID_5A_REG_BST_LOOPC_50PF_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPC_50PF << AW87XXX_PID_5A_REG_BST_LOOPC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LOOPC_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_LOOPC_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_LOOPC_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_LOOPC_START_BIT)
+
+/* BST_OS_WIDTH bit 3:2 (DFT3R 0x62) */
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OS_WIDTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_40NS	(0)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_40NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OS_WIDTH_40NS << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_30NS	(1)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_30NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OS_WIDTH_30NS << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_50NS	(2)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_50NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OS_WIDTH_50NS << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_60NS	(3)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_60NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OS_WIDTH_60NS << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OS_WIDTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT)
+
+/* BST_LOOPR bit 1:0 (DFT3R 0x62) */
+#define AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_LOOPR_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_LOOPR_320K	(0)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_320K_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPR_320K << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LOOPR_160K	(1)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_160K_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPR_160K << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LOOPR_480K	(2)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_480K_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPR_480K << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_BST_LOOPR_320K	(3)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_320K_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPR_320K << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_BST_LOOPR_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_LOOPR_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT)
+
+/* default value of DFT3R (0x62) */
+/* #define AW87XXX_PID_5A_REG_DFT3R_DEFAULT		(0x02) */
+
+/* DFT4R (0x63) detail */
+/* BST_BURST_IN_DELAY bit 7:6 (DFT4R 0x63) */
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_8US	(0)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_8US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_8US << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_12US	(1)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_12US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_12US << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_4US	(2)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_4US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_4US << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_2US	(3)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_2US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_2US << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT)
+
+/* BST_BURST_OUT_DELAY bit 5:4 (DFT4R 0x63) */
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_2US	(0)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_2US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_2US << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_4US	(1)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_4US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_4US << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P3US	(2)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P3US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P3US << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P0US	(3)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P0US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P0US << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT)
+
+/* BST_EN_DELAY bit 3:2 (DFT4R 0x63) */
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_EN_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_8NS	(0)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_8NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_DELAY_8NS << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_80NS	(1)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_80NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_DELAY_80NS << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_130NS	(2)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_130NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_DELAY_130NS << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_200NS	(3)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_200NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_DELAY_200NS << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_EN_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT)
+
+/* BST_GD_DELAY bit 1:0 (DFT4R 0x63) */
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_GD_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_1P2NS	(0)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_1P2NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_1P2NS << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_2P5NS	(1)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_2P5NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_2P5NS << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_1P2NS	(2)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_1P2NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_1P2NS << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_2P5NS	(3)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_2P5NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_2P5NS << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_GD_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT)
+
+/* default value of DFT4R (0x63) */
+/* #define AW87XXX_PID_5A_REG_DFT4R_DEFAULT		(0x08) */
+
+/* DFT5R (0x64) detail */
+/* PA_FLT_SR bit 7 (DFT5R 0x64) */
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_FLT_SR_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_FLT_SR_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_FLT_SR_ENABLE << AW87XXX_PID_5A_REG_PA_FLT_SR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_DISABLE	(1)
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_FLT_SR_DISABLE << AW87XXX_PID_5A_REG_PA_FLT_SR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_FLT_SR_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_FLT_SR_START_BIT)
+
+/* AGC1_VTH_SEL bit 6:5 (DFT5R 0x64) */
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC1_VTH_SEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN	(0)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_THGEN	(1)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_THGEN_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_VTH_SEL_THGEN << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN	(2)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN	(3)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC1_VTH_SEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT)
+
+/* BST_OVP2_EN bit 4 (DFT5R 0x64) */
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP2_EN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP2_EN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_EN_DISABLE << AW87XXX_PID_5A_REG_BST_OVP2_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_EN_ENABLE << AW87XXX_PID_5A_REG_BST_OVP2_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_EN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP2_EN_START_BIT)
+
+/* BST_OVP2_ITH bit 3:2 (DFT5R 0x64) */
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP2_ITH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P5KOHM	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P5KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P5KOHM << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P25KOHM	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P25KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P25KOHM << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P167KOHM	(2)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P167KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P167KOHM << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P125KOHM	(3)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P125KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P125KOHM << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_ITH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT)
+
+/* BST_OVP2_VTH bit 1:0 (DFT5R 0x64) */
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP2_VTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_13V_9V	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_13V_9V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_VTH_13V_9V << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_13P5V_9P5V	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_13P5V_9P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_VTH_13P5V_9P5V << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_14V_10V	(2)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_14V_10V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_VTH_14V_10V << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_14P5V_10P5V	(3)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_14P5V_10P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_VTH_14P5V_10P5V << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_VTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT)
+
+/* default value of DFT5R (0x64) */
+/* #define AW87XXX_PID_5A_REG_DFT5R_DEFAULT		(0x45) */
+
+/* DFT6R (0x65) detail */
+/* POWER_SAVE_DLY_SELECT bit 7 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_HIGH_VOLTAGE_TRIGGER	(0)
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_HIGH_VOLTAGE_TRIGGER_VALUE	\
+	(AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_HIGH_VOLTAGE_TRIGGER << AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_CLK_RISING_EDGE_TRIGGER	(1)
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_CLK_RISING_EDGE_TRIGGER_VALUE	\
+	(AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_CLK_RISING_EDGE_TRIGGER << AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_START_BIT)
+
+/* PA_OPD bit 6 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_PA_OPD_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_PA_OPD_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_OPD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_OPD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_OPD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_FLOATING	(0)
+#define AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_FLOATING_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_FLOATING << AW87XXX_PID_5A_REG_PA_OPD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_TIED_TO_GND	(1)
+#define AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_TIED_TO_GND_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_TIED_TO_GND << AW87XXX_PID_5A_REG_PA_OPD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OPD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_PA_OPD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_OPD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_OPD_START_BIT)
+
+/* CLK_OCP_SEL bit 5 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CLK_OCP_SEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CLK_OCP_SEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_160MS	(0)
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_160MS_VALUE	\
+	(AW87XXX_PID_5A_REG_CLK_OCP_SEL_160MS << AW87XXX_PID_5A_REG_CLK_OCP_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_640MS	(1)
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_640MS_VALUE	\
+	(AW87XXX_PID_5A_REG_CLK_OCP_SEL_640MS << AW87XXX_PID_5A_REG_CLK_OCP_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CLK_OCP_SEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CLK_OCP_SEL_START_BIT)
+
+/* BST_SKIP_EN bit 4 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SKIP_EN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SKIP_EN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SKIP_EN_DISABLE << AW87XXX_PID_5A_REG_BST_SKIP_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SKIP_EN_ENABLE << AW87XXX_PID_5A_REG_BST_SKIP_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SKIP_EN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SKIP_EN_START_BIT)
+
+/* BST_OVP_DEGLITCH_SEL bit 3 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_NO_DEGLITCH	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_NO_DEGLITCH_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_NO_DEGLITCH << AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEGLITCH_300NS	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEGLITCH_300NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEGLITCH_300NS << AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_START_BIT)
+
+/* BST_NCD_ITH bit 2:1 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_NCD_ITH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_150MA	(0)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_150MA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_NCD_ITH_150MA << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_200MA	(1)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_200MA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_NCD_ITH_200MA << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_250MA	(2)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_250MA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_NCD_ITH_250MA << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_300MA	(3)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_300MA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_NCD_ITH_300MA << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_NCD_ITH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT)
+
+/* BST_LMD_VTH bit 0 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_LMD_VTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_LMD_VTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_HIGH_SIDE_VDD	(0)
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_HIGH_SIDE_VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LMD_VTH_HIGH_SIDE_VDD << AW87XXX_PID_5A_REG_BST_LMD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_LOW_SIDE_VDD	(1)
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_LOW_SIDE_VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LMD_VTH_LOW_SIDE_VDD << AW87XXX_PID_5A_REG_BST_LMD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_LMD_VTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_LMD_VTH_START_BIT)
+
+/* default value of DFT6R (0x65) */
+/* #define AW87XXX_PID_5A_REG_DFT6R_DEFAULT		(0x53) */
+
+/* DFT7R (0x66) detail */
+
+/* PA_OC_DT bit 4:3 (DFT7R 0x66) */
+#define AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_OC_DT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_OC_DT_80NS	(0)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_80NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_DT_80NS << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_DT_150NS	(1)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_150NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_DT_150NS << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_DT_210NS	(2)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_210NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_DT_210NS << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_DT_240NS	(3)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_240NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_DT_240NS << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_DT_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_OC_DT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT)
+
+/* PA_RAMP_AGC1 bit 2:1 (DFT7R 0x66) */
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_RAMP_AGC1_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P8VDD	(0)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P8VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P8VDD << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P825VDD	(1)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P825VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P825VDD << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P85VDD	(2)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P85VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P85VDD << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P875VDD	(3)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P875VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P875VDD << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_RAMP_AGC1_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT)
+
+/* PA_OCSWD bit 0 (DFT7R 0x66) */
+#define AW87XXX_PID_5A_REG_PA_OCSWD_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PA_OCSWD_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_OCSWD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_OCSWD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_OCSWD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_GATEDRIVER	(0)
+#define AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_GATEDRIVER_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_GATEDRIVER << AW87XXX_PID_5A_REG_PA_OCSWD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_SWITCH_MOS	(1)
+#define AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_SWITCH_MOS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_SWITCH_MOS << AW87XXX_PID_5A_REG_PA_OCSWD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OCSWD_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_OCSWD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_OCSWD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_OCSWD_START_BIT)
+
+/* default value of DFT7R (0x66) */
+/* #define AW87XXX_PID_5A_REG_DFT7R_DEFAULT		(0x70) */
+
+/* DFT8R (0x67) detail */
+/* PA_GD_DELAY bit 7:6 (DFT8R 0x67) */
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_GD_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_1P2NS	(0)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_1P2NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_1P2NS << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_2P5NS	(1)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_2P5NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_2P5NS << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_1P2NS	(2)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_1P2NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_1P2NS << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_2P5NS	(3)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_2P5NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_2P5NS << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_GD_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT)
+
+/* PA_GD_DGT bit 5 (DFT8R 0x67) */
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_GD_DGT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_GD_DGT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_4NS	(0)
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_4NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DGT_4NS << AW87XXX_PID_5A_REG_PA_GD_DGT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_5P5NS	(1)
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_5P5NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DGT_5P5NS << AW87XXX_PID_5A_REG_PA_GD_DGT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_GD_DGT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_GD_DGT_START_BIT)
+
+/* PA_PORT bit 4:3 (DFT8R 0x67) */
+#define AW87XXX_PID_5A_REG_PA_PORT_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_PA_PORT_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PA_PORT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_PORT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_PORT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_PORT_80MS	(0)
+#define AW87XXX_PID_5A_REG_PA_PORT_80MS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_PORT_80MS << AW87XXX_PID_5A_REG_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_PORT_40MS	(1)
+#define AW87XXX_PID_5A_REG_PA_PORT_40MS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_PORT_40MS << AW87XXX_PID_5A_REG_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_PORT_20MS	(2)
+#define AW87XXX_PID_5A_REG_PA_PORT_20MS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_PORT_20MS << AW87XXX_PID_5A_REG_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_PORT_10MS	(3)
+#define AW87XXX_PID_5A_REG_PA_PORT_10MS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_PORT_10MS << AW87XXX_PID_5A_REG_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_PORT_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_PA_PORT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_PORT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_PORT_START_BIT)
+
+/* EN_AGC1_ADP bit 2 (DFT8R 0x67) */
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_AGC1_ADP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_AGC1_ADP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE	(0)
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE << AW87XXX_PID_5A_REG_EN_AGC1_ADP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY	(1)
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY << AW87XXX_PID_5A_REG_EN_AGC1_ADP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_AGC1_ADP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_AGC1_ADP_START_BIT)
+
+/* PD_CROSSZERO bit 1:0 (DFT8R 0x67) */
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PD_CROSSZERO_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO	(0)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC2AGC3_CROSS_ZERO_DISABLE_AGC1_CROSS_ZERO	(1)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC2AGC3_CROSS_ZERO_DISABLE_AGC1_CROSS_ZERO_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC2AGC3_CROSS_ZERO_DISABLE_AGC1_CROSS_ZERO << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC3_CROSS_ZERO_DISABLE_AGC1AGC2_CROSS_ZERO	(2)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC3_CROSS_ZERO_DISABLE_AGC1AGC2_CROSS_ZERO_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC3_CROSS_ZERO_DISABLE_AGC1AGC2_CROSS_ZERO << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_DISABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO	(3)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_DISABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_CROSSZERO_DISABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PD_CROSSZERO_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT)
+
+/* default value of DFT8R (0x67) */
+/* #define AW87XXX_PID_5A_REG_DFT8R_DEFAULT		(0x08) */
+
+/* DFT9R (0x68) detail */
+/* EN_BOOST_VCLAMP_SS bit 7 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DISABLE << AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_ENABLE << AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_START_BIT)
+
+/* EN_BOOST_PLDO bit 6 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_BOOST_PLDO_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_BOOST_PLDO_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_VDD	(0)
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_VDD << AW87XXX_PID_5A_REG_EN_BOOST_PLDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_PVLDO	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_PVLDO_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_PVLDO << AW87XXX_PID_5A_REG_EN_BOOST_PLDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_PLDO_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_BOOST_PLDO_START_BIT)
+
+/* EN_CLAMP bit 5 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_EN_CLAMP_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_EN_CLAMP_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_CLAMP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_CLAMP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_CLAMP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_CLAMP_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_CLAMP_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_CLAMP_DISABLE << AW87XXX_PID_5A_REG_EN_CLAMP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_CLAMP_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_CLAMP_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_CLAMP_ENABLE << AW87XXX_PID_5A_REG_EN_CLAMP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_CLAMP_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_EN_CLAMP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_CLAMP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_CLAMP_START_BIT)
+
+/* EN_VBG_PASS bit 4 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_VBG_PASS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_VBG_PASS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_VBG_PASS_DISABLE << AW87XXX_PID_5A_REG_EN_VBG_PASS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_VBG_PASS_ENABLE << AW87XXX_PID_5A_REG_EN_VBG_PASS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_VBG_PASS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_VBG_PASS_START_BIT)
+
+/* SS_SOFT_IPEAK_ADP bit 3 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DISABLE << AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_ENABLE << AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_START_BIT)
+
+/* EN_ADP_IPEAK bit 2 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_ADP_IPEAK_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_ADP_IPEAK_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DISABLE << AW87XXX_PID_5A_REG_EN_ADP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_ADP_IPEAK_ENABLE << AW87XXX_PID_5A_REG_EN_ADP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_ADP_IPEAK_START_BIT)
+
+/* SEL_FINISH_ID bit 1 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SEL_FINISH_ID_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SEL_FINISH_ID_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_MODE1_DELAY	(0)
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_MODE1_DELAY_VALUE	\
+	(AW87XXX_PID_5A_REG_SEL_FINISH_ID_MODE1_DELAY << AW87XXX_PID_5A_REG_SEL_FINISH_ID_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_LIMIT_SS_FINISH	(1)
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_LIMIT_SS_FINISH_VALUE	\
+	(AW87XXX_PID_5A_REG_SEL_FINISH_ID_LIMIT_SS_FINISH << AW87XXX_PID_5A_REG_SEL_FINISH_ID_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SEL_FINISH_ID_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SEL_FINISH_ID_START_BIT)
+
+/* SS_FINISH_SELECTED bit 0 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_3US	(0)
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_3US_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_3US << AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_0US	(1)
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_0US_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_0US << AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_START_BIT)
+
+/* default value of DFT9R (0x68) */
+/* #define AW87XXX_PID_5A_REG_DFT9R_DEFAULT		(0x21) */
+
+/* DFTAR (0x69) detail */
+/* HWM_DELAY_INITIAL bit 7:6 (DFTAR 0x69) */
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_104NS	(0)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_104NS_VALUE	\
+	(AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_104NS << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_63NS	(1)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_63NS_VALUE	\
+	(AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_63NS << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_56NS	(2)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_56NS_VALUE	\
+	(AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_56NS << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_42NS	(3)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_42NS_VALUE	\
+	(AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_42NS << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT)
+
+/* BST_DFPWM bit 5:3 (DFTAR 0x69) */
+#define AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_DFPWM_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_2P5US	(0)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_2P5US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_2P5US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_5US	(1)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_5US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_5US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_10US	(2)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_10US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_10US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_20US	(3)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_20US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_20US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_40US	(4)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_40US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_40US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_80US	(5)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_80US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_80US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_160US	(6)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_160US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_160US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_320US	(7)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_320US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_320US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+/* BST_SOFT_DELAY bit 2:0 (DFTAR 0x69) */
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SOFT_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_40US	(0)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_40US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_40US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_80US	(1)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_80US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_80US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_160US	(2)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_160US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_160US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_320US	(3)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_320US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_320US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_1280US	(4)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_1280US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_1280US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_2560US	(5)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_2560US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_2560US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_5120US	(6)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_5120US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_5120US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_10240US	(7)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_10240US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_10240US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+/* default value of DFTAR (0x69) */
+/* #define AW87XXX_PID_5A_REG_DFTAR_DEFAULT		(0xA4) */
+
+/* DFTBR (0x70) detail */
+/* BST_CLK_DIV bit 4 (DFTBR 0x70) */
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_CLK_DIV_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_CLK_DIV_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_4	(0)
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_4_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_4 << AW87XXX_PID_5A_REG_BST_CLK_DIV_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_2	(1)
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_2_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_2 << AW87XXX_PID_5A_REG_BST_CLK_DIV_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_CLK_DIV_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_CLK_DIV_START_BIT)
+
+/* RAMP_1SPW_VC bit 3:2 (DFTBR 0x70) */
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_RAMP_1SPW_VC_BITS_LEN)-1) << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT))
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P37VDD	(0)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P37VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P37VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P39VDD	(1)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P39VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P39VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P33VDD	(2)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P33VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P33VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P35VDD	(3)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P35VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P35VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_DEFAULT	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VC_DEFAULT_VALUE << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT)
+
+/* RAMP_1SPW_VL bit 1:0 (DFTBR 0x70) */
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_RAMP_1SPW_VL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P16VDD	(0)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P16VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P16VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P18VDD	(1)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P18VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P18VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P20VDD	(2)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P20VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P20VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P14VDD	(3)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P14VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P14VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT)
+
+/* default value of DFTBR (0x70) */
+/* #define AW87XXX_PID_5A_REG_DFTBR_DEFAULT		(0x1C) */
+
+/* DFTCR (0x71) detail */
+/* DT_EN bit 7 (DFTCR 0x71) */
+#define AW87XXX_PID_5A_REG_DT_EN_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_DT_EN_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_DT_EN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_DT_EN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_DT_EN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_DT_EN_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_DT_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_DT_EN_DISABLE << AW87XXX_PID_5A_REG_DT_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DT_EN_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_DT_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_DT_EN_ENABLE << AW87XXX_PID_5A_REG_DT_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DT_EN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_DT_EN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_DT_EN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_DT_EN_START_BIT)
+
+/* BST_TD bit 6:4 (DFTCR 0x71) */
+#define AW87XXX_PID_5A_REG_BST_TD_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_TD_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_BST_TD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_TD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_TD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_TD_0P08MS	(0)
+#define AW87XXX_PID_5A_REG_BST_TD_0P08MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_0P08MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_0P16MS	(1)
+#define AW87XXX_PID_5A_REG_BST_TD_0P16MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_0P16MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_0P32MS	(2)
+#define AW87XXX_PID_5A_REG_BST_TD_0P32MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_0P32MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_0P64MS	(3)
+#define AW87XXX_PID_5A_REG_BST_TD_0P64MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_0P64MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_1P28MS	(4)
+#define AW87XXX_PID_5A_REG_BST_TD_1P28MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_1P28MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_2P56MS	(5)
+#define AW87XXX_PID_5A_REG_BST_TD_2P56MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_2P56MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_5P12MS	(6)
+#define AW87XXX_PID_5A_REG_BST_TD_5P12MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_5P12MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_10P24MS	(7)
+#define AW87XXX_PID_5A_REG_BST_TD_10P24MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_10P24MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_TD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_TD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+/* BST_GTDR_DDT bit 3 (DFTCR 0x71) */
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_GTDR_DDT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_GTDR_DDT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_3NS	(0)
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_3NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GTDR_DDT_3NS << AW87XXX_PID_5A_REG_BST_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_6NS	(1)
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_6NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GTDR_DDT_6NS << AW87XXX_PID_5A_REG_BST_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_GTDR_DDT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_GTDR_DDT_START_BIT)
+
+/* BST_EN_RSQN_DLY bit 2 (DFTCR 0x71) */
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DISABLE << AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_ENABLE << AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_START_BIT)
+
+/* BST_RSQN_DLY bit 1:0 (DFTCR 0x71) */
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_RSQN_DLY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_15NS	(0)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_15NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_RSQN_DLY_15NS << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_25NS	(1)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_25NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_RSQN_DLY_25NS << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_35NS	(2)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_35NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_RSQN_DLY_35NS << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_45NS	(3)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_45NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_RSQN_DLY_45NS << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_RSQN_DLY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT)
+
+/* default value of DFTCR (0x71) */
+/* #define AW87XXX_PID_5A_REG_DFTCR_DEFAULT		(0x10) */
+
+/* DFTDR (0x72) detail */
+/* DLY_EN bit 7 (DFTDR 0x72) */
+#define AW87XXX_PID_5A_REG_DLY_EN_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_DLY_EN_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_DLY_EN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_DLY_EN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_DLY_EN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_DLY_EN_NO_DELAY	(0)
+#define AW87XXX_PID_5A_REG_DLY_EN_NO_DELAY_VALUE	\
+	(AW87XXX_PID_5A_REG_DLY_EN_NO_DELAY << AW87XXX_PID_5A_REG_DLY_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DLY_EN_DELAY_TWO_CLOCK	(1)
+#define AW87XXX_PID_5A_REG_DLY_EN_DELAY_TWO_CLOCK_VALUE	\
+	(AW87XXX_PID_5A_REG_DLY_EN_DELAY_TWO_CLOCK << AW87XXX_PID_5A_REG_DLY_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DLY_EN_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_DLY_EN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_DLY_EN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_DLY_EN_START_BIT)
+
+/* DOWNSIGNAL_SEL bit 6 (DFTDR 0x72) */
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_160MS	(0)
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_160MS_VALUE	\
+	(AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_160MS << AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_640MS	(1)
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_640MS_VALUE	\
+	(AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_640MS << AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_START_BIT)
+
+/* BST_SLOPE_LIMIT bit 5:3 (DFTDR 0x72) */
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0SLOPE	(0)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P25SLOPE	(1)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P25SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P25SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE	(2)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE	(3)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE	(4)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P75SLOPE	(5)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P75SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P75SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE	(6)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P75SLOPE	(7)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P75SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P75SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+
+/* MODEL_START_DELAY bit 2:1 (DFTDR 0x72) */
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_MODEL_START_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_20US	(0)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_20US_VALUE	\
+	(AW87XXX_PID_5A_REG_MODEL_START_DELAY_20US << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_0US	(1)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_0US_VALUE	\
+	(AW87XXX_PID_5A_REG_MODEL_START_DELAY_0US << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_5US	(2)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_5US_VALUE	\
+	(AW87XXX_PID_5A_REG_MODEL_START_DELAY_5US << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_2P5US	(3)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_2P5US_VALUE	\
+	(AW87XXX_PID_5A_REG_MODEL_START_DELAY_2P5US << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_MODEL_START_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT)
+
+/* PEAK_LIMIT_SS_CAP bit 0 (DFTDR 0x72) */
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_350FF	(0)
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_350FF_VALUE	\
+	(AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_350FF << AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_0FF	(1)
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_0FF_VALUE	\
+	(AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_0FF << AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_START_BIT)
+
+/* default value of DFTDR (0x72) */
+/* #define AW87XXX_PID_5A_REG_DFTDR_DEFAULT		(0xA0) */
+
+/* DFTER (0x73) detail */
+/* BST_SS_TIME bit 7:6 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SS_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_35US	(0)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_35US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SS_TIME_35US << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_56US	(1)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_56US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SS_TIME_56US << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_76US	(2)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_76US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SS_TIME_76US << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_107US	(3)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_107US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SS_TIME_107US << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SS_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT)
+
+/* PD_UVLO bit 5 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_PD_UVLO_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_PD_UVLO_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PD_UVLO_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PD_UVLO_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PD_UVLO_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PD_UVLO_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_PD_UVLO_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_UVLO_ENABLE << AW87XXX_PID_5A_REG_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_UVLO_DISABLE	(1)
+#define AW87XXX_PID_5A_REG_PD_UVLO_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_UVLO_DISABLE << AW87XXX_PID_5A_REG_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_UVLO_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PD_UVLO_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PD_UVLO_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PD_UVLO_START_BIT)
+
+/* UVLO_VTH bit 4:3 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_UVLO_VTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P6V_VL2P5V	(0)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P6V_VL2P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_VTH_VH2P6V_VL2P5V << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P7V_VL2P6V	(1)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P7V_VL2P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_VTH_VH2P7V_VL2P6V << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P8V_VL2P7V	(2)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P8V_VL2P7V_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_VTH_VH2P8V_VL2P7V << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P9V_VL2P8V	(3)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P9V_VL2P8V_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_VTH_VH2P9V_VL2P8V << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_VTH_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_UVLO_VTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT)
+
+/* UVLO_DT bit 2 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_UVLO_DT_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_UVLO_DT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_UVLO_DT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_UVLO_DT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_UVLO_DT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_UVLO_DT_3US	(0)
+#define AW87XXX_PID_5A_REG_UVLO_DT_3US_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_DT_3US << AW87XXX_PID_5A_REG_UVLO_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_DT_10US	(1)
+#define AW87XXX_PID_5A_REG_UVLO_DT_10US_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_DT_10US << AW87XXX_PID_5A_REG_UVLO_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_DT_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_UVLO_DT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_UVLO_DT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_UVLO_DT_START_BIT)
+
+/* OC_DISABLE bit 1 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_OC_DISABLE_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_OC_DISABLE_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_OC_DISABLE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_OC_DISABLE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_OC_DISABLE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_OC_DISABLE_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_OC_DISABLE_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_OC_DISABLE_ENABLE << AW87XXX_PID_5A_REG_OC_DISABLE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OC_DISABLE_SHUTDOWN	(1)
+#define AW87XXX_PID_5A_REG_OC_DISABLE_SHUTDOWN_VALUE	\
+	(AW87XXX_PID_5A_REG_OC_DISABLE_SHUTDOWN << AW87XXX_PID_5A_REG_OC_DISABLE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OC_DISABLE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_OC_DISABLE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_OC_DISABLE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_OC_DISABLE_START_BIT)
+
+/* PD_OT bit 0 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_PD_OT_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PD_OT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PD_OT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PD_OT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PD_OT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PD_OT_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_PD_OT_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_OT_ENABLE << AW87XXX_PID_5A_REG_PD_OT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_OT_SHUTDOWN	(1)
+#define AW87XXX_PID_5A_REG_PD_OT_SHUTDOWN_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_OT_SHUTDOWN << AW87XXX_PID_5A_REG_PD_OT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_OT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PD_OT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PD_OT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PD_OT_START_BIT)
+
+/* default value of DFTER (0x73) */
+/* #define AW87XXX_PID_5A_REG_DFTER_DEFAULT		(0x54) */
+
+/* DFTFR (0x74) detail */
+/* EN_SWF bit 6 (DFTFR 0x74) */
+#define AW87XXX_PID_5A_REG_EN_SWF_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_EN_SWF_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_SWF_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_SWF_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_SWF_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_SWF_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_SWF_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_SWF_DISABLE << AW87XXX_PID_5A_REG_EN_SWF_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_SWF_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_SWF_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_SWF_ENABLE << AW87XXX_PID_5A_REG_EN_SWF_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_SWF_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_SWF_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_SWF_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_SWF_START_BIT)
+
+/* SS_CONTROL bit 5:4 (DFTFR 0x74) */
+#define AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SS_CONTROL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SPREAD_SPECTRUM	(0)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SPREAD_SPECTRUM_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_CONTROL_SPREAD_SPECTRUM << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20111	(1)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20111_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_CONTROL_SW20111 << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20000	(2)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20000_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_CONTROL_SW20000 << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20111	(3)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20111_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_CONTROL_SW20111 << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_SS_CONTROL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SS_CONTROL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT)
+
+/* PA_GTDR_DDT bit 3:2 (DFTFR 0x74) */
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_GTDR_DDT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_12NS	(0)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_12NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GTDR_DDT_12NS << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_13NS	(1)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_13NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GTDR_DDT_13NS << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_14NS	(2)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_14NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GTDR_DDT_14NS << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_15NS	(3)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_15NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GTDR_DDT_15NS << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_GTDR_DDT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT)
+
+/* EN_HWM_DELAY bit 1 (DFTFR 0x74) */
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_HWM_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_HWM_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HWM_DELAY_DISABLE << AW87XXX_PID_5A_REG_EN_HWM_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HWM_DELAY_ENABLE << AW87XXX_PID_5A_REG_EN_HWM_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_HWM_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_HWM_DELAY_START_BIT)
+
+/* EN_HW_MODE bit 0 (DFTFR 0x74) */
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_HW_MODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_HW_MODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HW_MODE_DISABLE << AW87XXX_PID_5A_REG_EN_HW_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HW_MODE_ENABLE << AW87XXX_PID_5A_REG_EN_HW_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_HW_MODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_HW_MODE_START_BIT)
+
+/* default value of DFTFR (0x74) */
+/* #define AW87XXX_PID_5A_REG_DFTFR_DEFAULT		(0x00) */
+
+/* detail information of registers end */
+
+#endif  /* #ifndef  __AW87XXX_PID_5A_REG_H__ */
\ No newline at end of file
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_60_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_60_reg.h
new file mode 100644
index 000000000..ba47dd1ff
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_60_reg.h
@@ -0,0 +1,5246 @@
+#ifndef __AW87XXX_PID_60_REG_H__
+#define __AW87XXX_PID_60_REG_H__
+
+/* registers list */
+#define AW87XXX_PID_60_ID_REG			(0x00)
+#define AW87XXX_PID_60_SYSCTRL_REG		(0x01)
+#define AW87XXX_PID_60_BSTOVR_REG		(0x02)
+#define AW87XXX_PID_60_PEAKLIMIT_REG		(0x03)
+#define AW87XXX_PID_60_ADPSET_REG		(0x04)
+#define AW87XXX_PID_60_PAG_REG			(0x05)
+#define AW87XXX_PID_60_AGC1PA_REG		(0x06)
+#define AW87XXX_PID_60_AGC2PA_REG		(0x07)
+#define AW87XXX_PID_60_AGC3PA_REG		(0x08)
+#define AW87XXX_PID_60_AGC3P_REG		(0x09)
+#define AW87XXX_PID_60_LOW_BAT_REG		(0x0A)
+#define AW87XXX_PID_60_BSTOUT_REG		(0x0B)
+#define AW87XXX_PID_60_SYSST_REG		(0x59)
+#define AW87XXX_PID_60_SYSINT_REG		(0x60)
+#define AW87XXX_PID_60_BURST_CON_REG		(0x61)
+#define AW87XXX_PID_60_BST_BIAS_REG		(0x62)
+#define AW87XXX_PID_60_BST_EA_REG		(0x63)
+#define AW87XXX_PID_60_BST_DE_SOFT_REG		(0x64)
+#define AW87XXX_PID_60_BST_BURST_KICK_REG	(0x65)
+#define AW87XXX_PID_60_BST_CON1_REG		(0x66)
+#define AW87XXX_PID_60_BST_OVP_REG		(0x67)
+#define AW87XXX_PID_60_LINE_MODE_REG		(0x68)
+#define AW87XXX_PID_60_BST_ISEN_REG		(0x69)
+#define AW87XXX_PID_60_BST_PEAK_REG		(0x6A)
+#define AW87XXX_PID_60_BST_PEAK2_REG		(0x6B)
+#define AW87XXX_PID_60_OFFTIME_REG		(0x6C)
+#define AW87XXX_PID_60_ADPBST_REG		(0x6D)
+#define AW87XXX_PID_60_OTA_REG			(0x6E)
+#define AW87XXX_PID_60_RAMPGEN_REG		(0x6F)
+#define AW87XXX_PID_60_CLASSD_SYSCTRL_REG	(0x70)
+#define AW87XXX_PID_60_GTDR_REG			(0x71)
+#define AW87XXX_PID_60_OC_REG			(0x72)
+#define AW87XXX_PID_60_AGC_CON_REG		(0x73)
+#define AW87XXX_PID_60_NG_REG			(0x74)
+#define AW87XXX_PID_60_NG2_REG			(0x75)
+#define AW87XXX_PID_60_NG3_REG			(0x76)
+#define AW87XXX_PID_60_CP_REG			(0x77)
+#define AW87XXX_PID_60_TEST_GTDR_REG		(0x78)
+#define AW87XXX_PID_60_TEST_BST_REG		(0x79)
+#define AW87XXX_PID_60_TEST_MODE_REG		(0x7A)
+#define AW87XXX_PID_60_TEST_CON_REG		(0x7B)
+#define AW87XXX_PID_60_ENCR_REG			(0x7C)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_60_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_60_REG_MAX			(0x7D)
+
+#define REG_NONE_ACCESS					(0)
+#define REG_RD_ACCESS					(1 << 0)
+#define REG_WR_ACCESS					(1 << 1)
+#define AW87XXX_PID_60_ESD_REG_VAL			(0x91)
+
+const unsigned char aw87xxx_pid_60_reg_access[AW87XXX_PID_60_REG_MAX] = {
+	[AW87XXX_PID_60_ID_REG]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_60_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BSTOVR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_PEAKLIMIT_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_ADPSET_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_PAG_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_AGC1PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_AGC2PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_AGC3PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_AGC3P_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_LOW_BAT_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BSTOUT_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_60_SYSST_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_60_SYSINT_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_60_BURST_CON_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_BIAS_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_EA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_DE_SOFT_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_BURST_KICK_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_CON1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_OVP_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_LINE_MODE_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_ISEN_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_PEAK_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_PEAK2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_OFFTIME_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_ADPBST_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_OTA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_RAMPGEN_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_CLASSD_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_GTDR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_OC_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_AGC_CON_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_NG_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_NG2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_NG3_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_CP_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_TEST_GTDR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_TEST_BST_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_TEST_MODE_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_TEST_CON_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_ENCR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+/* detail information of registers begin */
+/* ID (0x00) detail */
+/* IDCODE bit 7:0 (ID 0x00) */
+#define AW87XXX_PID_60_IDCODE_START_BIT	(0)
+#define AW87XXX_PID_60_IDCODE_BITS_LEN	(8)
+#define AW87XXX_PID_60_IDCODE_MASK		\
+	(~(((1<<AW87XXX_PID_60_IDCODE_BITS_LEN)-1) << AW87XXX_PID_60_IDCODE_START_BIT))
+
+#define AW87XXX_PID_60_IDCODE_DEFAULT_VALUE	(0x60)
+#define AW87XXX_PID_60_IDCODE_DEFAULT	\
+	(AW87XXX_PID_60_IDCODE_DEFAULT_VALUE << AW87XXX_PID_60_IDCODE_START_BIT)
+
+/* default value of ID (0x00) */
+/* #define AW87XXX_PID_60_ID_DEFAULT		(0x60) */
+
+/* SYSCTRL (0x01) detail */
+/* EN_HVBAT bit 0 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_EN_HVBAT_START_BIT	(0)
+#define AW87XXX_PID_60_EN_HVBAT_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_HVBAT_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_HVBAT_BITS_LEN)-1) << AW87XXX_PID_60_EN_HVBAT_START_BIT))
+
+#define AW87XXX_PID_60_EN_HVBAT_DISABLE	(0)
+#define AW87XXX_PID_60_EN_HVBAT_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_HVBAT_DISABLE << AW87XXX_PID_60_EN_HVBAT_START_BIT)
+
+#define AW87XXX_PID_60_EN_HVBAT_ENABLE	(1)
+#define AW87XXX_PID_60_EN_HVBAT_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_HVBAT_ENABLE << AW87XXX_PID_60_EN_HVBAT_START_BIT)
+
+#define AW87XXX_PID_60_EN_HVBAT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_HVBAT_DEFAULT	\
+	(AW87XXX_PID_60_EN_HVBAT_DEFAULT_VALUE << AW87XXX_PID_60_EN_HVBAT_START_BIT)
+
+/* RCV_MODE bit 1 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_RCV_MODE_START_BIT	(1)
+#define AW87XXX_PID_60_RCV_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_60_RCV_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_60_RCV_MODE_BITS_LEN)-1) << AW87XXX_PID_60_RCV_MODE_START_BIT))
+
+#define AW87XXX_PID_60_RCV_MODE_DISABLE	(0)
+#define AW87XXX_PID_60_RCV_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_60_RCV_MODE_DISABLE << AW87XXX_PID_60_RCV_MODE_START_BIT)
+
+#define AW87XXX_PID_60_RCV_MODE_ENABLE	(1)
+#define AW87XXX_PID_60_RCV_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_RCV_MODE_ENABLE << AW87XXX_PID_60_RCV_MODE_START_BIT)
+
+#define AW87XXX_PID_60_RCV_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_RCV_MODE_DEFAULT	\
+	(AW87XXX_PID_60_RCV_MODE_DEFAULT_VALUE << AW87XXX_PID_60_RCV_MODE_START_BIT)
+
+/* EN_PA bit 2 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_EN_PA_START_BIT	(2)
+#define AW87XXX_PID_60_EN_PA_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_PA_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_PA_BITS_LEN)-1) << AW87XXX_PID_60_EN_PA_START_BIT))
+
+#define AW87XXX_PID_60_EN_PA_DISABLE	(0)
+#define AW87XXX_PID_60_EN_PA_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_PA_DISABLE << AW87XXX_PID_60_EN_PA_START_BIT)
+
+#define AW87XXX_PID_60_EN_PA_ENABLE		(1)
+#define AW87XXX_PID_60_EN_PA_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_PA_ENABLE << AW87XXX_PID_60_EN_PA_START_BIT)
+
+#define AW87XXX_PID_60_EN_PA_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_EN_PA_DEFAULT	\
+	(AW87XXX_PID_60_EN_PA_DEFAULT_VALUE << AW87XXX_PID_60_EN_PA_START_BIT)
+
+/* EN_BOOST bit 3 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_EN_BOOST_START_BIT	(3)
+#define AW87XXX_PID_60_EN_BOOST_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_BOOST_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_BOOST_BITS_LEN)-1) << AW87XXX_PID_60_EN_BOOST_START_BIT))
+
+#define AW87XXX_PID_60_EN_BOOST_DISABLE	(0)
+#define AW87XXX_PID_60_EN_BOOST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_BOOST_DISABLE << AW87XXX_PID_60_EN_BOOST_START_BIT)
+
+#define AW87XXX_PID_60_EN_BOOST_ENABLE	(1)
+#define AW87XXX_PID_60_EN_BOOST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_BOOST_ENABLE << AW87XXX_PID_60_EN_BOOST_START_BIT)
+
+#define AW87XXX_PID_60_EN_BOOST_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_EN_BOOST_DEFAULT	\
+	(AW87XXX_PID_60_EN_BOOST_DEFAULT_VALUE << AW87XXX_PID_60_EN_BOOST_START_BIT)
+
+/* EN_CP bit 4 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_EN_CP_START_BIT	(4)
+#define AW87XXX_PID_60_EN_CP_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_CP_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_CP_BITS_LEN)-1) << AW87XXX_PID_60_EN_CP_START_BIT))
+
+#define AW87XXX_PID_60_EN_CP_DISABLE	(0)
+#define AW87XXX_PID_60_EN_CP_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_CP_DISABLE << AW87XXX_PID_60_EN_CP_START_BIT)
+
+#define AW87XXX_PID_60_EN_CP_ENABLE		(1)
+#define AW87XXX_PID_60_EN_CP_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_CP_ENABLE << AW87XXX_PID_60_EN_CP_START_BIT)
+
+#define AW87XXX_PID_60_EN_CP_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_EN_CP_DEFAULT	\
+	(AW87XXX_PID_60_EN_CP_DEFAULT_VALUE << AW87XXX_PID_60_EN_CP_START_BIT)
+
+/* EN_SW bit 5 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_EN_SW_START_BIT	(5)
+#define AW87XXX_PID_60_EN_SW_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_SW_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_SW_BITS_LEN)-1) << AW87XXX_PID_60_EN_SW_START_BIT))
+
+#define AW87XXX_PID_60_EN_SW_DISABLE	(0)
+#define AW87XXX_PID_60_EN_SW_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_SW_DISABLE << AW87XXX_PID_60_EN_SW_START_BIT)
+
+#define AW87XXX_PID_60_EN_SW_ENABLE		(1)
+#define AW87XXX_PID_60_EN_SW_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_SW_ENABLE << AW87XXX_PID_60_EN_SW_START_BIT)
+
+#define AW87XXX_PID_60_EN_SW_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_SW_DEFAULT	\
+	(AW87XXX_PID_60_EN_SW_DEFAULT_VALUE << AW87XXX_PID_60_EN_SW_START_BIT)
+
+/* default value of SYSCTRL (0x01) */
+/* #define AW87XXX_PID_60_SYSCTRL_DEFAULT		(0x1C) */
+
+/* BSTOVR (0x02) detail */
+/* CP_FREQ bit 6:5 (BSTOVR 0x02) */
+#define AW87XXX_PID_60_CP_FREQ_START_BIT	(5)
+#define AW87XXX_PID_60_CP_FREQ_BITS_LEN	(2)
+#define AW87XXX_PID_60_CP_FREQ_MASK		\
+	(~(((1<<AW87XXX_PID_60_CP_FREQ_BITS_LEN)-1) << AW87XXX_PID_60_CP_FREQ_START_BIT))
+
+#define AW87XXX_PID_60_CP_FREQ_4P8MHZ	(0)
+#define AW87XXX_PID_60_CP_FREQ_4P8MHZ_VALUE	\
+	(AW87XXX_PID_60_CP_FREQ_4P8MHZ << AW87XXX_PID_60_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_60_CP_FREQ_6P4MHZ	(1)
+#define AW87XXX_PID_60_CP_FREQ_6P4MHZ_VALUE	\
+	(AW87XXX_PID_60_CP_FREQ_6P4MHZ << AW87XXX_PID_60_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_60_CP_FREQ_8P0MHZ	(2)
+#define AW87XXX_PID_60_CP_FREQ_8P0MHZ_VALUE	\
+	(AW87XXX_PID_60_CP_FREQ_8P0MHZ << AW87XXX_PID_60_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_60_CP_FREQ_9P6MHZ	(3)
+#define AW87XXX_PID_60_CP_FREQ_9P6MHZ_VALUE	\
+	(AW87XXX_PID_60_CP_FREQ_9P6MHZ << AW87XXX_PID_60_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_60_CP_FREQ_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_CP_FREQ_DEFAULT	\
+	(AW87XXX_PID_60_CP_FREQ_DEFAULT_VALUE << AW87XXX_PID_60_CP_FREQ_START_BIT)
+
+/* BST_VOUT bit 4:0 (BSTOVR 0x02) */
+#define AW87XXX_PID_60_BST_VOUT_START_BIT	(0)
+#define AW87XXX_PID_60_BST_VOUT_BITS_LEN	(5)
+#define AW87XXX_PID_60_BST_VOUT_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_VOUT_BITS_LEN)-1) << AW87XXX_PID_60_BST_VOUT_START_BIT))
+
+#define AW87XXX_PID_60_BST_VOUT_4P75V	(0)
+#define AW87XXX_PID_60_BST_VOUT_4P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_4P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_5P0V	(1)
+#define AW87XXX_PID_60_BST_VOUT_5P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_5P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_5P25V	(2)
+#define AW87XXX_PID_60_BST_VOUT_5P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_5P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_5P5V	(3)
+#define AW87XXX_PID_60_BST_VOUT_5P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_5P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_5P75V	(4)
+#define AW87XXX_PID_60_BST_VOUT_5P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_5P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_6P0V	(5)
+#define AW87XXX_PID_60_BST_VOUT_6P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_6P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_6P25V	(6)
+#define AW87XXX_PID_60_BST_VOUT_6P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_6P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_6P5V	(7)
+#define AW87XXX_PID_60_BST_VOUT_6P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_6P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_6P75V	(8)
+#define AW87XXX_PID_60_BST_VOUT_6P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_6P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_7P0V	(9)
+#define AW87XXX_PID_60_BST_VOUT_7P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_7P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_7P25V	(10)
+#define AW87XXX_PID_60_BST_VOUT_7P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_7P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_7P5V	(11)
+#define AW87XXX_PID_60_BST_VOUT_7P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_7P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_7P75V	(12)
+#define AW87XXX_PID_60_BST_VOUT_7P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_7P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_8P0V	(13)
+#define AW87XXX_PID_60_BST_VOUT_8P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_8P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_8P25V	(14)
+#define AW87XXX_PID_60_BST_VOUT_8P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_8P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_8P5V	(15)
+#define AW87XXX_PID_60_BST_VOUT_8P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_8P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_8P75V	(16)
+#define AW87XXX_PID_60_BST_VOUT_8P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_8P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_9P0V	(17)
+#define AW87XXX_PID_60_BST_VOUT_9P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_9P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_9P25V	(18)
+#define AW87XXX_PID_60_BST_VOUT_9P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_9P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_9P5V	(19)
+#define AW87XXX_PID_60_BST_VOUT_9P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_9P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_9P75V	(20)
+#define AW87XXX_PID_60_BST_VOUT_9P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_9P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_10P0V	(21)
+#define AW87XXX_PID_60_BST_VOUT_10P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_10P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_10P25V	(22)
+#define AW87XXX_PID_60_BST_VOUT_10P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_10P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_10P5V	(23)
+#define AW87XXX_PID_60_BST_VOUT_10P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_10P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_10P75V	(24)
+#define AW87XXX_PID_60_BST_VOUT_10P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_10P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_11P0V	(25)
+#define AW87XXX_PID_60_BST_VOUT_11P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_11P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_11P25V	(26)
+#define AW87XXX_PID_60_BST_VOUT_11P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_11P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_11P5V	(27)
+#define AW87XXX_PID_60_BST_VOUT_11P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_11P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_11P75V	(28)
+#define AW87XXX_PID_60_BST_VOUT_11P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_11P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_12P0V	(29)
+#define AW87XXX_PID_60_BST_VOUT_12P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_12P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_12P25V	(30)
+#define AW87XXX_PID_60_BST_VOUT_12P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_12P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_DEFAULT_VALUE	(0x11)
+#define AW87XXX_PID_60_BST_VOUT_DEFAULT	\
+	(AW87XXX_PID_60_BST_VOUT_DEFAULT_VALUE << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+/* default value of BSTOVR (0x02) */
+/* #define AW87XXX_PID_60_BSTOVR_DEFAULT		(0x31) */
+
+/* PEAKLIMIT (0x03) detail */
+/* BST_OVP2_VTH bit 6:4 (PEAKLIMIT 0x03) */
+#define AW87XXX_PID_60_BST_OVP2_VTH_START_BIT	(4)
+#define AW87XXX_PID_60_BST_OVP2_VTH_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_OVP2_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP2_VTH_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_13P5V	(0)
+#define AW87XXX_PID_60_BST_OVP2_VTH_13P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_13P5V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_14P0	(1)
+#define AW87XXX_PID_60_BST_OVP2_VTH_14P0_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_14P0 << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_14P5V	(2)
+#define AW87XXX_PID_60_BST_OVP2_VTH_14P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_14P5V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_15P0V	(3)
+#define AW87XXX_PID_60_BST_OVP2_VTH_15P0V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_15P0V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_9P0V	(4)
+#define AW87XXX_PID_60_BST_OVP2_VTH_9P0V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_9P0V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_9P5V	(5)
+#define AW87XXX_PID_60_BST_OVP2_VTH_9P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_9P5V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_10P0V	(6)
+#define AW87XXX_PID_60_BST_OVP2_VTH_10P0V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_10P0V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_10P5V	(7)
+#define AW87XXX_PID_60_BST_OVP2_VTH_10P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_10P5V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_OVP2_VTH_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+/* BST_IPEAK bit 3:0 (PEAKLIMIT 0x03) */
+#define AW87XXX_PID_60_BST_IPEAK_START_BIT	(0)
+#define AW87XXX_PID_60_BST_IPEAK_BITS_LEN	(4)
+#define AW87XXX_PID_60_BST_IPEAK_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_1P5A	(0)
+#define AW87XXX_PID_60_BST_IPEAK_1P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_1P5A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_1P75A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_1P75A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_1P75A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_2P0A	(2)
+#define AW87XXX_PID_60_BST_IPEAK_2P0A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_2P0A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_2P25A	(3)
+#define AW87XXX_PID_60_BST_IPEAK_2P25A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_2P25A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_2P5A	(4)
+#define AW87XXX_PID_60_BST_IPEAK_2P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_2P5A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_2P75A	(5)
+#define AW87XXX_PID_60_BST_IPEAK_2P75A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_2P75A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_3P0A	(6)
+#define AW87XXX_PID_60_BST_IPEAK_3P0A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_3P0A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_3P25A	(7)
+#define AW87XXX_PID_60_BST_IPEAK_3P25A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_3P25A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_3P5A	(8)
+#define AW87XXX_PID_60_BST_IPEAK_3P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_3P5A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_3P75A	(9)
+#define AW87XXX_PID_60_BST_IPEAK_3P75A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_3P75A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_4A		(10)
+#define AW87XXX_PID_60_BST_IPEAK_4A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_4A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_4P25A	(11)
+#define AW87XXX_PID_60_BST_IPEAK_4P25A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_4P25A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_4P50A	(12)
+#define AW87XXX_PID_60_BST_IPEAK_4P50A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_4P50A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_DEFAULT_VALUE	(9)
+#define AW87XXX_PID_60_BST_IPEAK_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+/* default value of PEAKLIMIT (0x03) */
+/* #define AW87XXX_PID_60_PEAKLIMIT_DEFAULT		(0x09) */
+
+/* ADPSET (0x04) detail */
+/* EN_ADP_BST bit 6 (ADPSET 0x04) */
+#define AW87XXX_PID_60_EN_ADP_BST_START_BIT	(6)
+#define AW87XXX_PID_60_EN_ADP_BST_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_ADP_BST_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_ADP_BST_BITS_LEN)-1) << AW87XXX_PID_60_EN_ADP_BST_START_BIT))
+
+#define AW87XXX_PID_60_EN_ADP_BST_DISABLE	(0)
+#define AW87XXX_PID_60_EN_ADP_BST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_BST_DISABLE << AW87XXX_PID_60_EN_ADP_BST_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_BST_ENABLE	(1)
+#define AW87XXX_PID_60_EN_ADP_BST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_BST_ENABLE << AW87XXX_PID_60_EN_ADP_BST_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_BST_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_EN_ADP_BST_DEFAULT	\
+	(AW87XXX_PID_60_EN_ADP_BST_DEFAULT_VALUE << AW87XXX_PID_60_EN_ADP_BST_START_BIT)
+
+/* ADP_BOOST_MODE bit 5:3 (ADPSET 0x04) */
+#define AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT	(3)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_BITS_LEN	(3)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_60_ADP_BOOST_MODE_BITS_LEN)-1) << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT))
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_RCV	(0)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_RCV_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_RCV << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_FORCE_BOOST	(1)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_FORCE_BOOST_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_FORCE_BOOST << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_OSBOSD	(2)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_OSBOSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_OSBOSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_TSBTSD	(3)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_TSBTSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_TSBTSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_TSBOSD	(4)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_TSBOSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_TSBOSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBOSD	(5)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBOSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_MSBOSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBTSD	(6)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBTSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_MSBTSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBMSD	(7)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBMSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_MSBMSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_DEFAULT	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_DEFAULT_VALUE << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+/* SET_BOOST_VTH2 bit 2:0 (ADPSET 0x04) */
+#define AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT	(0)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_BITS_LEN	(3)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_MASK	\
+	(~(((1<<AW87XXX_PID_60_SET_BOOST_VTH2_BITS_LEN)-1) << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT))
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P2W	(0)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P2W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_1P2W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P4W	(1)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P4W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_1P4W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P6W	(2)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P6W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_1P6W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P8W	(3)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P8W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_1P8W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P0W	(4)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P0W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_2P0W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P2W	(5)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P2W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_2P2W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P4W	(6)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P4W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_2P4W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P6W	(7)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P6W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_2P6W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_DEFAULT	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_DEFAULT_VALUE << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+/* default value of ADPSET (0x04) */
+/* #define AW87XXX_PID_60_ADPSET_DEFAULT		(0x54) */
+
+/* PAG (0x05) detail */
+/* SET_BOOST_VTH1 bit 6:5 (PAG 0x05) */
+#define AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT	(5)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_BITS_LEN	(2)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_MASK	\
+	(~(((1<<AW87XXX_PID_60_SET_BOOST_VTH1_BITS_LEN)-1) << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT))
+
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P1W	(0)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P1W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH1_0P1W << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P2W	(1)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P2W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH1_0P2W << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P3W	(2)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P3W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH1_0P3W << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P4W	(3)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P4W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH1_0P4W << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH1_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_DEFAULT	\
+	(AW87XXX_PID_60_SET_BOOST_VTH1_DEFAULT_VALUE << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT)
+
+/* PA_GAIN bit 4:0 (PAG 0x05) */
+#define AW87XXX_PID_60_PA_GAIN_START_BIT	(0)
+#define AW87XXX_PID_60_PA_GAIN_BITS_LEN	(5)
+#define AW87XXX_PID_60_PA_GAIN_MASK		\
+	(~(((1<<AW87XXX_PID_60_PA_GAIN_BITS_LEN)-1) << AW87XXX_PID_60_PA_GAIN_START_BIT))
+
+#define AW87XXX_PID_60_PA_GAIN_0DB		(0)
+#define AW87XXX_PID_60_PA_GAIN_0DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_0DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_1P5DB	(1)
+#define AW87XXX_PID_60_PA_GAIN_1P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_1P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_3DB		(2)
+#define AW87XXX_PID_60_PA_GAIN_3DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_3DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_4P5DB	(3)
+#define AW87XXX_PID_60_PA_GAIN_4P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_4P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_6DB		(4)
+#define AW87XXX_PID_60_PA_GAIN_6DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_6DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_7P5DB	(5)
+#define AW87XXX_PID_60_PA_GAIN_7P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_7P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_9DB		(6)
+#define AW87XXX_PID_60_PA_GAIN_9DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_9DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_10P5DB	(7)
+#define AW87XXX_PID_60_PA_GAIN_10P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_10P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_12DB		(8)
+#define AW87XXX_PID_60_PA_GAIN_12DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_12DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_13P5DB	(9)
+#define AW87XXX_PID_60_PA_GAIN_13P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_13P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_15DB		(10)
+#define AW87XXX_PID_60_PA_GAIN_15DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_15DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_16P5DB	(11)
+#define AW87XXX_PID_60_PA_GAIN_16P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_16P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_18DB		(12)
+#define AW87XXX_PID_60_PA_GAIN_18DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_18DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_19P5DB	(13)
+#define AW87XXX_PID_60_PA_GAIN_19P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_19P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_21DB		(14)
+#define AW87XXX_PID_60_PA_GAIN_21DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_21DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_22P5DB	(15)
+#define AW87XXX_PID_60_PA_GAIN_22P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_22P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_24DB		(16)
+#define AW87XXX_PID_60_PA_GAIN_24DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_24DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_25P5DB	(17)
+#define AW87XXX_PID_60_PA_GAIN_25P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_25P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_27DB		(18)
+#define AW87XXX_PID_60_PA_GAIN_27DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_27DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+/*
+Fix me here:
+reg_addr:0x05, reg_name:PAG, field_name:PA_GAIN, content:when RCV_MODE=0PA_GAIN  default 10000
+maybe need to fix manually
+*/
+#define AW87XXX_PID_60_PA_GAIN_DEFAULT_VALUE	(0x10)
+#define AW87XXX_PID_60_PA_GAIN_DEFAULT	\
+	(AW87XXX_PID_60_PA_GAIN_DEFAULT_VALUE << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+/* default value of PAG (0x05) */
+/* #define AW87XXX_PID_60_PAG_DEFAULT		(0x50) */
+
+/* AGC1PA (0x06) detail */
+/* PD_AGC1 bit 7 (AGC1PA 0x06) */
+#define AW87XXX_PID_60_PD_AGC1_START_BIT	(7)
+#define AW87XXX_PID_60_PD_AGC1_BITS_LEN	(1)
+#define AW87XXX_PID_60_PD_AGC1_MASK		\
+	(~(((1<<AW87XXX_PID_60_PD_AGC1_BITS_LEN)-1) << AW87XXX_PID_60_PD_AGC1_START_BIT))
+
+#define AW87XXX_PID_60_PD_AGC1_ENABLE	(0)
+#define AW87XXX_PID_60_PD_AGC1_ENABLE_VALUE	\
+	(AW87XXX_PID_60_PD_AGC1_ENABLE << AW87XXX_PID_60_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PD_AGC1_DISABLE	(1)
+#define AW87XXX_PID_60_PD_AGC1_DISABLE_VALUE	\
+	(AW87XXX_PID_60_PD_AGC1_DISABLE << AW87XXX_PID_60_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PD_AGC1_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PD_AGC1_DEFAULT	\
+	(AW87XXX_PID_60_PD_AGC1_DEFAULT_VALUE << AW87XXX_PID_60_PD_AGC1_START_BIT)
+
+/* AGC1_OUTPUT_LEVEL bit 6:3 (AGC1PA 0x06) */
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT	(3)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_BITS_LEN	(4)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_BITS_LEN)-1) << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT))
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5V	(0)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P2V	(1)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P2V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P2V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P4V	(2)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P4V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P4V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P6V	(3)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P6V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P6V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P8V	(4)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P8V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P8V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P0V	(5)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P0V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P0V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P2V	(6)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P2V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P2V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P4V	(7)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P4V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P4V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P6V	(8)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P6V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P6V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P8V	(9)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P8V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P8V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7V	(10)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P2V	(11)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P2V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P2V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P4V	(12)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P4V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P4V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P6V	(13)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P6V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P6V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P8V	(14)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P8V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P8V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_8V	(15)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_8V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_8V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_DEFAULT_VALUE	(0x9)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_DEFAULT	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_DEFAULT_VALUE << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+/* AGC1_ATT_TIME bit 2:0 (AGC1PA 0x06) */
+#define AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC1_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P04MSDB	(0)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P04MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P04MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P08MSDB	(1)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P08MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P08MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P16MSDB	(2)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P16MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P16MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P32MSDB	(3)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P32MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P32MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P02MSDB	(4)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P02MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P02MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P01MSDB	(5)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P01MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P01MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB	(6)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+/*
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB	(7)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+*/
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+/* default value of AGC1PA (0x06) */
+/* #define AW87XXX_PID_60_AGC1PA_DEFAULT		(0x49) */
+
+/* AGC2PA (0x07) detail */
+/* AGC2_OUTPUT_POWER bit 6:3 (AGC2PA 0x07) */
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT	(3)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_BITS_LEN	(4)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC2_OUTPUT_POWER_BITS_LEN)-1) << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT))
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P0W4_OHM	(0)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P0W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P4W4_OHM	(1)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P4W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P4W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P8W4_OHM	(2)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P8W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P8W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P2W4_OHM	(3)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P2W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P2W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P6W4_OHM	(4)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P6W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P0W4_OHM	(5)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P0W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P4W4_OHM	(6)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P4W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P4W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P8W4_OHM	(7)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P8W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P8W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P2W4_OHM	(8)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P2W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P2W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P6W4_OHM	(9)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P6W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_6W4_OHM	(10)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_6W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_AGC2_OFF	(11)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_AGC2_OFF_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_AGC2_OFF << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_DEFAULT	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_DEFAULT_VALUE << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+/* AGC2_ATT_TIME bit 2:0 (AGC2PA 0x07) */
+#define AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC2_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P16MSDB	(0)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P16MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_0P16MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P32MSDB	(1)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P32MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_0P32MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P64MSDB	(2)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P64MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_0P64MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_2P56MSDB	(3)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_2P56MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_2P56MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_10P24MSDB	(4)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_10P24MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_40P96MSDB	(5)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_40P96MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_82MSDB	(6)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_82MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_82MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_164MSDB	(7)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_164MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_164MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+/* default value of AGC2PA (0x07) */
+/* #define AW87XXX_PID_60_AGC2PA_DEFAULT		(0x1A) */
+
+/* AGC3PA (0x08) detail */
+/* PD_AGC3 bit 4 (AGC3PA 0x08) */
+#define AW87XXX_PID_60_PD_AGC3_START_BIT	(4)
+#define AW87XXX_PID_60_PD_AGC3_BITS_LEN	(1)
+#define AW87XXX_PID_60_PD_AGC3_MASK		\
+	(~(((1<<AW87XXX_PID_60_PD_AGC3_BITS_LEN)-1) << AW87XXX_PID_60_PD_AGC3_START_BIT))
+
+#define AW87XXX_PID_60_PD_AGC3_ENABLE	(0)
+#define AW87XXX_PID_60_PD_AGC3_ENABLE_VALUE	\
+	(AW87XXX_PID_60_PD_AGC3_ENABLE << AW87XXX_PID_60_PD_AGC3_START_BIT)
+
+#define AW87XXX_PID_60_PD_AGC3_DISABLE	(1)
+#define AW87XXX_PID_60_PD_AGC3_DISABLE_VALUE	\
+	(AW87XXX_PID_60_PD_AGC3_DISABLE << AW87XXX_PID_60_PD_AGC3_START_BIT)
+
+#define AW87XXX_PID_60_PD_AGC3_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PD_AGC3_DEFAULT	\
+	(AW87XXX_PID_60_PD_AGC3_DEFAULT_VALUE << AW87XXX_PID_60_PD_AGC3_START_BIT)
+
+/* EN_HW_MODE bit 5 (AGC3PA 0x08) */
+#define AW87XXX_PID_60_EN_HW_MODE_START_BIT	(5)
+#define AW87XXX_PID_60_EN_HW_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_HW_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_HW_MODE_BITS_LEN)-1) << AW87XXX_PID_60_EN_HW_MODE_START_BIT))
+
+#define AW87XXX_PID_60_EN_HW_MODE_DISABLE	(0)
+#define AW87XXX_PID_60_EN_HW_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_HW_MODE_DISABLE << AW87XXX_PID_60_EN_HW_MODE_START_BIT)
+
+#define AW87XXX_PID_60_EN_HW_MODE_ENABLE	(1)
+#define AW87XXX_PID_60_EN_HW_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_HW_MODE_ENABLE << AW87XXX_PID_60_EN_HW_MODE_START_BIT)
+
+#define AW87XXX_PID_60_EN_HW_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_HW_MODE_DEFAULT	\
+	(AW87XXX_PID_60_EN_HW_MODE_DEFAULT_VALUE << AW87XXX_PID_60_EN_HW_MODE_START_BIT)
+
+/* AGC3_OUTPUT_POWER bit 3:0 (AGC3PA 0x08) */
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT	(0)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_BITS_LEN	(4)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC3_OUTPUT_POWER_BITS_LEN)-1) << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT))
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P0W4_OHM	(0)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P0W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P2W4_OHM	(1)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P2W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P2W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P4W4_OHM	(2)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P4W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P4W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P6W4_OHM	(3)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P6W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P8W4_OHM	(4)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P8W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P8W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P0W4_OHM	(5)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P0W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P2W4_OHM	(6)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P2W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P2W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P4W4_OHM	(7)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P4W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P4W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P6W4_OHM	(8)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P6W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P8W4_OHM	(9)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P8W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P8W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P0W4_OHM	(10)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P0W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P2W4_OHM	(11)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P2W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P2W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P4W4_OHM	(12)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P4W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P4W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P6W4_OHM	(13)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P6W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P8W4_OHM	(14)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P8W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P8W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_4P0W4_OHM	(15)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_4P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_4P0W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_DEFAULT	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_DEFAULT_VALUE << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+/* default value of AGC3PA (0x08) */
+/* #define AW87XXX_PID_60_AGC3PA_DEFAULT		(0x03) */
+
+/* AGC3P (0x09) detail */
+/* AGC3_REL_TIME bit 7:5 (AGC3P 0x09) */
+#define AW87XXX_PID_60_AGC3_REL_TIME_START_BIT	(5)
+#define AW87XXX_PID_60_AGC3_REL_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_60_AGC3_REL_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC3_REL_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_5P12MSDB	(0)
+#define AW87XXX_PID_60_AGC3_REL_TIME_5P12MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_5P12MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_10P24MSDB	(1)
+#define AW87XXX_PID_60_AGC3_REL_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_10P24MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_20P48MSDB	(2)
+#define AW87XXX_PID_60_AGC3_REL_TIME_20P48MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_20P48MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_40P96MSDB	(3)
+#define AW87XXX_PID_60_AGC3_REL_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_40P96MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_81P92MSDB	(4)
+#define AW87XXX_PID_60_AGC3_REL_TIME_81P92MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_81P92MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_163P84MSDB	(5)
+#define AW87XXX_PID_60_AGC3_REL_TIME_163P84MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_163P84MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_327P68MSDB	(6)
+#define AW87XXX_PID_60_AGC3_REL_TIME_327P68MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_327P68MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_655P36MSDB	(7)
+#define AW87XXX_PID_60_AGC3_REL_TIME_655P36MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_655P36MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_AGC3_REL_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+/* AGC3_ATT_TIME bit 4:2 (AGC3P 0x09) */
+#define AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT	(2)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC3_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_1P28MSDB	(0)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_1P28MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_1P28MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_2P56MSDB	(1)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_2P56MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_2P56MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_10P24MSDB	(2)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_10P24MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_40P96MSDB	(3)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_40P96MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_82MSDB	(4)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_82MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_82MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_164MSDB	(5)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_164MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_164MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_328MSDB	(6)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_328MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_328MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_656MSDB	(7)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_656MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_656MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+/* AGC3_FIRST_ATT_TIME bit 1:0 (AGC3P 0x09) */
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_5P12MS	(0)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_5P12MS_VALUE	\
+	(AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_5P12MS << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_10P24MS	(1)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_10P24MS_VALUE	\
+	(AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_10P24MS << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_20P48MS	(2)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_20P48MS_VALUE	\
+	(AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_20P48MS << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_41MS	(3)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_41MS_VALUE	\
+	(AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_41MS << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT)
+
+/* default value of AGC3P (0x09) */
+/* #define AW87XXX_PID_60_AGC3P_DEFAULT		(0x4E) */
+
+/* LOW_BAT (0x0A) detail */
+/* EN_BAT_SFGD bit 6 (LOW_BAT 0x0A) */
+#define AW87XXX_PID_60_EN_BAT_SFGD_START_BIT	(6)
+#define AW87XXX_PID_60_EN_BAT_SFGD_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_BAT_SFGD_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_BAT_SFGD_BITS_LEN)-1) << AW87XXX_PID_60_EN_BAT_SFGD_START_BIT))
+
+#define AW87XXX_PID_60_EN_BAT_SFGD_DISABLE	(0)
+#define AW87XXX_PID_60_EN_BAT_SFGD_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_BAT_SFGD_DISABLE << AW87XXX_PID_60_EN_BAT_SFGD_START_BIT)
+
+#define AW87XXX_PID_60_EN_BAT_SFGD_ENABLE	(1)
+#define AW87XXX_PID_60_EN_BAT_SFGD_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_BAT_SFGD_ENABLE << AW87XXX_PID_60_EN_BAT_SFGD_START_BIT)
+
+#define AW87XXX_PID_60_EN_BAT_SFGD_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_BAT_SFGD_DEFAULT	\
+	(AW87XXX_PID_60_EN_BAT_SFGD_DEFAULT_VALUE << AW87XXX_PID_60_EN_BAT_SFGD_START_BIT)
+
+/* BAT_SFGD_VTH bit 5:4 (LOW_BAT 0x0A) */
+#define AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT	(4)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BAT_SFGD_VTH_BITS_LEN)-1) << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT))
+
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P3V	(0)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P3V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_VTH_3P3V << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P4V	(1)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P4V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_VTH_3P4V << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P5V	(2)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P5V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_VTH_3P5V << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P6V	(3)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P6V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_VTH_3P6V << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_VTH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_DEFAULT	\
+	(AW87XXX_PID_60_BAT_SFGD_VTH_DEFAULT_VALUE << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT)
+
+/* BAT_SFGD_LEVEL bit 3:2 (LOW_BAT 0x0A) */
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT	(2)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_BITS_LEN	(2)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_BAT_SFGD_LEVEL_BITS_LEN)-1) << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT))
+
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_5V	(0)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_5V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_LEVEL_5V << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_5P5V	(1)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_5P5V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_LEVEL_5P5V << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_6V	(2)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_6V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_LEVEL_6V << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_6P5V	(3)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_6P5V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_LEVEL_6P5V << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_DEFAULT_VALUE	(0x01)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_DEFAULT	\
+	(AW87XXX_PID_60_BAT_SFGD_LEVEL_DEFAULT_VALUE << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT)
+
+/* BAT_SFGD_DEGLITCH bit 1:0 (LOW_BAT 0x0A) */
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT	(0)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_BITS_LEN	(2)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BAT_SFGD_DEGLITCH_BITS_LEN)-1) << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT))
+
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_1MS	(0)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_1MS_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_DEGLITCH_1MS << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_500US	(1)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_500US_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_DEGLITCH_500US << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_200US	(2)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_200US_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_DEGLITCH_200US << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DISABLE	(3)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DISABLE << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DEFAULT	\
+	(AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DEFAULT_VALUE << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT)
+
+/* default value of LOW_BAT (0x0A) */
+/* #define AW87XXX_PID_60_LOW_BAT_DEFAULT		(0x14) */
+
+/* BSTOUT (0x0B) detail */
+/* ADP_BOOST_VOUT bit 4:0 (BSTOUT 0x0B) */
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT	(0)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_BITS_LEN	(5)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_MASK	\
+	(~(((1<<AW87XXX_PID_60_ADP_BOOST_VOUT_BITS_LEN)-1) << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT))
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_4P75V	(0)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_4P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_4P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P0V	(1)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_5P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P25V	(2)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_5P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P5V	(3)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_5P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P75V	(4)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_5P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P0V	(5)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_6P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P25V	(6)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_6P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P5V	(7)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_6P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P75V	(8)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_6P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P0V	(9)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_7P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P25V	(10)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_7P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P5V	(11)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_7P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P75V	(12)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_7P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P0V	(13)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_8P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P25V	(14)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_8P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P5V	(15)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_8P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P75V	(16)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_8P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P0V	(17)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_9P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P25V	(18)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_9P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P5V	(19)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_9P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P75V	(20)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_9P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P0V	(21)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_10P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P25V	(22)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_10P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P5V	(23)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_10P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P75V	(24)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_10P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P0V	(25)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_11P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P25V	(26)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_11P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P5V	(27)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_11P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P75V	(28)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_11P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_12P0V	(29)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_12P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_12P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_12P25V	(30)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_12P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_12P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_DEFAULT_VALUE	(0x11)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_DEFAULT	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_DEFAULT_VALUE << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+/* default value of BSTOUT (0x0B) */
+/* #define AW87XXX_PID_60_BSTOUT_DEFAULT		(0x11) */
+
+/* SYSST (0x59) detail */
+/* ADP_BOOST_S bit 0 (SYSST 0x59) */
+#define AW87XXX_PID_60_ADP_BOOST_S_START_BIT	(0)
+#define AW87XXX_PID_60_ADP_BOOST_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_ADP_BOOST_S_MASK	\
+	(~(((1<<AW87XXX_PID_60_ADP_BOOST_S_BITS_LEN)-1) << AW87XXX_PID_60_ADP_BOOST_S_START_BIT))
+
+#define AW87XXX_PID_60_ADP_BOOST_S_DIRECT_MODE	(0)
+#define AW87XXX_PID_60_ADP_BOOST_S_DIRECT_MODE_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_S_DIRECT_MODE << AW87XXX_PID_60_ADP_BOOST_S_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_S_BOOST_MODE	(1)
+#define AW87XXX_PID_60_ADP_BOOST_S_BOOST_MODE_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_S_BOOST_MODE << AW87XXX_PID_60_ADP_BOOST_S_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_ADP_BOOST_S_DEFAULT	\
+	(AW87XXX_PID_60_ADP_BOOST_S_DEFAULT_VALUE << AW87XXX_PID_60_ADP_BOOST_S_START_BIT)
+
+/* OT160_S bit 1 (SYSST 0x59) */
+#define AW87XXX_PID_60_OT160_S_START_BIT	(1)
+#define AW87XXX_PID_60_OT160_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_OT160_S_MASK		\
+	(~(((1<<AW87XXX_PID_60_OT160_S_BITS_LEN)-1) << AW87XXX_PID_60_OT160_S_START_BIT))
+
+#define AW87XXX_PID_60_OT160_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_OT160_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_OT160_S_NORMAL_OPERATION << AW87XXX_PID_60_OT160_S_START_BIT)
+
+#define AW87XXX_PID_60_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_60_OT160_S_START_BIT)
+
+#define AW87XXX_PID_60_OT160_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_OT160_S_DEFAULT	\
+	(AW87XXX_PID_60_OT160_S_DEFAULT_VALUE << AW87XXX_PID_60_OT160_S_START_BIT)
+
+/* PA_OC_S bit 2 (SYSST 0x59) */
+#define AW87XXX_PID_60_PA_OC_S_START_BIT	(2)
+#define AW87XXX_PID_60_PA_OC_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_OC_S_MASK		\
+	(~(((1<<AW87XXX_PID_60_PA_OC_S_BITS_LEN)-1) << AW87XXX_PID_60_PA_OC_S_START_BIT))
+
+#define AW87XXX_PID_60_PA_OC_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_PA_OC_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_PA_OC_S_NORMAL_OPERATION << AW87XXX_PID_60_PA_OC_S_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_60_PA_OC_S_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PA_OC_S_DEFAULT	\
+	(AW87XXX_PID_60_PA_OC_S_DEFAULT_VALUE << AW87XXX_PID_60_PA_OC_S_START_BIT)
+
+/* BST_SCP_S bit 3 (SYSST 0x59) */
+#define AW87XXX_PID_60_BST_SCP_S_START_BIT	(3)
+#define AW87XXX_PID_60_BST_SCP_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SCP_S_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SCP_S_BITS_LEN)-1) << AW87XXX_PID_60_BST_SCP_S_START_BIT))
+
+#define AW87XXX_PID_60_BST_SCP_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_SCP_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_S_NORMAL_OPERATION << AW87XXX_PID_60_BST_SCP_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED << AW87XXX_PID_60_BST_SCP_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_SCP_S_DEFAULT	\
+	(AW87XXX_PID_60_BST_SCP_S_DEFAULT_VALUE << AW87XXX_PID_60_BST_SCP_S_START_BIT)
+
+/* BST_OVP2_S bit 4 (SYSST 0x59) */
+#define AW87XXX_PID_60_BST_OVP2_S_START_BIT	(4)
+#define AW87XXX_PID_60_BST_OVP2_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP2_S_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP2_S_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP2_S_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP2_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_OVP2_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_S_NORMAL_OPERATION << AW87XXX_PID_60_BST_OVP2_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED << AW87XXX_PID_60_BST_OVP2_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_OVP2_S_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP2_S_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP2_S_START_BIT)
+
+/* BST_OVP_S bit 5 (SYSST 0x59) */
+#define AW87XXX_PID_60_BST_OVP_S_START_BIT	(5)
+#define AW87XXX_PID_60_BST_OVP_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP_S_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP_S_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP_S_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_OVP_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_S_NORMAL_OPERATION << AW87XXX_PID_60_BST_OVP_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION	(1)
+#define AW87XXX_PID_60_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION << AW87XXX_PID_60_BST_OVP_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_OVP_S_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP_S_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP_S_START_BIT)
+
+/* LOW_BATT_S bit 6 (SYSST 0x59) */
+#define AW87XXX_PID_60_LOW_BATT_S_START_BIT	(6)
+#define AW87XXX_PID_60_LOW_BATT_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_LOW_BATT_S_MASK	\
+	(~(((1<<AW87XXX_PID_60_LOW_BATT_S_BITS_LEN)-1) << AW87XXX_PID_60_LOW_BATT_S_START_BIT))
+
+#define AW87XXX_PID_60_LOW_BATT_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_LOW_BATT_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_LOW_BATT_S_NORMAL_OPERATION << AW87XXX_PID_60_LOW_BATT_S_START_BIT)
+
+#define AW87XXX_PID_60_LOW_BATT_S_LOW_VBAT_DETECTED	(1)
+#define AW87XXX_PID_60_LOW_BATT_S_LOW_VBAT_DETECTED_VALUE	\
+	(AW87XXX_PID_60_LOW_BATT_S_LOW_VBAT_DETECTED << AW87XXX_PID_60_LOW_BATT_S_START_BIT)
+
+#define AW87XXX_PID_60_LOW_BATT_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_LOW_BATT_S_DEFAULT	\
+	(AW87XXX_PID_60_LOW_BATT_S_DEFAULT_VALUE << AW87XXX_PID_60_LOW_BATT_S_START_BIT)
+
+/* UVLO_S bit 7 (SYSST 0x59) */
+#define AW87XXX_PID_60_UVLO_S_START_BIT	(7)
+#define AW87XXX_PID_60_UVLO_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_UVLO_S_MASK		\
+	(~(((1<<AW87XXX_PID_60_UVLO_S_BITS_LEN)-1) << AW87XXX_PID_60_UVLO_S_START_BIT))
+
+#define AW87XXX_PID_60_UVLO_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_UVLO_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_UVLO_S_NORMAL_OPERATION << AW87XXX_PID_60_UVLO_S_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_S_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_60_UVLO_S_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_60_UVLO_S_VBAT_UNDER_VOLTAGE << AW87XXX_PID_60_UVLO_S_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_UVLO_S_DEFAULT	\
+	(AW87XXX_PID_60_UVLO_S_DEFAULT_VALUE << AW87XXX_PID_60_UVLO_S_START_BIT)
+
+/* default value of SYSST (0x59) */
+/* #define AW87XXX_PID_60_SYSST_DEFAULT		(0xFF) */
+
+/* SYSINT (0x60) detail */
+/* ADP_BOOST_I bit 0 (SYSINT 0x60) */
+#define AW87XXX_PID_60_ADP_BOOST_I_START_BIT	(0)
+#define AW87XXX_PID_60_ADP_BOOST_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_ADP_BOOST_I_MASK	\
+	(~(((1<<AW87XXX_PID_60_ADP_BOOST_I_BITS_LEN)-1) << AW87XXX_PID_60_ADP_BOOST_I_START_BIT))
+
+#define AW87XXX_PID_60_ADP_BOOST_I_DIRECT_MODE	(0)
+#define AW87XXX_PID_60_ADP_BOOST_I_DIRECT_MODE_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_I_DIRECT_MODE << AW87XXX_PID_60_ADP_BOOST_I_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_I_BOOST_MODE	(1)
+#define AW87XXX_PID_60_ADP_BOOST_I_BOOST_MODE_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_I_BOOST_MODE << AW87XXX_PID_60_ADP_BOOST_I_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_ADP_BOOST_I_DEFAULT	\
+	(AW87XXX_PID_60_ADP_BOOST_I_DEFAULT_VALUE << AW87XXX_PID_60_ADP_BOOST_I_START_BIT)
+
+/* OT160_I bit 1 (SYSINT 0x60) */
+#define AW87XXX_PID_60_OT160_I_START_BIT	(1)
+#define AW87XXX_PID_60_OT160_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_OT160_I_MASK		\
+	(~(((1<<AW87XXX_PID_60_OT160_I_BITS_LEN)-1) << AW87XXX_PID_60_OT160_I_START_BIT))
+
+#define AW87XXX_PID_60_OT160_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_OT160_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_OT160_I_NORMAL_OPERATION << AW87XXX_PID_60_OT160_I_START_BIT)
+
+#define AW87XXX_PID_60_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_60_OT160_I_START_BIT)
+
+#define AW87XXX_PID_60_OT160_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_OT160_I_DEFAULT	\
+	(AW87XXX_PID_60_OT160_I_DEFAULT_VALUE << AW87XXX_PID_60_OT160_I_START_BIT)
+
+/* PA_OC_I bit 2 (SYSINT 0x60) */
+#define AW87XXX_PID_60_PA_OC_I_START_BIT	(2)
+#define AW87XXX_PID_60_PA_OC_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_OC_I_MASK		\
+	(~(((1<<AW87XXX_PID_60_PA_OC_I_BITS_LEN)-1) << AW87XXX_PID_60_PA_OC_I_START_BIT))
+
+#define AW87XXX_PID_60_PA_OC_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_PA_OC_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_PA_OC_I_NORMAL_OPERATION << AW87XXX_PID_60_PA_OC_I_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_60_PA_OC_I_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PA_OC_I_DEFAULT	\
+	(AW87XXX_PID_60_PA_OC_I_DEFAULT_VALUE << AW87XXX_PID_60_PA_OC_I_START_BIT)
+
+/* BST_SCP_I bit 3 (SYSINT 0x60) */
+#define AW87XXX_PID_60_BST_SCP_I_START_BIT	(3)
+#define AW87XXX_PID_60_BST_SCP_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SCP_I_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SCP_I_BITS_LEN)-1) << AW87XXX_PID_60_BST_SCP_I_START_BIT))
+
+#define AW87XXX_PID_60_BST_SCP_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_SCP_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_I_NORMAL_OPERATION << AW87XXX_PID_60_BST_SCP_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED << AW87XXX_PID_60_BST_SCP_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_SCP_I_DEFAULT	\
+	(AW87XXX_PID_60_BST_SCP_I_DEFAULT_VALUE << AW87XXX_PID_60_BST_SCP_I_START_BIT)
+
+/* BST_OVP2_I bit 4 (SYSINT 0x60) */
+#define AW87XXX_PID_60_BST_OVP2_I_START_BIT	(4)
+#define AW87XXX_PID_60_BST_OVP2_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP2_I_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP2_I_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP2_I_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP2_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_OVP2_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_I_NORMAL_OPERATION << AW87XXX_PID_60_BST_OVP2_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED << AW87XXX_PID_60_BST_OVP2_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_OVP2_I_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP2_I_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP2_I_START_BIT)
+
+/* BST_OVP_I bit 5 (SYSINT 0x60) */
+#define AW87XXX_PID_60_BST_OVP_I_START_BIT	(5)
+#define AW87XXX_PID_60_BST_OVP_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP_I_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP_I_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP_I_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_OVP_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_I_NORMAL_OPERATION << AW87XXX_PID_60_BST_OVP_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION	(1)
+#define AW87XXX_PID_60_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION << AW87XXX_PID_60_BST_OVP_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_OVP_I_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP_I_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP_I_START_BIT)
+
+/* LOW_BATT_I bit 6 (SYSINT 0x60) */
+#define AW87XXX_PID_60_LOW_BATT_I_START_BIT	(6)
+#define AW87XXX_PID_60_LOW_BATT_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_LOW_BATT_I_MASK	\
+	(~(((1<<AW87XXX_PID_60_LOW_BATT_I_BITS_LEN)-1) << AW87XXX_PID_60_LOW_BATT_I_START_BIT))
+
+#define AW87XXX_PID_60_LOW_BATT_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_LOW_BATT_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_LOW_BATT_I_NORMAL_OPERATION << AW87XXX_PID_60_LOW_BATT_I_START_BIT)
+
+#define AW87XXX_PID_60_LOW_BATT_I_LOW_VBAT_DETECTED	(1)
+#define AW87XXX_PID_60_LOW_BATT_I_LOW_VBAT_DETECTED_VALUE	\
+	(AW87XXX_PID_60_LOW_BATT_I_LOW_VBAT_DETECTED << AW87XXX_PID_60_LOW_BATT_I_START_BIT)
+
+#define AW87XXX_PID_60_LOW_BATT_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_LOW_BATT_I_DEFAULT	\
+	(AW87XXX_PID_60_LOW_BATT_I_DEFAULT_VALUE << AW87XXX_PID_60_LOW_BATT_I_START_BIT)
+
+/* UVLO_I bit 7 (SYSINT 0x60) */
+#define AW87XXX_PID_60_UVLO_I_START_BIT	(7)
+#define AW87XXX_PID_60_UVLO_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_UVLO_I_MASK		\
+	(~(((1<<AW87XXX_PID_60_UVLO_I_BITS_LEN)-1) << AW87XXX_PID_60_UVLO_I_START_BIT))
+
+#define AW87XXX_PID_60_UVLO_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_UVLO_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_UVLO_I_NORMAL_OPERATION << AW87XXX_PID_60_UVLO_I_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_I_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_60_UVLO_I_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_60_UVLO_I_VBAT_UNDER_VOLTAGE << AW87XXX_PID_60_UVLO_I_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_UVLO_I_DEFAULT	\
+	(AW87XXX_PID_60_UVLO_I_DEFAULT_VALUE << AW87XXX_PID_60_UVLO_I_START_BIT)
+
+/* default value of SYSINT (0x60) */
+/* #define AW87XXX_PID_60_SYSINT_DEFAULT		(0xFF) */
+
+/* BURST_CON (0x61) detail */
+/* BURST_PEAK bit 7:5 (BURST_CON 0x61) */
+#define AW87XXX_PID_60_BURST_PEAK_START_BIT	(5)
+#define AW87XXX_PID_60_BURST_PEAK_BITS_LEN	(3)
+#define AW87XXX_PID_60_BURST_PEAK_MASK	\
+	(~(((1<<AW87XXX_PID_60_BURST_PEAK_BITS_LEN)-1) << AW87XXX_PID_60_BURST_PEAK_START_BIT))
+
+#define AW87XXX_PID_60_BURST_PEAK_10MA	(0)
+#define AW87XXX_PID_60_BURST_PEAK_10MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_10MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_20MA	(1)
+#define AW87XXX_PID_60_BURST_PEAK_20MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_20MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_30MA	(2)
+#define AW87XXX_PID_60_BURST_PEAK_30MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_30MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_50MA	(3)
+#define AW87XXX_PID_60_BURST_PEAK_50MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_50MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_70MA	(4)
+#define AW87XXX_PID_60_BURST_PEAK_70MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_70MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_130MA	(5)
+#define AW87XXX_PID_60_BURST_PEAK_130MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_130MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_160MA	(7)
+#define AW87XXX_PID_60_BURST_PEAK_160MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_160MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_60_BURST_PEAK_DEFAULT	\
+	(AW87XXX_PID_60_BURST_PEAK_DEFAULT_VALUE << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+/* BST_BURST_SS bit 4:2 (BURST_CON 0x61) */
+#define AW87XXX_PID_60_BST_BURST_SS_START_BIT	(2)
+#define AW87XXX_PID_60_BST_BURST_SS_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_BURST_SS_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_SS_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_SS_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_SS_700MV	(0)
+#define AW87XXX_PID_60_BST_BURST_SS_700MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_700MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_760MV	(1)
+#define AW87XXX_PID_60_BST_BURST_SS_760MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_760MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_820MV	(2)
+#define AW87XXX_PID_60_BST_BURST_SS_820MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_820MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_880MV	(3)
+#define AW87XXX_PID_60_BST_BURST_SS_880MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_880MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_940MV	(4)
+#define AW87XXX_PID_60_BST_BURST_SS_940MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_940MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_1000MV	(5)
+#define AW87XXX_PID_60_BST_BURST_SS_1000MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_1000MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_1060MV	(6)
+#define AW87XXX_PID_60_BST_BURST_SS_1060MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_1060MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_1120MV	(7)
+#define AW87XXX_PID_60_BST_BURST_SS_1120MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_1120MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_BURST_SS_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_SS_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+/* BST_COMPMAX bit 1:0 (BURST_CON 0x61) */
+#define AW87XXX_PID_60_BST_COMPMAX_START_BIT	(0)
+#define AW87XXX_PID_60_BST_COMPMAX_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_COMPMAX_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_COMPMAX_BITS_LEN)-1) << AW87XXX_PID_60_BST_COMPMAX_START_BIT))
+
+#define AW87XXX_PID_60_BST_COMPMAX_2P0V	(0)
+#define AW87XXX_PID_60_BST_COMPMAX_2P0V_VALUE	\
+	(AW87XXX_PID_60_BST_COMPMAX_2P0V << AW87XXX_PID_60_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_60_BST_COMPMAX_2P2V	(1)
+#define AW87XXX_PID_60_BST_COMPMAX_2P2V_VALUE	\
+	(AW87XXX_PID_60_BST_COMPMAX_2P2V << AW87XXX_PID_60_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_60_BST_COMPMAX_2P3V	(2)
+#define AW87XXX_PID_60_BST_COMPMAX_2P3V_VALUE	\
+	(AW87XXX_PID_60_BST_COMPMAX_2P3V << AW87XXX_PID_60_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_60_BST_COMPMAX_2P4V	(3)
+#define AW87XXX_PID_60_BST_COMPMAX_2P4V_VALUE	\
+	(AW87XXX_PID_60_BST_COMPMAX_2P4V << AW87XXX_PID_60_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_60_BST_COMPMAX_DEFAULT_VALUE	(3)
+#define AW87XXX_PID_60_BST_COMPMAX_DEFAULT	\
+	(AW87XXX_PID_60_BST_COMPMAX_DEFAULT_VALUE << AW87XXX_PID_60_BST_COMPMAX_START_BIT)
+
+/* default value of BURST_CON (0x61) */
+/* #define AW87XXX_PID_60_BURST_CON_DEFAULT		(0x47) */
+
+/* BST_BIAS (0x62) detail */
+/* BST_EA_CUR bit 0 (BST_BIAS 0x62) */
+#define AW87XXX_PID_60_BST_EA_CUR_START_BIT	(0)
+#define AW87XXX_PID_60_BST_EA_CUR_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_EA_CUR_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_EA_CUR_BITS_LEN)-1) << AW87XXX_PID_60_BST_EA_CUR_START_BIT))
+
+#define AW87XXX_PID_60_BST_EA_CUR_1UA	(0)
+#define AW87XXX_PID_60_BST_EA_CUR_1UA_VALUE	\
+	(AW87XXX_PID_60_BST_EA_CUR_1UA << AW87XXX_PID_60_BST_EA_CUR_START_BIT)
+
+#define AW87XXX_PID_60_BST_EA_CUR_2UA	(1)
+#define AW87XXX_PID_60_BST_EA_CUR_2UA_VALUE	\
+	(AW87XXX_PID_60_BST_EA_CUR_2UA << AW87XXX_PID_60_BST_EA_CUR_START_BIT)
+
+#define AW87XXX_PID_60_BST_EA_CUR_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_EA_CUR_DEFAULT	\
+	(AW87XXX_PID_60_BST_EA_CUR_DEFAULT_VALUE << AW87XXX_PID_60_BST_EA_CUR_START_BIT)
+
+/* BST_BURST_SSMD bit 5 (BST_BIAS 0x62) */
+#define AW87XXX_PID_60_BST_BURST_SSMD_START_BIT	(5)
+#define AW87XXX_PID_60_BST_BURST_SSMD_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_BURST_SSMD_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_SSMD_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_SSMD_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_SSMD_SLOW	(0)
+#define AW87XXX_PID_60_BST_BURST_SSMD_SLOW_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SSMD_SLOW << AW87XXX_PID_60_BST_BURST_SSMD_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SSMD_FAST	(1)
+#define AW87XXX_PID_60_BST_BURST_SSMD_FAST_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SSMD_FAST << AW87XXX_PID_60_BST_BURST_SSMD_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SSMD_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_BURST_SSMD_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_SSMD_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_SSMD_START_BIT)
+
+/* BST_NCD_ITH bit 7:6 (BST_BIAS 0x62) */
+#define AW87XXX_PID_60_BST_NCD_ITH_START_BIT	(6)
+#define AW87XXX_PID_60_BST_NCD_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_NCD_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_NCD_ITH_BITS_LEN)-1) << AW87XXX_PID_60_BST_NCD_ITH_START_BIT))
+
+#define AW87XXX_PID_60_BST_NCD_ITH_170MA	(0)
+#define AW87XXX_PID_60_BST_NCD_ITH_170MA_VALUE	\
+	(AW87XXX_PID_60_BST_NCD_ITH_170MA << AW87XXX_PID_60_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_NCD_ITH_220MA	(1)
+#define AW87XXX_PID_60_BST_NCD_ITH_220MA_VALUE	\
+	(AW87XXX_PID_60_BST_NCD_ITH_220MA << AW87XXX_PID_60_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_NCD_ITH_280MA	(2)
+#define AW87XXX_PID_60_BST_NCD_ITH_280MA_VALUE	\
+	(AW87XXX_PID_60_BST_NCD_ITH_280MA << AW87XXX_PID_60_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_NCD_ITH_340MA	(3)
+#define AW87XXX_PID_60_BST_NCD_ITH_340MA_VALUE	\
+	(AW87XXX_PID_60_BST_NCD_ITH_340MA << AW87XXX_PID_60_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_NCD_ITH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_NCD_ITH_DEFAULT	\
+	(AW87XXX_PID_60_BST_NCD_ITH_DEFAULT_VALUE << AW87XXX_PID_60_BST_NCD_ITH_START_BIT)
+
+/* BST_VOUT_TRIM bit 4:3 (BST_BIAS 0x62) */
+#define AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT	(3)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_VOUT_TRIM_BITS_LEN)-1) << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT))
+
+#define AW87XXX_PID_60_BST_VOUT_TRIM_25UA	(0)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_25UA_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_TRIM_25UA << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_TRIM_24UA	(1)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_24UA_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_TRIM_24UA << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_TRIM_25P5UA	(2)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_25P5UA_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_TRIM_25P5UA << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_TRIM_24P5UA	(3)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_24P5UA_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_TRIM_24P5UA << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_TRIM_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_DEFAULT	\
+	(AW87XXX_PID_60_BST_VOUT_TRIM_DEFAULT_VALUE << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT)
+
+/* BST_BURST_IN bit 2:1 (BST_BIAS 0x62) */
+#define AW87XXX_PID_60_BST_BURST_IN_START_BIT	(1)
+#define AW87XXX_PID_60_BST_BURST_IN_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_BURST_IN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_IN_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_IN_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_IN_3MV	(0)
+#define AW87XXX_PID_60_BST_BURST_IN_3MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_3MV << AW87XXX_PID_60_BST_BURST_IN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_5MV	(1)
+#define AW87XXX_PID_60_BST_BURST_IN_5MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_5MV << AW87XXX_PID_60_BST_BURST_IN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_7MV	(2)
+#define AW87XXX_PID_60_BST_BURST_IN_7MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_7MV << AW87XXX_PID_60_BST_BURST_IN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_9MV	(3)
+#define AW87XXX_PID_60_BST_BURST_IN_9MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_9MV << AW87XXX_PID_60_BST_BURST_IN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_BURST_IN_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_IN_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_IN_START_BIT)
+
+/* default value of BST_BIAS (0x62) */
+/* #define AW87XXX_PID_60_BST_BIAS_DEFAULT		(0x60) */
+
+/* BST_EA (0x63) detail */
+/* BST_LOW_CLAMP_EN bit 2 (BST_EA 0x63) */
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_START_BIT	(2)
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_LOW_CLAMP_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_LOW_CLAMP_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_DISABLE	(0)
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_LOW_CLAMP_EN_DISABLE << AW87XXX_PID_60_BST_LOW_CLAMP_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_LOW_CLAMP_EN_ENABLE << AW87XXX_PID_60_BST_LOW_CLAMP_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_LOW_CLAMP_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_LOW_CLAMP_EN_START_BIT)
+
+/* EN_VOUT_DIV bit 7 (BST_EA 0x63) */
+#define AW87XXX_PID_60_EN_VOUT_DIV_START_BIT	(7)
+#define AW87XXX_PID_60_EN_VOUT_DIV_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_VOUT_DIV_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_VOUT_DIV_BITS_LEN)-1) << AW87XXX_PID_60_EN_VOUT_DIV_START_BIT))
+
+#define AW87XXX_PID_60_EN_VOUT_DIV_DISABLE	(0)
+#define AW87XXX_PID_60_EN_VOUT_DIV_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_VOUT_DIV_DISABLE << AW87XXX_PID_60_EN_VOUT_DIV_START_BIT)
+
+#define AW87XXX_PID_60_EN_VOUT_DIV_ENABLE	(1)
+#define AW87XXX_PID_60_EN_VOUT_DIV_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_VOUT_DIV_ENABLE << AW87XXX_PID_60_EN_VOUT_DIV_START_BIT)
+
+#define AW87XXX_PID_60_EN_VOUT_DIV_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_EN_VOUT_DIV_DEFAULT	\
+	(AW87XXX_PID_60_EN_VOUT_DIV_DEFAULT_VALUE << AW87XXX_PID_60_EN_VOUT_DIV_START_BIT)
+
+/* BST_BURST_OUT_DELAY bit 6:5 (BST_EA 0x63) */
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT	(5)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_OUT_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_2P8US	(0)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_2P8US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_OUT_DELAY_2P8US << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_8P1US	(1)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_8P1US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_OUT_DELAY_8P1US << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P2US	(2)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P2US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P2US << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P8US	(3)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P8US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P8US << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_OUT_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT)
+
+/* BST_BURST_IN_DELAY bit 4:3 (BST_EA 0x63) */
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT	(3)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_IN_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_7P4US	(0)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_7P4US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_DELAY_7P4US << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_14P6US	(1)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_14P6US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_DELAY_14P6US << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_3P7US	(2)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_3P7US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_DELAY_3P7US << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_5US	(3)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_5US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_DELAY_5US << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_IN_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT)
+
+/* BST_LOOPR bit 1:0 (BST_EA 0x63) */
+#define AW87XXX_PID_60_BST_LOOPR_START_BIT	(0)
+#define AW87XXX_PID_60_BST_LOOPR_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_LOOPR_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_LOOPR_BITS_LEN)-1) << AW87XXX_PID_60_BST_LOOPR_START_BIT))
+
+#define AW87XXX_PID_60_BST_LOOPR_100K	(0)
+#define AW87XXX_PID_60_BST_LOOPR_100K_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPR_100K << AW87XXX_PID_60_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPR_200K	(1)
+#define AW87XXX_PID_60_BST_LOOPR_200K_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPR_200K << AW87XXX_PID_60_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPR_400K	(2)
+#define AW87XXX_PID_60_BST_LOOPR_400K_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPR_400K << AW87XXX_PID_60_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPR_500K	(3)
+#define AW87XXX_PID_60_BST_LOOPR_500K_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPR_500K << AW87XXX_PID_60_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPR_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_60_BST_LOOPR_DEFAULT	\
+	(AW87XXX_PID_60_BST_LOOPR_DEFAULT_VALUE << AW87XXX_PID_60_BST_LOOPR_START_BIT)
+
+/* default value of BST_EA (0x63) */
+/* #define AW87XXX_PID_60_BST_EA_DEFAULT		(0x86) */
+
+/* BST_DE_SOFT (0x64) detail */
+/* EN_ADP_PEAK bit 0 (BST_DE_SOFT 0x64) */
+#define AW87XXX_PID_60_EN_ADP_PEAK_START_BIT	(0)
+#define AW87XXX_PID_60_EN_ADP_PEAK_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_ADP_PEAK_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_ADP_PEAK_BITS_LEN)-1) << AW87XXX_PID_60_EN_ADP_PEAK_START_BIT))
+
+#define AW87XXX_PID_60_EN_ADP_PEAK_DISABLE	(0)
+#define AW87XXX_PID_60_EN_ADP_PEAK_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_PEAK_DISABLE << AW87XXX_PID_60_EN_ADP_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_PEAK_ENABLE	(1)
+#define AW87XXX_PID_60_EN_ADP_PEAK_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_PEAK_ENABLE << AW87XXX_PID_60_EN_ADP_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_PEAK_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_EN_ADP_PEAK_DEFAULT	\
+	(AW87XXX_PID_60_EN_ADP_PEAK_DEFAULT_VALUE << AW87XXX_PID_60_EN_ADP_PEAK_START_BIT)
+
+/* BST_SOFT_MODE_EN bit 7 (BST_DE_SOFT 0x64) */
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_START_BIT	(7)
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SOFT_MODE_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_SOFT_MODE_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_DISABLE	(0)
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_MODE_EN_DISABLE << AW87XXX_PID_60_BST_SOFT_MODE_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_MODE_EN_ENABLE << AW87XXX_PID_60_BST_SOFT_MODE_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_SOFT_MODE_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_SOFT_MODE_EN_START_BIT)
+
+/* BST_LOOPC bit 6:5 (BST_DE_SOFT 0x64) */
+#define AW87XXX_PID_60_BST_LOOPC_START_BIT	(5)
+#define AW87XXX_PID_60_BST_LOOPC_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_LOOPC_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_LOOPC_BITS_LEN)-1) << AW87XXX_PID_60_BST_LOOPC_START_BIT))
+
+#define AW87XXX_PID_60_BST_LOOPC_30PF	(0)
+#define AW87XXX_PID_60_BST_LOOPC_30PF_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPC_30PF << AW87XXX_PID_60_BST_LOOPC_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPC_40PF	(1)
+#define AW87XXX_PID_60_BST_LOOPC_40PF_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPC_40PF << AW87XXX_PID_60_BST_LOOPC_START_BIT)
+
+/*
+#define AW87XXX_PID_60_BST_LOOPC_40PF	(2)
+#define AW87XXX_PID_60_BST_LOOPC_40PF_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPC_40PF << AW87XXX_PID_60_BST_LOOPC_START_BIT)
+*/
+
+#define AW87XXX_PID_60_BST_LOOPC_50PF	(3)
+#define AW87XXX_PID_60_BST_LOOPC_50PF_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPC_50PF << AW87XXX_PID_60_BST_LOOPC_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPC_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_LOOPC_DEFAULT	\
+	(AW87XXX_PID_60_BST_LOOPC_DEFAULT_VALUE << AW87XXX_PID_60_BST_LOOPC_START_BIT)
+
+/* BST_SEL_DFPWM bit 4:3 (BST_DE_SOFT 0x64) */
+#define AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT	(3)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SEL_DFPWM_BITS_LEN)-1) << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT))
+
+#define AW87XXX_PID_60_BST_SEL_DFPWM_32US_00_2US	(0)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_32US_00_2US_VALUE	\
+	(AW87XXX_PID_60_BST_SEL_DFPWM_32US_00_2US << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_SEL_DFPWM_64US_01_CLK	(1)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_64US_01_CLK_VALUE	\
+	(AW87XXX_PID_60_BST_SEL_DFPWM_64US_01_CLK << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_SEL_DFPWM_128US_10_4US	(2)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_128US_10_4US_VALUE	\
+	(AW87XXX_PID_60_BST_SEL_DFPWM_128US_10_4US << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_SEL_DFPWM_256US_11_8US	(3)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_256US_11_8US_VALUE	\
+	(AW87XXX_PID_60_BST_SEL_DFPWM_256US_11_8US << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_SEL_DFPWM_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_DEFAULT	\
+	(AW87XXX_PID_60_BST_SEL_DFPWM_DEFAULT_VALUE << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT)
+
+/* BST_SOFT_DELAY bit 2:1 (BST_DE_SOFT 0x64) */
+#define AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT	(1)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SOFT_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_BST_SOFT_DELAY_40US_001280U	(0)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_40US_001280U_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_DELAY_40US_001280U << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_DELAY_80US_012560U	(1)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_80US_012560U_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_DELAY_80US_012560U << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_DELAY_160US_105120U	(2)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_160US_105120U_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_DELAY_160US_105120U << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_DELAY_320US_1110240U	(3)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_320US_1110240U_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_DELAY_320US_1110240U << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_DELAY_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_BST_SOFT_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT)
+
+/* default value of BST_DE_SOFT (0x64) */
+/* #define AW87XXX_PID_60_BST_DE_SOFT_DEFAULT		(0x09) */
+
+/* BST_BURST_KICK (0x65) detail */
+/* EN_TRANS_ERROR bit 0 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_EN_TRANS_ERROR_START_BIT	(0)
+#define AW87XXX_PID_60_EN_TRANS_ERROR_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_TRANS_ERROR_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_TRANS_ERROR_BITS_LEN)-1) << AW87XXX_PID_60_EN_TRANS_ERROR_START_BIT))
+
+#define AW87XXX_PID_60_EN_TRANS_ERROR_DISABLE	(0)
+#define AW87XXX_PID_60_EN_TRANS_ERROR_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_TRANS_ERROR_DISABLE << AW87XXX_PID_60_EN_TRANS_ERROR_START_BIT)
+
+#define AW87XXX_PID_60_EN_TRANS_ERROR_ENABLE	(1)
+#define AW87XXX_PID_60_EN_TRANS_ERROR_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_TRANS_ERROR_ENABLE << AW87XXX_PID_60_EN_TRANS_ERROR_START_BIT)
+
+#define AW87XXX_PID_60_EN_TRANS_ERROR_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_EN_TRANS_ERROR_DEFAULT	\
+	(AW87XXX_PID_60_EN_TRANS_ERROR_DEFAULT_VALUE << AW87XXX_PID_60_EN_TRANS_ERROR_START_BIT)
+
+/* BST_SCP_VTH bit 1 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_BST_SCP_VTH_START_BIT	(1)
+#define AW87XXX_PID_60_BST_SCP_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SCP_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SCP_VTH_BITS_LEN)-1) << AW87XXX_PID_60_BST_SCP_VTH_START_BIT))
+
+#define AW87XXX_PID_60_BST_SCP_VTH_HIGH_SIDE_VDD	(0)
+#define AW87XXX_PID_60_BST_SCP_VTH_HIGH_SIDE_VDD_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_VTH_HIGH_SIDE_VDD << AW87XXX_PID_60_BST_SCP_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_VTH_LOW_SIDE_VDD	(1)
+#define AW87XXX_PID_60_BST_SCP_VTH_LOW_SIDE_VDD_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_VTH_LOW_SIDE_VDD << AW87XXX_PID_60_BST_SCP_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_VTH_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SCP_VTH_DEFAULT	\
+	(AW87XXX_PID_60_BST_SCP_VTH_DEFAULT_VALUE << AW87XXX_PID_60_BST_SCP_VTH_START_BIT)
+
+/* BST_SKIP_EN bit 6 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_BST_SKIP_EN_START_BIT	(6)
+#define AW87XXX_PID_60_BST_SKIP_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SKIP_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SKIP_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_SKIP_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_SKIP_EN_ENABLE	(0)
+#define AW87XXX_PID_60_BST_SKIP_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SKIP_EN_ENABLE << AW87XXX_PID_60_BST_SKIP_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_SKIP_EN_DISABLE	(1)
+#define AW87XXX_PID_60_BST_SKIP_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SKIP_EN_DISABLE << AW87XXX_PID_60_BST_SKIP_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_SKIP_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SKIP_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_SKIP_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_SKIP_EN_START_BIT)
+
+/* BST_ADBK_COMP_ADJ bit 7 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_START_BIT	(7)
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_ADBK_COMP_ADJ_BITS_LEN)-1) << AW87XXX_PID_60_BST_ADBK_COMP_ADJ_START_BIT))
+
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_14UA	(0)
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_14UA_VALUE	\
+	(AW87XXX_PID_60_BST_ADBK_COMP_ADJ_14UA << AW87XXX_PID_60_BST_ADBK_COMP_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_10UA	(1)
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_10UA_VALUE	\
+	(AW87XXX_PID_60_BST_ADBK_COMP_ADJ_10UA << AW87XXX_PID_60_BST_ADBK_COMP_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_DEFAULT	\
+	(AW87XXX_PID_60_BST_ADBK_COMP_ADJ_DEFAULT_VALUE << AW87XXX_PID_60_BST_ADBK_COMP_ADJ_START_BIT)
+
+/* BST_OVP2_ITH bit 5:4 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_BST_OVP2_ITH_START_BIT	(4)
+#define AW87XXX_PID_60_BST_OVP2_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_OVP2_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP2_ITH_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP2_ITH_32MA	(0)
+#define AW87XXX_PID_60_BST_OVP2_ITH_32MA_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_ITH_32MA << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_ITH_48MA	(1)
+#define AW87XXX_PID_60_BST_OVP2_ITH_48MA_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_ITH_48MA << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_ITH_64MA	(2)
+#define AW87XXX_PID_60_BST_OVP2_ITH_64MA_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_ITH_64MA << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT)
+
+/*
+#define AW87XXX_PID_60_BST_OVP2_ITH_64MA	(3)
+#define AW87XXX_PID_60_BST_OVP2_ITH_64MA_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_ITH_64MA << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT)
+*/
+
+#define AW87XXX_PID_60_BST_OVP2_ITH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_OVP2_ITH_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP2_ITH_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT)
+
+/* BST_KICK_ITH bit 3:2 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_BST_KICK_ITH_START_BIT	(2)
+#define AW87XXX_PID_60_BST_KICK_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_KICK_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_KICK_ITH_BITS_LEN)-1) << AW87XXX_PID_60_BST_KICK_ITH_START_BIT))
+
+#define AW87XXX_PID_60_BST_KICK_ITH_32MA	(0)
+#define AW87XXX_PID_60_BST_KICK_ITH_32MA_VALUE	\
+	(AW87XXX_PID_60_BST_KICK_ITH_32MA << AW87XXX_PID_60_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_KICK_ITH_48MA	(1)
+#define AW87XXX_PID_60_BST_KICK_ITH_48MA_VALUE	\
+	(AW87XXX_PID_60_BST_KICK_ITH_48MA << AW87XXX_PID_60_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_KICK_ITH_64MA	(2)
+#define AW87XXX_PID_60_BST_KICK_ITH_64MA_VALUE	\
+	(AW87XXX_PID_60_BST_KICK_ITH_64MA << AW87XXX_PID_60_BST_KICK_ITH_START_BIT)
+
+/*
+#define AW87XXX_PID_60_BST_KICK_ITH_64MA	(3)
+#define AW87XXX_PID_60_BST_KICK_ITH_64MA_VALUE	\
+	(AW87XXX_PID_60_BST_KICK_ITH_64MA << AW87XXX_PID_60_BST_KICK_ITH_START_BIT)
+*/
+
+#define AW87XXX_PID_60_BST_KICK_ITH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_KICK_ITH_DEFAULT	\
+	(AW87XXX_PID_60_BST_KICK_ITH_DEFAULT_VALUE << AW87XXX_PID_60_BST_KICK_ITH_START_BIT)
+
+/* default value of BST_BURST_KICK (0x65) */
+/* #define AW87XXX_PID_60_BST_BURST_KICK_DEFAULT		(0x14) */
+
+/* BST_CON1 (0x66) detail */
+/* BST_GTDR_DDT bit 2 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_BST_GTDR_DDT_START_BIT	(2)
+#define AW87XXX_PID_60_BST_GTDR_DDT_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_GTDR_DDT_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_GTDR_DDT_BITS_LEN)-1) << AW87XXX_PID_60_BST_GTDR_DDT_START_BIT))
+
+#define AW87XXX_PID_60_BST_GTDR_DDT_9NS	(0)
+#define AW87XXX_PID_60_BST_GTDR_DDT_9NS_VALUE	\
+	(AW87XXX_PID_60_BST_GTDR_DDT_9NS << AW87XXX_PID_60_BST_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_BST_GTDR_DDT_12NS	(1)
+#define AW87XXX_PID_60_BST_GTDR_DDT_12NS_VALUE	\
+	(AW87XXX_PID_60_BST_GTDR_DDT_12NS << AW87XXX_PID_60_BST_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_BST_GTDR_DDT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_GTDR_DDT_DEFAULT	\
+	(AW87XXX_PID_60_BST_GTDR_DDT_DEFAULT_VALUE << AW87XXX_PID_60_BST_GTDR_DDT_START_BIT)
+
+/* EN_ADP_MODE1_DEGLITCH bit 3 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_START_BIT	(3)
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_BITS_LEN)-1) << AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_START_BIT))
+
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DISABLE	(0)
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DISABLE << AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_ENABLE	(1)
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_ENABLE << AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DEFAULT	\
+	(AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DEFAULT_VALUE << AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+/* SS_FINISH_SELECT bit 6 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_SS_FINISH_SELECT_START_BIT	(6)
+#define AW87XXX_PID_60_SS_FINISH_SELECT_BITS_LEN	(1)
+#define AW87XXX_PID_60_SS_FINISH_SELECT_MASK	\
+	(~(((1<<AW87XXX_PID_60_SS_FINISH_SELECT_BITS_LEN)-1) << AW87XXX_PID_60_SS_FINISH_SELECT_START_BIT))
+
+#define AW87XXX_PID_60_SS_FINISH_SELECT_NOT_USE	(0)
+#define AW87XXX_PID_60_SS_FINISH_SELECT_NOT_USE_VALUE	\
+	(AW87XXX_PID_60_SS_FINISH_SELECT_NOT_USE << AW87XXX_PID_60_SS_FINISH_SELECT_START_BIT)
+
+#define AW87XXX_PID_60_SS_FINISH_SELECT_USE	(1)
+#define AW87XXX_PID_60_SS_FINISH_SELECT_USE_VALUE	\
+	(AW87XXX_PID_60_SS_FINISH_SELECT_USE << AW87XXX_PID_60_SS_FINISH_SELECT_START_BIT)
+
+#define AW87XXX_PID_60_SS_FINISH_SELECT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_SS_FINISH_SELECT_DEFAULT	\
+	(AW87XXX_PID_60_SS_FINISH_SELECT_DEFAULT_VALUE << AW87XXX_PID_60_SS_FINISH_SELECT_START_BIT)
+
+/* BST_GDRV_TEST bit 7 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_BST_GDRV_TEST_START_BIT	(7)
+#define AW87XXX_PID_60_BST_GDRV_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_GDRV_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_GDRV_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_GDRV_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_GDRV_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_GDRV_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_GDRV_TEST_DIABLE << AW87XXX_PID_60_BST_GDRV_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_GDRV_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_GDRV_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_GDRV_TEST_ENABLE << AW87XXX_PID_60_BST_GDRV_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_GDRV_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_GDRV_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_GDRV_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_GDRV_TEST_START_BIT)
+
+/* BST_EN_DELAY bit 5:4 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_BST_EN_DELAY_START_BIT	(4)
+#define AW87XXX_PID_60_BST_EN_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_EN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_EN_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_BST_EN_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_BST_EN_DELAY_8N	(0)
+#define AW87XXX_PID_60_BST_EN_DELAY_8N_VALUE	\
+	(AW87XXX_PID_60_BST_EN_DELAY_8N << AW87XXX_PID_60_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_DELAY_80N	(1)
+#define AW87XXX_PID_60_BST_EN_DELAY_80N_VALUE	\
+	(AW87XXX_PID_60_BST_EN_DELAY_80N << AW87XXX_PID_60_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_DELAY_130N	(2)
+#define AW87XXX_PID_60_BST_EN_DELAY_130N_VALUE	\
+	(AW87XXX_PID_60_BST_EN_DELAY_130N << AW87XXX_PID_60_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_DELAY_200N	(3)
+#define AW87XXX_PID_60_BST_EN_DELAY_200N_VALUE	\
+	(AW87XXX_PID_60_BST_EN_DELAY_200N << AW87XXX_PID_60_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_DELAY_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_EN_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_BST_EN_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_BST_EN_DELAY_START_BIT)
+
+/* BST_SRC bit 1:0 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_BST_SRC_START_BIT	(0)
+#define AW87XXX_PID_60_BST_SRC_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_SRC_MASK		\
+	(~(((1<<AW87XXX_PID_60_BST_SRC_BITS_LEN)-1) << AW87XXX_PID_60_BST_SRC_START_BIT))
+
+#define AW87XXX_PID_60_BST_SRC_3NS		(0)
+#define AW87XXX_PID_60_BST_SRC_3NS_VALUE	\
+	(AW87XXX_PID_60_BST_SRC_3NS << AW87XXX_PID_60_BST_SRC_START_BIT)
+
+#define AW87XXX_PID_60_BST_SRC_4NS		(1)
+#define AW87XXX_PID_60_BST_SRC_4NS_VALUE	\
+	(AW87XXX_PID_60_BST_SRC_4NS << AW87XXX_PID_60_BST_SRC_START_BIT)
+
+#define AW87XXX_PID_60_BST_SRC_7NS		(2)
+#define AW87XXX_PID_60_BST_SRC_7NS_VALUE	\
+	(AW87XXX_PID_60_BST_SRC_7NS << AW87XXX_PID_60_BST_SRC_START_BIT)
+
+#define AW87XXX_PID_60_BST_SRC_15NS		(3)
+#define AW87XXX_PID_60_BST_SRC_15NS_VALUE	\
+	(AW87XXX_PID_60_BST_SRC_15NS << AW87XXX_PID_60_BST_SRC_START_BIT)
+
+#define AW87XXX_PID_60_BST_SRC_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SRC_DEFAULT	\
+	(AW87XXX_PID_60_BST_SRC_DEFAULT_VALUE << AW87XXX_PID_60_BST_SRC_START_BIT)
+
+/* default value of BST_CON1 (0x66) */
+/* #define AW87XXX_PID_60_BST_CON1_DEFAULT		(0x10) */
+
+/* BST_OVP (0x67) detail */
+/* BST_OVP_VTH bit 0 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_OVP_VTH_START_BIT	(0)
+#define AW87XXX_PID_60_BST_OVP_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP_VTH_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP_VTH_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP_VTH_3MINUS6P875V	(0)
+#define AW87XXX_PID_60_BST_OVP_VTH_3MINUS6P875V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_VTH_3MINUS6P875V << AW87XXX_PID_60_BST_OVP_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_VTH_7MINUS11V	(1)
+#define AW87XXX_PID_60_BST_OVP_VTH_7MINUS11V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_VTH_7MINUS11V << AW87XXX_PID_60_BST_OVP_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_VTH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_OVP_VTH_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP_VTH_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP_VTH_START_BIT)
+
+/* BST_VFB_EN bit 1 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_VFB_EN_START_BIT	(1)
+#define AW87XXX_PID_60_BST_VFB_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_VFB_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_VFB_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_VFB_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_VFB_EN_DISABLE	(0)
+#define AW87XXX_PID_60_BST_VFB_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_VFB_EN_DISABLE << AW87XXX_PID_60_BST_VFB_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_VFB_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_VFB_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_VFB_EN_ENABLE << AW87XXX_PID_60_BST_VFB_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_VFB_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_VFB_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_VFB_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_VFB_EN_START_BIT)
+
+/* BST_FORCE_PWM bit 2 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_FORCE_PWM_START_BIT	(2)
+#define AW87XXX_PID_60_BST_FORCE_PWM_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_FORCE_PWM_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_FORCE_PWM_BITS_LEN)-1) << AW87XXX_PID_60_BST_FORCE_PWM_START_BIT))
+
+#define AW87XXX_PID_60_BST_FORCE_PWM_DISABLE	(0)
+#define AW87XXX_PID_60_BST_FORCE_PWM_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_FORCE_PWM_DISABLE << AW87XXX_PID_60_BST_FORCE_PWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_FORCE_PWM_ENABLE	(1)
+#define AW87XXX_PID_60_BST_FORCE_PWM_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_FORCE_PWM_ENABLE << AW87XXX_PID_60_BST_FORCE_PWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_FORCE_PWM_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_FORCE_PWM_DEFAULT	\
+	(AW87XXX_PID_60_BST_FORCE_PWM_DEFAULT_VALUE << AW87XXX_PID_60_BST_FORCE_PWM_START_BIT)
+
+/* BST_OVP2_EN bit 5 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_OVP2_EN_START_BIT	(5)
+#define AW87XXX_PID_60_BST_OVP2_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP2_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP2_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP2_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP2_EN_DISABLE	(0)
+#define AW87XXX_PID_60_BST_OVP2_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_EN_DISABLE << AW87XXX_PID_60_BST_OVP2_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_OVP2_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_EN_ENABLE << AW87XXX_PID_60_BST_OVP2_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_OVP2_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP2_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP2_EN_START_BIT)
+
+/* BST_OVP_DEGLI_SEL bit 6 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_START_BIT	(6)
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP_DEGLI_SEL_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP_DEGLI_SEL_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_NO_DEGLITCH	(0)
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_NO_DEGLITCH_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_DEGLI_SEL_NO_DEGLITCH << AW87XXX_PID_60_BST_OVP_DEGLI_SEL_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEGLITCH	(1)
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEGLITCH_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEGLITCH << AW87XXX_PID_60_BST_OVP_DEGLI_SEL_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP_DEGLI_SEL_START_BIT)
+
+/* BST_CLK_DIV bit 7 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_CLK_DIV_START_BIT	(7)
+#define AW87XXX_PID_60_BST_CLK_DIV_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_CLK_DIV_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_CLK_DIV_BITS_LEN)-1) << AW87XXX_PID_60_BST_CLK_DIV_START_BIT))
+
+#define AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_4	(0)
+#define AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_4_VALUE	\
+	(AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_4 << AW87XXX_PID_60_BST_CLK_DIV_START_BIT)
+
+#define AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_2	(1)
+#define AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_2_VALUE	\
+	(AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_2 << AW87XXX_PID_60_BST_CLK_DIV_START_BIT)
+
+#define AW87XXX_PID_60_BST_CLK_DIV_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_CLK_DIV_DEFAULT	\
+	(AW87XXX_PID_60_BST_CLK_DIV_DEFAULT_VALUE << AW87XXX_PID_60_BST_CLK_DIV_START_BIT)
+
+/* BURST_HYS_EN bit 4:3 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BURST_HYS_EN_START_BIT	(3)
+#define AW87XXX_PID_60_BURST_HYS_EN_BITS_LEN	(2)
+#define AW87XXX_PID_60_BURST_HYS_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BURST_HYS_EN_BITS_LEN)-1) << AW87XXX_PID_60_BURST_HYS_EN_START_BIT))
+
+#define AW87XXX_PID_60_BURST_HYS_EN_OUT	(0)
+#define AW87XXX_PID_60_BURST_HYS_EN_OUT_VALUE	\
+	(AW87XXX_PID_60_BURST_HYS_EN_OUT << AW87XXX_PID_60_BURST_HYS_EN_START_BIT)
+
+#define AW87XXX_PID_60_BURST_HYS_EN_IN	(1)
+#define AW87XXX_PID_60_BURST_HYS_EN_IN_VALUE	\
+	(AW87XXX_PID_60_BURST_HYS_EN_IN << AW87XXX_PID_60_BURST_HYS_EN_START_BIT)
+
+#define AW87XXX_PID_60_BURST_HYS_EN_OUT_AND_IN	(3)
+#define AW87XXX_PID_60_BURST_HYS_EN_OUT_AND_IN_VALUE	\
+	(AW87XXX_PID_60_BURST_HYS_EN_OUT_AND_IN << AW87XXX_PID_60_BURST_HYS_EN_START_BIT)
+
+#define AW87XXX_PID_60_BURST_HYS_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BURST_HYS_EN_DEFAULT	\
+	(AW87XXX_PID_60_BURST_HYS_EN_DEFAULT_VALUE << AW87XXX_PID_60_BURST_HYS_EN_START_BIT)
+
+/* default value of BST_OVP (0x67) */
+/* #define AW87XXX_PID_60_BST_OVP_DEFAULT		(0x81) */
+
+/* LINE_MODE (0x68) detail */
+/* BST_EN_RSQN_DLY bit 0 (LINE_MODE 0x68) */
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_START_BIT	(0)
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_EN_RSQN_DLY_BITS_LEN)-1) << AW87XXX_PID_60_BST_EN_RSQN_DLY_START_BIT))
+
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_DISABLE	(0)
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_EN_RSQN_DLY_DISABLE << AW87XXX_PID_60_BST_EN_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_ENABLE	(1)
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_EN_RSQN_DLY_ENABLE << AW87XXX_PID_60_BST_EN_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_DEFAULT	\
+	(AW87XXX_PID_60_BST_EN_RSQN_DLY_DEFAULT_VALUE << AW87XXX_PID_60_BST_EN_RSQN_DLY_START_BIT)
+
+/* BST_FORCE_BOOST bit 1 (LINE_MODE 0x68) */
+#define AW87XXX_PID_60_BST_FORCE_BOOST_START_BIT	(1)
+#define AW87XXX_PID_60_BST_FORCE_BOOST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_FORCE_BOOST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_FORCE_BOOST_BITS_LEN)-1) << AW87XXX_PID_60_BST_FORCE_BOOST_START_BIT))
+
+#define AW87XXX_PID_60_BST_FORCE_BOOST_DISABLE	(0)
+#define AW87XXX_PID_60_BST_FORCE_BOOST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_FORCE_BOOST_DISABLE << AW87XXX_PID_60_BST_FORCE_BOOST_START_BIT)
+
+#define AW87XXX_PID_60_BST_FORCE_BOOST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_FORCE_BOOST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_FORCE_BOOST_ENABLE << AW87XXX_PID_60_BST_FORCE_BOOST_START_BIT)
+
+#define AW87XXX_PID_60_BST_FORCE_BOOST_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_FORCE_BOOST_DEFAULT	\
+	(AW87XXX_PID_60_BST_FORCE_BOOST_DEFAULT_VALUE << AW87XXX_PID_60_BST_FORCE_BOOST_START_BIT)
+
+/* BST_PWM_SHORT bit 2 (LINE_MODE 0x68) */
+#define AW87XXX_PID_60_BST_PWM_SHORT_START_BIT	(2)
+#define AW87XXX_PID_60_BST_PWM_SHORT_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_PWM_SHORT_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_PWM_SHORT_BITS_LEN)-1) << AW87XXX_PID_60_BST_PWM_SHORT_START_BIT))
+
+#define AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDD	(0)
+#define AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDD_VALUE	\
+	(AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDD << AW87XXX_PID_60_BST_PWM_SHORT_START_BIT)
+
+#define AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDDMINUSVTH	(1)
+#define AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDDMINUSVTH_VALUE	\
+	(AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDDMINUSVTH << AW87XXX_PID_60_BST_PWM_SHORT_START_BIT)
+
+#define AW87XXX_PID_60_BST_PWM_SHORT_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_PWM_SHORT_DEFAULT	\
+	(AW87XXX_PID_60_BST_PWM_SHORT_DEFAULT_VALUE << AW87XXX_PID_60_BST_PWM_SHORT_START_BIT)
+
+/* BST_OS_WIDTH bit 7:5 (LINE_MODE 0x68) */
+#define AW87XXX_PID_60_BST_OS_WIDTH_START_BIT	(5)
+#define AW87XXX_PID_60_BST_OS_WIDTH_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_OS_WIDTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OS_WIDTH_BITS_LEN)-1) << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT))
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_10NS	(0)
+#define AW87XXX_PID_60_BST_OS_WIDTH_10NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_10NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_20NS	(1)
+#define AW87XXX_PID_60_BST_OS_WIDTH_20NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_20NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_30NS	(2)
+#define AW87XXX_PID_60_BST_OS_WIDTH_30NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_30NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_40NS	(3)
+#define AW87XXX_PID_60_BST_OS_WIDTH_40NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_40NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_50NS	(4)
+#define AW87XXX_PID_60_BST_OS_WIDTH_50NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_50NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_60NS	(5)
+#define AW87XXX_PID_60_BST_OS_WIDTH_60NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_60NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_OS_WIDTH_DEFAULT	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_DEFAULT_VALUE << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+/* MODE1_START_DELAY bit 4:3 (LINE_MODE 0x68) */
+#define AW87XXX_PID_60_MODE1_START_DELAY_START_BIT	(3)
+#define AW87XXX_PID_60_MODE1_START_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_60_MODE1_START_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_MODE1_START_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_MODE1_START_DELAY_15P6US	(0)
+#define AW87XXX_PID_60_MODE1_START_DELAY_15P6US_VALUE	\
+	(AW87XXX_PID_60_MODE1_START_DELAY_15P6US << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_MODE1_START_DELAY_11P4US	(1)
+#define AW87XXX_PID_60_MODE1_START_DELAY_11P4US_VALUE	\
+	(AW87XXX_PID_60_MODE1_START_DELAY_11P4US << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_MODE1_START_DELAY_7P3US	(2)
+#define AW87XXX_PID_60_MODE1_START_DELAY_7P3US_VALUE	\
+	(AW87XXX_PID_60_MODE1_START_DELAY_7P3US << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_MODE1_START_DELAY_3US	(3)
+#define AW87XXX_PID_60_MODE1_START_DELAY_3US_VALUE	\
+	(AW87XXX_PID_60_MODE1_START_DELAY_3US << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_MODE1_START_DELAY_DEFAULT_VALUE	(3)
+#define AW87XXX_PID_60_MODE1_START_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_MODE1_START_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT)
+
+/* default value of LINE_MODE (0x68) */
+/* #define AW87XXX_PID_60_LINE_MODE_DEFAULT		(0x3F) */
+
+/* BST_ISEN (0x69) detail */
+/* BST_RSQN_DLY bit 7:5 (BST_ISEN 0x69) */
+#define AW87XXX_PID_60_BST_RSQN_DLY_START_BIT	(5)
+#define AW87XXX_PID_60_BST_RSQN_DLY_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_RSQN_DLY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_RSQN_DLY_BITS_LEN)-1) << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT))
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_15NS	(0)
+#define AW87XXX_PID_60_BST_RSQN_DLY_15NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_15NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_25NS	(1)
+#define AW87XXX_PID_60_BST_RSQN_DLY_25NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_25NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_35NS	(2)
+#define AW87XXX_PID_60_BST_RSQN_DLY_35NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_35NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_45NS	(3)
+#define AW87XXX_PID_60_BST_RSQN_DLY_45NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_45NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_70NS	(4)
+#define AW87XXX_PID_60_BST_RSQN_DLY_70NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_70NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_80NS	(5)
+#define AW87XXX_PID_60_BST_RSQN_DLY_80NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_80NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_90NS	(6)
+#define AW87XXX_PID_60_BST_RSQN_DLY_90NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_90NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_100NS	(7)
+#define AW87XXX_PID_60_BST_RSQN_DLY_100NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_100NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_60_BST_RSQN_DLY_DEFAULT	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_DEFAULT_VALUE << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+/* BST_SLOPE bit 4:3 (BST_ISEN 0x69) */
+#define AW87XXX_PID_60_BST_SLOPE_START_BIT	(3)
+#define AW87XXX_PID_60_BST_SLOPE_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_SLOPE_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SLOPE_BITS_LEN)-1) << AW87XXX_PID_60_BST_SLOPE_START_BIT))
+
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1	(0)
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_ISLOPE1 << AW87XXX_PID_60_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P25	(1)
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P25_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_ISLOPE1P25 << AW87XXX_PID_60_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P5	(2)
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P5_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_ISLOPE1P5 << AW87XXX_PID_60_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P75	(3)
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P75_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_ISLOPE1P75 << AW87XXX_PID_60_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SLOPE_DEFAULT	\
+	(AW87XXX_PID_60_BST_SLOPE_DEFAULT_VALUE << AW87XXX_PID_60_BST_SLOPE_START_BIT)
+
+/* BST_SLOPE_LIMIT bit 2:0 (BST_ISEN 0x69) */
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT	(0)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SLOPE_LIMIT_BITS_LEN)-1) << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT))
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_0P50ISLOPE	(0)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_0P50ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_0P50ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_0P75ISLOPE	(1)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_0P75ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_0P75ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P00ISLOPE	(2)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P00ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_1P00ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P25ISLOPE	(3)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P25ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_1P25ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P50ISLOPE	(4)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P50ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_1P50ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P75ISLOPE	(5)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P75ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_1P75ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_2P00ISLOPE	(6)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_2P00ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_2P00ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_2P25ISLOPE	(7)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_2P25ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_2P25ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_DEFAULT	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_DEFAULT_VALUE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+/* default value of BST_ISEN (0x69) */
+/* #define AW87XXX_PID_60_BST_ISEN_DEFAULT		(0x42) */
+
+/* BST_PEAK (0x6A) detail */
+/* BST_IPEAK_LOWBAT bit 3 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_START_BIT	(3)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_LOWBAT_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_LOWBAT_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P5A	(0)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P5A << AW87XXX_PID_60_BST_IPEAK_LOWBAT_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P75A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P75A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P75A << AW87XXX_PID_60_BST_IPEAK_LOWBAT_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_LOWBAT_START_BIT)
+
+/* BST_IPEAK_LOWBAT_EN bit 4 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_START_BIT	(4)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DISABLE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DISABLE << AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_ENABLE << AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+/* BST_IPEAK_ADJ bit 5 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_START_BIT	(5)
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_ADJ_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_ADJ_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK	(0)
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK << AW87XXX_PID_60_BST_IPEAK_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK0P5A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK0P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK0P5A << AW87XXX_PID_60_BST_IPEAK_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_ADJ_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_ADJ_START_BIT)
+
+/* BACK_ADPT_R400K bit 6 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_BACK_ADPT_R400K_START_BIT	(6)
+#define AW87XXX_PID_60_BACK_ADPT_R400K_BITS_LEN	(1)
+#define AW87XXX_PID_60_BACK_ADPT_R400K_MASK	\
+	(~(((1<<AW87XXX_PID_60_BACK_ADPT_R400K_BITS_LEN)-1) << AW87XXX_PID_60_BACK_ADPT_R400K_START_BIT))
+
+#define AW87XXX_PID_60_BACK_ADPT_R400K_DISABLE	(0)
+#define AW87XXX_PID_60_BACK_ADPT_R400K_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BACK_ADPT_R400K_DISABLE << AW87XXX_PID_60_BACK_ADPT_R400K_START_BIT)
+
+#define AW87XXX_PID_60_BACK_ADPT_R400K_ENABALE	(1)
+#define AW87XXX_PID_60_BACK_ADPT_R400K_ENABALE_VALUE	\
+	(AW87XXX_PID_60_BACK_ADPT_R400K_ENABALE << AW87XXX_PID_60_BACK_ADPT_R400K_START_BIT)
+
+#define AW87XXX_PID_60_BACK_ADPT_R400K_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BACK_ADPT_R400K_DEFAULT	\
+	(AW87XXX_PID_60_BACK_ADPT_R400K_DEFAULT_VALUE << AW87XXX_PID_60_BACK_ADPT_R400K_START_BIT)
+
+/* SEL_FINISH_ID bit 7 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_SEL_FINISH_ID_START_BIT	(7)
+#define AW87XXX_PID_60_SEL_FINISH_ID_BITS_LEN	(1)
+#define AW87XXX_PID_60_SEL_FINISH_ID_MASK	\
+	(~(((1<<AW87XXX_PID_60_SEL_FINISH_ID_BITS_LEN)-1) << AW87XXX_PID_60_SEL_FINISH_ID_START_BIT))
+
+#define AW87XXX_PID_60_SEL_FINISH_ID_MODE1START	(0)
+#define AW87XXX_PID_60_SEL_FINISH_ID_MODE1START_VALUE	\
+	(AW87XXX_PID_60_SEL_FINISH_ID_MODE1START << AW87XXX_PID_60_SEL_FINISH_ID_START_BIT)
+
+#define AW87XXX_PID_60_SEL_FINISH_ID_LIMITSSFINISH	(1)
+#define AW87XXX_PID_60_SEL_FINISH_ID_LIMITSSFINISH_VALUE	\
+	(AW87XXX_PID_60_SEL_FINISH_ID_LIMITSSFINISH << AW87XXX_PID_60_SEL_FINISH_ID_START_BIT)
+
+#define AW87XXX_PID_60_SEL_FINISH_ID_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_SEL_FINISH_ID_DEFAULT	\
+	(AW87XXX_PID_60_SEL_FINISH_ID_DEFAULT_VALUE << AW87XXX_PID_60_SEL_FINISH_ID_START_BIT)
+
+/* BST_IPEAK_SS bit 2:0 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_BST_IPEAK_SS_START_BIT	(0)
+#define AW87XXX_PID_60_BST_IPEAK_SS_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_IPEAK_SS_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_SS_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_0P8A	(0)
+#define AW87XXX_PID_60_BST_IPEAK_SS_0P8A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_0P8A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P0A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P0A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_1P0A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P25A	(2)
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P25A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_1P25A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P5A	(3)
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_1P5A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P75A	(4)
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P75A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_1P75A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_2A	(5)
+#define AW87XXX_PID_60_BST_IPEAK_SS_2A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_2A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_2P25A	(6)
+#define AW87XXX_PID_60_BST_IPEAK_SS_2P25A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_2P25A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_2P50A	(7)
+#define AW87XXX_PID_60_BST_IPEAK_SS_2P50A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_2P50A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_IPEAK_SS_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+/* default value of BST_PEAK (0x6A) */
+/* #define AW87XXX_PID_60_BST_PEAK_DEFAULT		(0x01) */
+
+/* BST_PEAK2 (0x6B) detail */
+/* BST_BACK_EN bit 2 (BST_PEAK2 0x6B) */
+#define AW87XXX_PID_60_BST_BACK_EN_START_BIT	(2)
+#define AW87XXX_PID_60_BST_BACK_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_BACK_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BACK_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_BACK_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_BACK_EN_ENABLE	(0)
+#define AW87XXX_PID_60_BST_BACK_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_BACK_EN_ENABLE << AW87XXX_PID_60_BST_BACK_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BACK_EN_DIABALE	(1)
+#define AW87XXX_PID_60_BST_BACK_EN_DIABALE_VALUE	\
+	(AW87XXX_PID_60_BST_BACK_EN_DIABALE << AW87XXX_PID_60_BST_BACK_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BACK_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_BACK_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_BACK_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_BACK_EN_START_BIT)
+
+/* BST_IPEAK_ITH_EN bit 3 (BST_PEAK2 0x6B) */
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_START_BIT	(3)
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_ITH_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_ITH_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAK	(0)
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAK_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAK << AW87XXX_PID_60_BST_IPEAK_ITH_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAKMINUS0P5A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAKMINUS0P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAKMINUS0P5A << AW87XXX_PID_60_BST_IPEAK_ITH_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_ITH_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_ITH_EN_START_BIT)
+
+/* BST_IPEAK_TRIM bit 7:4 (BST_PEAK2 0x6B) */
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT	(4)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_BITS_LEN	(4)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_TRIM_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0A	(0)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_0A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P2A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P2A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_0P2A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P4A	(2)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P4A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_0P4A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P6A	(3)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P6A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_0P6A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P6A	(8)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P6A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P6A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P4A	(9)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P4A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P4A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P2A	(10)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P2A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P2A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1A	(11)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P8A	(12)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P8A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P8A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P6A	(13)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P6A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P6A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P4A	(14)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P4A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P4A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P2A	(15)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P2A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P2A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+/* OFFTIME_OUT_C bit 1:0 (BST_PEAK2 0x6B) */
+#define AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT	(0)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_BITS_LEN	(2)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_MASK	\
+	(~(((1<<AW87XXX_PID_60_OFFTIME_OUT_C_BITS_LEN)-1) << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT))
+
+#define AW87XXX_PID_60_OFFTIME_OUT_C_0	(0)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_0_VALUE	\
+	(AW87XXX_PID_60_OFFTIME_OUT_C_0 << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT)
+
+#define AW87XXX_PID_60_OFFTIME_OUT_C_1	(1)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_1_VALUE	\
+	(AW87XXX_PID_60_OFFTIME_OUT_C_1 << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT)
+
+#define AW87XXX_PID_60_OFFTIME_OUT_C_2	(2)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_2_VALUE	\
+	(AW87XXX_PID_60_OFFTIME_OUT_C_2 << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT)
+
+#define AW87XXX_PID_60_OFFTIME_OUT_C_3	(3)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_3_VALUE	\
+	(AW87XXX_PID_60_OFFTIME_OUT_C_3 << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT)
+
+#define AW87XXX_PID_60_OFFTIME_OUT_C_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_DEFAULT	\
+	(AW87XXX_PID_60_OFFTIME_OUT_C_DEFAULT_VALUE << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT)
+
+/* default value of BST_PEAK2 (0x6B) */
+/* #define AW87XXX_PID_60_BST_PEAK2_DEFAULT		(0x02) */
+
+/* OFFTIME (0x6C) detail */
+/* HEAD_ROOM bit 3 (OFFTIME 0x6C) */
+#define AW87XXX_PID_60_HEAD_ROOM_START_BIT	(3)
+#define AW87XXX_PID_60_HEAD_ROOM_BITS_LEN	(1)
+#define AW87XXX_PID_60_HEAD_ROOM_MASK	\
+	(~(((1<<AW87XXX_PID_60_HEAD_ROOM_BITS_LEN)-1) << AW87XXX_PID_60_HEAD_ROOM_START_BIT))
+
+#define AW87XXX_PID_60_HEAD_ROOM_1P5V	(0)
+#define AW87XXX_PID_60_HEAD_ROOM_1P5V_VALUE	\
+	(AW87XXX_PID_60_HEAD_ROOM_1P5V << AW87XXX_PID_60_HEAD_ROOM_START_BIT)
+
+#define AW87XXX_PID_60_HEAD_ROOM_2P0V	(1)
+#define AW87XXX_PID_60_HEAD_ROOM_2P0V_VALUE	\
+	(AW87XXX_PID_60_HEAD_ROOM_2P0V << AW87XXX_PID_60_HEAD_ROOM_START_BIT)
+
+#define AW87XXX_PID_60_HEAD_ROOM_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_HEAD_ROOM_DEFAULT	\
+	(AW87XXX_PID_60_HEAD_ROOM_DEFAULT_VALUE << AW87XXX_PID_60_HEAD_ROOM_START_BIT)
+
+/* BST_OFFTIME_EN bit 7 (OFFTIME 0x6C) */
+#define AW87XXX_PID_60_BST_OFFTIME_EN_START_BIT	(7)
+#define AW87XXX_PID_60_BST_OFFTIME_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OFFTIME_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OFFTIME_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_OFFTIME_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_OFFTIME_EN_ENABLE	(0)
+#define AW87XXX_PID_60_BST_OFFTIME_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_EN_ENABLE << AW87XXX_PID_60_BST_OFFTIME_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_EN_DIABALE	(1)
+#define AW87XXX_PID_60_BST_OFFTIME_EN_DIABALE_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_EN_DIABALE << AW87XXX_PID_60_BST_OFFTIME_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_OFFTIME_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_OFFTIME_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_OFFTIME_EN_START_BIT)
+
+/* BST_OFFTIME bit 6:4 (OFFTIME 0x6C) */
+#define AW87XXX_PID_60_BST_OFFTIME_START_BIT	(4)
+#define AW87XXX_PID_60_BST_OFFTIME_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_OFFTIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OFFTIME_BITS_LEN)-1) << AW87XXX_PID_60_BST_OFFTIME_START_BIT))
+
+#define AW87XXX_PID_60_BST_OFFTIME_4	(0)
+#define AW87XXX_PID_60_BST_OFFTIME_4_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_4 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_3	(1)
+#define AW87XXX_PID_60_BST_OFFTIME_3_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_3 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_2	(2)
+#define AW87XXX_PID_60_BST_OFFTIME_2_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_2 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_1	(3)
+#define AW87XXX_PID_60_BST_OFFTIME_1_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_1 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_0	(4)
+#define AW87XXX_PID_60_BST_OFFTIME_0_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_0 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS1	(5)
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS1_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_MINUS1 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS2	(6)
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS2_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_MINUS2 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS3	(7)
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS3_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_MINUS3 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_DEFAULT_VALUE	(4)
+#define AW87XXX_PID_60_BST_OFFTIME_DEFAULT	\
+	(AW87XXX_PID_60_BST_OFFTIME_DEFAULT_VALUE << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+/* BST_OUT_VTH0 bit 2:0 (OFFTIME 0x6C) */
+#define AW87XXX_PID_60_BST_OUT_VTH0_START_BIT	(0)
+#define AW87XXX_PID_60_BST_OUT_VTH0_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_OUT_VTH0_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OUT_VTH0_BITS_LEN)-1) << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT))
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_6P5V	(0)
+#define AW87XXX_PID_60_BST_OUT_VTH0_6P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_6P5V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_6P75V	(1)
+#define AW87XXX_PID_60_BST_OUT_VTH0_6P75V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_6P75V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P0V	(2)
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P0V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_7P0V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P25V	(3)
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P25V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_7P25V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P5V	(4)
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_7P5V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P75V	(5)
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P75V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_7P75V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_8P0V	(6)
+#define AW87XXX_PID_60_BST_OUT_VTH0_8P0V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_8P0V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_8P25V	(7)
+#define AW87XXX_PID_60_BST_OUT_VTH0_8P25V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_8P25V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_OUT_VTH0_DEFAULT	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_DEFAULT_VALUE << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+/* default value of OFFTIME (0x6C) */
+/* #define AW87XXX_PID_60_OFFTIME_DEFAULT		(0x41) */
+
+/* ADPBST (0x6D) detail */
+/* REG_CLK_CP_OTA bit 0 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_START_BIT	(0)
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_CLK_CP_OTA_BITS_LEN)-1) << AW87XXX_PID_60_REG_CLK_CP_OTA_START_BIT))
+
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_200KHZ	(0)
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_200KHZ_VALUE	\
+	(AW87XXX_PID_60_REG_CLK_CP_OTA_200KHZ << AW87XXX_PID_60_REG_CLK_CP_OTA_START_BIT)
+
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_400KHZ	(1)
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_400KHZ_VALUE	\
+	(AW87XXX_PID_60_REG_CLK_CP_OTA_400KHZ << AW87XXX_PID_60_REG_CLK_CP_OTA_START_BIT)
+
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_DEFAULT	\
+	(AW87XXX_PID_60_REG_CLK_CP_OTA_DEFAULT_VALUE << AW87XXX_PID_60_REG_CLK_CP_OTA_START_BIT)
+
+/* OTA_MD2 bit 1 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_OTA_MD2_START_BIT	(1)
+#define AW87XXX_PID_60_OTA_MD2_BITS_LEN	(1)
+#define AW87XXX_PID_60_OTA_MD2_MASK		\
+	(~(((1<<AW87XXX_PID_60_OTA_MD2_BITS_LEN)-1) << AW87XXX_PID_60_OTA_MD2_START_BIT))
+
+#define AW87XXX_PID_60_OTA_MD2_DISABLE	(0)
+#define AW87XXX_PID_60_OTA_MD2_DISABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_MD2_DISABLE << AW87XXX_PID_60_OTA_MD2_START_BIT)
+
+#define AW87XXX_PID_60_OTA_MD2_ENABLE	(1)
+#define AW87XXX_PID_60_OTA_MD2_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_MD2_ENABLE << AW87XXX_PID_60_OTA_MD2_START_BIT)
+
+#define AW87XXX_PID_60_OTA_MD2_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_OTA_MD2_DEFAULT	\
+	(AW87XXX_PID_60_OTA_MD2_DEFAULT_VALUE << AW87XXX_PID_60_OTA_MD2_START_BIT)
+
+/* OTA_RCV bit 2 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_OTA_RCV_START_BIT	(2)
+#define AW87XXX_PID_60_OTA_RCV_BITS_LEN	(1)
+#define AW87XXX_PID_60_OTA_RCV_MASK		\
+	(~(((1<<AW87XXX_PID_60_OTA_RCV_BITS_LEN)-1) << AW87XXX_PID_60_OTA_RCV_START_BIT))
+
+#define AW87XXX_PID_60_OTA_RCV_DISABLE	(0)
+#define AW87XXX_PID_60_OTA_RCV_DISABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_RCV_DISABLE << AW87XXX_PID_60_OTA_RCV_START_BIT)
+
+#define AW87XXX_PID_60_OTA_RCV_ENABLE	(1)
+#define AW87XXX_PID_60_OTA_RCV_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_RCV_ENABLE << AW87XXX_PID_60_OTA_RCV_START_BIT)
+
+#define AW87XXX_PID_60_OTA_RCV_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_OTA_RCV_DEFAULT	\
+	(AW87XXX_PID_60_OTA_RCV_DEFAULT_VALUE << AW87XXX_PID_60_OTA_RCV_START_BIT)
+
+/* MSBM_VDD_SEL bit 3 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_MSBM_VDD_SEL_START_BIT	(3)
+#define AW87XXX_PID_60_MSBM_VDD_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_60_MSBM_VDD_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_MSBM_VDD_SEL_BITS_LEN)-1) << AW87XXX_PID_60_MSBM_VDD_SEL_START_BIT))
+
+#define AW87XXX_PID_60_MSBM_VDD_SEL_VDDBELOW4P5V	(0)
+#define AW87XXX_PID_60_MSBM_VDD_SEL_VDDBELOW4P5V_VALUE	\
+	(AW87XXX_PID_60_MSBM_VDD_SEL_VDDBELOW4P5V << AW87XXX_PID_60_MSBM_VDD_SEL_START_BIT)
+
+#define AW87XXX_PID_60_MSBM_VDD_SEL_VDDABOVE4P5V	(1)
+#define AW87XXX_PID_60_MSBM_VDD_SEL_VDDABOVE4P5V_VALUE	\
+	(AW87XXX_PID_60_MSBM_VDD_SEL_VDDABOVE4P5V << AW87XXX_PID_60_MSBM_VDD_SEL_START_BIT)
+
+#define AW87XXX_PID_60_MSBM_VDD_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_MSBM_VDD_SEL_DEFAULT	\
+	(AW87XXX_PID_60_MSBM_VDD_SEL_DEFAULT_VALUE << AW87XXX_PID_60_MSBM_VDD_SEL_START_BIT)
+
+/* DLY_EN bit 4 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_DLY_EN_START_BIT	(4)
+#define AW87XXX_PID_60_DLY_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_DLY_EN_MASK		\
+	(~(((1<<AW87XXX_PID_60_DLY_EN_BITS_LEN)-1) << AW87XXX_PID_60_DLY_EN_START_BIT))
+
+#define AW87XXX_PID_60_DLY_EN_DISABLE	(0)
+#define AW87XXX_PID_60_DLY_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_DLY_EN_DISABLE << AW87XXX_PID_60_DLY_EN_START_BIT)
+
+#define AW87XXX_PID_60_DLY_EN_ENABLE	(1)
+#define AW87XXX_PID_60_DLY_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_DLY_EN_ENABLE << AW87XXX_PID_60_DLY_EN_START_BIT)
+
+#define AW87XXX_PID_60_DLY_EN_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_DLY_EN_DEFAULT	\
+	(AW87XXX_PID_60_DLY_EN_DEFAULT_VALUE << AW87XXX_PID_60_DLY_EN_START_BIT)
+
+/* DLY_CLK_EN bit 5 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_DLY_CLK_EN_START_BIT	(5)
+#define AW87XXX_PID_60_DLY_CLK_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_DLY_CLK_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_DLY_CLK_EN_BITS_LEN)-1) << AW87XXX_PID_60_DLY_CLK_EN_START_BIT))
+
+#define AW87XXX_PID_60_DLY_CLK_EN_DISABLE	(0)
+#define AW87XXX_PID_60_DLY_CLK_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_DLY_CLK_EN_DISABLE << AW87XXX_PID_60_DLY_CLK_EN_START_BIT)
+
+#define AW87XXX_PID_60_DLY_CLK_EN_ENABLE	(1)
+#define AW87XXX_PID_60_DLY_CLK_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_DLY_CLK_EN_ENABLE << AW87XXX_PID_60_DLY_CLK_EN_START_BIT)
+
+#define AW87XXX_PID_60_DLY_CLK_EN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_DLY_CLK_EN_DEFAULT	\
+	(AW87XXX_PID_60_DLY_CLK_EN_DEFAULT_VALUE << AW87XXX_PID_60_DLY_CLK_EN_START_BIT)
+
+/* ADPBST_FALL_TIME bit 7:6 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT	(6)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_ADPBST_FALL_TIME_BITS_LEN)-1) << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT))
+
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_5MS	(0)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_5MS_VALUE	\
+	(AW87XXX_PID_60_ADPBST_FALL_TIME_5MS << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_10MS	(1)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_10MS_VALUE	\
+	(AW87XXX_PID_60_ADPBST_FALL_TIME_10MS << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_20MS	(2)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_20MS_VALUE	\
+	(AW87XXX_PID_60_ADPBST_FALL_TIME_20MS << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_40MS	(3)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_40MS_VALUE	\
+	(AW87XXX_PID_60_ADPBST_FALL_TIME_40MS << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_DEFAULT	\
+	(AW87XXX_PID_60_ADPBST_FALL_TIME_DEFAULT_VALUE << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT)
+
+/* default value of ADPBST (0x6D) */
+/* #define AW87XXX_PID_60_ADPBST_DEFAULT		(0x50) */
+
+/* OTA (0x6E) detail */
+/* EN_SWF bit 0 (OTA 0x6E) */
+#define AW87XXX_PID_60_EN_SWF_START_BIT	(0)
+#define AW87XXX_PID_60_EN_SWF_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_SWF_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_SWF_BITS_LEN)-1) << AW87XXX_PID_60_EN_SWF_START_BIT))
+
+#define AW87XXX_PID_60_EN_SWF_DISABLE	(0)
+#define AW87XXX_PID_60_EN_SWF_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_SWF_DISABLE << AW87XXX_PID_60_EN_SWF_START_BIT)
+
+#define AW87XXX_PID_60_EN_SWF_ENABLE	(1)
+#define AW87XXX_PID_60_EN_SWF_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_SWF_ENABLE << AW87XXX_PID_60_EN_SWF_START_BIT)
+
+#define AW87XXX_PID_60_EN_SWF_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_SWF_DEFAULT	\
+	(AW87XXX_PID_60_EN_SWF_DEFAULT_VALUE << AW87XXX_PID_60_EN_SWF_START_BIT)
+
+/* BST_CK_MODE bit 1 (OTA 0x6E) */
+#define AW87XXX_PID_60_BST_CK_MODE_START_BIT	(1)
+#define AW87XXX_PID_60_BST_CK_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_CK_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_CK_MODE_BITS_LEN)-1) << AW87XXX_PID_60_BST_CK_MODE_START_BIT))
+
+#define AW87XXX_PID_60_BST_CK_MODE_1P6MHZ	(0)
+#define AW87XXX_PID_60_BST_CK_MODE_1P6MHZ_VALUE	\
+	(AW87XXX_PID_60_BST_CK_MODE_1P6MHZ << AW87XXX_PID_60_BST_CK_MODE_START_BIT)
+
+#define AW87XXX_PID_60_BST_CK_MODE_2P0MHZ	(1)
+#define AW87XXX_PID_60_BST_CK_MODE_2P0MHZ_VALUE	\
+	(AW87XXX_PID_60_BST_CK_MODE_2P0MHZ << AW87XXX_PID_60_BST_CK_MODE_START_BIT)
+
+#define AW87XXX_PID_60_BST_CK_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_BST_CK_MODE_DEFAULT	\
+	(AW87XXX_PID_60_BST_CK_MODE_DEFAULT_VALUE << AW87XXX_PID_60_BST_CK_MODE_START_BIT)
+
+/* EN_LOOP_GBW_REDUCE bit 2 (OTA 0x6E) */
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_START_BIT	(2)
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_BITS_LEN)-1) << AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_START_BIT))
+
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DISABLE	(0)
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DISABLE << AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_START_BIT)
+
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_ENABLE	(1)
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_ENABLE << AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_START_BIT)
+
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DEFAULT	\
+	(AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DEFAULT_VALUE << AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_START_BIT)
+
+/* EN_DEM_POWER bit 3 (OTA 0x6E) */
+#define AW87XXX_PID_60_EN_DEM_POWER_START_BIT	(3)
+#define AW87XXX_PID_60_EN_DEM_POWER_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_DEM_POWER_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_DEM_POWER_BITS_LEN)-1) << AW87XXX_PID_60_EN_DEM_POWER_START_BIT))
+
+#define AW87XXX_PID_60_EN_DEM_POWER_DISABLE	(0)
+#define AW87XXX_PID_60_EN_DEM_POWER_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_DEM_POWER_DISABLE << AW87XXX_PID_60_EN_DEM_POWER_START_BIT)
+
+#define AW87XXX_PID_60_EN_DEM_POWER_ENABLE	(1)
+#define AW87XXX_PID_60_EN_DEM_POWER_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_DEM_POWER_ENABLE << AW87XXX_PID_60_EN_DEM_POWER_START_BIT)
+
+#define AW87XXX_PID_60_EN_DEM_POWER_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_DEM_POWER_DEFAULT	\
+	(AW87XXX_PID_60_EN_DEM_POWER_DEFAULT_VALUE << AW87XXX_PID_60_EN_DEM_POWER_START_BIT)
+
+/* REG_CLK_CP_RIN bit 4 (OTA 0x6E) */
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_START_BIT	(4)
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_CLK_CP_RIN_BITS_LEN)-1) << AW87XXX_PID_60_REG_CLK_CP_RIN_START_BIT))
+
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_200KHZ	(0)
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_200KHZ_VALUE	\
+	(AW87XXX_PID_60_REG_CLK_CP_RIN_200KHZ << AW87XXX_PID_60_REG_CLK_CP_RIN_START_BIT)
+
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_400KHZ	(1)
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_400KHZ_VALUE	\
+	(AW87XXX_PID_60_REG_CLK_CP_RIN_400KHZ << AW87XXX_PID_60_REG_CLK_CP_RIN_START_BIT)
+
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_DEFAULT	\
+	(AW87XXX_PID_60_REG_CLK_CP_RIN_DEFAULT_VALUE << AW87XXX_PID_60_REG_CLK_CP_RIN_START_BIT)
+
+/* EN_DEM bit 5 (OTA 0x6E) */
+#define AW87XXX_PID_60_EN_DEM_START_BIT	(5)
+#define AW87XXX_PID_60_EN_DEM_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_DEM_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_DEM_BITS_LEN)-1) << AW87XXX_PID_60_EN_DEM_START_BIT))
+
+#define AW87XXX_PID_60_EN_DEM_DISABLE	(0)
+#define AW87XXX_PID_60_EN_DEM_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_DEM_DISABLE << AW87XXX_PID_60_EN_DEM_START_BIT)
+
+#define AW87XXX_PID_60_EN_DEM_ENABLE	(1)
+#define AW87XXX_PID_60_EN_DEM_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_DEM_ENABLE << AW87XXX_PID_60_EN_DEM_START_BIT)
+
+#define AW87XXX_PID_60_EN_DEM_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_DEM_DEFAULT	\
+	(AW87XXX_PID_60_EN_DEM_DEFAULT_VALUE << AW87XXX_PID_60_EN_DEM_START_BIT)
+
+/* OTA_NG bit 6 (OTA 0x6E) */
+#define AW87XXX_PID_60_OTA_NG_START_BIT	(6)
+#define AW87XXX_PID_60_OTA_NG_BITS_LEN	(1)
+#define AW87XXX_PID_60_OTA_NG_MASK		\
+	(~(((1<<AW87XXX_PID_60_OTA_NG_BITS_LEN)-1) << AW87XXX_PID_60_OTA_NG_START_BIT))
+
+#define AW87XXX_PID_60_OTA_NG_DISABLE	(0)
+#define AW87XXX_PID_60_OTA_NG_DISABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_NG_DISABLE << AW87XXX_PID_60_OTA_NG_START_BIT)
+
+#define AW87XXX_PID_60_OTA_NG_ENABLE	(1)
+#define AW87XXX_PID_60_OTA_NG_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_NG_ENABLE << AW87XXX_PID_60_OTA_NG_START_BIT)
+
+#define AW87XXX_PID_60_OTA_NG_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_OTA_NG_DEFAULT	\
+	(AW87XXX_PID_60_OTA_NG_DEFAULT_VALUE << AW87XXX_PID_60_OTA_NG_START_BIT)
+
+/* OTA_CP bit 7 (OTA 0x6E) */
+#define AW87XXX_PID_60_OTA_CP_START_BIT	(7)
+#define AW87XXX_PID_60_OTA_CP_BITS_LEN	(1)
+#define AW87XXX_PID_60_OTA_CP_MASK		\
+	(~(((1<<AW87XXX_PID_60_OTA_CP_BITS_LEN)-1) << AW87XXX_PID_60_OTA_CP_START_BIT))
+
+#define AW87XXX_PID_60_OTA_CP_DISABLE	(0)
+#define AW87XXX_PID_60_OTA_CP_DISABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_CP_DISABLE << AW87XXX_PID_60_OTA_CP_START_BIT)
+
+#define AW87XXX_PID_60_OTA_CP_ENABLE	(1)
+#define AW87XXX_PID_60_OTA_CP_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_CP_ENABLE << AW87XXX_PID_60_OTA_CP_START_BIT)
+
+#define AW87XXX_PID_60_OTA_CP_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_OTA_CP_DEFAULT	\
+	(AW87XXX_PID_60_OTA_CP_DEFAULT_VALUE << AW87XXX_PID_60_OTA_CP_START_BIT)
+
+/* default value of OTA (0x6E) */
+/* #define AW87XXX_PID_60_OTA_DEFAULT		(0xC0) */
+
+/* RAMPGEN (0x6F) detail */
+/* RAMP_1SPW_VL bit 7:6 (RAMPGEN 0x6F) */
+#define AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT	(6)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_BITS_LEN	(2)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_MASK	\
+	(~(((1<<AW87XXX_PID_60_RAMP_1SPW_VL_BITS_LEN)-1) << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT))
+
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P16VDD	(0)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P16VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VL_0P16VDD << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P18VDD	(1)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P18VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VL_0P18VDD << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P20VDD	(2)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P20VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VL_0P20VDD << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P14VDD	(3)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P14VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VL_0P14VDD << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_DEFAULT	\
+	(AW87XXX_PID_60_RAMP_1SPW_VL_DEFAULT_VALUE << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT)
+
+/* PA_RAMP_AGC1 bit 5:4 (RAMPGEN 0x6F) */
+#define AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT	(4)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_BITS_LEN	(2)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_RAMP_AGC1_BITS_LEN)-1) << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT))
+
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P8VDD	(0)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P8VDD_VALUE	\
+	(AW87XXX_PID_60_PA_RAMP_AGC1_0P8VDD << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P825VDD	(1)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P825VDD_VALUE	\
+	(AW87XXX_PID_60_PA_RAMP_AGC1_0P825VDD << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P85VDD	(2)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P85VDD_VALUE	\
+	(AW87XXX_PID_60_PA_RAMP_AGC1_0P85VDD << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P875VDD	(3)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P875VDD_VALUE	\
+	(AW87XXX_PID_60_PA_RAMP_AGC1_0P875VDD << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PA_RAMP_AGC1_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_DEFAULT	\
+	(AW87XXX_PID_60_PA_RAMP_AGC1_DEFAULT_VALUE << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT)
+
+/* RAMP_1SPW_VC bit 3:2 (RAMPGEN 0x6F) */
+#define AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT	(2)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_BITS_LEN	(2)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_MASK	\
+	(~(((1<<AW87XXX_PID_60_RAMP_1SPW_VC_BITS_LEN)-1) << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT))
+
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P37VDD	(0)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P37VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VC_0P37VDD << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P39VDD	(1)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P39VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VC_0P39VDD << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P33VDD	(2)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P33VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VC_0P33VDD << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P35VDD	(3)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P35VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VC_0P35VDD << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VC_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_DEFAULT	\
+	(AW87XXX_PID_60_RAMP_1SPW_VC_DEFAULT_VALUE << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT)
+
+/* SS_CONTROL bit 1:0 (RAMPGEN 0x6F) */
+#define AW87XXX_PID_60_SS_CONTROL_START_BIT	(0)
+#define AW87XXX_PID_60_SS_CONTROL_BITS_LEN	(2)
+#define AW87XXX_PID_60_SS_CONTROL_MASK	\
+	(~(((1<<AW87XXX_PID_60_SS_CONTROL_BITS_LEN)-1) << AW87XXX_PID_60_SS_CONTROL_START_BIT))
+
+#define AW87XXX_PID_60_SS_CONTROL_SS_MODE	(0)
+#define AW87XXX_PID_60_SS_CONTROL_SS_MODE_VALUE	\
+	(AW87XXX_PID_60_SS_CONTROL_SS_MODE << AW87XXX_PID_60_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE111	(1)
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE111_VALUE	\
+	(AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE111 << AW87XXX_PID_60_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE000	(2)
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE000_VALUE	\
+	(AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE000 << AW87XXX_PID_60_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE011	(3)
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE011_VALUE	\
+	(AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE011 << AW87XXX_PID_60_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_60_SS_CONTROL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_SS_CONTROL_DEFAULT	\
+	(AW87XXX_PID_60_SS_CONTROL_DEFAULT_VALUE << AW87XXX_PID_60_SS_CONTROL_START_BIT)
+
+/* default value of RAMPGEN (0x6F) */
+/* #define AW87XXX_PID_60_RAMPGEN_DEFAULT		(0x0C) */
+
+/* CLASSD_SYSCTRL (0x70) detail */
+/* SEL_VCOM1 bit 0 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_SEL_VCOM1_START_BIT	(0)
+#define AW87XXX_PID_60_SEL_VCOM1_BITS_LEN	(1)
+#define AW87XXX_PID_60_SEL_VCOM1_MASK	\
+	(~(((1<<AW87XXX_PID_60_SEL_VCOM1_BITS_LEN)-1) << AW87XXX_PID_60_SEL_VCOM1_START_BIT))
+
+#define AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V	(0)
+#define AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V_VALUE	\
+	(AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V << AW87XXX_PID_60_SEL_VCOM1_START_BIT)
+
+/*
+#define AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V	(1)
+#define AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V_VALUE	\
+	(AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V << AW87XXX_PID_60_SEL_VCOM1_START_BIT)
+*/
+/*
+Fix me here:
+reg_addr:0x70, reg_name:CLASSD_SYSCTRL, field_name:SEL_VCOM1, content:When ENOTA=0:
+maybe need to fix manually
+*/
+#define AW87XXX_PID_60_SEL_VCOM1_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_SEL_VCOM1_DEFAULT	\
+	(AW87XXX_PID_60_SEL_VCOM1_DEFAULT_VALUE << AW87XXX_PID_60_SEL_VCOM1_START_BIT)
+
+/* PA_OPD bit 1 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_PA_OPD_START_BIT	(1)
+#define AW87XXX_PID_60_PA_OPD_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_OPD_MASK		\
+	(~(((1<<AW87XXX_PID_60_PA_OPD_BITS_LEN)-1) << AW87XXX_PID_60_PA_OPD_START_BIT))
+
+#define AW87XXX_PID_60_PA_OPD_FLOATING	(0)
+#define AW87XXX_PID_60_PA_OPD_FLOATING_VALUE	\
+	(AW87XXX_PID_60_PA_OPD_FLOATING << AW87XXX_PID_60_PA_OPD_START_BIT)
+
+#define AW87XXX_PID_60_PA_OPD_TIED_TO_GND	(1)
+#define AW87XXX_PID_60_PA_OPD_TIED_TO_GND_VALUE	\
+	(AW87XXX_PID_60_PA_OPD_TIED_TO_GND << AW87XXX_PID_60_PA_OPD_START_BIT)
+
+#define AW87XXX_PID_60_PA_OPD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PA_OPD_DEFAULT	\
+	(AW87XXX_PID_60_PA_OPD_DEFAULT_VALUE << AW87XXX_PID_60_PA_OPD_START_BIT)
+
+/* CLK_OCP_SEL bit 4 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_CLK_OCP_SEL_START_BIT	(4)
+#define AW87XXX_PID_60_CLK_OCP_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_60_CLK_OCP_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_CLK_OCP_SEL_BITS_LEN)-1) << AW87XXX_PID_60_CLK_OCP_SEL_START_BIT))
+
+#define AW87XXX_PID_60_CLK_OCP_SEL_160MS	(0)
+#define AW87XXX_PID_60_CLK_OCP_SEL_160MS_VALUE	\
+	(AW87XXX_PID_60_CLK_OCP_SEL_160MS << AW87XXX_PID_60_CLK_OCP_SEL_START_BIT)
+
+#define AW87XXX_PID_60_CLK_OCP_SEL_SHUTDOWN	(1)
+#define AW87XXX_PID_60_CLK_OCP_SEL_SHUTDOWN_VALUE	\
+	(AW87XXX_PID_60_CLK_OCP_SEL_SHUTDOWN << AW87XXX_PID_60_CLK_OCP_SEL_START_BIT)
+
+#define AW87XXX_PID_60_CLK_OCP_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_CLK_OCP_SEL_DEFAULT	\
+	(AW87XXX_PID_60_CLK_OCP_SEL_DEFAULT_VALUE << AW87XXX_PID_60_CLK_OCP_SEL_START_BIT)
+
+/* PD_OT bit 5 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_PD_OT_START_BIT	(5)
+#define AW87XXX_PID_60_PD_OT_BITS_LEN	(1)
+#define AW87XXX_PID_60_PD_OT_MASK		\
+	(~(((1<<AW87XXX_PID_60_PD_OT_BITS_LEN)-1) << AW87XXX_PID_60_PD_OT_START_BIT))
+
+#define AW87XXX_PID_60_PD_OT_ENABLE		(0)
+#define AW87XXX_PID_60_PD_OT_ENABLE_VALUE	\
+	(AW87XXX_PID_60_PD_OT_ENABLE << AW87XXX_PID_60_PD_OT_START_BIT)
+
+#define AW87XXX_PID_60_PD_OT_SHUTDOWN	(1)
+#define AW87XXX_PID_60_PD_OT_SHUTDOWN_VALUE	\
+	(AW87XXX_PID_60_PD_OT_SHUTDOWN << AW87XXX_PID_60_PD_OT_START_BIT)
+
+#define AW87XXX_PID_60_PD_OT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PD_OT_DEFAULT	\
+	(AW87XXX_PID_60_PD_OT_DEFAULT_VALUE << AW87XXX_PID_60_PD_OT_START_BIT)
+
+/* PA_FLT_SR bit 6 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_PA_FLT_SR_START_BIT	(6)
+#define AW87XXX_PID_60_PA_FLT_SR_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_FLT_SR_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_FLT_SR_BITS_LEN)-1) << AW87XXX_PID_60_PA_FLT_SR_START_BIT))
+
+#define AW87XXX_PID_60_PA_FLT_SR_ADD_RC	(0)
+#define AW87XXX_PID_60_PA_FLT_SR_ADD_RC_VALUE	\
+	(AW87XXX_PID_60_PA_FLT_SR_ADD_RC << AW87XXX_PID_60_PA_FLT_SR_START_BIT)
+
+#define AW87XXX_PID_60_PA_FLT_SR_NO_RC	(1)
+#define AW87XXX_PID_60_PA_FLT_SR_NO_RC_VALUE	\
+	(AW87XXX_PID_60_PA_FLT_SR_NO_RC << AW87XXX_PID_60_PA_FLT_SR_START_BIT)
+
+#define AW87XXX_PID_60_PA_FLT_SR_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PA_FLT_SR_DEFAULT	\
+	(AW87XXX_PID_60_PA_FLT_SR_DEFAULT_VALUE << AW87XXX_PID_60_PA_FLT_SR_START_BIT)
+
+/* PA_PORT bit 3:2 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_PA_PORT_START_BIT	(2)
+#define AW87XXX_PID_60_PA_PORT_BITS_LEN	(2)
+#define AW87XXX_PID_60_PA_PORT_MASK		\
+	(~(((1<<AW87XXX_PID_60_PA_PORT_BITS_LEN)-1) << AW87XXX_PID_60_PA_PORT_START_BIT))
+
+#define AW87XXX_PID_60_PA_PORT_80MS		(0)
+#define AW87XXX_PID_60_PA_PORT_80MS_VALUE	\
+	(AW87XXX_PID_60_PA_PORT_80MS << AW87XXX_PID_60_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_60_PA_PORT_40MS		(1)
+#define AW87XXX_PID_60_PA_PORT_40MS_VALUE	\
+	(AW87XXX_PID_60_PA_PORT_40MS << AW87XXX_PID_60_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_60_PA_PORT_20MS		(2)
+#define AW87XXX_PID_60_PA_PORT_20MS_VALUE	\
+	(AW87XXX_PID_60_PA_PORT_20MS << AW87XXX_PID_60_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_60_PA_PORT_10MS		(3)
+#define AW87XXX_PID_60_PA_PORT_10MS_VALUE	\
+	(AW87XXX_PID_60_PA_PORT_10MS << AW87XXX_PID_60_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_60_PA_PORT_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PA_PORT_DEFAULT	\
+	(AW87XXX_PID_60_PA_PORT_DEFAULT_VALUE << AW87XXX_PID_60_PA_PORT_START_BIT)
+
+/* default value of CLASSD_SYSCTRL (0x70) */
+/* #define AW87XXX_PID_60_CLASSD_SYSCTRL_DEFAULT		(0x07) */
+
+/* GTDR (0x71) detail */
+/* REG_DUTY_T bit 0 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_DUTY_T_START_BIT	(0)
+#define AW87XXX_PID_60_REG_DUTY_T_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_DUTY_T_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_DUTY_T_BITS_LEN)-1) << AW87XXX_PID_60_REG_DUTY_T_START_BIT))
+
+#define AW87XXX_PID_60_REG_DUTY_T_DISABLE	(0)
+#define AW87XXX_PID_60_REG_DUTY_T_DISABLE_VALUE	\
+	(AW87XXX_PID_60_REG_DUTY_T_DISABLE << AW87XXX_PID_60_REG_DUTY_T_START_BIT)
+
+#define AW87XXX_PID_60_REG_DUTY_T_ENALBE	(1)
+#define AW87XXX_PID_60_REG_DUTY_T_ENALBE_VALUE	\
+	(AW87XXX_PID_60_REG_DUTY_T_ENALBE << AW87XXX_PID_60_REG_DUTY_T_START_BIT)
+
+#define AW87XXX_PID_60_REG_DUTY_T_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_REG_DUTY_T_DEFAULT	\
+	(AW87XXX_PID_60_REG_DUTY_T_DEFAULT_VALUE << AW87XXX_PID_60_REG_DUTY_T_START_BIT)
+
+/* LN_DELAY bit 1 (GTDR 0x71) */
+#define AW87XXX_PID_60_LN_DELAY_START_BIT	(1)
+#define AW87XXX_PID_60_LN_DELAY_BITS_LEN	(1)
+#define AW87XXX_PID_60_LN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_LN_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_LN_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_LN_DELAY_DISABLE	(0)
+#define AW87XXX_PID_60_LN_DELAY_DISABLE_VALUE	\
+	(AW87XXX_PID_60_LN_DELAY_DISABLE << AW87XXX_PID_60_LN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_LN_DELAY_ENABLE	(1)
+#define AW87XXX_PID_60_LN_DELAY_ENABLE_VALUE	\
+	(AW87XXX_PID_60_LN_DELAY_ENABLE << AW87XXX_PID_60_LN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_LN_DELAY_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_LN_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_LN_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_LN_DELAY_START_BIT)
+
+/* HN_DELAY bit 2 (GTDR 0x71) */
+#define AW87XXX_PID_60_HN_DELAY_START_BIT	(2)
+#define AW87XXX_PID_60_HN_DELAY_BITS_LEN	(1)
+#define AW87XXX_PID_60_HN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_HN_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_HN_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_HN_DELAY_DISABLE	(0)
+#define AW87XXX_PID_60_HN_DELAY_DISABLE_VALUE	\
+	(AW87XXX_PID_60_HN_DELAY_DISABLE << AW87XXX_PID_60_HN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_HN_DELAY_ENABLE	(1)
+#define AW87XXX_PID_60_HN_DELAY_ENABLE_VALUE	\
+	(AW87XXX_PID_60_HN_DELAY_ENABLE << AW87XXX_PID_60_HN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_HN_DELAY_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_HN_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_HN_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_HN_DELAY_START_BIT)
+
+/* REG_T_EDGE bit 3 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_T_EDGE_START_BIT	(3)
+#define AW87XXX_PID_60_REG_T_EDGE_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_T_EDGE_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_T_EDGE_BITS_LEN)-1) << AW87XXX_PID_60_REG_T_EDGE_START_BIT))
+
+#define AW87XXX_PID_60_REG_T_EDGE_5NS	(0)
+#define AW87XXX_PID_60_REG_T_EDGE_5NS_VALUE	\
+	(AW87XXX_PID_60_REG_T_EDGE_5NS << AW87XXX_PID_60_REG_T_EDGE_START_BIT)
+
+#define AW87XXX_PID_60_REG_T_EDGE_15NS	(1)
+#define AW87XXX_PID_60_REG_T_EDGE_15NS_VALUE	\
+	(AW87XXX_PID_60_REG_T_EDGE_15NS << AW87XXX_PID_60_REG_T_EDGE_START_BIT)
+
+#define AW87XXX_PID_60_REG_T_EDGE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_T_EDGE_DEFAULT	\
+	(AW87XXX_PID_60_REG_T_EDGE_DEFAULT_VALUE << AW87XXX_PID_60_REG_T_EDGE_START_BIT)
+
+/* REG_L_PULL bit 4 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_L_PULL_START_BIT	(4)
+#define AW87XXX_PID_60_REG_L_PULL_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_L_PULL_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_L_PULL_BITS_LEN)-1) << AW87XXX_PID_60_REG_L_PULL_START_BIT))
+
+#define AW87XXX_PID_60_REG_L_PULL_7NS	(0)
+#define AW87XXX_PID_60_REG_L_PULL_7NS_VALUE	\
+	(AW87XXX_PID_60_REG_L_PULL_7NS << AW87XXX_PID_60_REG_L_PULL_START_BIT)
+
+#define AW87XXX_PID_60_REG_L_PULL_14NS	(1)
+#define AW87XXX_PID_60_REG_L_PULL_14NS_VALUE	\
+	(AW87XXX_PID_60_REG_L_PULL_14NS << AW87XXX_PID_60_REG_L_PULL_START_BIT)
+
+#define AW87XXX_PID_60_REG_L_PULL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_L_PULL_DEFAULT	\
+	(AW87XXX_PID_60_REG_L_PULL_DEFAULT_VALUE << AW87XXX_PID_60_REG_L_PULL_START_BIT)
+
+/* REG_L_PUD bit 5 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_L_PUD_START_BIT	(5)
+#define AW87XXX_PID_60_REG_L_PUD_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_L_PUD_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_L_PUD_BITS_LEN)-1) << AW87XXX_PID_60_REG_L_PUD_START_BIT))
+
+#define AW87XXX_PID_60_REG_L_PUD_0NS	(0)
+#define AW87XXX_PID_60_REG_L_PUD_0NS_VALUE	\
+	(AW87XXX_PID_60_REG_L_PUD_0NS << AW87XXX_PID_60_REG_L_PUD_START_BIT)
+
+#define AW87XXX_PID_60_REG_L_PUD_3NS	(1)
+#define AW87XXX_PID_60_REG_L_PUD_3NS_VALUE	\
+	(AW87XXX_PID_60_REG_L_PUD_3NS << AW87XXX_PID_60_REG_L_PUD_START_BIT)
+
+#define AW87XXX_PID_60_REG_L_PUD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_REG_L_PUD_DEFAULT	\
+	(AW87XXX_PID_60_REG_L_PUD_DEFAULT_VALUE << AW87XXX_PID_60_REG_L_PUD_START_BIT)
+
+/* REG_HNG_PULL bit 6 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_HNG_PULL_START_BIT	(6)
+#define AW87XXX_PID_60_REG_HNG_PULL_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_HNG_PULL_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_HNG_PULL_BITS_LEN)-1) << AW87XXX_PID_60_REG_HNG_PULL_START_BIT))
+
+#define AW87XXX_PID_60_REG_HNG_PULL_DISABLE	(0)
+#define AW87XXX_PID_60_REG_HNG_PULL_DISABLE_VALUE	\
+	(AW87XXX_PID_60_REG_HNG_PULL_DISABLE << AW87XXX_PID_60_REG_HNG_PULL_START_BIT)
+
+#define AW87XXX_PID_60_REG_HNG_PULL_ENABLE	(1)
+#define AW87XXX_PID_60_REG_HNG_PULL_ENABLE_VALUE	\
+	(AW87XXX_PID_60_REG_HNG_PULL_ENABLE << AW87XXX_PID_60_REG_HNG_PULL_START_BIT)
+
+#define AW87XXX_PID_60_REG_HNG_PULL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_HNG_PULL_DEFAULT	\
+	(AW87XXX_PID_60_REG_HNG_PULL_DEFAULT_VALUE << AW87XXX_PID_60_REG_HNG_PULL_START_BIT)
+
+/* REG_DUTY_VTH bit 7 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_DUTY_VTH_START_BIT	(7)
+#define AW87XXX_PID_60_REG_DUTY_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_DUTY_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_DUTY_VTH_BITS_LEN)-1) << AW87XXX_PID_60_REG_DUTY_VTH_START_BIT))
+
+#define AW87XXX_PID_60_REG_DUTY_VTH_POVTH0	(0)
+#define AW87XXX_PID_60_REG_DUTY_VTH_POVTH0_VALUE	\
+	(AW87XXX_PID_60_REG_DUTY_VTH_POVTH0 << AW87XXX_PID_60_REG_DUTY_VTH_START_BIT)
+
+#define AW87XXX_PID_60_REG_DUTY_VTH_POVTH4	(1)
+#define AW87XXX_PID_60_REG_DUTY_VTH_POVTH4_VALUE	\
+	(AW87XXX_PID_60_REG_DUTY_VTH_POVTH4 << AW87XXX_PID_60_REG_DUTY_VTH_START_BIT)
+
+#define AW87XXX_PID_60_REG_DUTY_VTH_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_DUTY_VTH_DEFAULT	\
+	(AW87XXX_PID_60_REG_DUTY_VTH_DEFAULT_VALUE << AW87XXX_PID_60_REG_DUTY_VTH_START_BIT)
+
+/* default value of GTDR (0x71) */
+/* #define AW87XXX_PID_60_GTDR_DEFAULT		(0x27) */
+
+/* OC (0x72) detail */
+/* REG_SHORT_GUARD bit 7 (OC 0x72) */
+#define AW87XXX_PID_60_REG_SHORT_GUARD_START_BIT	(7)
+#define AW87XXX_PID_60_REG_SHORT_GUARD_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_SHORT_GUARD_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_SHORT_GUARD_BITS_LEN)-1) << AW87XXX_PID_60_REG_SHORT_GUARD_START_BIT))
+
+#define AW87XXX_PID_60_REG_SHORT_GUARD_DISABLE	(0)
+#define AW87XXX_PID_60_REG_SHORT_GUARD_DISABLE_VALUE	\
+	(AW87XXX_PID_60_REG_SHORT_GUARD_DISABLE << AW87XXX_PID_60_REG_SHORT_GUARD_START_BIT)
+
+#define AW87XXX_PID_60_REG_SHORT_GUARD_ENALBE	(1)
+#define AW87XXX_PID_60_REG_SHORT_GUARD_ENALBE_VALUE	\
+	(AW87XXX_PID_60_REG_SHORT_GUARD_ENALBE << AW87XXX_PID_60_REG_SHORT_GUARD_START_BIT)
+
+#define AW87XXX_PID_60_REG_SHORT_GUARD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_REG_SHORT_GUARD_DEFAULT	\
+	(AW87XXX_PID_60_REG_SHORT_GUARD_DEFAULT_VALUE << AW87XXX_PID_60_REG_SHORT_GUARD_START_BIT)
+
+/* PA_GTDR_DDT bit 6:5 (OC 0x72) */
+#define AW87XXX_PID_60_PA_GTDR_DDT_START_BIT	(5)
+#define AW87XXX_PID_60_PA_GTDR_DDT_BITS_LEN	(2)
+#define AW87XXX_PID_60_PA_GTDR_DDT_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_GTDR_DDT_BITS_LEN)-1) << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT))
+
+#define AW87XXX_PID_60_PA_GTDR_DDT_12NS	(0)
+#define AW87XXX_PID_60_PA_GTDR_DDT_12NS_VALUE	\
+	(AW87XXX_PID_60_PA_GTDR_DDT_12NS << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_PA_GTDR_DDT_13NS	(1)
+#define AW87XXX_PID_60_PA_GTDR_DDT_13NS_VALUE	\
+	(AW87XXX_PID_60_PA_GTDR_DDT_13NS << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_PA_GTDR_DDT_14NS	(2)
+#define AW87XXX_PID_60_PA_GTDR_DDT_14NS_VALUE	\
+	(AW87XXX_PID_60_PA_GTDR_DDT_14NS << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_PA_GTDR_DDT_15NS	(3)
+#define AW87XXX_PID_60_PA_GTDR_DDT_15NS_VALUE	\
+	(AW87XXX_PID_60_PA_GTDR_DDT_15NS << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_PA_GTDR_DDT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PA_GTDR_DDT_DEFAULT	\
+	(AW87XXX_PID_60_PA_GTDR_DDT_DEFAULT_VALUE << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT)
+
+/* PA_OC_ITH bit 4:2 (OC 0x72) */
+#define AW87XXX_PID_60_PA_OC_ITH_START_BIT	(2)
+#define AW87XXX_PID_60_PA_OC_ITH_BITS_LEN	(3)
+#define AW87XXX_PID_60_PA_OC_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_OC_ITH_BITS_LEN)-1) << AW87XXX_PID_60_PA_OC_ITH_START_BIT))
+
+#define AW87XXX_PID_60_PA_OC_ITH_3P4A	(0)
+#define AW87XXX_PID_60_PA_OC_ITH_3P4A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_3P4A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_3P8A	(1)
+#define AW87XXX_PID_60_PA_OC_ITH_3P8A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_3P8A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_4P2A	(2)
+#define AW87XXX_PID_60_PA_OC_ITH_4P2A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_4P2A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_4P6A	(3)
+#define AW87XXX_PID_60_PA_OC_ITH_4P6A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_4P6A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_5P0A	(4)
+#define AW87XXX_PID_60_PA_OC_ITH_5P0A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_5P0A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_5P4A	(5)
+#define AW87XXX_PID_60_PA_OC_ITH_5P4A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_5P4A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_5P7A	(6)
+#define AW87XXX_PID_60_PA_OC_ITH_5P7A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_5P7A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_6P0A	(7)
+#define AW87XXX_PID_60_PA_OC_ITH_6P0A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_6P0A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_PA_OC_ITH_DEFAULT	\
+	(AW87XXX_PID_60_PA_OC_ITH_DEFAULT_VALUE << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+/* PA_OC_DT bit 1:0 (OC 0x72) */
+#define AW87XXX_PID_60_PA_OC_DT_START_BIT	(0)
+#define AW87XXX_PID_60_PA_OC_DT_BITS_LEN	(2)
+#define AW87XXX_PID_60_PA_OC_DT_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_OC_DT_BITS_LEN)-1) << AW87XXX_PID_60_PA_OC_DT_START_BIT))
+
+#define AW87XXX_PID_60_PA_OC_DT_20NS	(0)
+#define AW87XXX_PID_60_PA_OC_DT_20NS_VALUE	\
+	(AW87XXX_PID_60_PA_OC_DT_20NS << AW87XXX_PID_60_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_DT_40NS	(1)
+#define AW87XXX_PID_60_PA_OC_DT_40NS_VALUE	\
+	(AW87XXX_PID_60_PA_OC_DT_40NS << AW87XXX_PID_60_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_DT_60NS	(2)
+#define AW87XXX_PID_60_PA_OC_DT_60NS_VALUE	\
+	(AW87XXX_PID_60_PA_OC_DT_60NS << AW87XXX_PID_60_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_DT_80NS	(3)
+#define AW87XXX_PID_60_PA_OC_DT_80NS_VALUE	\
+	(AW87XXX_PID_60_PA_OC_DT_80NS << AW87XXX_PID_60_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_DT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PA_OC_DT_DEFAULT	\
+	(AW87XXX_PID_60_PA_OC_DT_DEFAULT_VALUE << AW87XXX_PID_60_PA_OC_DT_START_BIT)
+
+/* default value of OC (0x72) */
+/* #define AW87XXX_PID_60_OC_DEFAULT		(0x8C) */
+
+/* AGC_CON (0x73) detail */
+/* PA_OCSWD bit 6 (AGC_CON 0x73) */
+#define AW87XXX_PID_60_PA_OCSWD_START_BIT	(6)
+#define AW87XXX_PID_60_PA_OCSWD_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_OCSWD_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_OCSWD_BITS_LEN)-1) << AW87XXX_PID_60_PA_OCSWD_START_BIT))
+
+#define AW87XXX_PID_60_PA_OCSWD_FAST	(0)
+#define AW87XXX_PID_60_PA_OCSWD_FAST_VALUE	\
+	(AW87XXX_PID_60_PA_OCSWD_FAST << AW87XXX_PID_60_PA_OCSWD_START_BIT)
+
+#define AW87XXX_PID_60_PA_OCSWD_SLOW	(1)
+#define AW87XXX_PID_60_PA_OCSWD_SLOW_VALUE	\
+	(AW87XXX_PID_60_PA_OCSWD_SLOW << AW87XXX_PID_60_PA_OCSWD_START_BIT)
+
+#define AW87XXX_PID_60_PA_OCSWD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PA_OCSWD_DEFAULT	\
+	(AW87XXX_PID_60_PA_OCSWD_DEFAULT_VALUE << AW87XXX_PID_60_PA_OCSWD_START_BIT)
+
+/* PD_CROSSZERO bit 5:4 (AGC_CON 0x73) */
+#define AW87XXX_PID_60_PD_CROSSZERO_START_BIT	(4)
+#define AW87XXX_PID_60_PD_CROSSZERO_BITS_LEN	(2)
+#define AW87XXX_PID_60_PD_CROSSZERO_MASK	\
+	(~(((1<<AW87XXX_PID_60_PD_CROSSZERO_BITS_LEN)-1) << AW87XXX_PID_60_PD_CROSSZERO_START_BIT))
+
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC2_3_CROSSZERO	(0)
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC2_3_CROSSZERO_VALUE	\
+	(AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC2_3_CROSSZERO << AW87XXX_PID_60_PD_CROSSZERO_START_BIT)
+
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO	(1)
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO_VALUE	\
+	(AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO << AW87XXX_PID_60_PD_CROSSZERO_START_BIT)
+
+/*
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO	(2)
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO_VALUE	\
+	(AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO << AW87XXX_PID_60_PD_CROSSZERO_START_BIT)
+*/
+
+#define AW87XXX_PID_60_PD_CROSSZERO_AGC123_CROSSZERO	(3)
+#define AW87XXX_PID_60_PD_CROSSZERO_AGC123_CROSSZERO_VALUE	\
+	(AW87XXX_PID_60_PD_CROSSZERO_AGC123_CROSSZERO << AW87XXX_PID_60_PD_CROSSZERO_START_BIT)
+/*
+Fix me here:
+reg_addr:0x73, reg_name:AGC_CON, field_name:PD_CROSSZERO, content:AGC cross_zero adaptively When EN_AGC1_ADP=1
+maybe need to fix manually
+*/
+#define AW87XXX_PID_60_PD_CROSSZERO_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PD_CROSSZERO_DEFAULT	\
+	(AW87XXX_PID_60_PD_CROSSZERO_DEFAULT_VALUE << AW87XXX_PID_60_PD_CROSSZERO_START_BIT)
+
+/* AGC1_VTH_SEL bit 3:2 (AGC_CON 0x73) */
+#define AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT	(2)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_BITS_LEN	(2)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC1_VTH_SEL_BITS_LEN)-1) << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT))
+
+#define AW87XXX_PID_60_AGC1_VTH_SEL_RAMPGEN	(0)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_RAMPGEN_VALUE	\
+	(AW87XXX_PID_60_AGC1_VTH_SEL_RAMPGEN << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_VTH_SEL_THGEN	(1)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_THGEN_VALUE	\
+	(AW87XXX_PID_60_AGC1_VTH_SEL_THGEN << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN	(2)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN_VALUE	\
+	(AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT)
+
+/*
+#define AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN	(3)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN_VALUE	\
+	(AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT)
+*/
+
+#define AW87XXX_PID_60_AGC1_VTH_SEL_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_DEFAULT	\
+	(AW87XXX_PID_60_AGC1_VTH_SEL_DEFAULT_VALUE << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT)
+
+/* AGC2_FIRST_ATT_TIME bit 1:0 (AGC_CON 0x73) */
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P08MS	(0)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P08MS_VALUE	\
+	(AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P08MS << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P32MS	(1)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P32MS_VALUE	\
+	(AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P32MS << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_1P28MS	(2)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_1P28MS_VALUE	\
+	(AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_1P28MS << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_5P12MS	(3)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_5P12MS_VALUE	\
+	(AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_5P12MS << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT)
+
+/* default value of AGC_CON (0x73) */
+/* #define AW87XXX_PID_60_AGC_CON_DEFAULT		(0x48) */
+
+/* NG (0x74) detail */
+/* NG_MODE bit 2 (NG 0x74) */
+#define AW87XXX_PID_60_NG_MODE_START_BIT	(2)
+#define AW87XXX_PID_60_NG_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_60_NG_MODE_MASK		\
+	(~(((1<<AW87XXX_PID_60_NG_MODE_BITS_LEN)-1) << AW87XXX_PID_60_NG_MODE_START_BIT))
+
+#define AW87XXX_PID_60_NG_MODE_MODE1	(0)
+#define AW87XXX_PID_60_NG_MODE_MODE1_VALUE	\
+	(AW87XXX_PID_60_NG_MODE_MODE1 << AW87XXX_PID_60_NG_MODE_START_BIT)
+
+#define AW87XXX_PID_60_NG_MODE_MODE2	(1)
+#define AW87XXX_PID_60_NG_MODE_MODE2_VALUE	\
+	(AW87XXX_PID_60_NG_MODE_MODE2 << AW87XXX_PID_60_NG_MODE_START_BIT)
+
+#define AW87XXX_PID_60_NG_MODE_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_NG_MODE_DEFAULT	\
+	(AW87XXX_PID_60_NG_MODE_DEFAULT_VALUE << AW87XXX_PID_60_NG_MODE_START_BIT)
+
+/* EN_NG bit 3 (NG 0x74) */
+#define AW87XXX_PID_60_EN_NG_START_BIT	(3)
+#define AW87XXX_PID_60_EN_NG_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_NG_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_NG_BITS_LEN)-1) << AW87XXX_PID_60_EN_NG_START_BIT))
+
+#define AW87XXX_PID_60_EN_NG_DISABLE	(0)
+#define AW87XXX_PID_60_EN_NG_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_NG_DISABLE << AW87XXX_PID_60_EN_NG_START_BIT)
+
+#define AW87XXX_PID_60_EN_NG_ENABLE		(1)
+#define AW87XXX_PID_60_EN_NG_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_NG_ENABLE << AW87XXX_PID_60_EN_NG_START_BIT)
+
+#define AW87XXX_PID_60_EN_NG_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_NG_DEFAULT	\
+	(AW87XXX_PID_60_EN_NG_DEFAULT_VALUE << AW87XXX_PID_60_EN_NG_START_BIT)
+
+/* EN_AGC1_ADP bit 7 (NG 0x74) */
+#define AW87XXX_PID_60_EN_AGC1_ADP_START_BIT	(7)
+#define AW87XXX_PID_60_EN_AGC1_ADP_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_AGC1_ADP_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_AGC1_ADP_BITS_LEN)-1) << AW87XXX_PID_60_EN_AGC1_ADP_START_BIT))
+
+#define AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE	(0)
+#define AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE_VALUE	\
+	(AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE << AW87XXX_PID_60_EN_AGC1_ADP_START_BIT)
+
+#define AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY	(1)
+#define AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY_VALUE	\
+	(AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY << AW87XXX_PID_60_EN_AGC1_ADP_START_BIT)
+
+#define AW87XXX_PID_60_EN_AGC1_ADP_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_AGC1_ADP_DEFAULT	\
+	(AW87XXX_PID_60_EN_AGC1_ADP_DEFAULT_VALUE << AW87XXX_PID_60_EN_AGC1_ADP_START_BIT)
+
+/* PAVG_ADJ bit 6:4 (NG 0x74) */
+#define AW87XXX_PID_60_PAVG_ADJ_START_BIT	(4)
+#define AW87XXX_PID_60_PAVG_ADJ_BITS_LEN	(3)
+#define AW87XXX_PID_60_PAVG_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_60_PAVG_ADJ_BITS_LEN)-1) << AW87XXX_PID_60_PAVG_ADJ_START_BIT))
+
+#define AW87XXX_PID_60_PAVG_ADJ_0P94	(0)
+#define AW87XXX_PID_60_PAVG_ADJ_0P94_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_0P94 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_0P97	(1)
+#define AW87XXX_PID_60_PAVG_ADJ_0P97_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_0P97 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_1P0		(2)
+#define AW87XXX_PID_60_PAVG_ADJ_1P0_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_1P0 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_1P03	(3)
+#define AW87XXX_PID_60_PAVG_ADJ_1P03_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_1P03 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_1P06	(4)
+#define AW87XXX_PID_60_PAVG_ADJ_1P06_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_1P06 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_1P09	(5)
+#define AW87XXX_PID_60_PAVG_ADJ_1P09_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_1P09 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_PAVG_ADJ_DEFAULT	\
+	(AW87XXX_PID_60_PAVG_ADJ_DEFAULT_VALUE << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+/* NG_GAIN bit 1:0 (NG 0x74) */
+#define AW87XXX_PID_60_NG_GAIN_START_BIT	(0)
+#define AW87XXX_PID_60_NG_GAIN_BITS_LEN	(2)
+#define AW87XXX_PID_60_NG_GAIN_MASK		\
+	(~(((1<<AW87XXX_PID_60_NG_GAIN_BITS_LEN)-1) << AW87XXX_PID_60_NG_GAIN_START_BIT))
+
+#define AW87XXX_PID_60_NG_GAIN_MINUS6DB	(0)
+#define AW87XXX_PID_60_NG_GAIN_MINUS6DB_VALUE	\
+	(AW87XXX_PID_60_NG_GAIN_MINUS6DB << AW87XXX_PID_60_NG_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_NG_GAIN_MINUS7P5DB	(1)
+#define AW87XXX_PID_60_NG_GAIN_MINUS7P5DB_VALUE	\
+	(AW87XXX_PID_60_NG_GAIN_MINUS7P5DB << AW87XXX_PID_60_NG_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_NG_GAIN_MINUS9DB	(2)
+#define AW87XXX_PID_60_NG_GAIN_MINUS9DB_VALUE	\
+	(AW87XXX_PID_60_NG_GAIN_MINUS9DB << AW87XXX_PID_60_NG_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_NG_GAIN_MINUS12DB	(3)
+#define AW87XXX_PID_60_NG_GAIN_MINUS12DB_VALUE	\
+	(AW87XXX_PID_60_NG_GAIN_MINUS12DB << AW87XXX_PID_60_NG_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_NG_GAIN_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_NG_GAIN_DEFAULT	\
+	(AW87XXX_PID_60_NG_GAIN_DEFAULT_VALUE << AW87XXX_PID_60_NG_GAIN_START_BIT)
+
+/* default value of NG (0x74) */
+/* #define AW87XXX_PID_60_NG_DEFAULT		(0x27) */
+
+/* NG2 (0x75) detail */
+/* NG_CLK0_SEL bit 0 (NG2 0x75) */
+#define AW87XXX_PID_60_NG_CLK0_SEL_START_BIT	(0)
+#define AW87XXX_PID_60_NG_CLK0_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_60_NG_CLK0_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_NG_CLK0_SEL_BITS_LEN)-1) << AW87XXX_PID_60_NG_CLK0_SEL_START_BIT))
+
+#define AW87XXX_PID_60_NG_CLK0_SEL_5US	(0)
+#define AW87XXX_PID_60_NG_CLK0_SEL_5US_VALUE	\
+	(AW87XXX_PID_60_NG_CLK0_SEL_5US << AW87XXX_PID_60_NG_CLK0_SEL_START_BIT)
+
+#define AW87XXX_PID_60_NG_CLK0_SEL_10US	(1)
+#define AW87XXX_PID_60_NG_CLK0_SEL_10US_VALUE	\
+	(AW87XXX_PID_60_NG_CLK0_SEL_10US << AW87XXX_PID_60_NG_CLK0_SEL_START_BIT)
+
+#define AW87XXX_PID_60_NG_CLK0_SEL_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_NG_CLK0_SEL_DEFAULT	\
+	(AW87XXX_PID_60_NG_CLK0_SEL_DEFAULT_VALUE << AW87XXX_PID_60_NG_CLK0_SEL_START_BIT)
+
+/* NG_DEGLITCH_CTRL bit 7 (NG2 0x75) */
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_START_BIT	(7)
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_BITS_LEN	(1)
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_MASK	\
+	(~(((1<<AW87XXX_PID_60_NG_DEGLITCH_CTRL_BITS_LEN)-1) << AW87XXX_PID_60_NG_DEGLITCH_CTRL_START_BIT))
+
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_8P6N	(0)
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_8P6N_VALUE	\
+	(AW87XXX_PID_60_NG_DEGLITCH_CTRL_8P6N << AW87XXX_PID_60_NG_DEGLITCH_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_14P2N	(1)
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_14P2N_VALUE	\
+	(AW87XXX_PID_60_NG_DEGLITCH_CTRL_14P2N << AW87XXX_PID_60_NG_DEGLITCH_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_DEFAULT	\
+	(AW87XXX_PID_60_NG_DEGLITCH_CTRL_DEFAULT_VALUE << AW87XXX_PID_60_NG_DEGLITCH_CTRL_START_BIT)
+
+/* NGVTH bit 6:4 (NG2 0x75) */
+#define AW87XXX_PID_60_NGVTH_START_BIT	(4)
+#define AW87XXX_PID_60_NGVTH_BITS_LEN	(3)
+#define AW87XXX_PID_60_NGVTH_MASK		\
+	(~(((1<<AW87XXX_PID_60_NGVTH_BITS_LEN)-1) << AW87XXX_PID_60_NGVTH_START_BIT))
+
+#define AW87XXX_PID_60_NGVTH_5MV		(0)
+#define AW87XXX_PID_60_NGVTH_5MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_5MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_8MV		(1)
+#define AW87XXX_PID_60_NGVTH_8MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_8MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_10MV		(2)
+#define AW87XXX_PID_60_NGVTH_10MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_10MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_12MV		(3)
+#define AW87XXX_PID_60_NGVTH_12MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_12MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_14MV		(4)
+#define AW87XXX_PID_60_NGVTH_14MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_14MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_16MV		(5)
+#define AW87XXX_PID_60_NGVTH_16MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_16MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+/*
+#define AW87XXX_PID_60_NGVTH_16MV		(6)
+#define AW87XXX_PID_60_NGVTH_16MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_16MV << AW87XXX_PID_60_NGVTH_START_BIT)
+*/
+
+#define AW87XXX_PID_60_NGVTH_25MV		(7)
+#define AW87XXX_PID_60_NGVTH_25MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_25MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_NGVTH_DEFAULT	\
+	(AW87XXX_PID_60_NGVTH_DEFAULT_VALUE << AW87XXX_PID_60_NGVTH_START_BIT)
+
+/* NG_ACK bit 3:1 (NG2 0x75) */
+#define AW87XXX_PID_60_NG_ACK_START_BIT	(1)
+#define AW87XXX_PID_60_NG_ACK_BITS_LEN	(3)
+#define AW87XXX_PID_60_NG_ACK_MASK		\
+	(~(((1<<AW87XXX_PID_60_NG_ACK_BITS_LEN)-1) << AW87XXX_PID_60_NG_ACK_START_BIT))
+
+#define AW87XXX_PID_60_NG_ACK_10MS		(0)
+#define AW87XXX_PID_60_NG_ACK_10MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_10MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_20MS		(1)
+#define AW87XXX_PID_60_NG_ACK_20MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_20MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_40MS		(2)
+#define AW87XXX_PID_60_NG_ACK_40MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_40MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_80MS		(3)
+#define AW87XXX_PID_60_NG_ACK_80MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_80MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_160MS		(4)
+#define AW87XXX_PID_60_NG_ACK_160MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_160MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_320MS		(5)
+#define AW87XXX_PID_60_NG_ACK_320MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_320MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_640MS		(6)
+#define AW87XXX_PID_60_NG_ACK_640MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_640MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_1280MS	(7)
+#define AW87XXX_PID_60_NG_ACK_1280MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_1280MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_60_NG_ACK_DEFAULT	\
+	(AW87XXX_PID_60_NG_ACK_DEFAULT_VALUE << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+/* default value of NG2 (0x75) */
+/* #define AW87XXX_PID_60_NG2_DEFAULT		(0xA9) */
+
+/* NG3 (0x76) detail */
+/* NG_RCK bit 7:5 (NG3 0x76) */
+#define AW87XXX_PID_60_NG_RCK_START_BIT	(5)
+#define AW87XXX_PID_60_NG_RCK_BITS_LEN	(3)
+#define AW87XXX_PID_60_NG_RCK_MASK		\
+	(~(((1<<AW87XXX_PID_60_NG_RCK_BITS_LEN)-1) << AW87XXX_PID_60_NG_RCK_START_BIT))
+
+#define AW87XXX_PID_60_NG_RCK_90US		(0)
+#define AW87XXX_PID_60_NG_RCK_90US_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_90US << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_180US		(1)
+#define AW87XXX_PID_60_NG_RCK_180US_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_180US << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_360US		(2)
+#define AW87XXX_PID_60_NG_RCK_360US_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_360US << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_720US		(3)
+#define AW87XXX_PID_60_NG_RCK_720US_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_720US << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_1P44M		(4)
+#define AW87XXX_PID_60_NG_RCK_1P44M_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_1P44M << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_2P88MS	(5)
+#define AW87XXX_PID_60_NG_RCK_2P88MS_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_2P88MS << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_5P76MS	(6)
+#define AW87XXX_PID_60_NG_RCK_5P76MS_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_5P76MS << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_11P52MS	(7)
+#define AW87XXX_PID_60_NG_RCK_11P52MS_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_11P52MS << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_60_NG_RCK_DEFAULT	\
+	(AW87XXX_PID_60_NG_RCK_DEFAULT_VALUE << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+/* NG_WCK bit 4:2 (NG3 0x76) */
+#define AW87XXX_PID_60_NG_WCK_START_BIT	(2)
+#define AW87XXX_PID_60_NG_WCK_BITS_LEN	(3)
+#define AW87XXX_PID_60_NG_WCK_MASK		\
+	(~(((1<<AW87XXX_PID_60_NG_WCK_BITS_LEN)-1) << AW87XXX_PID_60_NG_WCK_START_BIT))
+
+#define AW87XXX_PID_60_NG_WCK_20MS		(0)
+#define AW87XXX_PID_60_NG_WCK_20MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_20MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_40MS		(1)
+#define AW87XXX_PID_60_NG_WCK_40MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_40MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_80MS		(2)
+#define AW87XXX_PID_60_NG_WCK_80MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_80MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_160MS		(3)
+#define AW87XXX_PID_60_NG_WCK_160MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_160MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_320MS		(4)
+#define AW87XXX_PID_60_NG_WCK_320MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_320MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_640MS		(5)
+#define AW87XXX_PID_60_NG_WCK_640MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_640MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_1280MS	(6)
+#define AW87XXX_PID_60_NG_WCK_1280MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_1280MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_2556MS	(7)
+#define AW87XXX_PID_60_NG_WCK_2556MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_2556MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_60_NG_WCK_DEFAULT	\
+	(AW87XXX_PID_60_NG_WCK_DEFAULT_VALUE << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+/* CP_VOS bit 1:0 (NG3 0x76) */
+#define AW87XXX_PID_60_CP_VOS_START_BIT	(0)
+#define AW87XXX_PID_60_CP_VOS_BITS_LEN	(2)
+#define AW87XXX_PID_60_CP_VOS_MASK		\
+	(~(((1<<AW87XXX_PID_60_CP_VOS_BITS_LEN)-1) << AW87XXX_PID_60_CP_VOS_START_BIT))
+
+#define AW87XXX_PID_60_CP_VOS_0MV		(0)
+#define AW87XXX_PID_60_CP_VOS_0MV_VALUE	\
+	(AW87XXX_PID_60_CP_VOS_0MV << AW87XXX_PID_60_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_60_CP_VOS_50MV		(1)
+#define AW87XXX_PID_60_CP_VOS_50MV_VALUE	\
+	(AW87XXX_PID_60_CP_VOS_50MV << AW87XXX_PID_60_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_60_CP_VOS_100MV		(2)
+#define AW87XXX_PID_60_CP_VOS_100MV_VALUE	\
+	(AW87XXX_PID_60_CP_VOS_100MV << AW87XXX_PID_60_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_60_CP_VOS_150MV		(3)
+#define AW87XXX_PID_60_CP_VOS_150MV_VALUE	\
+	(AW87XXX_PID_60_CP_VOS_150MV << AW87XXX_PID_60_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_60_CP_VOS_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_CP_VOS_DEFAULT	\
+	(AW87XXX_PID_60_CP_VOS_DEFAULT_VALUE << AW87XXX_PID_60_CP_VOS_START_BIT)
+
+/* default value of NG3 (0x76) */
+/* #define AW87XXX_PID_60_NG3_DEFAULT		(0x91) */
+
+/* CP (0x77) detail */
+/* CP_DDT bit 0 (CP 0x77) */
+#define AW87XXX_PID_60_CP_DDT_START_BIT	(0)
+#define AW87XXX_PID_60_CP_DDT_BITS_LEN	(1)
+#define AW87XXX_PID_60_CP_DDT_MASK		\
+	(~(((1<<AW87XXX_PID_60_CP_DDT_BITS_LEN)-1) << AW87XXX_PID_60_CP_DDT_START_BIT))
+
+#define AW87XXX_PID_60_CP_DDT_0NS		(0)
+#define AW87XXX_PID_60_CP_DDT_0NS_VALUE	\
+	(AW87XXX_PID_60_CP_DDT_0NS << AW87XXX_PID_60_CP_DDT_START_BIT)
+
+#define AW87XXX_PID_60_CP_DDT_10NS		(1)
+#define AW87XXX_PID_60_CP_DDT_10NS_VALUE	\
+	(AW87XXX_PID_60_CP_DDT_10NS << AW87XXX_PID_60_CP_DDT_START_BIT)
+
+#define AW87XXX_PID_60_CP_DDT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_CP_DDT_DEFAULT	\
+	(AW87XXX_PID_60_CP_DDT_DEFAULT_VALUE << AW87XXX_PID_60_CP_DDT_START_BIT)
+
+/* CPOK_TM bit 1 (CP 0x77) */
+#define AW87XXX_PID_60_CPOK_TM_START_BIT	(1)
+#define AW87XXX_PID_60_CPOK_TM_BITS_LEN	(1)
+#define AW87XXX_PID_60_CPOK_TM_MASK		\
+	(~(((1<<AW87XXX_PID_60_CPOK_TM_BITS_LEN)-1) << AW87XXX_PID_60_CPOK_TM_START_BIT))
+
+#define AW87XXX_PID_60_CPOK_TM_0P6MS	(0)
+#define AW87XXX_PID_60_CPOK_TM_0P6MS_VALUE	\
+	(AW87XXX_PID_60_CPOK_TM_0P6MS << AW87XXX_PID_60_CPOK_TM_START_BIT)
+
+#define AW87XXX_PID_60_CPOK_TM_1MS		(1)
+#define AW87XXX_PID_60_CPOK_TM_1MS_VALUE	\
+	(AW87XXX_PID_60_CPOK_TM_1MS << AW87XXX_PID_60_CPOK_TM_START_BIT)
+
+#define AW87XXX_PID_60_CPOK_TM_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_CPOK_TM_DEFAULT	\
+	(AW87XXX_PID_60_CPOK_TM_DEFAULT_VALUE << AW87XXX_PID_60_CPOK_TM_START_BIT)
+
+/* UVLO_DT bit 4 (CP 0x77) */
+#define AW87XXX_PID_60_UVLO_DT_START_BIT	(4)
+#define AW87XXX_PID_60_UVLO_DT_BITS_LEN	(1)
+#define AW87XXX_PID_60_UVLO_DT_MASK		\
+	(~(((1<<AW87XXX_PID_60_UVLO_DT_BITS_LEN)-1) << AW87XXX_PID_60_UVLO_DT_START_BIT))
+
+#define AW87XXX_PID_60_UVLO_DT_3US		(0)
+#define AW87XXX_PID_60_UVLO_DT_3US_VALUE	\
+	(AW87XXX_PID_60_UVLO_DT_3US << AW87XXX_PID_60_UVLO_DT_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_DT_10US		(1)
+#define AW87XXX_PID_60_UVLO_DT_10US_VALUE	\
+	(AW87XXX_PID_60_UVLO_DT_10US << AW87XXX_PID_60_UVLO_DT_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_DT_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_UVLO_DT_DEFAULT	\
+	(AW87XXX_PID_60_UVLO_DT_DEFAULT_VALUE << AW87XXX_PID_60_UVLO_DT_START_BIT)
+
+/* PD_UVLO bit 7 (CP 0x77) */
+#define AW87XXX_PID_60_PD_UVLO_START_BIT	(7)
+#define AW87XXX_PID_60_PD_UVLO_BITS_LEN	(1)
+#define AW87XXX_PID_60_PD_UVLO_MASK		\
+	(~(((1<<AW87XXX_PID_60_PD_UVLO_BITS_LEN)-1) << AW87XXX_PID_60_PD_UVLO_START_BIT))
+
+#define AW87XXX_PID_60_PD_UVLO_ENABLE	(0)
+#define AW87XXX_PID_60_PD_UVLO_ENABLE_VALUE	\
+	(AW87XXX_PID_60_PD_UVLO_ENABLE << AW87XXX_PID_60_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_60_PD_UVLO_DISABLE	(1)
+#define AW87XXX_PID_60_PD_UVLO_DISABLE_VALUE	\
+	(AW87XXX_PID_60_PD_UVLO_DISABLE << AW87XXX_PID_60_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_60_PD_UVLO_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PD_UVLO_DEFAULT	\
+	(AW87XXX_PID_60_PD_UVLO_DEFAULT_VALUE << AW87XXX_PID_60_PD_UVLO_START_BIT)
+
+/* UVLO_VTH bit 6:5 (CP 0x77) */
+#define AW87XXX_PID_60_UVLO_VTH_START_BIT	(5)
+#define AW87XXX_PID_60_UVLO_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_60_UVLO_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_UVLO_VTH_BITS_LEN)-1) << AW87XXX_PID_60_UVLO_VTH_START_BIT))
+
+#define AW87XXX_PID_60_UVLO_VTH_VH2P6V_VL2P5V	(0)
+#define AW87XXX_PID_60_UVLO_VTH_VH2P6V_VL2P5V_VALUE	\
+	(AW87XXX_PID_60_UVLO_VTH_VH2P6V_VL2P5V << AW87XXX_PID_60_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_VTH_VH2P7V_VL2P6V	(1)
+#define AW87XXX_PID_60_UVLO_VTH_VH2P7V_VL2P6V_VALUE	\
+	(AW87XXX_PID_60_UVLO_VTH_VH2P7V_VL2P6V << AW87XXX_PID_60_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_VTH_VH2P8V_VL2P7V	(2)
+#define AW87XXX_PID_60_UVLO_VTH_VH2P8V_VL2P7V_VALUE	\
+	(AW87XXX_PID_60_UVLO_VTH_VH2P8V_VL2P7V << AW87XXX_PID_60_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_VTH_VH2P9V_VL2P8V	(3)
+#define AW87XXX_PID_60_UVLO_VTH_VH2P9V_VL2P8V_VALUE	\
+	(AW87XXX_PID_60_UVLO_VTH_VH2P9V_VL2P8V << AW87XXX_PID_60_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_VTH_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_UVLO_VTH_DEFAULT	\
+	(AW87XXX_PID_60_UVLO_VTH_DEFAULT_VALUE << AW87XXX_PID_60_UVLO_VTH_START_BIT)
+
+/* CP_LDO bit 3:2 (CP 0x77) */
+#define AW87XXX_PID_60_CP_LDO_START_BIT	(2)
+#define AW87XXX_PID_60_CP_LDO_BITS_LEN	(2)
+#define AW87XXX_PID_60_CP_LDO_MASK		\
+	(~(((1<<AW87XXX_PID_60_CP_LDO_BITS_LEN)-1) << AW87XXX_PID_60_CP_LDO_START_BIT))
+
+#define AW87XXX_PID_60_CP_LDO_4P75V		(0)
+#define AW87XXX_PID_60_CP_LDO_4P75V_VALUE	\
+	(AW87XXX_PID_60_CP_LDO_4P75V << AW87XXX_PID_60_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_60_CP_LDO_5V		(1)
+#define AW87XXX_PID_60_CP_LDO_5V_VALUE	\
+	(AW87XXX_PID_60_CP_LDO_5V << AW87XXX_PID_60_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_60_CP_LDO_5P25V		(2)
+#define AW87XXX_PID_60_CP_LDO_5P25V_VALUE	\
+	(AW87XXX_PID_60_CP_LDO_5P25V << AW87XXX_PID_60_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_60_CP_LDO_5P5V		(3)
+#define AW87XXX_PID_60_CP_LDO_5P5V_VALUE	\
+	(AW87XXX_PID_60_CP_LDO_5P5V << AW87XXX_PID_60_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_60_CP_LDO_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_CP_LDO_DEFAULT	\
+	(AW87XXX_PID_60_CP_LDO_DEFAULT_VALUE << AW87XXX_PID_60_CP_LDO_START_BIT)
+
+/* default value of CP (0x77) */
+/* #define AW87XXX_PID_60_CP_DEFAULT		(0x5A) */
+
+/* TEST_GTDR (0x78) detail */
+/* TEST_OC bit 0 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_TEST_OC_START_BIT	(0)
+#define AW87XXX_PID_60_TEST_OC_BITS_LEN	(1)
+#define AW87XXX_PID_60_TEST_OC_MASK		\
+	(~(((1<<AW87XXX_PID_60_TEST_OC_BITS_LEN)-1) << AW87XXX_PID_60_TEST_OC_START_BIT))
+
+#define AW87XXX_PID_60_TEST_OC_DISABLE	(0)
+#define AW87XXX_PID_60_TEST_OC_DISABLE_VALUE	\
+	(AW87XXX_PID_60_TEST_OC_DISABLE << AW87XXX_PID_60_TEST_OC_START_BIT)
+
+#define AW87XXX_PID_60_TEST_OC_ENABLE	(1)
+#define AW87XXX_PID_60_TEST_OC_ENABLE_VALUE	\
+	(AW87XXX_PID_60_TEST_OC_ENABLE << AW87XXX_PID_60_TEST_OC_START_BIT)
+
+#define AW87XXX_PID_60_TEST_OC_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_TEST_OC_DEFAULT	\
+	(AW87XXX_PID_60_TEST_OC_DEFAULT_VALUE << AW87XXX_PID_60_TEST_OC_START_BIT)
+
+/* OC_DEBUG_EN bit 1 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_OC_DEBUG_EN_START_BIT	(1)
+#define AW87XXX_PID_60_OC_DEBUG_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_OC_DEBUG_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_OC_DEBUG_EN_BITS_LEN)-1) << AW87XXX_PID_60_OC_DEBUG_EN_START_BIT))
+
+#define AW87XXX_PID_60_OC_DEBUG_EN_DISABLE	(0)
+#define AW87XXX_PID_60_OC_DEBUG_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_EN_DISABLE << AW87XXX_PID_60_OC_DEBUG_EN_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_EN_ENABLE	(1)
+#define AW87XXX_PID_60_OC_DEBUG_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_EN_ENABLE << AW87XXX_PID_60_OC_DEBUG_EN_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_EN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_OC_DEBUG_EN_DEFAULT	\
+	(AW87XXX_PID_60_OC_DEBUG_EN_DEFAULT_VALUE << AW87XXX_PID_60_OC_DEBUG_EN_START_BIT)
+
+/* LN_RON_T_N bit 4 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_LN_RON_T_N_START_BIT	(4)
+#define AW87XXX_PID_60_LN_RON_T_N_BITS_LEN	(1)
+#define AW87XXX_PID_60_LN_RON_T_N_MASK	\
+	(~(((1<<AW87XXX_PID_60_LN_RON_T_N_BITS_LEN)-1) << AW87XXX_PID_60_LN_RON_T_N_START_BIT))
+
+#define AW87XXX_PID_60_LN_RON_T_N_DISABLE	(0)
+#define AW87XXX_PID_60_LN_RON_T_N_DISABLE_VALUE	\
+	(AW87XXX_PID_60_LN_RON_T_N_DISABLE << AW87XXX_PID_60_LN_RON_T_N_START_BIT)
+
+#define AW87XXX_PID_60_LN_RON_T_N_ENALBE	(1)
+#define AW87XXX_PID_60_LN_RON_T_N_ENALBE_VALUE	\
+	(AW87XXX_PID_60_LN_RON_T_N_ENALBE << AW87XXX_PID_60_LN_RON_T_N_START_BIT)
+
+#define AW87XXX_PID_60_LN_RON_T_N_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_LN_RON_T_N_DEFAULT	\
+	(AW87XXX_PID_60_LN_RON_T_N_DEFAULT_VALUE << AW87XXX_PID_60_LN_RON_T_N_START_BIT)
+
+/* LN_RON_T_P bit 5 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_LN_RON_T_P_START_BIT	(5)
+#define AW87XXX_PID_60_LN_RON_T_P_BITS_LEN	(1)
+#define AW87XXX_PID_60_LN_RON_T_P_MASK	\
+	(~(((1<<AW87XXX_PID_60_LN_RON_T_P_BITS_LEN)-1) << AW87XXX_PID_60_LN_RON_T_P_START_BIT))
+
+#define AW87XXX_PID_60_LN_RON_T_P_DISABLE	(0)
+#define AW87XXX_PID_60_LN_RON_T_P_DISABLE_VALUE	\
+	(AW87XXX_PID_60_LN_RON_T_P_DISABLE << AW87XXX_PID_60_LN_RON_T_P_START_BIT)
+
+#define AW87XXX_PID_60_LN_RON_T_P_ENALBE	(1)
+#define AW87XXX_PID_60_LN_RON_T_P_ENALBE_VALUE	\
+	(AW87XXX_PID_60_LN_RON_T_P_ENALBE << AW87XXX_PID_60_LN_RON_T_P_START_BIT)
+
+#define AW87XXX_PID_60_LN_RON_T_P_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_LN_RON_T_P_DEFAULT	\
+	(AW87XXX_PID_60_LN_RON_T_P_DEFAULT_VALUE << AW87XXX_PID_60_LN_RON_T_P_START_BIT)
+
+/* HN_RON_T_N bit 6 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_HN_RON_T_N_START_BIT	(6)
+#define AW87XXX_PID_60_HN_RON_T_N_BITS_LEN	(1)
+#define AW87XXX_PID_60_HN_RON_T_N_MASK	\
+	(~(((1<<AW87XXX_PID_60_HN_RON_T_N_BITS_LEN)-1) << AW87XXX_PID_60_HN_RON_T_N_START_BIT))
+
+#define AW87XXX_PID_60_HN_RON_T_N_DISABLE	(0)
+#define AW87XXX_PID_60_HN_RON_T_N_DISABLE_VALUE	\
+	(AW87XXX_PID_60_HN_RON_T_N_DISABLE << AW87XXX_PID_60_HN_RON_T_N_START_BIT)
+
+#define AW87XXX_PID_60_HN_RON_T_N_ENALBE	(1)
+#define AW87XXX_PID_60_HN_RON_T_N_ENALBE_VALUE	\
+	(AW87XXX_PID_60_HN_RON_T_N_ENALBE << AW87XXX_PID_60_HN_RON_T_N_START_BIT)
+
+#define AW87XXX_PID_60_HN_RON_T_N_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_HN_RON_T_N_DEFAULT	\
+	(AW87XXX_PID_60_HN_RON_T_N_DEFAULT_VALUE << AW87XXX_PID_60_HN_RON_T_N_START_BIT)
+
+/* HN_RON_T_P bit 7 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_HN_RON_T_P_START_BIT	(7)
+#define AW87XXX_PID_60_HN_RON_T_P_BITS_LEN	(1)
+#define AW87XXX_PID_60_HN_RON_T_P_MASK	\
+	(~(((1<<AW87XXX_PID_60_HN_RON_T_P_BITS_LEN)-1) << AW87XXX_PID_60_HN_RON_T_P_START_BIT))
+
+#define AW87XXX_PID_60_HN_RON_T_P_DISABLE	(0)
+#define AW87XXX_PID_60_HN_RON_T_P_DISABLE_VALUE	\
+	(AW87XXX_PID_60_HN_RON_T_P_DISABLE << AW87XXX_PID_60_HN_RON_T_P_START_BIT)
+
+#define AW87XXX_PID_60_HN_RON_T_P_ENALBE	(1)
+#define AW87XXX_PID_60_HN_RON_T_P_ENALBE_VALUE	\
+	(AW87XXX_PID_60_HN_RON_T_P_ENALBE << AW87XXX_PID_60_HN_RON_T_P_START_BIT)
+
+#define AW87XXX_PID_60_HN_RON_T_P_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_HN_RON_T_P_DEFAULT	\
+	(AW87XXX_PID_60_HN_RON_T_P_DEFAULT_VALUE << AW87XXX_PID_60_HN_RON_T_P_START_BIT)
+
+/* OC_DEBUG_SEL bit 3:2 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT	(2)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_BITS_LEN	(2)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_OC_DEBUG_SEL_BITS_LEN)-1) << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT))
+
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VOPP	(0)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VOPP_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_SEL_VOPP << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VOPN	(1)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VOPN_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_SEL_VOPN << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VONP	(2)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VONP_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_SEL_VONP << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VONN	(3)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VONN_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_SEL_VONN << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_DEFAULT	\
+	(AW87XXX_PID_60_OC_DEBUG_SEL_DEFAULT_VALUE << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT)
+
+/* default value of TEST_GTDR (0x78) */
+/* #define AW87XXX_PID_60_TEST_GTDR_DEFAULT		(0x00) */
+
+/* TEST_BST (0x79) detail */
+/* BST_LNMOS_TEST bit 0 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_LNMOS_TEST_START_BIT	(0)
+#define AW87XXX_PID_60_BST_LNMOS_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_LNMOS_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_LNMOS_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_LNMOS_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_LNMOS_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_LNMOS_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_LNMOS_TEST_DIABLE << AW87XXX_PID_60_BST_LNMOS_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_LNMOS_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_LNMOS_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_LNMOS_TEST_ENABLE << AW87XXX_PID_60_BST_LNMOS_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_LNMOS_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_LNMOS_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_LNMOS_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_LNMOS_TEST_START_BIT)
+
+/* BST_HNMOS_TEST bit 1 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_HNMOS_TEST_START_BIT	(1)
+#define AW87XXX_PID_60_BST_HNMOS_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_HNMOS_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_HNMOS_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_HNMOS_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_HNMOS_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_HNMOS_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_HNMOS_TEST_DIABLE << AW87XXX_PID_60_BST_HNMOS_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_HNMOS_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_HNMOS_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_HNMOS_TEST_ENABLE << AW87XXX_PID_60_BST_HNMOS_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_HNMOS_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_HNMOS_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_HNMOS_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_HNMOS_TEST_START_BIT)
+
+/* BST_SCP_TEST bit 2 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_SCP_TEST_START_BIT	(2)
+#define AW87XXX_PID_60_BST_SCP_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SCP_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SCP_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_SCP_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_SCP_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_SCP_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_TEST_DIABLE << AW87XXX_PID_60_BST_SCP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_SCP_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_TEST_ENABLE << AW87XXX_PID_60_BST_SCP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SCP_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_SCP_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_SCP_TEST_START_BIT)
+
+/* ANTIR_TEST bit 3 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_ANTIR_TEST_START_BIT	(3)
+#define AW87XXX_PID_60_ANTIR_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_ANTIR_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_ANTIR_TEST_BITS_LEN)-1) << AW87XXX_PID_60_ANTIR_TEST_START_BIT))
+
+#define AW87XXX_PID_60_ANTIR_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_ANTIR_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_ANTIR_TEST_DIABLE << AW87XXX_PID_60_ANTIR_TEST_START_BIT)
+
+#define AW87XXX_PID_60_ANTIR_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_ANTIR_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_ANTIR_TEST_ENABLE << AW87XXX_PID_60_ANTIR_TEST_START_BIT)
+
+#define AW87XXX_PID_60_ANTIR_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_ANTIR_TEST_DEFAULT	\
+	(AW87XXX_PID_60_ANTIR_TEST_DEFAULT_VALUE << AW87XXX_PID_60_ANTIR_TEST_START_BIT)
+
+/* BST_PEAK_TEST bit 4 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_PEAK_TEST_START_BIT	(4)
+#define AW87XXX_PID_60_BST_PEAK_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_PEAK_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_PEAK_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_PEAK_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_PEAK_TEST_DISABLE	(0)
+#define AW87XXX_PID_60_BST_PEAK_TEST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_PEAK_TEST_DISABLE << AW87XXX_PID_60_BST_PEAK_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_PEAK_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_PEAK_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_PEAK_TEST_ENABLE << AW87XXX_PID_60_BST_PEAK_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_PEAK_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_PEAK_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_PEAK_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_PEAK_TEST_START_BIT)
+
+/* BST_OVP_TEST bit 5 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_OVP_TEST_START_BIT	(5)
+#define AW87XXX_PID_60_BST_OVP_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_OVP_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_TEST_DIABLE << AW87XXX_PID_60_BST_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_OVP_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_TEST_ENABLE << AW87XXX_PID_60_BST_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_OVP_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP_TEST_START_BIT)
+
+/* BST_TEST_EN bit 6 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_TEST_EN_START_BIT	(6)
+#define AW87XXX_PID_60_BST_TEST_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_TEST_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_TEST_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_TEST_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_TEST_EN_DIABLE	(0)
+#define AW87XXX_PID_60_BST_TEST_EN_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_TEST_EN_DIABLE << AW87XXX_PID_60_BST_TEST_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_TEST_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_TEST_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_TEST_EN_ENABLE << AW87XXX_PID_60_BST_TEST_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_TEST_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_TEST_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_TEST_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_TEST_EN_START_BIT)
+
+/* OC_DISABLE bit 7 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_OC_DISABLE_START_BIT	(7)
+#define AW87XXX_PID_60_OC_DISABLE_BITS_LEN	(1)
+#define AW87XXX_PID_60_OC_DISABLE_MASK	\
+	(~(((1<<AW87XXX_PID_60_OC_DISABLE_BITS_LEN)-1) << AW87XXX_PID_60_OC_DISABLE_START_BIT))
+
+#define AW87XXX_PID_60_OC_DISABLE_ENABLE	(0)
+#define AW87XXX_PID_60_OC_DISABLE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OC_DISABLE_ENABLE << AW87XXX_PID_60_OC_DISABLE_START_BIT)
+
+#define AW87XXX_PID_60_OC_DISABLE_SHUTDOWN	(1)
+#define AW87XXX_PID_60_OC_DISABLE_SHUTDOWN_VALUE	\
+	(AW87XXX_PID_60_OC_DISABLE_SHUTDOWN << AW87XXX_PID_60_OC_DISABLE_START_BIT)
+
+#define AW87XXX_PID_60_OC_DISABLE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_OC_DISABLE_DEFAULT	\
+	(AW87XXX_PID_60_OC_DISABLE_DEFAULT_VALUE << AW87XXX_PID_60_OC_DISABLE_START_BIT)
+
+/* default value of TEST_BST (0x79) */
+/* #define AW87XXX_PID_60_TEST_BST_DEFAULT		(0x00) */
+
+/* TEST_MODE (0x7A) detail */
+/* PA_TEST_FORCE bit 3 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_PA_TEST_FORCE_START_BIT	(3)
+#define AW87XXX_PID_60_PA_TEST_FORCE_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_TEST_FORCE_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_TEST_FORCE_BITS_LEN)-1) << AW87XXX_PID_60_PA_TEST_FORCE_START_BIT))
+
+#define AW87XXX_PID_60_PA_TEST_FORCE_DISABLE	(0)
+#define AW87XXX_PID_60_PA_TEST_FORCE_DISABLE_VALUE	\
+	(AW87XXX_PID_60_PA_TEST_FORCE_DISABLE << AW87XXX_PID_60_PA_TEST_FORCE_START_BIT)
+
+#define AW87XXX_PID_60_PA_TEST_FORCE_ENABLE	(1)
+#define AW87XXX_PID_60_PA_TEST_FORCE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_PA_TEST_FORCE_ENABLE << AW87XXX_PID_60_PA_TEST_FORCE_START_BIT)
+
+#define AW87XXX_PID_60_PA_TEST_FORCE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PA_TEST_FORCE_DEFAULT	\
+	(AW87XXX_PID_60_PA_TEST_FORCE_DEFAULT_VALUE << AW87XXX_PID_60_PA_TEST_FORCE_START_BIT)
+
+/* BST_TEST_FORCE bit 4 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_BST_TEST_FORCE_START_BIT	(4)
+#define AW87XXX_PID_60_BST_TEST_FORCE_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_TEST_FORCE_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_TEST_FORCE_BITS_LEN)-1) << AW87XXX_PID_60_BST_TEST_FORCE_START_BIT))
+
+#define AW87XXX_PID_60_BST_TEST_FORCE_DISABLE	(0)
+#define AW87XXX_PID_60_BST_TEST_FORCE_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_TEST_FORCE_DISABLE << AW87XXX_PID_60_BST_TEST_FORCE_START_BIT)
+
+#define AW87XXX_PID_60_BST_TEST_FORCE_ENABLE	(1)
+#define AW87XXX_PID_60_BST_TEST_FORCE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_TEST_FORCE_ENABLE << AW87XXX_PID_60_BST_TEST_FORCE_START_BIT)
+
+#define AW87XXX_PID_60_BST_TEST_FORCE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_BST_TEST_FORCE_DEFAULT	\
+	(AW87XXX_PID_60_BST_TEST_FORCE_DEFAULT_VALUE << AW87XXX_PID_60_BST_TEST_FORCE_START_BIT)
+
+/* EN_OT_TEST bit 5 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_EN_OT_TEST_START_BIT	(5)
+#define AW87XXX_PID_60_EN_OT_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_OT_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_OT_TEST_BITS_LEN)-1) << AW87XXX_PID_60_EN_OT_TEST_START_BIT))
+
+#define AW87XXX_PID_60_EN_OT_TEST_DISABLE	(0)
+#define AW87XXX_PID_60_EN_OT_TEST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_OT_TEST_DISABLE << AW87XXX_PID_60_EN_OT_TEST_START_BIT)
+
+#define AW87XXX_PID_60_EN_OT_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_EN_OT_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_OT_TEST_ENABLE << AW87XXX_PID_60_EN_OT_TEST_START_BIT)
+
+#define AW87XXX_PID_60_EN_OT_TEST_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_OT_TEST_DEFAULT	\
+	(AW87XXX_PID_60_EN_OT_TEST_DEFAULT_VALUE << AW87XXX_PID_60_EN_OT_TEST_START_BIT)
+
+/* EN_TEST bit 6 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_EN_TEST_START_BIT	(6)
+#define AW87XXX_PID_60_EN_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_TEST_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_TEST_BITS_LEN)-1) << AW87XXX_PID_60_EN_TEST_START_BIT))
+
+#define AW87XXX_PID_60_EN_TEST_DISABLE	(0)
+#define AW87XXX_PID_60_EN_TEST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_TEST_DISABLE << AW87XXX_PID_60_EN_TEST_START_BIT)
+
+#define AW87XXX_PID_60_EN_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_EN_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_TEST_ENABLE << AW87XXX_PID_60_EN_TEST_START_BIT)
+
+#define AW87XXX_PID_60_EN_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_EN_TEST_DEFAULT	\
+	(AW87XXX_PID_60_EN_TEST_DEFAULT_VALUE << AW87XXX_PID_60_EN_TEST_START_BIT)
+
+/* BST_BURST_TEST bit 7 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_BST_BURST_TEST_START_BIT	(7)
+#define AW87XXX_PID_60_BST_BURST_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_BURST_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_BURST_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_TEST_DIABLE << AW87XXX_PID_60_BST_BURST_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_BURST_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_TEST_ENABLE << AW87XXX_PID_60_BST_BURST_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_BURST_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_TEST_START_BIT)
+
+/* TEST_ANALOG_CTRL bit 2:0 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT	(0)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_BITS_LEN	(3)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_MASK	\
+	(~(((1<<AW87XXX_PID_60_TEST_ANALOG_CTRL_BITS_LEN)-1) << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT))
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VBG	(0)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VBG_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_VBG << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_COMPT	(1)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_COMPT_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_COMPT << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_HALFVDD	(2)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_HALFVDD_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_HALFVDD << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VCSEL	(3)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VCSEL_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_VCSEL << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VLSEL	(4)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VLSEL_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_VLSEL << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH1T	(5)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH1T_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH1T << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH4T	(6)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH4T_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH4T << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VCM2T	(7)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VCM2T_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_VCM2T << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_DEFAULT	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_DEFAULT_VALUE << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+/* default value of TEST_MODE (0x7A) */
+/* #define AW87XXX_PID_60_TEST_MODE_DEFAULT		(0x00) */
+
+/* TEST_CON (0x7B) detail */
+/* COMP_TEST bit 5 (TEST_CON 0x7B) */
+#define AW87XXX_PID_60_COMP_TEST_START_BIT	(5)
+#define AW87XXX_PID_60_COMP_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_COMP_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_COMP_TEST_BITS_LEN)-1) << AW87XXX_PID_60_COMP_TEST_START_BIT))
+
+#define AW87XXX_PID_60_COMP_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_COMP_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_COMP_TEST_DIABLE << AW87XXX_PID_60_COMP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_COMP_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_COMP_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_COMP_TEST_ENABLE << AW87XXX_PID_60_COMP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_COMP_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_COMP_TEST_DEFAULT	\
+	(AW87XXX_PID_60_COMP_TEST_DEFAULT_VALUE << AW87XXX_PID_60_COMP_TEST_START_BIT)
+
+/* REG_EN_ESD bit 6 (TEST_CON 0x7B) */
+#define AW87XXX_PID_60_REG_EN_ESD_START_BIT	(6)
+#define AW87XXX_PID_60_REG_EN_ESD_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_EN_ESD_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_EN_ESD_BITS_LEN)-1) << AW87XXX_PID_60_REG_EN_ESD_START_BIT))
+
+#define AW87XXX_PID_60_REG_EN_ESD_DISABLE	(0)
+#define AW87XXX_PID_60_REG_EN_ESD_DISABLE_VALUE	\
+	(AW87XXX_PID_60_REG_EN_ESD_DISABLE << AW87XXX_PID_60_REG_EN_ESD_START_BIT)
+
+#define AW87XXX_PID_60_REG_EN_ESD_ENABLE	(1)
+#define AW87XXX_PID_60_REG_EN_ESD_ENABLE_VALUE	\
+	(AW87XXX_PID_60_REG_EN_ESD_ENABLE << AW87XXX_PID_60_REG_EN_ESD_START_BIT)
+
+#define AW87XXX_PID_60_REG_EN_ESD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_REG_EN_ESD_DEFAULT	\
+	(AW87XXX_PID_60_REG_EN_ESD_DEFAULT_VALUE << AW87XXX_PID_60_REG_EN_ESD_START_BIT)
+
+/* EN_POWER_MT bit 7 (TEST_CON 0x7B) */
+#define AW87XXX_PID_60_EN_POWER_MT_START_BIT	(7)
+#define AW87XXX_PID_60_EN_POWER_MT_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_POWER_MT_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_POWER_MT_BITS_LEN)-1) << AW87XXX_PID_60_EN_POWER_MT_START_BIT))
+
+#define AW87XXX_PID_60_EN_POWER_MT_DISABLE	(0)
+#define AW87XXX_PID_60_EN_POWER_MT_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_POWER_MT_DISABLE << AW87XXX_PID_60_EN_POWER_MT_START_BIT)
+
+#define AW87XXX_PID_60_EN_POWER_MT_ENABLE	(1)
+#define AW87XXX_PID_60_EN_POWER_MT_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_POWER_MT_ENABLE << AW87XXX_PID_60_EN_POWER_MT_START_BIT)
+
+#define AW87XXX_PID_60_EN_POWER_MT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_POWER_MT_DEFAULT	\
+	(AW87XXX_PID_60_EN_POWER_MT_DEFAULT_VALUE << AW87XXX_PID_60_EN_POWER_MT_START_BIT)
+
+/* TEST_DIGITAL_CTRL bit 4:0 (TEST_CON 0x7B) */
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT	(0)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BITS_LEN	(5)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_MASK	\
+	(~(((1<<AW87XXX_PID_60_TEST_DIGITAL_CTRL_BITS_LEN)-1) << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT))
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVPS	(0)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVPS_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVPS << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVP2	(1)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVP2_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVP2 << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTHNMOS	(2)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTHNMOS_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTHNMOS << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTLNMOS	(3)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTLNMOS_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTLNMOS << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTPEAK	(4)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTPEAK_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTPEAK << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTRSQ	(5)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTRSQ_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTRSQ << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTBURST	(6)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTBURST_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTBURST << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSSFINISH	(7)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSSFINISH_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSSFINISH << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSCP	(8)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSCP_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSCP << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTENCLAMP	(9)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTENCLAMP_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTENCLAMP << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTNCD	(10)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTNCD_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTNCD << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENSYNC	(11)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENSYNC_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENSYNC << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENOTA	(12)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENOTA_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENOTA << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_NGDET	(13)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_NGDET_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_NGDET << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTN	(14)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTN_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTN << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTN	(15)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTN_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTN << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEN	(16)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEN_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEN << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTP	(17)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTP_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTP << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTP	(18)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTP_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTP << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEP	(19)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEP_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEP << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ADPBOOST	(20)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ADPBOOST_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_ADPBOOST << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW0ABOVE	(21)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW0ABOVE_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW0ABOVE << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW3ABOVE	(22)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW3ABOVE_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW3ABOVE << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_AMPOC	(23)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_AMPOC_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_AMPOC << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_DEFAULT	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_DEFAULT_VALUE << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+/* default value of TEST_CON (0x7B) */
+/* #define AW87XXX_PID_60_TEST_CON_DEFAULT		(0x00) */
+
+/* ENCR (0x7C) detail */
+/* TEST_REG_ENCRY bit 7:6 (ENCR 0x7C) */
+#define AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT	(6)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_BITS_LEN	(2)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_MASK	\
+	(~(((1<<AW87XXX_PID_60_TEST_REG_ENCRY_BITS_LEN)-1) << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT))
+
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE0	(0)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE0_VALUE	\
+	(AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE0 << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE1	(1)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE1_VALUE	\
+	(AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE1 << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE2	(2)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE2_VALUE	\
+	(AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE2 << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CAN_BE_WRITE	(3)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CAN_BE_WRITE_VALUE	\
+	(AW87XXX_PID_60_TEST_REG_ENCRY_CAN_BE_WRITE << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT)
+/*
+Fix me here:
+reg_addr:0x7C, reg_name:ENCR, field_name:TEST_REG_ENCRY, content:Encryption bits for test registers(78h~7Ch) , when0x7D=7a & test_Reg_Encry=11
+maybe need to fix manually
+*/
+#define AW87XXX_PID_60_TEST_REG_ENCRY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_DEFAULT	\
+	(AW87XXX_PID_60_TEST_REG_ENCRY_DEFAULT_VALUE << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT)
+
+/* PRODUCT_REG_ENCRY bit 5:0 (ENCR 0x7C) */
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT	(0)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_BITS_LEN	(6)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_MASK	\
+	(~(((1<<AW87XXX_PID_60_PRODUCT_REG_ENCRY_BITS_LEN)-1) << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT))
+
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87560	(1)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87560_VALUE	\
+	(AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87560 << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87561	(2)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87561_VALUE	\
+	(AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87561 << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87562	(4)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87562_VALUE	\
+	(AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87562 << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87501	(8)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87501_VALUE	\
+	(AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87501 << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT)
+/*
+Fix me here:
+reg_addr:0x7C, reg_name:ENCR, field_name:PRODUCT_REG_ENCRY, content:Production encryption  register (when0x7D=7a & test_Reg_Encry=11 
+maybe need to fix manually
+*/
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_DEFAULT	\
+	(AW87XXX_PID_60_PRODUCT_REG_ENCRY_DEFAULT_VALUE << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT)
+
+/* default value of ENCR (0x7C) */
+/* #define AW87XXX_PID_60_ENCR_DEFAULT		(0x01) */
+
+/* detail information of registers end */
+
+#endif  /* #ifndef  __AW87XXX_PID_60_REG_H__ */
\ No newline at end of file
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_76_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_76_reg.h
new file mode 100644
index 000000000..13280cdb5
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_76_reg.h
@@ -0,0 +1,1205 @@
+#ifndef __AW87XXX_PID_76_REG_H__
+#define __AW87XXX_PID_76_REG_H__
+
+/* registers list */
+#define AW87XXX_PID_76_ID_REG			(0x00)
+#define AW87XXX_PID_76_SYSCTRL_REG		(0x01)
+#define AW87XXX_PID_76_MDCTRL_REG		(0x02)
+#define AW87XXX_PID_76_CPOVP_REG		(0x03)
+#define AW87XXX_PID_76_CPP_REG			(0x04)
+#define AW87XXX_PID_76_PAG_REG			(0x05)
+#define AW87XXX_PID_76_AGC3P_REG		(0x06)
+#define AW87XXX_PID_76_AGC3PA_REG		(0x07)
+#define AW87XXX_PID_76_AGC2P_REG		(0x08)
+#define AW87XXX_PID_76_AGC2PA_REG		(0x09)
+#define AW87XXX_PID_76_AGC1PA_REG		(0x0A)
+#define AW87XXX_PID_76_SYSST_REG		(0x59)
+#define AW87XXX_PID_76_SYSINT_REG		(0x60)
+#define AW87XXX_PID_76_DFT_SYSCTRL_REG		(0x61)
+#define AW87XXX_PID_76_DFT_MDCTRL_REG		(0x62)
+#define AW87XXX_PID_76_DFT_CPADP_REG		(0x63)
+#define AW87XXX_PID_76_DFT_AGCPA_REG		(0x64)
+#define AW87XXX_PID_76_DFT_POFR_REG		(0x65)
+#define AW87XXX_PID_76_DFT_OC_REG		(0x66)
+#define AW87XXX_PID_76_DFT_ADP1_REG		(0x67)
+#define AW87XXX_PID_76_DFT_REF_REG		(0x68)
+#define AW87XXX_PID_76_DFT_LDO_REG		(0x69)
+#define AW87XXX_PID_76_ADP1_REG			(0x70)
+#define AW87XXX_PID_76_ADP2_REG			(0x71)
+#define AW87XXX_PID_76_NG1_REG			(0x72)
+#define AW87XXX_PID_76_NG2_REG			(0x73)
+#define AW87XXX_PID_76_NG3_REG			(0x74)
+#define AW87XXX_PID_76_CP_REG			(0x75)
+#define AW87XXX_PID_76_AB_REG			(0x76)
+#define AW87XXX_PID_76_TEST_REG			(0x77)
+#define AW87XXX_PID_76_ENCR_REG			(0x78)
+#define AW87XXX_PID_76_DFT_ADP1_CHECK		(0x04)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_76_softrst_access[2] = {0x00, 0xaa};
+
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_76_REG_MAX				(0x79)
+
+#define REG_NONE_ACCESS					(0)
+#define REG_RD_ACCESS					(1 << 0)
+#define REG_WR_ACCESS					(1 << 1)
+
+const unsigned char aw87xxx_pid_76_reg_access[AW87XXX_PID_76_REG_MAX] = {
+	[AW87XXX_PID_76_ID_REG]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_76_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_MDCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_CPOVP_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_CPP_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_PAG_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AGC3P_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AGC3PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AGC2P_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AGC2PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AGC1PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_SYSST_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_76_SYSINT_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_76_DFT_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_MDCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_CPADP_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_AGCPA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_POFR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_OC_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_ADP1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_REF_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_LDO_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_ADP1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_ADP2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_NG1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_NG2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_NG3_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_CP_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AB_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_TEST_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_ENCR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+/* detail information of registers begin */
+/* ID (0x00) detail */
+/* IDCODE bit 7:0 (ID 0x00) */
+#define AW87XXX_PID_76_IDCODE_START_BIT	(0)
+#define AW87XXX_PID_76_IDCODE_BITS_LEN	(8)
+#define AW87XXX_PID_76_IDCODE_MASK		\
+	(~(((1<<AW87XXX_PID_76_IDCODE_BITS_LEN)-1) << AW87XXX_PID_76_IDCODE_START_BIT))
+
+#define AW87XXX_PID_76_IDCODE_DEFAULT_VALUE	(0x76)
+#define AW87XXX_PID_76_IDCODE_DEFAULT	\
+	(AW87XXX_PID_76_IDCODE_DEFAULT_VALUE << AW87XXX_PID_76_IDCODE_START_BIT)
+
+/* default value of ID (0x00) */
+/* #define AW87XXX_PID_76_ID_DEFAULT		(0x76) */
+
+/* SYSCTRL (0x01) detail */
+/* EN_PA bit 2 (SYSCTRL 0x01) */
+#define AW87XXX_PID_76_EN_PA_START_BIT	(2)
+#define AW87XXX_PID_76_EN_PA_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_PA_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_PA_BITS_LEN)-1) << AW87XXX_PID_76_EN_PA_START_BIT))
+
+#define AW87XXX_PID_76_EN_PA_DISABLE	(0)
+#define AW87XXX_PID_76_EN_PA_DISABLE_VALUE	\
+	(AW87XXX_PID_76_EN_PA_DISABLE << AW87XXX_PID_76_EN_PA_START_BIT)
+
+#define AW87XXX_PID_76_EN_PA_ENABLE_DEPENDS_ON_EN_AB	(1)
+#define AW87XXX_PID_76_EN_PA_ENABLE_DEPENDS_ON_EN_AB_VALUE	\
+	(AW87XXX_PID_76_EN_PA_ENABLE_DEPENDS_ON_EN_AB << AW87XXX_PID_76_EN_PA_START_BIT)
+
+#define AW87XXX_PID_76_EN_PA_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_EN_PA_DEFAULT	\
+	(AW87XXX_PID_76_EN_PA_DEFAULT_VALUE << AW87XXX_PID_76_EN_PA_START_BIT)
+
+/* EN_CP bit 1 (SYSCTRL 0x01) */
+#define AW87XXX_PID_76_EN_CP_START_BIT	(1)
+#define AW87XXX_PID_76_EN_CP_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_CP_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_CP_BITS_LEN)-1) << AW87XXX_PID_76_EN_CP_START_BIT))
+
+#define AW87XXX_PID_76_EN_CP_DISABLE_PVDD0	(0)
+#define AW87XXX_PID_76_EN_CP_DISABLE_PVDD0_VALUE	\
+	(AW87XXX_PID_76_EN_CP_DISABLE_PVDD0 << AW87XXX_PID_76_EN_CP_START_BIT)
+
+#define AW87XXX_PID_76_EN_CP_ENABLE_DEPENDS_ON_EN_2X	(1)
+#define AW87XXX_PID_76_EN_CP_ENABLE_DEPENDS_ON_EN_2X_VALUE	\
+	(AW87XXX_PID_76_EN_CP_ENABLE_DEPENDS_ON_EN_2X << AW87XXX_PID_76_EN_CP_START_BIT)
+
+#define AW87XXX_PID_76_EN_CP_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_EN_CP_DEFAULT	\
+	(AW87XXX_PID_76_EN_CP_DEFAULT_VALUE << AW87XXX_PID_76_EN_CP_START_BIT)
+
+/* PU_CPPA bit 0 (SYSCTRL 0x01) */
+#define AW87XXX_PID_76_PU_CPPA_START_BIT	(0)
+#define AW87XXX_PID_76_PU_CPPA_BITS_LEN	(1)
+#define AW87XXX_PID_76_PU_CPPA_MASK		\
+	(~(((1<<AW87XXX_PID_76_PU_CPPA_BITS_LEN)-1) << AW87XXX_PID_76_PU_CPPA_START_BIT))
+
+#define AW87XXX_PID_76_PU_CPPA_POWERMINUS_DOWN	(0)
+#define AW87XXX_PID_76_PU_CPPA_POWERMINUS_DOWN_VALUE	\
+	(AW87XXX_PID_76_PU_CPPA_POWERMINUS_DOWN << AW87XXX_PID_76_PU_CPPA_START_BIT)
+
+#define AW87XXX_PID_76_PU_CPPA_POWERMINUS_UP	(1)
+#define AW87XXX_PID_76_PU_CPPA_POWERMINUS_UP_VALUE	\
+	(AW87XXX_PID_76_PU_CPPA_POWERMINUS_UP << AW87XXX_PID_76_PU_CPPA_START_BIT)
+
+#define AW87XXX_PID_76_PU_CPPA_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_PU_CPPA_DEFAULT	\
+	(AW87XXX_PID_76_PU_CPPA_DEFAULT_VALUE << AW87XXX_PID_76_PU_CPPA_START_BIT)
+
+/* default value of SYSCTRL (0x01) */
+/* #define AW87XXX_PID_76_SYSCTRL_DEFAULT		(0x06) */
+
+/* MDCTRL (0x02) detail */
+/* EN_ADAP bit 4 (MDCTRL 0x02) */
+#define AW87XXX_PID_76_EN_ADAP_START_BIT	(4)
+#define AW87XXX_PID_76_EN_ADAP_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_ADAP_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_ADAP_BITS_LEN)-1) << AW87XXX_PID_76_EN_ADAP_START_BIT))
+
+#define AW87XXX_PID_76_EN_ADAP_DISABLEDEFAULT	(0)
+#define AW87XXX_PID_76_EN_ADAP_DISABLEDEFAULT_VALUE	\
+	(AW87XXX_PID_76_EN_ADAP_DISABLEDEFAULT << AW87XXX_PID_76_EN_ADAP_START_BIT)
+
+#define AW87XXX_PID_76_EN_ADAP_ENABLE	(1)
+#define AW87XXX_PID_76_EN_ADAP_ENABLE_VALUE	\
+	(AW87XXX_PID_76_EN_ADAP_ENABLE << AW87XXX_PID_76_EN_ADAP_START_BIT)
+
+#define AW87XXX_PID_76_EN_ADAP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_EN_ADAP_DEFAULT	\
+	(AW87XXX_PID_76_EN_ADAP_DEFAULT_VALUE << AW87XXX_PID_76_EN_ADAP_START_BIT)
+
+/* EN_2X bit 3 (MDCTRL 0x02) */
+#define AW87XXX_PID_76_EN_2X_START_BIT	(3)
+#define AW87XXX_PID_76_EN_2X_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_2X_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_2X_BITS_LEN)-1) << AW87XXX_PID_76_EN_2X_START_BIT))
+
+#define AW87XXX_PID_76_EN_2X_DISABLE	(0)
+#define AW87XXX_PID_76_EN_2X_DISABLE_VALUE	\
+	(AW87XXX_PID_76_EN_2X_DISABLE << AW87XXX_PID_76_EN_2X_START_BIT)
+
+#define AW87XXX_PID_76_EN_2X_ENABLE		(1)
+#define AW87XXX_PID_76_EN_2X_ENABLE_VALUE	\
+	(AW87XXX_PID_76_EN_2X_ENABLE << AW87XXX_PID_76_EN_2X_START_BIT)
+
+#define AW87XXX_PID_76_EN_2X_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_EN_2X_DEFAULT	\
+	(AW87XXX_PID_76_EN_2X_DEFAULT_VALUE << AW87XXX_PID_76_EN_2X_START_BIT)
+
+/* EN_SPK bit 2 (MDCTRL 0x02) */
+#define AW87XXX_PID_76_EN_SPK_START_BIT	(2)
+#define AW87XXX_PID_76_EN_SPK_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_SPK_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_SPK_BITS_LEN)-1) << AW87XXX_PID_76_EN_SPK_START_BIT))
+
+#define AW87XXX_PID_76_EN_SPK_DISABLE	(0)
+#define AW87XXX_PID_76_EN_SPK_DISABLE_VALUE	\
+	(AW87XXX_PID_76_EN_SPK_DISABLE << AW87XXX_PID_76_EN_SPK_START_BIT)
+
+#define AW87XXX_PID_76_EN_SPK_ENABLE	(1)
+#define AW87XXX_PID_76_EN_SPK_ENABLE_VALUE	\
+	(AW87XXX_PID_76_EN_SPK_ENABLE << AW87XXX_PID_76_EN_SPK_START_BIT)
+
+#define AW87XXX_PID_76_EN_SPK_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_EN_SPK_DEFAULT	\
+	(AW87XXX_PID_76_EN_SPK_DEFAULT_VALUE << AW87XXX_PID_76_EN_SPK_START_BIT)
+
+/* EN_LG bit 1 (MDCTRL 0x02) */
+#define AW87XXX_PID_76_EN_LG_START_BIT	(1)
+#define AW87XXX_PID_76_EN_LG_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_LG_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_LG_BITS_LEN)-1) << AW87XXX_PID_76_EN_LG_START_BIT))
+
+#define AW87XXX_PID_76_EN_LG_DISABLE	(0)
+#define AW87XXX_PID_76_EN_LG_DISABLE_VALUE	\
+	(AW87XXX_PID_76_EN_LG_DISABLE << AW87XXX_PID_76_EN_LG_START_BIT)
+
+#define AW87XXX_PID_76_EN_LG_ENABLE		(1)
+#define AW87XXX_PID_76_EN_LG_ENABLE_VALUE	\
+	(AW87XXX_PID_76_EN_LG_ENABLE << AW87XXX_PID_76_EN_LG_START_BIT)
+
+#define AW87XXX_PID_76_EN_LG_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_EN_LG_DEFAULT	\
+	(AW87XXX_PID_76_EN_LG_DEFAULT_VALUE << AW87XXX_PID_76_EN_LG_START_BIT)
+
+/* EN_AB bit 0 (MDCTRL 0x02) */
+#define AW87XXX_PID_76_EN_AB_START_BIT	(0)
+#define AW87XXX_PID_76_EN_AB_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_AB_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_AB_BITS_LEN)-1) << AW87XXX_PID_76_EN_AB_START_BIT))
+
+#define AW87XXX_PID_76_EN_AB_DISABLE	(0)
+#define AW87XXX_PID_76_EN_AB_DISABLE_VALUE	\
+	(AW87XXX_PID_76_EN_AB_DISABLE << AW87XXX_PID_76_EN_AB_START_BIT)
+
+#define AW87XXX_PID_76_EN_AB_ENABLE		(1)
+#define AW87XXX_PID_76_EN_AB_ENABLE_VALUE	\
+	(AW87XXX_PID_76_EN_AB_ENABLE << AW87XXX_PID_76_EN_AB_START_BIT)
+
+#define AW87XXX_PID_76_EN_AB_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_EN_AB_DEFAULT	\
+	(AW87XXX_PID_76_EN_AB_DEFAULT_VALUE << AW87XXX_PID_76_EN_AB_START_BIT)
+
+/* default value of MDCTRL (0x02) */
+/* #define AW87XXX_PID_76_MDCTRL_DEFAULT		(0x0C) */
+
+/* CPOVP (0x03) detail */
+/* CP_OVP1 bit 3:0 (CPOVP 0x03) */
+#define AW87XXX_PID_76_CP_OVP1_START_BIT	(0)
+#define AW87XXX_PID_76_CP_OVP1_BITS_LEN	(4)
+#define AW87XXX_PID_76_CP_OVP1_MASK		\
+	(~(((1<<AW87XXX_PID_76_CP_OVP1_BITS_LEN)-1) << AW87XXX_PID_76_CP_OVP1_START_BIT))
+
+#define AW87XXX_PID_76_CP_OVP1_6P0V		(0)
+#define AW87XXX_PID_76_CP_OVP1_6P0V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_6P0V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_6P25V	(1)
+#define AW87XXX_PID_76_CP_OVP1_6P25V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_6P25V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_6P5V		(2)
+#define AW87XXX_PID_76_CP_OVP1_6P5V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_6P5V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_6P75V	(3)
+#define AW87XXX_PID_76_CP_OVP1_6P75V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_6P75V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_7V		(4)
+#define AW87XXX_PID_76_CP_OVP1_7V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_7V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_7P25V	(5)
+#define AW87XXX_PID_76_CP_OVP1_7P25V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_7P25V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_7P5V		(6)
+#define AW87XXX_PID_76_CP_OVP1_7P5V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_7P5V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_7P75V	(7)
+#define AW87XXX_PID_76_CP_OVP1_7P75V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_7P75V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_8V		(8)
+#define AW87XXX_PID_76_CP_OVP1_8V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_8V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_8P25V	(9)
+#define AW87XXX_PID_76_CP_OVP1_8P25V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_8P25V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_8P5V		(10)
+#define AW87XXX_PID_76_CP_OVP1_8P5V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_8P5V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_8P75V	(11)
+#define AW87XXX_PID_76_CP_OVP1_8P75V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_8P75V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_9V		(12)
+#define AW87XXX_PID_76_CP_OVP1_9V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_9V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_9P25V	(13)
+#define AW87XXX_PID_76_CP_OVP1_9P25V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_9P25V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_9P5V		(14)
+#define AW87XXX_PID_76_CP_OVP1_9P5V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_9P5V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_RESERVEDP_IF_SET_TURNS_TO_DEFAULTP	(15)
+#define AW87XXX_PID_76_CP_OVP1_RESERVEDP_IF_SET_TURNS_TO_DEFAULTP_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_RESERVEDP_IF_SET_TURNS_TO_DEFAULTP << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_DEFAULT_VALUE	(8)
+#define AW87XXX_PID_76_CP_OVP1_DEFAULT	\
+	(AW87XXX_PID_76_CP_OVP1_DEFAULT_VALUE << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+/* default value of CPOVP (0x03) */
+/* #define AW87XXX_PID_76_CPOVP_DEFAULT		(0x08) */
+
+/* CPP (0x04) detail */
+/* CP_PEAK_CUR bit 4:2 (CPP 0x04) */
+#define AW87XXX_PID_76_CP_PEAK_CUR_START_BIT	(2)
+#define AW87XXX_PID_76_CP_PEAK_CUR_BITS_LEN	(3)
+#define AW87XXX_PID_76_CP_PEAK_CUR_MASK	\
+	(~(((1<<AW87XXX_PID_76_CP_PEAK_CUR_BITS_LEN)-1) << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT))
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_2A	(0)
+#define AW87XXX_PID_76_CP_PEAK_CUR_2A_VALUE	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_2A << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_2P5A	(1)
+#define AW87XXX_PID_76_CP_PEAK_CUR_2P5A_VALUE	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_2P5A << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_3A	(2)
+#define AW87XXX_PID_76_CP_PEAK_CUR_3A_VALUE	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_3A << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_3P5A	(3)
+#define AW87XXX_PID_76_CP_PEAK_CUR_3P5A_VALUE	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_3P5A << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_4A	(4)
+#define AW87XXX_PID_76_CP_PEAK_CUR_4A_VALUE	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_4A << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_CP_PEAK_CUR_DEFAULT	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_DEFAULT_VALUE << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+/* CP_SOFT_CUR bit 1:0 (CPP 0x04) */
+#define AW87XXX_PID_76_CP_SOFT_CUR_START_BIT	(0)
+#define AW87XXX_PID_76_CP_SOFT_CUR_BITS_LEN	(2)
+#define AW87XXX_PID_76_CP_SOFT_CUR_MASK	\
+	(~(((1<<AW87XXX_PID_76_CP_SOFT_CUR_BITS_LEN)-1) << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT))
+
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P2A	(0)
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P2A_VALUE	\
+	(AW87XXX_PID_76_CP_SOFT_CUR_0P2A << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P3A	(1)
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P3A_VALUE	\
+	(AW87XXX_PID_76_CP_SOFT_CUR_0P3A << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P4A	(2)
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P4A_VALUE	\
+	(AW87XXX_PID_76_CP_SOFT_CUR_0P4A << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P5A	(3)
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P5A_VALUE	\
+	(AW87XXX_PID_76_CP_SOFT_CUR_0P5A << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_SOFT_CUR_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_CP_SOFT_CUR_DEFAULT	\
+	(AW87XXX_PID_76_CP_SOFT_CUR_DEFAULT_VALUE << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT)
+
+/* default value of CPP (0x04) */
+/* #define AW87XXX_PID_76_CPP_DEFAULT		(0x05) */
+
+/* PAG (0x05) detail */
+/* GAIN bit 4:0 (PAG 0x05) */
+#define AW87XXX_PID_76_GAIN_START_BIT	(0)
+#define AW87XXX_PID_76_GAIN_BITS_LEN	(5)
+#define AW87XXX_PID_76_GAIN_MASK		\
+	(~(((1<<AW87XXX_PID_76_GAIN_BITS_LEN)-1) << AW87XXX_PID_76_GAIN_START_BIT))
+
+#define AW87XXX_PID_76_GAIN_0DB			(0)
+#define AW87XXX_PID_76_GAIN_0DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_0DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_1P5DB		(1)
+#define AW87XXX_PID_76_GAIN_1P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_1P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_3DB			(2)
+#define AW87XXX_PID_76_GAIN_3DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_3DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_4P5DB		(3)
+#define AW87XXX_PID_76_GAIN_4P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_4P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_6DB			(4)
+#define AW87XXX_PID_76_GAIN_6DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_6DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_7P5DB		(5)
+#define AW87XXX_PID_76_GAIN_7P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_7P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_9DB			(6)
+#define AW87XXX_PID_76_GAIN_9DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_9DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_10P5DB		(7)
+#define AW87XXX_PID_76_GAIN_10P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_10P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_12DB		(8)
+#define AW87XXX_PID_76_GAIN_12DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_12DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_13P5DB		(9)
+#define AW87XXX_PID_76_GAIN_13P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_13P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_15DB		(10)
+#define AW87XXX_PID_76_GAIN_15DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_15DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_16P5DB		(11)
+#define AW87XXX_PID_76_GAIN_16P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_16P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_18DB		(12)
+#define AW87XXX_PID_76_GAIN_18DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_18DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_19P5DB		(13)
+#define AW87XXX_PID_76_GAIN_19P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_19P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_21DB		(14)
+#define AW87XXX_PID_76_GAIN_21DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_21DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_22P5DB		(15)
+#define AW87XXX_PID_76_GAIN_22P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_22P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_24DB		(16)
+#define AW87XXX_PID_76_GAIN_24DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_24DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_25P5DB		(17)
+#define AW87XXX_PID_76_GAIN_25P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_25P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_27DB		(18)
+#define AW87XXX_PID_76_GAIN_27DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_27DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_DEFAULT_VALUE	(12)
+#define AW87XXX_PID_76_GAIN_DEFAULT		\
+	(AW87XXX_PID_76_GAIN_DEFAULT_VALUE << AW87XXX_PID_76_GAIN_START_BIT)
+
+/* default value of PAG (0x05) */
+/* #define AW87XXX_PID_76_PAG_DEFAULT		(0x0C) */
+
+/* AGC3P (0x06) detail */
+/* AGC3PO bit 3:0 (AGC3P 0x06) */
+#define AW87XXX_PID_76_AGC3PO_START_BIT	(0)
+#define AW87XXX_PID_76_AGC3PO_BITS_LEN	(4)
+#define AW87XXX_PID_76_AGC3PO_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC3PO_BITS_LEN)-1) << AW87XXX_PID_76_AGC3PO_START_BIT))
+
+#define AW87XXX_PID_76_AGC3PO_0P2W4		(0)
+#define AW87XXX_PID_76_AGC3PO_0P2W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_0P2W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_0P4W4		(1)
+#define AW87XXX_PID_76_AGC3PO_0P4W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_0P4W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_0P6W4		(2)
+#define AW87XXX_PID_76_AGC3PO_0P6W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_0P6W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_0P8W4		(3)
+#define AW87XXX_PID_76_AGC3PO_0P8W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_0P8W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_1P0W4		(4)
+#define AW87XXX_PID_76_AGC3PO_1P0W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_1P0W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_1P2W4		(5)
+#define AW87XXX_PID_76_AGC3PO_1P2W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_1P2W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_1P4W4		(6)
+#define AW87XXX_PID_76_AGC3PO_1P4W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_1P4W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_1P6W4		(7)
+#define AW87XXX_PID_76_AGC3PO_1P6W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_1P6W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_1P8W4		(8)
+#define AW87XXX_PID_76_AGC3PO_1P8W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_1P8W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_2P0W4		(9)
+#define AW87XXX_PID_76_AGC3PO_2P0W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_2P0W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_2P2W4		(10)
+#define AW87XXX_PID_76_AGC3PO_2P2W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_2P2W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_2P4W4		(11)
+#define AW87XXX_PID_76_AGC3PO_2P4W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_2P4W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_2P6W4		(12)
+#define AW87XXX_PID_76_AGC3PO_2P6W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_2P6W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_2P8W4		(13)
+#define AW87XXX_PID_76_AGC3PO_2P8W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_2P8W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_3P0W4		(14)
+#define AW87XXX_PID_76_AGC3PO_3P0W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_3P0W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_AGC3_OFF	(15)
+#define AW87XXX_PID_76_AGC3PO_AGC3_OFF_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_AGC3_OFF << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_DEFAULT_VALUE	(7)
+#define AW87XXX_PID_76_AGC3PO_DEFAULT	\
+	(AW87XXX_PID_76_AGC3PO_DEFAULT_VALUE << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+/* default value of AGC3P (0x06) */
+/* #define AW87XXX_PID_76_AGC3P_DEFAULT		(0x07) */
+
+/* AGC3PA (0x07) detail */
+/* AGC3RT bit 7:5 (AGC3PA 0x07) */
+#define AW87XXX_PID_76_AGC3RT_START_BIT	(5)
+#define AW87XXX_PID_76_AGC3RT_BITS_LEN	(3)
+#define AW87XXX_PID_76_AGC3RT_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC3RT_BITS_LEN)-1) << AW87XXX_PID_76_AGC3RT_START_BIT))
+
+#define AW87XXX_PID_76_AGC3RT_5P12MSDB	(0)
+#define AW87XXX_PID_76_AGC3RT_5P12MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_5P12MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_10P24MSDB	(1)
+#define AW87XXX_PID_76_AGC3RT_10P24MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_10P24MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_20P48MSDB	(2)
+#define AW87XXX_PID_76_AGC3RT_20P48MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_20P48MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_41MSDB	(3)
+#define AW87XXX_PID_76_AGC3RT_41MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_41MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_82MSDB	(4)
+#define AW87XXX_PID_76_AGC3RT_82MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_82MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_164MSDB	(5)
+#define AW87XXX_PID_76_AGC3RT_164MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_164MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_328MSDB	(6)
+#define AW87XXX_PID_76_AGC3RT_328MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_328MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_656MSDB	(7)
+#define AW87XXX_PID_76_AGC3RT_656MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_656MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_76_AGC3RT_DEFAULT	\
+	(AW87XXX_PID_76_AGC3RT_DEFAULT_VALUE << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+/* AGC3AT bit 4:2 (AGC3PA 0x07) */
+#define AW87XXX_PID_76_AGC3AT_START_BIT	(2)
+#define AW87XXX_PID_76_AGC3AT_BITS_LEN	(3)
+#define AW87XXX_PID_76_AGC3AT_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC3AT_BITS_LEN)-1) << AW87XXX_PID_76_AGC3AT_START_BIT))
+
+#define AW87XXX_PID_76_AGC3AT_1P28MSDB	(0)
+#define AW87XXX_PID_76_AGC3AT_1P28MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_1P28MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_2P56MSDB	(1)
+#define AW87XXX_PID_76_AGC3AT_2P56MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_2P56MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_10P24MSDB	(2)
+#define AW87XXX_PID_76_AGC3AT_10P24MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_10P24MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_41MSDB	(3)
+#define AW87XXX_PID_76_AGC3AT_41MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_41MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_82MSDB	(4)
+#define AW87XXX_PID_76_AGC3AT_82MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_82MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_164MSDB	(5)
+#define AW87XXX_PID_76_AGC3AT_164MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_164MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_328MSDB	(6)
+#define AW87XXX_PID_76_AGC3AT_328MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_328MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_656MSDB	(7)
+#define AW87XXX_PID_76_AGC3AT_656MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_656MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_DEFAULT_VALUE	(3)
+#define AW87XXX_PID_76_AGC3AT_DEFAULT	\
+	(AW87XXX_PID_76_AGC3AT_DEFAULT_VALUE << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+/* AGC3FSAT bit 1:0 (AGC3PA 0x07) */
+#define AW87XXX_PID_76_AGC3FSAT_START_BIT	(0)
+#define AW87XXX_PID_76_AGC3FSAT_BITS_LEN	(2)
+#define AW87XXX_PID_76_AGC3FSAT_MASK	\
+	(~(((1<<AW87XXX_PID_76_AGC3FSAT_BITS_LEN)-1) << AW87XXX_PID_76_AGC3FSAT_START_BIT))
+
+#define AW87XXX_PID_76_AGC3FSAT_10P24MSDB	(0)
+#define AW87XXX_PID_76_AGC3FSAT_10P24MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3FSAT_10P24MSDB << AW87XXX_PID_76_AGC3FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3FSAT_20P48MSDB	(1)
+#define AW87XXX_PID_76_AGC3FSAT_20P48MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3FSAT_20P48MSDB << AW87XXX_PID_76_AGC3FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3FSAT_41MSDB	(2)
+#define AW87XXX_PID_76_AGC3FSAT_41MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3FSAT_41MSDB << AW87XXX_PID_76_AGC3FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3FSAT_82MSDB	(3)
+#define AW87XXX_PID_76_AGC3FSAT_82MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3FSAT_82MSDB << AW87XXX_PID_76_AGC3FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3FSAT_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_76_AGC3FSAT_DEFAULT	\
+	(AW87XXX_PID_76_AGC3FSAT_DEFAULT_VALUE << AW87XXX_PID_76_AGC3FSAT_START_BIT)
+
+/* default value of AGC3PA (0x07) */
+/* #define AW87XXX_PID_76_AGC3PA_DEFAULT		(0x4E) */
+
+/* AGC2P (0x08) detail */
+/* AGC2PO bit 3:0 (AGC2P 0x08) */
+#define AW87XXX_PID_76_AGC2PO_START_BIT	(0)
+#define AW87XXX_PID_76_AGC2PO_BITS_LEN	(4)
+#define AW87XXX_PID_76_AGC2PO_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC2PO_BITS_LEN)-1) << AW87XXX_PID_76_AGC2PO_START_BIT))
+
+#define AW87XXX_PID_76_AGC2PO_0P8W4		(0)
+#define AW87XXX_PID_76_AGC2PO_0P8W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_0P8W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_1P2W4		(1)
+#define AW87XXX_PID_76_AGC2PO_1P2W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_1P2W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_1P6W4		(2)
+#define AW87XXX_PID_76_AGC2PO_1P6W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_1P6W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_2P0W4		(3)
+#define AW87XXX_PID_76_AGC2PO_2P0W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_2P0W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_2P4W4		(4)
+#define AW87XXX_PID_76_AGC2PO_2P4W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_2P4W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_2P8W4		(5)
+#define AW87XXX_PID_76_AGC2PO_2P8W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_2P8W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_3P2W4		(6)
+#define AW87XXX_PID_76_AGC2PO_3P2W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_3P2W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_3P6W4		(7)
+#define AW87XXX_PID_76_AGC2PO_3P6W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_3P6W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_4P0W4		(8)
+#define AW87XXX_PID_76_AGC2PO_4P0W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_4P0W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_AGC2_OFF	(9)
+#define AW87XXX_PID_76_AGC2PO_AGC2_OFF_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_AGC2_OFF << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_DEFAULT_VALUE	(6)
+#define AW87XXX_PID_76_AGC2PO_DEFAULT	\
+	(AW87XXX_PID_76_AGC2PO_DEFAULT_VALUE << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+/* default value of AGC2P (0x08) */
+/* #define AW87XXX_PID_76_AGC2P_DEFAULT		(0x06) */
+
+/* AGC2PA (0x09) detail */
+/* AGC2AT bit 4:2 (AGC2PA 0x09) */
+#define AW87XXX_PID_76_AGC2AT_START_BIT	(2)
+#define AW87XXX_PID_76_AGC2AT_BITS_LEN	(3)
+#define AW87XXX_PID_76_AGC2AT_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC2AT_BITS_LEN)-1) << AW87XXX_PID_76_AGC2AT_START_BIT))
+
+#define AW87XXX_PID_76_AGC2AT_0P16MSDB	(0)
+#define AW87XXX_PID_76_AGC2AT_0P16MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_0P16MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_0P32MSDB	(1)
+#define AW87XXX_PID_76_AGC2AT_0P32MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_0P32MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_0P64MSDB	(2)
+#define AW87XXX_PID_76_AGC2AT_0P64MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_0P64MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_2P56MSDB	(3)
+#define AW87XXX_PID_76_AGC2AT_2P56MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_2P56MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_10P24MSDB	(4)
+#define AW87XXX_PID_76_AGC2AT_10P24MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_10P24MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_41MSDB	(5)
+#define AW87XXX_PID_76_AGC2AT_41MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_41MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_82MSDB	(6)
+#define AW87XXX_PID_76_AGC2AT_82MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_82MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_164MSDB	(7)
+#define AW87XXX_PID_76_AGC2AT_164MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_164MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_76_AGC2AT_DEFAULT	\
+	(AW87XXX_PID_76_AGC2AT_DEFAULT_VALUE << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+/* AGC2FSAT bit 1:0 (AGC2PA 0x09) */
+#define AW87XXX_PID_76_AGC2FSAT_START_BIT	(0)
+#define AW87XXX_PID_76_AGC2FSAT_BITS_LEN	(2)
+#define AW87XXX_PID_76_AGC2FSAT_MASK	\
+	(~(((1<<AW87XXX_PID_76_AGC2FSAT_BITS_LEN)-1) << AW87XXX_PID_76_AGC2FSAT_START_BIT))
+
+#define AW87XXX_PID_76_AGC2FSAT_0P16MSDB	(0)
+#define AW87XXX_PID_76_AGC2FSAT_0P16MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2FSAT_0P16MSDB << AW87XXX_PID_76_AGC2FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2FSAT_0P64MSDB	(1)
+#define AW87XXX_PID_76_AGC2FSAT_0P64MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2FSAT_0P64MSDB << AW87XXX_PID_76_AGC2FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2FSAT_2P56MSDB	(2)
+#define AW87XXX_PID_76_AGC2FSAT_2P56MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2FSAT_2P56MSDB << AW87XXX_PID_76_AGC2FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2FSAT_10P24MSDB	(3)
+#define AW87XXX_PID_76_AGC2FSAT_10P24MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2FSAT_10P24MSDB << AW87XXX_PID_76_AGC2FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2FSAT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_AGC2FSAT_DEFAULT	\
+	(AW87XXX_PID_76_AGC2FSAT_DEFAULT_VALUE << AW87XXX_PID_76_AGC2FSAT_START_BIT)
+
+/* default value of AGC2PA (0x09) */
+/* #define AW87XXX_PID_76_AGC2PA_DEFAULT		(0x08) */
+
+/* AGC1PA (0x0A) detail */
+/* AGC1THVTH bit 6:3 (AGC1PA 0x0A) */
+#define AW87XXX_PID_76_AGC1THVTH_START_BIT	(3)
+#define AW87XXX_PID_76_AGC1THVTH_BITS_LEN	(4)
+#define AW87XXX_PID_76_AGC1THVTH_MASK	\
+	(~(((1<<AW87XXX_PID_76_AGC1THVTH_BITS_LEN)-1) << AW87XXX_PID_76_AGC1THVTH_START_BIT))
+
+#define AW87XXX_PID_76_AGC1THVTH_5V		(0)
+#define AW87XXX_PID_76_AGC1THVTH_5V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_5V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_5P2V	(1)
+#define AW87XXX_PID_76_AGC1THVTH_5P2V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_5P2V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_5P4V	(2)
+#define AW87XXX_PID_76_AGC1THVTH_5P4V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_5P4V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_5P6V	(3)
+#define AW87XXX_PID_76_AGC1THVTH_5P6V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_5P6V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_5P8V	(4)
+#define AW87XXX_PID_76_AGC1THVTH_5P8V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_5P8V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_6P0V	(5)
+#define AW87XXX_PID_76_AGC1THVTH_6P0V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_6P0V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_6P2V	(6)
+#define AW87XXX_PID_76_AGC1THVTH_6P2V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_6P2V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_6P4V	(7)
+#define AW87XXX_PID_76_AGC1THVTH_6P4V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_6P4V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_6P6V	(8)
+#define AW87XXX_PID_76_AGC1THVTH_6P6V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_6P6V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_6P8V	(9)
+#define AW87XXX_PID_76_AGC1THVTH_6P8V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_6P8V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_7V		(10)
+#define AW87XXX_PID_76_AGC1THVTH_7V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_7V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_7P2V	(11)
+#define AW87XXX_PID_76_AGC1THVTH_7P2V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_7P2V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_7P4V	(12)
+#define AW87XXX_PID_76_AGC1THVTH_7P4V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_7P4V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_7P6V	(13)
+#define AW87XXX_PID_76_AGC1THVTH_7P6V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_7P6V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_7P8V	(14)
+#define AW87XXX_PID_76_AGC1THVTH_7P8V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_7P8V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_8V		(15)
+#define AW87XXX_PID_76_AGC1THVTH_8V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_8V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_DEFAULT_VALUE	(9)
+#define AW87XXX_PID_76_AGC1THVTH_DEFAULT	\
+	(AW87XXX_PID_76_AGC1THVTH_DEFAULT_VALUE << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+/* AGC1AT bit 2:1 (AGC1PA 0x0A) */
+#define AW87XXX_PID_76_AGC1AT_START_BIT	(1)
+#define AW87XXX_PID_76_AGC1AT_BITS_LEN	(2)
+#define AW87XXX_PID_76_AGC1AT_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC1AT_BITS_LEN)-1) << AW87XXX_PID_76_AGC1AT_START_BIT))
+
+#define AW87XXX_PID_76_AGC1AT_0P04MSDB	(0)
+#define AW87XXX_PID_76_AGC1AT_0P04MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC1AT_0P04MSDB << AW87XXX_PID_76_AGC1AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC1AT_0P08MSDB	(1)
+#define AW87XXX_PID_76_AGC1AT_0P08MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC1AT_0P08MSDB << AW87XXX_PID_76_AGC1AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC1AT_0P16MSDB	(2)
+#define AW87XXX_PID_76_AGC1AT_0P16MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC1AT_0P16MSDB << AW87XXX_PID_76_AGC1AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC1AT_0P32MSDB	(3)
+#define AW87XXX_PID_76_AGC1AT_0P32MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC1AT_0P32MSDB << AW87XXX_PID_76_AGC1AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC1AT_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_AGC1AT_DEFAULT	\
+	(AW87XXX_PID_76_AGC1AT_DEFAULT_VALUE << AW87XXX_PID_76_AGC1AT_START_BIT)
+
+/* PD_AGC1 bit 0 (AGC1PA 0x0A) */
+#define AW87XXX_PID_76_PD_AGC1_START_BIT	(0)
+#define AW87XXX_PID_76_PD_AGC1_BITS_LEN	(1)
+#define AW87XXX_PID_76_PD_AGC1_MASK		\
+	(~(((1<<AW87XXX_PID_76_PD_AGC1_BITS_LEN)-1) << AW87XXX_PID_76_PD_AGC1_START_BIT))
+
+#define AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_UP	(0)
+#define AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_UP_VALUE	\
+	(AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_UP << AW87XXX_PID_76_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_DOWN	(1)
+#define AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_DOWN_VALUE	\
+	(AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_DOWN << AW87XXX_PID_76_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_76_PD_AGC1_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_PD_AGC1_DEFAULT	\
+	(AW87XXX_PID_76_PD_AGC1_DEFAULT_VALUE << AW87XXX_PID_76_PD_AGC1_START_BIT)
+
+/* default value of AGC1PA (0x0A) */
+/* #define AW87XXX_PID_76_AGC1PA_DEFAULT		(0x4A) */
+
+/* SYSST (0x59) detail */
+/* UVLOS bit 7 (SYSST 0x59) */
+#define AW87XXX_PID_76_UVLOS_START_BIT	(7)
+#define AW87XXX_PID_76_UVLOS_BITS_LEN	(1)
+#define AW87XXX_PID_76_UVLOS_MASK		\
+	(~(((1<<AW87XXX_PID_76_UVLOS_BITS_LEN)-1) << AW87XXX_PID_76_UVLOS_START_BIT))
+
+#define AW87XXX_PID_76_UVLOS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_76_UVLOS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_UVLOS_NORMAL_OPERATION << AW87XXX_PID_76_UVLOS_START_BIT)
+
+#define AW87XXX_PID_76_UVLOS_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_76_UVLOS_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_76_UVLOS_VBAT_UNDER_VOLTAGE << AW87XXX_PID_76_UVLOS_START_BIT)
+
+#define AW87XXX_PID_76_UVLOS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_UVLOS_DEFAULT	\
+	(AW87XXX_PID_76_UVLOS_DEFAULT_VALUE << AW87XXX_PID_76_UVLOS_START_BIT)
+
+/* OTNS bit 6 (SYSST 0x59) */
+#define AW87XXX_PID_76_OTNS_START_BIT	(6)
+#define AW87XXX_PID_76_OTNS_BITS_LEN	(1)
+#define AW87XXX_PID_76_OTNS_MASK		\
+	(~(((1<<AW87XXX_PID_76_OTNS_BITS_LEN)-1) << AW87XXX_PID_76_OTNS_START_BIT))
+
+#define AW87XXX_PID_76_OTNS_DETECTED	(0)
+#define AW87XXX_PID_76_OTNS_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OTNS_DETECTED << AW87XXX_PID_76_OTNS_START_BIT)
+
+#define AW87XXX_PID_76_OTNS_NORMAL_OPERATION	(1)
+#define AW87XXX_PID_76_OTNS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_OTNS_NORMAL_OPERATION << AW87XXX_PID_76_OTNS_START_BIT)
+
+#define AW87XXX_PID_76_OTNS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_OTNS_DEFAULT		\
+	(AW87XXX_PID_76_OTNS_DEFAULT_VALUE << AW87XXX_PID_76_OTNS_START_BIT)
+
+/* OC_FLAGS bit 5 (SYSST 0x59) */
+#define AW87XXX_PID_76_OC_FLAGS_START_BIT	(5)
+#define AW87XXX_PID_76_OC_FLAGS_BITS_LEN	(1)
+#define AW87XXX_PID_76_OC_FLAGS_MASK	\
+	(~(((1<<AW87XXX_PID_76_OC_FLAGS_BITS_LEN)-1) << AW87XXX_PID_76_OC_FLAGS_START_BIT))
+
+#define AW87XXX_PID_76_OC_FLAGS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_76_OC_FLAGS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_OC_FLAGS_NORMAL_OPERATION << AW87XXX_PID_76_OC_FLAGS_START_BIT)
+
+#define AW87XXX_PID_76_OC_FLAGS_DETECTED	(1)
+#define AW87XXX_PID_76_OC_FLAGS_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OC_FLAGS_DETECTED << AW87XXX_PID_76_OC_FLAGS_START_BIT)
+
+#define AW87XXX_PID_76_OC_FLAGS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_OC_FLAGS_DEFAULT	\
+	(AW87XXX_PID_76_OC_FLAGS_DEFAULT_VALUE << AW87XXX_PID_76_OC_FLAGS_START_BIT)
+
+/* ADAP_CPS bit 4 (SYSST 0x59) */
+#define AW87XXX_PID_76_ADAP_CPS_START_BIT	(4)
+#define AW87XXX_PID_76_ADAP_CPS_BITS_LEN	(1)
+#define AW87XXX_PID_76_ADAP_CPS_MASK	\
+	(~(((1<<AW87XXX_PID_76_ADAP_CPS_BITS_LEN)-1) << AW87XXX_PID_76_ADAP_CPS_START_BIT))
+
+#define AW87XXX_PID_76_ADAP_CPS_1X_MODE	(0)
+#define AW87XXX_PID_76_ADAP_CPS_1X_MODE_VALUE	\
+	(AW87XXX_PID_76_ADAP_CPS_1X_MODE << AW87XXX_PID_76_ADAP_CPS_START_BIT)
+
+#define AW87XXX_PID_76_ADAP_CPS_2X_MODE	(1)
+#define AW87XXX_PID_76_ADAP_CPS_2X_MODE_VALUE	\
+	(AW87XXX_PID_76_ADAP_CPS_2X_MODE << AW87XXX_PID_76_ADAP_CPS_START_BIT)
+
+#define AW87XXX_PID_76_ADAP_CPS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_ADAP_CPS_DEFAULT	\
+	(AW87XXX_PID_76_ADAP_CPS_DEFAULT_VALUE << AW87XXX_PID_76_ADAP_CPS_START_BIT)
+
+/* STARTOKS bit 3 (SYSST 0x59) */
+#define AW87XXX_PID_76_STARTOKS_START_BIT	(3)
+#define AW87XXX_PID_76_STARTOKS_BITS_LEN	(1)
+#define AW87XXX_PID_76_STARTOKS_MASK	\
+	(~(((1<<AW87XXX_PID_76_STARTOKS_BITS_LEN)-1) << AW87XXX_PID_76_STARTOKS_START_BIT))
+
+#define AW87XXX_PID_76_STARTOKS_CP_START_FAIL_DECTECTED	(0)
+#define AW87XXX_PID_76_STARTOKS_CP_START_FAIL_DECTECTED_VALUE	\
+	(AW87XXX_PID_76_STARTOKS_CP_START_FAIL_DECTECTED << AW87XXX_PID_76_STARTOKS_START_BIT)
+
+#define AW87XXX_PID_76_STARTOKS_NORMAL_OPERATION	(1)
+#define AW87XXX_PID_76_STARTOKS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_STARTOKS_NORMAL_OPERATION << AW87XXX_PID_76_STARTOKS_START_BIT)
+
+#define AW87XXX_PID_76_STARTOKS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_STARTOKS_DEFAULT	\
+	(AW87XXX_PID_76_STARTOKS_DEFAULT_VALUE << AW87XXX_PID_76_STARTOKS_START_BIT)
+
+/* OVP1S bit 2 (SYSST 0x59) */
+#define AW87XXX_PID_76_OVP1S_START_BIT	(2)
+#define AW87XXX_PID_76_OVP1S_BITS_LEN	(1)
+#define AW87XXX_PID_76_OVP1S_MASK		\
+	(~(((1<<AW87XXX_PID_76_OVP1S_BITS_LEN)-1) << AW87XXX_PID_76_OVP1S_START_BIT))
+
+#define AW87XXX_PID_76_OVP1S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_76_OVP1S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_OVP1S_NORMAL_OPERATION << AW87XXX_PID_76_OVP1S_START_BIT)
+
+#define AW87XXX_PID_76_OVP1S_CP_OVP_DETECTED	(1)
+#define AW87XXX_PID_76_OVP1S_CP_OVP_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OVP1S_CP_OVP_DETECTED << AW87XXX_PID_76_OVP1S_START_BIT)
+
+#define AW87XXX_PID_76_OVP1S_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_OVP1S_DEFAULT	\
+	(AW87XXX_PID_76_OVP1S_DEFAULT_VALUE << AW87XXX_PID_76_OVP1S_START_BIT)
+
+/* PORNS bit 1 (SYSST 0x59) */
+#define AW87XXX_PID_76_PORNS_START_BIT	(1)
+#define AW87XXX_PID_76_PORNS_BITS_LEN	(1)
+#define AW87XXX_PID_76_PORNS_MASK		\
+	(~(((1<<AW87XXX_PID_76_PORNS_BITS_LEN)-1) << AW87XXX_PID_76_PORNS_START_BIT))
+
+#define AW87XXX_PID_76_PORNS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_PORNS_DEFAULT	\
+	(AW87XXX_PID_76_PORNS_DEFAULT_VALUE << AW87XXX_PID_76_PORNS_START_BIT)
+
+/* CP_SHORTS bit 0 (SYSST 0x59) */
+#define AW87XXX_PID_76_CP_SHORTS_START_BIT	(0)
+#define AW87XXX_PID_76_CP_SHORTS_BITS_LEN	(1)
+#define AW87XXX_PID_76_CP_SHORTS_MASK	\
+	(~(((1<<AW87XXX_PID_76_CP_SHORTS_BITS_LEN)-1) << AW87XXX_PID_76_CP_SHORTS_START_BIT))
+
+#define AW87XXX_PID_76_CP_SHORTS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_76_CP_SHORTS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_CP_SHORTS_NORMAL_OPERATION << AW87XXX_PID_76_CP_SHORTS_START_BIT)
+
+#define AW87XXX_PID_76_CP_SHORTS_CHARGE_PUMP_SHORT_DECTECTED	(1)
+#define AW87XXX_PID_76_CP_SHORTS_CHARGE_PUMP_SHORT_DECTECTED_VALUE	\
+	(AW87XXX_PID_76_CP_SHORTS_CHARGE_PUMP_SHORT_DECTECTED << AW87XXX_PID_76_CP_SHORTS_START_BIT)
+
+#define AW87XXX_PID_76_CP_SHORTS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_CP_SHORTS_DEFAULT	\
+	(AW87XXX_PID_76_CP_SHORTS_DEFAULT_VALUE << AW87XXX_PID_76_CP_SHORTS_START_BIT)
+
+/* default value of SYSST (0x59) */
+/* #define AW87XXX_PID_76_SYSST_DEFAULT		(0xD0) */
+
+/* SYSINT (0x60) detail */
+/* UVLOI bit 7 (SYSINT 0x60) */
+#define AW87XXX_PID_76_UVLOI_START_BIT	(7)
+#define AW87XXX_PID_76_UVLOI_BITS_LEN	(1)
+#define AW87XXX_PID_76_UVLOI_MASK		\
+	(~(((1<<AW87XXX_PID_76_UVLOI_BITS_LEN)-1) << AW87XXX_PID_76_UVLOI_START_BIT))
+
+#define AW87XXX_PID_76_UVLOI_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_UVLOI_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_UVLOI_NOT_CHANGE << AW87XXX_PID_76_UVLOI_START_BIT)
+
+#define AW87XXX_PID_76_UVLOI_DETECTED	(1)
+#define AW87XXX_PID_76_UVLOI_DETECTED_VALUE	\
+	(AW87XXX_PID_76_UVLOI_DETECTED << AW87XXX_PID_76_UVLOI_START_BIT)
+
+#define AW87XXX_PID_76_UVLOI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_UVLOI_DEFAULT	\
+	(AW87XXX_PID_76_UVLOI_DEFAULT_VALUE << AW87XXX_PID_76_UVLOI_START_BIT)
+
+/* OTNI bit 6 (SYSINT 0x60) */
+#define AW87XXX_PID_76_OTNI_START_BIT	(6)
+#define AW87XXX_PID_76_OTNI_BITS_LEN	(1)
+#define AW87XXX_PID_76_OTNI_MASK		\
+	(~(((1<<AW87XXX_PID_76_OTNI_BITS_LEN)-1) << AW87XXX_PID_76_OTNI_START_BIT))
+
+#define AW87XXX_PID_76_OTNI_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_OTNI_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_OTNI_NOT_CHANGE << AW87XXX_PID_76_OTNI_START_BIT)
+
+#define AW87XXX_PID_76_OTNI_DETECTED	(1)
+#define AW87XXX_PID_76_OTNI_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OTNI_DETECTED << AW87XXX_PID_76_OTNI_START_BIT)
+
+#define AW87XXX_PID_76_OTNI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_OTNI_DEFAULT		\
+	(AW87XXX_PID_76_OTNI_DEFAULT_VALUE << AW87XXX_PID_76_OTNI_START_BIT)
+
+/* OC_FLAGI bit 5 (SYSINT 0x60) */
+#define AW87XXX_PID_76_OC_FLAGI_START_BIT	(5)
+#define AW87XXX_PID_76_OC_FLAGI_BITS_LEN	(1)
+#define AW87XXX_PID_76_OC_FLAGI_MASK	\
+	(~(((1<<AW87XXX_PID_76_OC_FLAGI_BITS_LEN)-1) << AW87XXX_PID_76_OC_FLAGI_START_BIT))
+
+#define AW87XXX_PID_76_OC_FLAGI_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_OC_FLAGI_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_OC_FLAGI_NOT_CHANGE << AW87XXX_PID_76_OC_FLAGI_START_BIT)
+
+#define AW87XXX_PID_76_OC_FLAGI_DETECTED	(1)
+#define AW87XXX_PID_76_OC_FLAGI_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OC_FLAGI_DETECTED << AW87XXX_PID_76_OC_FLAGI_START_BIT)
+
+#define AW87XXX_PID_76_OC_FLAGI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_OC_FLAGI_DEFAULT	\
+	(AW87XXX_PID_76_OC_FLAGI_DEFAULT_VALUE << AW87XXX_PID_76_OC_FLAGI_START_BIT)
+
+/* ADAP_CPI bit 4 (SYSINT 0x60) */
+#define AW87XXX_PID_76_ADAP_CPI_START_BIT	(4)
+#define AW87XXX_PID_76_ADAP_CPI_BITS_LEN	(1)
+#define AW87XXX_PID_76_ADAP_CPI_MASK	\
+	(~(((1<<AW87XXX_PID_76_ADAP_CPI_BITS_LEN)-1) << AW87XXX_PID_76_ADAP_CPI_START_BIT))
+
+#define AW87XXX_PID_76_ADAP_CPI_1X_MODE	(0)
+#define AW87XXX_PID_76_ADAP_CPI_1X_MODE_VALUE	\
+	(AW87XXX_PID_76_ADAP_CPI_1X_MODE << AW87XXX_PID_76_ADAP_CPI_START_BIT)
+
+#define AW87XXX_PID_76_ADAP_CPI_2X_MODE	(1)
+#define AW87XXX_PID_76_ADAP_CPI_2X_MODE_VALUE	\
+	(AW87XXX_PID_76_ADAP_CPI_2X_MODE << AW87XXX_PID_76_ADAP_CPI_START_BIT)
+
+#define AW87XXX_PID_76_ADAP_CPI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_ADAP_CPI_DEFAULT	\
+	(AW87XXX_PID_76_ADAP_CPI_DEFAULT_VALUE << AW87XXX_PID_76_ADAP_CPI_START_BIT)
+
+/* STARTOKI bit 3 (SYSINT 0x60) */
+#define AW87XXX_PID_76_STARTOKI_START_BIT	(3)
+#define AW87XXX_PID_76_STARTOKI_BITS_LEN	(1)
+#define AW87XXX_PID_76_STARTOKI_MASK	\
+	(~(((1<<AW87XXX_PID_76_STARTOKI_BITS_LEN)-1) << AW87XXX_PID_76_STARTOKI_START_BIT))
+
+#define AW87XXX_PID_76_STARTOKI_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_STARTOKI_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_STARTOKI_NOT_CHANGE << AW87XXX_PID_76_STARTOKI_START_BIT)
+
+#define AW87XXX_PID_76_STARTOKI_DECTECTED	(1)
+#define AW87XXX_PID_76_STARTOKI_DECTECTED_VALUE	\
+	(AW87XXX_PID_76_STARTOKI_DECTECTED << AW87XXX_PID_76_STARTOKI_START_BIT)
+
+#define AW87XXX_PID_76_STARTOKI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_STARTOKI_DEFAULT	\
+	(AW87XXX_PID_76_STARTOKI_DEFAULT_VALUE << AW87XXX_PID_76_STARTOKI_START_BIT)
+
+/* OVP1I bit 2 (SYSINT 0x60) */
+#define AW87XXX_PID_76_OVP1I_START_BIT	(2)
+#define AW87XXX_PID_76_OVP1I_BITS_LEN	(1)
+#define AW87XXX_PID_76_OVP1I_MASK		\
+	(~(((1<<AW87XXX_PID_76_OVP1I_BITS_LEN)-1) << AW87XXX_PID_76_OVP1I_START_BIT))
+
+#define AW87XXX_PID_76_OVP1I_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_OVP1I_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_OVP1I_NOT_CHANGE << AW87XXX_PID_76_OVP1I_START_BIT)
+
+#define AW87XXX_PID_76_OVP1I_DETECTED	(1)
+#define AW87XXX_PID_76_OVP1I_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OVP1I_DETECTED << AW87XXX_PID_76_OVP1I_START_BIT)
+
+#define AW87XXX_PID_76_OVP1I_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_OVP1I_DEFAULT	\
+	(AW87XXX_PID_76_OVP1I_DEFAULT_VALUE << AW87XXX_PID_76_OVP1I_START_BIT)
+
+/* PORNI bit 1 (SYSINT 0x60) */
+#define AW87XXX_PID_76_PORNI_START_BIT	(1)
+#define AW87XXX_PID_76_PORNI_BITS_LEN	(1)
+#define AW87XXX_PID_76_PORNI_MASK		\
+	(~(((1<<AW87XXX_PID_76_PORNI_BITS_LEN)-1) << AW87XXX_PID_76_PORNI_START_BIT))
+
+#define AW87XXX_PID_76_PORNI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_PORNI_DEFAULT	\
+	(AW87XXX_PID_76_PORNI_DEFAULT_VALUE << AW87XXX_PID_76_PORNI_START_BIT)
+
+/* CP_SHORTI bit 0 (SYSINT 0x60) */
+#define AW87XXX_PID_76_CP_SHORTI_START_BIT	(0)
+#define AW87XXX_PID_76_CP_SHORTI_BITS_LEN	(1)
+#define AW87XXX_PID_76_CP_SHORTI_MASK	\
+	(~(((1<<AW87XXX_PID_76_CP_SHORTI_BITS_LEN)-1) << AW87XXX_PID_76_CP_SHORTI_START_BIT))
+
+#define AW87XXX_PID_76_CP_SHORTI_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_CP_SHORTI_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_CP_SHORTI_NOT_CHANGE << AW87XXX_PID_76_CP_SHORTI_START_BIT)
+
+#define AW87XXX_PID_76_CP_SHORTI_SHORT_DECTECTED	(1)
+#define AW87XXX_PID_76_CP_SHORTI_SHORT_DECTECTED_VALUE	\
+	(AW87XXX_PID_76_CP_SHORTI_SHORT_DECTECTED << AW87XXX_PID_76_CP_SHORTI_START_BIT)
+
+#define AW87XXX_PID_76_CP_SHORTI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_CP_SHORTI_DEFAULT	\
+	(AW87XXX_PID_76_CP_SHORTI_DEFAULT_VALUE << AW87XXX_PID_76_CP_SHORTI_START_BIT)
+
+/* default value of SYSINT (0x60) */
+/* #define AW87XXX_PID_76_SYSINT_DEFAULT		(0x00) */
+
+/* detail information of registers end */
+
+#endif  /* #ifndef  __AW87XXX_PID_76_REG_H__ */
\ No newline at end of file
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_9b_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_9b_reg.h
new file mode 100644
index 000000000..27baeb96c
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_9b_reg.h
@@ -0,0 +1,81 @@
+#ifndef __AW87XXX_PID_9B_REG_H__
+#define __AW87XXX_PID_9B_REG_H__
+
+#define AW87XXX_PID_9B_CHIPID_REG		(0x00)
+#define AW87XXX_PID_9B_SYSCTRL_REG		(0x01)
+#define AW87XXX_PID_9B_BATSAFE_REG		(0x02)
+#define AW87XXX_PID_9B_BOV_REG			(0x03)
+#define AW87XXX_PID_9B_BP_REG			(0x04)
+#define AW87XXX_PID_9B_GAIN_REG			(0x05)
+#define AW87XXX_PID_9B_AGC3_PO_REG		(0x06)
+#define AW87XXX_PID_9B_AGC3_REG			(0x07)
+#define AW87XXX_PID_9B_AGC2_REG			(0x08)
+#define AW87XXX_PID_9B_AGC1_REG			(0x09)
+
+#define AW87XXX_PID_9B_SYSCTRL_DEFAULT		(0x03)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_9b_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_9B_REG_MAX			(0x64)
+
+#define REG_NONE_ACCESS		(0)
+#define REG_RD_ACCESS		(1 << 0)
+#define REG_WR_ACCESS		(1 << 1)
+
+const unsigned char aw87xxx_pid_9b_reg_access[AW87XXX_PID_9B_REG_MAX] = {
+	[AW87XXX_PID_9B_CHIPID_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_9B_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_BATSAFE_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_BOV_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_BP_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_GAIN_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_AGC3_PO_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_AGC3_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_AGC2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_AGC1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+
+#define AW87XXX_PID_9B_ENCRYPTION_REG		(0x64)
+#define AW87XXX_PID_9B_ENCRYPTION_BOOST_OUTPUT_SET	(0x2C)
+
+/* REG_EN_SW bit 2 (SYSCTRL 0x01) */
+#define AW87XXX_PID_9B_REG_EN_SW_START_BIT	(2)
+#define AW87XXX_PID_9B_REG_EN_SW_BITS_LEN	(1)
+#define AW87XXX_PID_9B_REG_EN_SW_MASK	\
+	(~(((1<<AW87XXX_PID_9B_REG_EN_SW_BITS_LEN)-1) << AW87XXX_PID_9B_REG_EN_SW_START_BIT))
+
+#define AW87XXX_PID_9B_REG_EN_SW_DISABLE	(0)
+#define AW87XXX_PID_9B_REG_EN_SW_DISABLE_VALUE	\
+	(AW87XXX_PID_9B_REG_EN_SW_DISABLE << AW87XXX_PID_9B_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_9B_REG_EN_SW_ENABLE		(1)
+#define AW87XXX_PID_9B_REG_EN_SW_ENABLE_VALUE	\
+	(AW87XXX_PID_9B_REG_EN_SW_ENABLE << AW87XXX_PID_9B_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_9B_REG_EN_SW_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_9B_REG_EN_SW_DEFAULT	\
+	(AW87XXX_PID_9B_REG_EN_SW_DEFAULT_VALUE << AW87XXX_PID_9B_REG_EN_SW_START_BIT)
+
+/* SPK_MODE bit 0 (SYSCTRL 0x01) */
+#define AW87XXX_PID_9B_SPK_MODE_START_BIT	(0)
+#define AW87XXX_PID_9B_SPK_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_9B_SPK_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_9B_SPK_MODE_BITS_LEN)-1) << AW87XXX_PID_9B_SPK_MODE_START_BIT))
+
+#define AW87XXX_PID_9B_SPK_MODE_DISABLE	(0)
+#define AW87XXX_PID_9B_SPK_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_9B_SPK_MODE_DISABLE << AW87XXX_PID_9B_SPK_MODE_START_BIT)
+
+#define AW87XXX_PID_9B_SPK_MODE_ENABLE	(1)
+#define AW87XXX_PID_9B_SPK_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_9B_SPK_MODE_ENABLE << AW87XXX_PID_9B_SPK_MODE_START_BIT)
+
+#endif
-- 
2.52.0


From 32398d12212ba6007b624878860f6ce24068b9de Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Mon, 28 Oct 2024 00:16:12 +0100
Subject: [PATCH 070/112] Codec: aw87xxx: add dmi match for handheld devices

---
 sound/soc/codecs/aw87xxx/aw87xxx.c | 51 ++++++++++++++++++++++++++++--
 1 file changed, 49 insertions(+), 2 deletions(-)

diff --git a/sound/soc/codecs/aw87xxx/aw87xxx.c b/sound/soc/codecs/aw87xxx/aw87xxx.c
index 837a60dea..3d732400e 100644
--- a/sound/soc/codecs/aw87xxx/aw87xxx.c
+++ b/sound/soc/codecs/aw87xxx/aw87xxx.c
@@ -33,6 +33,7 @@
 #include <linux/io.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/dmi.h>
 #include <linux/dma-mapping.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
@@ -841,6 +842,48 @@ static void aw87xxx_fw_load_work_routine(struct work_struct *work)
 	}
 }
 
+static const struct dmi_system_id firmware_names[] = {
+	{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "KUN"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_kun.bin",
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "Loki MiniPro"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_minipro.bin",
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "AIR 1S"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_air1s.bin",
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "AIR Plus"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_airplus.bin",
+	},
+	{
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
+		  DMI_MATCH(DMI_PRODUCT_NAME, "FLIP"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_flip.bin",
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "NEO-01"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_orangepi.bin",
+	},
+	{}
+};
+
 static void aw87xxx_fw_load_init(struct aw87xxx *aw87xxx)
 {
 #ifdef AW_CFG_UPDATE_DELAY
@@ -848,8 +891,12 @@ static void aw87xxx_fw_load_init(struct aw87xxx *aw87xxx)
 #else
 	int cfg_timer_val = 0;
 #endif
-	AW_DEV_LOGI(aw87xxx->dev, "enter");
-	snprintf(aw87xxx->fw_name, AW87XXX_FW_NAME_MAX, "%s", AW87XXX_FW_BIN_NAME);
+	const struct dmi_system_id *fwname_sysid = dmi_first_match(firmware_names);
+	const char *fwname = fwname_sysid ?
+		fwname_sysid->driver_data : AW87XXX_FW_BIN_NAME;
+
+	AW_DEV_LOGI(aw87xxx->dev, "loading firmware name: [%s]", fwname);
+	snprintf(aw87xxx->fw_name, AW87XXX_FW_NAME_MAX, "%s", fwname);
 	aw87xxx_acf_init(&aw87xxx->aw_dev, &aw87xxx->acf_info, aw87xxx->dev_index);
 
 	INIT_DELAYED_WORK(&aw87xxx->fw_load_work, aw87xxx_fw_load_work_routine);
-- 
2.52.0


From 6beeacbcf4b60511c521f3d7dc0cd139d34ba438 Mon Sep 17 00:00:00 2001
From: fewtarius <fewtarius@steamfork.org>
Date: Fri, 26 Jul 2024 22:28:04 +0200
Subject: [PATCH 071/112] ALSA: hda/realtek: Add Ayaneo Air 1S audio quirk

Co-developed-by: linh1987
---
 sound/hda/codecs/realtek/alc269.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/sound/hda/codecs/realtek/alc269.c b/sound/hda/codecs/realtek/alc269.c
index 0a0496deb..0894afd66 100644
--- a/sound/hda/codecs/realtek/alc269.c
+++ b/sound/hda/codecs/realtek/alc269.c
@@ -3550,6 +3550,7 @@ enum {
 	ALC269VB_FIXUP_ASUS_ZENBOOK,
 	ALC269VB_FIXUP_ASUS_ZENBOOK_UX31A,
 	ALC269VB_FIXUP_ASUS_MIC_NO_PRESENCE,
+	ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX,
 	ALC269_FIXUP_LIMIT_INT_MIC_BOOST_MUTE_LED,
 	ALC269VB_FIXUP_ORDISSIMO_EVE2,
 	ALC283_FIXUP_CHROME_BOOK,
@@ -4302,6 +4303,13 @@ static const struct hda_fixup alc269_fixups[] = {
 		.chained = true,
 		.chain_id = ALC269_FIXUP_HEADSET_MIC
 	},
+	[ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = (const struct hda_pintbl[]) {
+			{ 0x1a, 0x90170110 },
+			{ }
+		},
+	},
 	[ALC269_FIXUP_LIMIT_INT_MIC_BOOST_MUTE_LED] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc269_fixup_limit_int_mic_boost,
@@ -7369,6 +7377,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x2782, 0x1705, "MEDION E15433", ALC269VC_FIXUP_INFINIX_Y4_MAX),
 	SND_PCI_QUIRK(0x2782, 0x1707, "Vaio VJFE-ADL", ALC298_FIXUP_SPK_VOLUME),
 	SND_PCI_QUIRK(0x2782, 0x4900, "MEDION E15443", ALC233_FIXUP_MEDION_MTL_SPK),
+	SND_PCI_QUIRK(0x1f66, 0x0103, "AYANEO AIR 1S", ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX),
 	SND_PCI_QUIRK(0x8086, 0x2074, "Intel NUC 8", ALC233_FIXUP_INTEL_NUC8_DMIC),
 	SND_PCI_QUIRK(0x8086, 0x2080, "Intel NUC 8 Rugged", ALC256_FIXUP_INTEL_NUC8_RUGGED),
 	SND_PCI_QUIRK(0x8086, 0x2081, "Intel NUC 10", ALC256_FIXUP_INTEL_NUC10),
@@ -7494,6 +7503,7 @@ static const struct hda_model_fixup alc269_fixup_models[] = {
 	{.id = ALC269VB_FIXUP_ASUS_ZENBOOK, .name = "asus-zenbook"},
 	{.id = ALC269VB_FIXUP_ASUS_ZENBOOK_UX31A, .name = "asus-zenbook-ux31a"},
 	{.id = ALC269VB_FIXUP_ORDISSIMO_EVE2, .name = "ordissimo"},
+	{.id = ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX, .name = "ayaneo-speaker-pin-fix"},
 	{.id = ALC282_FIXUP_ASUS_TX300, .name = "asus-tx300"},
 	{.id = ALC283_FIXUP_INT_MIC, .name = "alc283-int-mic"},
 	{.id = ALC290_FIXUP_MONO_SPEAKERS_HSJACK, .name = "mono-speakers"},
-- 
2.52.0


From 8561ebff76bad3e0d40451704820ca83734cecdf Mon Sep 17 00:00:00 2001
From: CVMagic <546352+CVMagic@users.noreply.github.com>
Date: Fri, 22 Sep 2023 21:53:06 +0200
Subject: [PATCH 072/112] ALSA: hda/realtek: Use DMI matching for Ayaneo Geek,
 Ayaneo 2, and Ayn MiniPro

Co-developed-by: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
---
 sound/hda/codecs/realtek/alc269.c | 51 ++++++++++++++++++++++++++++++-
 1 file changed, 50 insertions(+), 1 deletion(-)

diff --git a/sound/hda/codecs/realtek/alc269.c b/sound/hda/codecs/realtek/alc269.c
index 0894afd66..8a5bf9fc3 100644
--- a/sound/hda/codecs/realtek/alc269.c
+++ b/sound/hda/codecs/realtek/alc269.c
@@ -2555,6 +2555,20 @@ static void alc294_gx502_toggle_output(struct hda_codec *codec,
 		alc_write_coef_idx(codec, 0x10, 0x0a20);
 }
 
+static void alc269_fixup_headphone_volume(struct hda_codec *codec,
+					const struct hda_fixup *fix, int action)
+{
+	/* Pin 0x21: Some devices share 0x14 for headphones and speakers.
+	 * This will fix ensure these devices have volume controls. */
+	if (!is_jack_detectable(codec, 0x21))
+		return;
+
+	if (action == HDA_FIXUP_ACT_PRE_PROBE) {
+		static const hda_nid_t conn1[] = { 0x02 };
+		snd_hda_override_conn_list(codec, 0x14, ARRAY_SIZE(conn1), conn1);
+	}
+}
+
 static void alc294_fixup_gx502_hp(struct hda_codec *codec,
 					const struct hda_fixup *fix, int action)
 {
@@ -3537,6 +3551,8 @@ enum {
 	ALC269_FIXUP_DELL4_MIC_NO_PRESENCE,
 	ALC269_FIXUP_DELL4_MIC_NO_PRESENCE_QUIET,
 	ALC269_FIXUP_HEADSET_MODE,
+	ALC269_FIXUP_DMI_MATCH,
+	ALC269_FIXUP_AYA_HEADSET_VOLUME,
 	ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC,
 	ALC269_FIXUP_ASPIRE_HEADSET_MIC,
 	ALC269_FIXUP_ASUS_X101_FUNC,
@@ -3819,6 +3835,30 @@ enum {
 	ALC236_FIXUP_HP_MUTE_LED_MICMUTE_GPIO,
 };
 
+/* A special fixup for AYN and AYANEO handhelds as both
+*  have the same PCI SSID as well as the same codec, but
+*  require different quirks, falling back to DMI matching.
+*/
+static void alc269_fixup_match_via_dmi(struct hda_codec *codec,
+                                        const struct hda_fixup *fix, int action)
+{
+	int alc269_fix_id;
+	const char *board_name = dmi_get_system_info(DMI_BOARD_NAME);
+
+	if (dmi_name_in_vendors("AYANEO") || dmi_name_in_vendors("AYADEVICE") || dmi_name_in_vendors("AYA DEVICE")) {
+		if (board_name && (strcmp(board_name, "AYANEO 2") || strcmp(board_name, "AYANEO 2S") || strcmp(board_name, "GEEK") || strcmp(board_name, "GEEK 1S"))) {
+			alc269_fix_id = ALC269_FIXUP_AYA_HEADSET_VOLUME;
+		} else {
+			return;
+		}
+	} else if (dmi_name_in_vendors("ayn") && strcmp(board_name, "Loki MiniPro")) {
+		alc269_fix_id = ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX;
+	} else {
+		return;
+	}
+	__snd_hda_apply_fixup(codec, alc269_fix_id, action, 0);
+}
+
 /* A special fixup for Lenovo C940 and Yoga Duet 7;
  * both have the very same PCI SSID, and we need to apply different fixups
  * depending on the codec ID
@@ -5115,6 +5155,14 @@ static const struct hda_fixup alc269_fixups[] = {
 			{ 0x1b, 0x90170152 } /* use as internal speaker (back) */
 		}
 	},
+	[ALC269_FIXUP_DMI_MATCH] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc269_fixup_match_via_dmi,
+	},
+	[ALC269_FIXUP_AYA_HEADSET_VOLUME] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc269_fixup_headphone_volume,
+	},
 	[ALC299_FIXUP_PREDATOR_SPK] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
@@ -7376,8 +7424,9 @@ static const struct hda_quirk alc269_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x2782, 0x1701, "Infinix Y4 Max", ALC269VC_FIXUP_INFINIX_Y4_MAX),
 	SND_PCI_QUIRK(0x2782, 0x1705, "MEDION E15433", ALC269VC_FIXUP_INFINIX_Y4_MAX),
 	SND_PCI_QUIRK(0x2782, 0x1707, "Vaio VJFE-ADL", ALC298_FIXUP_SPK_VOLUME),
-	SND_PCI_QUIRK(0x2782, 0x4900, "MEDION E15443", ALC233_FIXUP_MEDION_MTL_SPK),
+	SND_PCI_QUIRK(0x1f66, 0x0101, "AYANEO 2/GEEK/Ayn MiniPro", ALC269_FIXUP_DMI_MATCH),
 	SND_PCI_QUIRK(0x1f66, 0x0103, "AYANEO AIR 1S", ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX),
+	SND_PCI_QUIRK(0x2782, 0x4900, "MEDION E15443", ALC233_FIXUP_MEDION_MTL_SPK),
 	SND_PCI_QUIRK(0x8086, 0x2074, "Intel NUC 8", ALC233_FIXUP_INTEL_NUC8_DMIC),
 	SND_PCI_QUIRK(0x8086, 0x2080, "Intel NUC 8 Rugged", ALC256_FIXUP_INTEL_NUC8_RUGGED),
 	SND_PCI_QUIRK(0x8086, 0x2081, "Intel NUC 10", ALC256_FIXUP_INTEL_NUC10),
-- 
2.52.0


From 9eddc53b6e5b6b139b1a6a9713094393f838a779 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 15 Mar 2025 23:44:25 +0100
Subject: [PATCH 073/112] remove bmi260 matches from bmi270 driver due to sleep
 issues

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/iio/imu/bmi270/bmi270_i2c.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/iio/imu/bmi270/bmi270_i2c.c b/drivers/iio/imu/bmi270/bmi270_i2c.c
index b909a421a..ae6956aa1 100644
--- a/drivers/iio/imu/bmi270/bmi270_i2c.c
+++ b/drivers/iio/imu/bmi270/bmi270_i2c.c
@@ -40,9 +40,9 @@ static const struct i2c_device_id bmi270_i2c_id[] = {
 
 static const struct acpi_device_id bmi270_acpi_match[] = {
 	/* GPD Win Mini, Aya Neo AIR Pro, OXP Mini Pro, etc. */
-	{ "BMI0160",  (kernel_ulong_t)&bmi260_chip_info },
-	/* GPD Win Max 2 2023(sincice BIOS v0.40), etc. */
-	{ "BMI0260",  (kernel_ulong_t)&bmi260_chip_info },
+	// { "BMI0160",  (kernel_ulong_t)&bmi260_chip_info },
+	// /* GPD Win Max 2 2023(sincice BIOS v0.40), etc. */
+	// { "BMI0260",  (kernel_ulong_t)&bmi260_chip_info },
 	{ }
 };
 
-- 
2.52.0


From 560b6017a2dab6b867e8c3be2831736df184474c Mon Sep 17 00:00:00 2001
From: Armin Wolf <W_Armin@gmx.de>
Date: Sun, 11 May 2025 22:44:18 +0200
Subject: [PATCH 074/112] platform/x86: msi-wmi-platform: Use input buffer for
 returning result

Modify msi_wmi_platform_query() to reuse the input buffer for
returning the result of a WMI method call. Using a separate output
buffer to return the result is unnecessary because the WMI interface
requires both buffers to have the same length anyway.

Co-developed-by: Antheas Kapenekakis <lkml@antheas.dev>
Signed-off-by: Armin Wolf <W_Armin@gmx.de>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 53 ++++++++++++-------------
 1 file changed, 26 insertions(+), 27 deletions(-)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index e912fcc12..8d0f9328c 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -22,6 +22,7 @@
 #include <linux/mutex.h>
 #include <linux/printk.h>
 #include <linux/rwsem.h>
+#include <linux/string.h>
 #include <linux/types.h>
 #include <linux/wmi.h>
 
@@ -141,19 +142,19 @@ static int msi_wmi_platform_parse_buffer(union acpi_object *obj, u8 *output, siz
 }
 
 static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
-				  enum msi_wmi_platform_method method, u8 *input,
-				  size_t input_length, u8 *output, size_t output_length)
+				  enum msi_wmi_platform_method method, u8 *buffer,
+				  size_t length)
 {
 	struct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };
 	struct acpi_buffer in = {
-		.length = input_length,
-		.pointer = input
+		.length = length,
+		.pointer = buffer
 	};
 	union acpi_object *obj;
 	acpi_status status;
 	int ret;
 
-	if (!input_length || !output_length)
+	if (!length)
 		return -EINVAL;
 
 	/*
@@ -170,7 +171,7 @@ static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
 	if (!obj)
 		return -ENODATA;
 
-	ret = msi_wmi_platform_parse_buffer(obj, output, output_length);
+	ret = msi_wmi_platform_parse_buffer(obj, buffer, length);
 	kfree(obj);
 
 	return ret;
@@ -186,17 +187,15 @@ static int msi_wmi_platform_read(struct device *dev, enum hwmon_sensor_types typ
 				 int channel, long *val)
 {
 	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
-	u8 input[32] = { 0 };
-	u8 output[32];
+	u8 buffer[32] = { 0 };
 	u16 value;
 	int ret;
 
-	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_FAN, input, sizeof(input), output,
-				     sizeof(output));
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_FAN, buf, sizeof(buf));
 	if (ret < 0)
 		return ret;
 
-	value = get_unaligned_be16(&output[channel * 2 + 1]);
+	value = get_unaligned_be16(&buffer[channel * 2 + 1]);
 	if (!value)
 		*val = 0;
 	else
@@ -246,13 +245,17 @@ static ssize_t msi_wmi_platform_write(struct file *fp, const char __user *input,
 		return ret;
 
 	down_write(&data->buffer_lock);
-	ret = msi_wmi_platform_query(data->data, data->method, payload, data->length, data->buffer,
+	ret = msi_wmi_platform_query(data->data, data->method, data->buffer,
 				     data->length);
 	up_write(&data->buffer_lock);
 
 	if (ret < 0)
 		return ret;
 
+	down_write(&data->buffer_lock);
+	memcpy(data->buffer, payload, data->length);
+	up_write(&data->buffer_lock);
+
 	return length;
 }
 
@@ -349,23 +352,21 @@ static int msi_wmi_platform_hwmon_init(struct msi_wmi_platform_data *data)
 
 static int msi_wmi_platform_ec_init(struct msi_wmi_platform_data *data)
 {
-	u8 input[32] = { 0 };
-	u8 output[32];
+	u8 buffer[32] = { 0 };
 	u8 flags;
 	int ret;
 
-	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_EC, input, sizeof(input), output,
-				     sizeof(output));
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_EC, buffer, sizeof(buffer));
 	if (ret < 0)
 		return ret;
 
-	flags = output[MSI_PLATFORM_EC_FLAGS_OFFSET];
+	flags = buffer[MSI_PLATFORM_EC_FLAGS_OFFSET];
 
 	dev_dbg(&data->wdev->dev, "EC RAM version %lu.%lu\n",
 		FIELD_GET(MSI_PLATFORM_EC_MAJOR_MASK, flags),
 		FIELD_GET(MSI_PLATFORM_EC_MINOR_MASK, flags));
 	dev_dbg(&data->wdev->dev, "EC firmware version %.28s\n",
-		&output[MSI_PLATFORM_EC_VERSION_OFFSET]);
+		&buffer[MSI_PLATFORM_EC_VERSION_OFFSET]);
 
 	if (!(flags & MSI_PLATFORM_EC_IS_TIGERLAKE)) {
 		if (!force)
@@ -379,27 +380,25 @@ static int msi_wmi_platform_ec_init(struct msi_wmi_platform_data *data)
 
 static int msi_wmi_platform_init(struct msi_wmi_platform_data *data)
 {
-	u8 input[32] = { 0 };
-	u8 output[32];
+	u8 buffer[32] = { 0 };
 	int ret;
 
-	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_WMI, input, sizeof(input), output,
-				     sizeof(output));
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_WMI, buffer, sizeof(buffer));
 	if (ret < 0)
 		return ret;
 
 	dev_dbg(&data->wdev->dev, "WMI interface version %u.%u\n",
-		output[MSI_PLATFORM_WMI_MAJOR_OFFSET],
-		output[MSI_PLATFORM_WMI_MINOR_OFFSET]);
+		buffer[MSI_PLATFORM_WMI_MAJOR_OFFSET],
+		buffer[MSI_PLATFORM_WMI_MINOR_OFFSET]);
 
-	if (output[MSI_PLATFORM_WMI_MAJOR_OFFSET] != MSI_WMI_PLATFORM_INTERFACE_VERSION) {
+	if (buffer[MSI_PLATFORM_WMI_MAJOR_OFFSET] != MSI_WMI_PLATFORM_INTERFACE_VERSION) {
 		if (!force)
 			return -ENODEV;
 
 		dev_warn(&data->wdev->dev,
 			 "Loading despite unsupported WMI interface version (%u.%u)\n",
-			 output[MSI_PLATFORM_WMI_MAJOR_OFFSET],
-			 output[MSI_PLATFORM_WMI_MINOR_OFFSET]);
+			 buffer[MSI_PLATFORM_WMI_MAJOR_OFFSET],
+			 buffer[MSI_PLATFORM_WMI_MINOR_OFFSET]);
 	}
 
 	return 0;
-- 
2.52.0


From 9d1886d1f62fd40487bfd6b64f8d2712811b6e80 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:19 +0200
Subject: [PATCH 075/112] platform/x86: msi-wmi-platform: Add unlocked
 msi_wmi_platform_query

This driver requires to be able to handle transactions that perform
multiple WMI actions at a time. Therefore, it needs to be able to
lock the wmi_lock mutex for multiple operations.

Add msi_wmi_platform_query_unlocked() to allow the caller to
perform the WMI query without locking the wmi_lock mutex, by
renaming the existing function and adding a new one that only
locks the mutex.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 27 ++++++++++++++++---------
 1 file changed, 17 insertions(+), 10 deletions(-)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 8d0f9328c..94236214c 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -141,7 +141,7 @@ static int msi_wmi_platform_parse_buffer(union acpi_object *obj, u8 *output, siz
 	return 0;
 }
 
-static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
+static int msi_wmi_platform_query_unlocked(struct msi_wmi_platform_data *data,
 				  enum msi_wmi_platform_method method, u8 *buffer,
 				  size_t length)
 {
@@ -157,15 +157,9 @@ static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
 	if (!length)
 		return -EINVAL;
 
-	/*
-	 * The ACPI control method responsible for handling the WMI method calls
-	 * is not thread-safe. Because of this we have to do the locking ourself.
-	 */
-	scoped_guard(mutex, &data->wmi_lock) {
-		status = wmidev_evaluate_method(data->wdev, 0x0, method, &in, &out);
-		if (ACPI_FAILURE(status))
-			return -EIO;
-	}
+	status = wmidev_evaluate_method(data->wdev, 0x0, method, &in, &out);
+	if (ACPI_FAILURE(status))
+		return -EIO;
 
 	obj = out.pointer;
 	if (!obj)
@@ -177,6 +171,19 @@ static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
 	return ret;
 }
 
+static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
+				  enum msi_wmi_platform_method method, u8 *buffer,
+				  size_t length)
+{
+	/*
+	 * The ACPI control method responsible for handling the WMI method calls
+	 * is not thread-safe. Because of this we have to do the locking ourself.
+	 */
+	scoped_guard(mutex, &data->wmi_lock) {
+		return msi_wmi_platform_query_unlocked(data, method, buffer, length);
+	}
+}
+
 static umode_t msi_wmi_platform_is_visible(const void *drvdata, enum hwmon_sensor_types type,
 					   u32 attr, int channel)
 {
-- 
2.52.0


From 7663a1c4d405ea0fbabf2b3d610f75474662ebff Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:20 +0200
Subject: [PATCH 076/112] platform/x86: msi-wmi-platform: Add quirk system

MSI uses the WMI interface as a passthrough for writes to the EC
and uses a board name match and a quirk table from userspace on
Windows. Therefore, there is no auto-detection functionality and
we have to fallback to a quirk table.

Introduce it here, prior to starting to add features to it.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 54 +++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 94236214c..626d284d7 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -80,8 +80,12 @@ enum msi_wmi_platform_method {
 	MSI_PLATFORM_GET_WMI		= 0x1d,
 };
 
+struct msi_wmi_platform_quirk {
+};
+
 struct msi_wmi_platform_data {
 	struct wmi_device *wdev;
+	struct msi_wmi_platform_quirk *quirks;
 	struct mutex wmi_lock;	/* Necessary when calling WMI methods */
 };
 
@@ -125,6 +129,49 @@ static const char * const msi_wmi_platform_debugfs_names[] = {
 	"get_wmi"
 };
 
+static struct msi_wmi_platform_quirk quirk_default = {};
+static struct msi_wmi_platform_quirk quirk_gen1 = {
+};
+static struct msi_wmi_platform_quirk quirk_gen2 = {
+};
+static struct msi_wmi_platform_quirk quirk_amd = {
+};
+
+static const struct dmi_system_id msi_quirks[] = {
+	{
+		.ident = "MSI Claw (gen 1)",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-1T41"),
+		},
+		.driver_data = &quirk_gen1,
+	},
+	{
+		.ident = "MSI Claw AI+ 7",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-1T42"),
+		},
+		.driver_data = &quirk_gen2,
+	},
+	{
+		.ident = "MSI Claw AI+ 8",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-1T52"),
+		},
+		.driver_data = &quirk_gen2,
+	},
+	{
+		.ident = "MSI Claw A8",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-1T8K"),
+		},
+		.driver_data = &quirk_amd,
+	},
+};
+
 static int msi_wmi_platform_parse_buffer(union acpi_object *obj, u8 *output, size_t length)
 {
 	if (obj->type != ACPI_TYPE_BUFFER)
@@ -414,6 +461,7 @@ static int msi_wmi_platform_init(struct msi_wmi_platform_data *data)
 static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 {
 	struct msi_wmi_platform_data *data;
+	const struct dmi_system_id *dmi_id;
 	int ret;
 
 	data = devm_kzalloc(&wdev->dev, sizeof(*data), GFP_KERNEL);
@@ -423,6 +471,12 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 	data->wdev = wdev;
 	dev_set_drvdata(&wdev->dev, data);
 
+	dmi_id = dmi_first_match(msi_quirks);
+	if (dmi_id)
+		data->quirks = dmi_id->driver_data;
+	else
+		data->quirks = &quirk_default;
+
 	ret = devm_mutex_init(&wdev->dev, &data->wmi_lock);
 	if (ret < 0)
 		return ret;
-- 
2.52.0


From 878875cd5c5c39f9058e2f9a55c67bf850ab7a6f Mon Sep 17 00:00:00 2001
From: Armin Wolf <W_Armin@gmx.de>
Date: Sun, 11 May 2025 22:44:21 +0200
Subject: [PATCH 077/112] platform/x86: msi-wmi-platform: Add support for fan
 control

Adds fan curve support for the MSI platform. These devices contain
support for two fans, where they are named CPU and GPU but in the
case of the Claw series just map to left and right fan.

Co-developed-by: Antheas Kapenekakis <lkml@antheas.dev>
Signed-off-by: Armin Wolf <W_Armin@gmx.de>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 .../wmi/devices/msi-wmi-platform.rst          |  26 ++
 drivers/platform/x86/msi-wmi-platform.c       | 328 +++++++++++++++++-
 2 files changed, 337 insertions(+), 17 deletions(-)

diff --git a/Documentation/wmi/devices/msi-wmi-platform.rst b/Documentation/wmi/devices/msi-wmi-platform.rst
index 73197b319..704bfdac5 100644
--- a/Documentation/wmi/devices/msi-wmi-platform.rst
+++ b/Documentation/wmi/devices/msi-wmi-platform.rst
@@ -169,6 +169,32 @@ The fan RPM readings can be calculated with the following formula:
 
 If the fan speed reading is zero, then the fan RPM is zero too.
 
+The subfeature ``0x01`` is used to retrieve the fan speed table for the CPU fan. The output
+data contains the fan speed table and two bytes with unknown data. The fan speed table
+consists of six 8-bit entries, each containing a fan speed value in percent.
+
+The subfeature ``0x02`` is used tho retrieve the same data for the GPU fan.
+
+WMI method Set_Fan()
+--------------------
+
+The fan speed tables can be accessed using subfeature ``0x01`` (CPU fan) and subfeature ``0x02``
+(GPU fan). The input data has the same format as the output data of the ``Get_Fan`` WMI method.
+
+WMI method Get_AP()
+-------------------
+
+The current fan mode can be accessed using subfeature ``0x01``. The output data contains a flag
+byte and two bytes of unknown data. If the 7th bit inside the flag byte is cleared then all fans
+are operating in automatic mode, otherwise the fans operate based on the fan speed tables
+accessible thru the ``Get_Fan``/``Set_Fan`` WMI methods.
+
+WMI method Set_AP()
+-------------------
+
+The current fan mode can be changed using subfeature ``0x01``. The input data has the same format
+as the output data of the ``Get_AP`` WMI method.
+
 WMI method Get_WMI()
 --------------------
 
diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 626d284d7..9d5564319 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -16,13 +16,18 @@
 #include <linux/device/driver.h>
 #include <linux/dmi.h>
 #include <linux/errno.h>
+#include <linux/fixp-arith.h>
 #include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
 #include <linux/kernel.h>
+#include <linux/kstrtox.h>
+#include <linux/minmax.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/printk.h>
 #include <linux/rwsem.h>
 #include <linux/string.h>
+#include <linux/sysfs.h>
 #include <linux/types.h>
 #include <linux/wmi.h>
 
@@ -34,9 +39,11 @@
 
 #define MSI_WMI_PLATFORM_INTERFACE_VERSION	2
 
+/* Get_WMI() WMI method */
 #define MSI_PLATFORM_WMI_MAJOR_OFFSET	1
 #define MSI_PLATFORM_WMI_MINOR_OFFSET	2
 
+/* Get_EC() and Set_EC() WMI methods */
 #define MSI_PLATFORM_EC_FLAGS_OFFSET	1
 #define MSI_PLATFORM_EC_MINOR_MASK	GENMASK(3, 0)
 #define MSI_PLATFORM_EC_MAJOR_MASK	GENMASK(5, 4)
@@ -44,6 +51,18 @@
 #define MSI_PLATFORM_EC_IS_TIGERLAKE	BIT(7)
 #define MSI_PLATFORM_EC_VERSION_OFFSET	2
 
+/* Get_Fan() and Set_Fan() WMI methods */
+#define MSI_PLATFORM_FAN_SUBFEATURE_FAN_SPEED		0x0
+#define MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE	0x1
+#define MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE	0x2
+#define MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE	0x1
+#define MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE	0x2
+
+/* Get_AP() and Set_AP() WMI methods */
+#define MSI_PLATFORM_AP_SUBFEATURE_FAN_MODE	0x1
+#define MSI_PLATFORM_AP_FAN_FLAGS_OFFSET	1
+#define MSI_PLATFORM_AP_ENABLE_FAN_TABLES	BIT(7)
+
 static bool force;
 module_param_unsafe(force, bool, 0);
 MODULE_PARM_DESC(force, "Force loading without checking for supported WMI interface versions");
@@ -231,9 +250,201 @@ static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
 	}
 }
 
+static ssize_t msi_wmi_platform_fan_table_show(struct device *dev, struct device_attribute *attr,
+					       char *buf)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { sattr->nr };
+	u8 fan_percent;
+	int ret;
+
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_FAN, buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	fan_percent = buffer[sattr->index + 1];
+	if (fan_percent > 100)
+		return -EIO;
+
+	return sysfs_emit(buf, "%d\n", fixp_linear_interpolate(0, 0, 100, 255, fan_percent));
+}
+
+static ssize_t msi_wmi_platform_fan_table_store(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { sattr->nr };
+	long speed;
+	int ret;
+
+	ret = kstrtol(buf, 10, &speed);
+	if (ret < 0)
+		return ret;
+
+	speed = clamp_val(speed, 0, 255);
+
+	guard(mutex)(&data->wmi_lock);
+
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_GET_FAN,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	buffer[0] = sattr->nr;
+	buffer[sattr->index + 1] = fixp_linear_interpolate(0, 0, 255, 100, speed);
+
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_SET_FAN,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t msi_wmi_platform_temp_table_show(struct device *dev, struct device_attribute *attr,
+						char *buf)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { sattr->nr };
+	u8 temp_c;
+	int ret;
+
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_TEMPERATURE,
+				     buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	temp_c = buffer[sattr->index + 1];
+
+	return sysfs_emit(buf, "%d\n", temp_c);
+}
+
+static ssize_t msi_wmi_platform_temp_table_store(struct device *dev, struct device_attribute *attr,
+						 const char *buf, size_t count)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { sattr->nr };
+	long temp_c;
+	int ret;
+
+	ret = kstrtol(buf, 10, &temp_c);
+	if (ret < 0)
+		return ret;
+
+	temp_c = clamp_val(temp_c, 0, 255);
+
+	guard(mutex)(&data->wmi_lock);
+
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_GET_TEMPERATURE,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	buffer[0] = sattr->nr;
+	buffer[sattr->index + 1] = temp_c;
+
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_SET_TEMPERATURE,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point1_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x0);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point2_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x3);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point3_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x4);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point4_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x5);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point5_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x6);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point6_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x7);
+
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point1_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x1);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point2_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x2);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point3_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x3);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point4_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x4);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point5_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x5);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point6_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x6);
+
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point1_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x0);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point2_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x3);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point3_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x4);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point4_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x5);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point5_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x6);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point6_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x7);
+
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point1_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x1);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point2_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x2);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point3_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x3);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point4_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x4);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point5_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x5);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point6_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x6);
+
+static struct attribute *msi_wmi_platform_hwmon_attrs[] = {
+	&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point3_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point4_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point5_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point6_temp.dev_attr.attr,
+
+	&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point3_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point4_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point5_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point6_pwm.dev_attr.attr,
+
+	&sensor_dev_attr_pwm2_auto_point1_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point2_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point3_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point4_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point5_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point6_temp.dev_attr.attr,
+
+	&sensor_dev_attr_pwm2_auto_point1_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point2_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point3_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point4_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point5_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point6_pwm.dev_attr.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(msi_wmi_platform_hwmon);
+
 static umode_t msi_wmi_platform_is_visible(const void *drvdata, enum hwmon_sensor_types type,
 					   u32 attr, int channel)
 {
+	if (type == hwmon_pwm && attr == hwmon_pwm_enable)
+		return 0644;
+
 	return 0444;
 }
 
@@ -243,24 +454,102 @@ static int msi_wmi_platform_read(struct device *dev, enum hwmon_sensor_types typ
 	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
 	u8 buffer[32] = { 0 };
 	u16 value;
+	u8 flags;
 	int ret;
 
-	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_FAN, buf, sizeof(buf));
-	if (ret < 0)
-		return ret;
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			buffer[0] = MSI_PLATFORM_FAN_SUBFEATURE_FAN_SPEED;
+			ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_FAN, buffer,
+						     sizeof(buffer));
+			if (ret < 0)
+				return ret;
 
-	value = get_unaligned_be16(&buffer[channel * 2 + 1]);
-	if (!value)
-		*val = 0;
-	else
-		*val = 480000 / value;
+			value = get_unaligned_be16(&buffer[channel * 2 + 1]);
+			if (!value)
+				*val = 0;
+			else
+				*val = 480000 / value;
 
-	return 0;
+			return 0;
+		default:
+			return -EOPNOTSUPP;
+		}
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_enable:
+			buffer[0] = MSI_PLATFORM_AP_SUBFEATURE_FAN_MODE;
+			ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_AP, buffer,
+						     sizeof(buffer));
+			if (ret < 0)
+				return ret;
+
+			flags = buffer[MSI_PLATFORM_AP_FAN_FLAGS_OFFSET];
+			if (flags & MSI_PLATFORM_AP_ENABLE_FAN_TABLES)
+				*val = 1;
+			else
+				*val = 2;
+
+			return 0;
+		default:
+			return -EOPNOTSUPP;
+		}
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static int msi_wmi_platform_write(struct device *dev, enum hwmon_sensor_types type, u32 attr,
+				  int channel, long val)
+{
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { };
+	int ret;
+
+	guard(mutex)(&data->wmi_lock);
+
+	switch (type) {
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_enable:
+			buffer[0] = MSI_PLATFORM_AP_SUBFEATURE_FAN_MODE;
+			ret = msi_wmi_platform_query_unlocked(
+				data, MSI_PLATFORM_GET_AP, buffer,
+				sizeof(buffer));
+			if (ret < 0)
+				return ret;
+
+			buffer[0] = MSI_PLATFORM_AP_SUBFEATURE_FAN_MODE;
+			switch (val) {
+			case 1:
+				buffer[MSI_PLATFORM_AP_FAN_FLAGS_OFFSET] |=
+					MSI_PLATFORM_AP_ENABLE_FAN_TABLES;
+				break;
+			case 2:
+				buffer[MSI_PLATFORM_AP_FAN_FLAGS_OFFSET] &=
+					~MSI_PLATFORM_AP_ENABLE_FAN_TABLES;
+				break;
+			default:
+				return -EINVAL;
+			}
+
+			return msi_wmi_platform_query_unlocked(
+				data, MSI_PLATFORM_SET_AP, buffer,
+				sizeof(buffer));
+		default:
+			return -EOPNOTSUPP;
+		}
+	default:
+		return -EOPNOTSUPP;
+	}
 }
 
 static const struct hwmon_ops msi_wmi_platform_ops = {
 	.is_visible = msi_wmi_platform_is_visible,
 	.read = msi_wmi_platform_read,
+	.write = msi_wmi_platform_write,
 };
 
 static const struct hwmon_channel_info * const msi_wmi_platform_info[] = {
@@ -270,6 +559,10 @@ static const struct hwmon_channel_info * const msi_wmi_platform_info[] = {
 			   HWMON_F_INPUT,
 			   HWMON_F_INPUT
 			   ),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_ENABLE,
+			   HWMON_PWM_ENABLE
+			   ),
 	NULL
 };
 
@@ -278,8 +571,8 @@ static const struct hwmon_chip_info msi_wmi_platform_chip_info = {
 	.info = msi_wmi_platform_info,
 };
 
-static ssize_t msi_wmi_platform_write(struct file *fp, const char __user *input, size_t length,
-				      loff_t *offset)
+static ssize_t msi_wmi_platform_debugfs_write(struct file *fp, const char __user *input,
+					      size_t length, loff_t *offset)
 {
 	struct seq_file *seq = fp->private_data;
 	struct msi_wmi_platform_debugfs_data *data = seq->private;
@@ -313,7 +606,7 @@ static ssize_t msi_wmi_platform_write(struct file *fp, const char __user *input,
 	return length;
 }
 
-static int msi_wmi_platform_show(struct seq_file *seq, void *p)
+static int msi_wmi_platform_debugfs_show(struct seq_file *seq, void *p)
 {
 	struct msi_wmi_platform_debugfs_data *data = seq->private;
 	int ret;
@@ -325,19 +618,19 @@ static int msi_wmi_platform_show(struct seq_file *seq, void *p)
 	return ret;
 }
 
-static int msi_wmi_platform_open(struct inode *inode, struct file *fp)
+static int msi_wmi_platform_debugfs_open(struct inode *inode, struct file *fp)
 {
 	struct msi_wmi_platform_debugfs_data *data = inode->i_private;
 
 	/* The seq_file uses the last byte of the buffer for detecting buffer overflows */
-	return single_open_size(fp, msi_wmi_platform_show, data, data->length + 1);
+	return single_open_size(fp, msi_wmi_platform_debugfs_show, data, data->length + 1);
 }
 
 static const struct file_operations msi_wmi_platform_debugfs_fops = {
 	.owner = THIS_MODULE,
-	.open = msi_wmi_platform_open,
+	.open = msi_wmi_platform_debugfs_open,
 	.read = seq_read,
-	.write = msi_wmi_platform_write,
+	.write = msi_wmi_platform_debugfs_write,
 	.llseek = seq_lseek,
 	.release = single_release,
 };
@@ -399,7 +692,8 @@ static int msi_wmi_platform_hwmon_init(struct msi_wmi_platform_data *data)
 	struct device *hdev;
 
 	hdev = devm_hwmon_device_register_with_info(&data->wdev->dev, "msi_wmi_platform", data,
-						    &msi_wmi_platform_chip_info, NULL);
+						    &msi_wmi_platform_chip_info,
+						    msi_wmi_platform_hwmon_groups);
 
 	return PTR_ERR_OR_ZERO(hdev);
 }
-- 
2.52.0


From d43e6eb40a3d75877757b002b62f405ef3fd8935 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:22 +0200
Subject: [PATCH 078/112] platform/x86: msi-wmi-platform: Add platform profile
 through shift mode

MSI's version of platform profile in Windows is called shift mode.
Introduce it here, and add a profile handler to it.

It has 5 modes: sport, comfort, green, eco, and user.
Confusingly, for the Claw, MSI only uses sport, green, and eco,
where they correspond to performance, balanced, and low-power.
Therefore, comfort is mapped to balanced-performance, and user to
custom.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/Kconfig            |   1 +
 drivers/platform/x86/msi-wmi-platform.c | 113 ++++++++++++++++++++++++
 2 files changed, 114 insertions(+)

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 4cb7d97a9..713211395 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -555,6 +555,7 @@ config MSI_WMI_PLATFORM
 	depends on ACPI_WMI
 	depends on DMI
 	depends on HWMON
+	select ACPI_PLATFORM_PROFILE
 	help
 	  Say Y here if you want to have support for WMI-based platform features
 	  like fan sensor access on MSI machines.
diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 9d5564319..f363a82ab 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -17,6 +17,7 @@
 #include <linux/dmi.h>
 #include <linux/errno.h>
 #include <linux/fixp-arith.h>
+#include <linux/platform_profile.h>
 #include <linux/hwmon.h>
 #include <linux/hwmon-sysfs.h>
 #include <linux/kernel.h>
@@ -63,6 +64,16 @@
 #define MSI_PLATFORM_AP_FAN_FLAGS_OFFSET	1
 #define MSI_PLATFORM_AP_ENABLE_FAN_TABLES	BIT(7)
 
+/* Get_Data() and Set_Data() Shift Mode Register */
+#define MSI_PLATFORM_SHIFT_ADDR		0xd2
+#define MSI_PLATFORM_SHIFT_DISABLE	BIT(7)
+#define MSI_PLATFORM_SHIFT_ENABLE	(BIT(7) | BIT(6))
+#define MSI_PLATFORM_SHIFT_SPORT	(MSI_PLATFORM_SHIFT_ENABLE + 4)
+#define MSI_PLATFORM_SHIFT_COMFORT	(MSI_PLATFORM_SHIFT_ENABLE + 0)
+#define MSI_PLATFORM_SHIFT_GREEN	(MSI_PLATFORM_SHIFT_ENABLE + 1)
+#define MSI_PLATFORM_SHIFT_ECO		(MSI_PLATFORM_SHIFT_ENABLE + 2)
+#define MSI_PLATFORM_SHIFT_USER		(MSI_PLATFORM_SHIFT_ENABLE + 3)
+
 static bool force;
 module_param_unsafe(force, bool, 0);
 MODULE_PARM_DESC(force, "Force loading without checking for supported WMI interface versions");
@@ -100,12 +111,14 @@ enum msi_wmi_platform_method {
 };
 
 struct msi_wmi_platform_quirk {
+	bool shift_mode;	/* Shift mode is supported */
 };
 
 struct msi_wmi_platform_data {
 	struct wmi_device *wdev;
 	struct msi_wmi_platform_quirk *quirks;
 	struct mutex wmi_lock;	/* Necessary when calling WMI methods */
+	struct device *ppdev;
 };
 
 struct msi_wmi_platform_debugfs_data {
@@ -150,8 +163,10 @@ static const char * const msi_wmi_platform_debugfs_names[] = {
 
 static struct msi_wmi_platform_quirk quirk_default = {};
 static struct msi_wmi_platform_quirk quirk_gen1 = {
+	.shift_mode = true
 };
 static struct msi_wmi_platform_quirk quirk_gen2 = {
+	.shift_mode = true
 };
 static struct msi_wmi_platform_quirk quirk_amd = {
 };
@@ -571,6 +586,90 @@ static const struct hwmon_chip_info msi_wmi_platform_chip_info = {
 	.info = msi_wmi_platform_info,
 };
 
+static int msi_wmi_platform_profile_probe(void *drvdata, unsigned long *choices)
+{
+	set_bit(PLATFORM_PROFILE_LOW_POWER, choices);
+	set_bit(PLATFORM_PROFILE_BALANCED, choices);
+	set_bit(PLATFORM_PROFILE_BALANCED_PERFORMANCE, choices);
+	set_bit(PLATFORM_PROFILE_PERFORMANCE, choices);
+	return 0;
+}
+
+static int msi_wmi_platform_profile_get(struct device *dev,
+					enum platform_profile_option *profile)
+{
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	u8 buffer[32] = { };
+
+	buffer[0] = MSI_PLATFORM_SHIFT_ADDR;
+
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_DATA, buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	if (buffer[0] != 1)
+		return -EINVAL;
+
+	switch (buffer[1]) {
+	case MSI_PLATFORM_SHIFT_SPORT:
+		*profile = PLATFORM_PROFILE_PERFORMANCE;
+		return 0;
+	case MSI_PLATFORM_SHIFT_COMFORT:
+		*profile = PLATFORM_PROFILE_BALANCED_PERFORMANCE;
+		return 0;
+	case MSI_PLATFORM_SHIFT_GREEN:
+		*profile = PLATFORM_PROFILE_BALANCED;
+		return 0;
+	case MSI_PLATFORM_SHIFT_ECO:
+		*profile = PLATFORM_PROFILE_LOW_POWER;
+		return 0;
+	case MSI_PLATFORM_SHIFT_USER:
+		*profile = PLATFORM_PROFILE_CUSTOM;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int msi_wmi_platform_profile_set(struct device *dev,
+					enum platform_profile_option profile)
+{
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { };
+
+	buffer[0] = MSI_PLATFORM_SHIFT_ADDR;
+
+	switch (profile) {
+	case PLATFORM_PROFILE_PERFORMANCE:
+		buffer[1] = MSI_PLATFORM_SHIFT_SPORT;
+		break;
+	case PLATFORM_PROFILE_BALANCED_PERFORMANCE:
+		buffer[1] = MSI_PLATFORM_SHIFT_COMFORT;
+		break;
+	case PLATFORM_PROFILE_BALANCED:
+		buffer[1] = MSI_PLATFORM_SHIFT_GREEN;
+		break;
+	case PLATFORM_PROFILE_LOW_POWER:
+		buffer[1] = MSI_PLATFORM_SHIFT_ECO;
+		break;
+	case PLATFORM_PROFILE_CUSTOM:
+		buffer[1] = MSI_PLATFORM_SHIFT_USER;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return msi_wmi_platform_query(data, MSI_PLATFORM_SET_DATA, buffer, sizeof(buffer));
+}
+
+static const struct platform_profile_ops msi_wmi_platform_profile_ops = {
+	.probe = msi_wmi_platform_profile_probe,
+	.profile_get = msi_wmi_platform_profile_get,
+	.profile_set = msi_wmi_platform_profile_set,
+};
+
 static ssize_t msi_wmi_platform_debugfs_write(struct file *fp, const char __user *input,
 					      size_t length, loff_t *offset)
 {
@@ -752,6 +851,18 @@ static int msi_wmi_platform_init(struct msi_wmi_platform_data *data)
 	return 0;
 }
 
+static int msi_wmi_platform_profile_setup(struct msi_wmi_platform_data *data)
+{
+	if (!data->quirks->shift_mode)
+		return 0;
+
+	data->ppdev = devm_platform_profile_register(
+		&data->wdev->dev, "msi-wmi-platform", data,
+		&msi_wmi_platform_profile_ops);
+
+	return PTR_ERR_OR_ZERO(data->ppdev);
+}
+
 static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 {
 	struct msi_wmi_platform_data *data;
@@ -785,6 +896,8 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 
 	msi_wmi_platform_debugfs_init(data);
 
+	msi_wmi_platform_profile_setup(data);
+
 	return msi_wmi_platform_hwmon_init(data);
 }
 
-- 
2.52.0


From 7e1af26fdbf960a8dcffb66ea9515c42fe85bc77 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:23 +0200
Subject: [PATCH 079/112] platform/x86: msi-wmi-platform: Add tunable support
 via firmware attributes

Adds PL1/PL2/SPL/SPPT/FPPT support through the firmware attributes
interface. The min and max values are quirked, and the attributes are
only defined if they are set to a non-zero value. These values are meant
to be set in conjunction with shift mode, where shift mode automatically
sets an upper bound those (e.g., low-power would be used with 8W).

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/Kconfig            |   1 +
 drivers/platform/x86/msi-wmi-platform.c | 382 +++++++++++++++++++++++-
 2 files changed, 381 insertions(+), 2 deletions(-)

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 713211395..1ce198133 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -556,6 +556,7 @@ config MSI_WMI_PLATFORM
 	depends on DMI
 	depends on HWMON
 	select ACPI_PLATFORM_PROFILE
+	select FW_ATTR_CLASS
 	help
 	  Say Y here if you want to have support for WMI-based platform features
 	  like fan sensor access on MSI machines.
diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index f363a82ab..f4afeab94 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -34,6 +34,8 @@
 
 #include <linux/unaligned.h>
 
+#include "firmware_attributes_class.h"
+
 #define DRIVER_NAME	"msi-wmi-platform"
 
 #define MSI_PLATFORM_GUID	"ABBC0F6E-8EA1-11D1-00A0-C90629100000"
@@ -74,6 +76,11 @@
 #define MSI_PLATFORM_SHIFT_ECO		(MSI_PLATFORM_SHIFT_ENABLE + 2)
 #define MSI_PLATFORM_SHIFT_USER		(MSI_PLATFORM_SHIFT_ENABLE + 3)
 
+/* Get_Data() and Set_Data() Params */
+#define MSI_PLATFORM_PPT_PL1_SPL_ADDR	0x50
+#define MSI_PLATFORM_PPT_PL2_SPPT_ADDR	0x51
+#define MSI_PLATFORM_PPT_PL3_FPPT_ADDR	0x52
+
 static bool force;
 module_param_unsafe(force, bool, 0);
 MODULE_PARM_DESC(force, "Force loading without checking for supported WMI interface versions");
@@ -112,6 +119,10 @@ enum msi_wmi_platform_method {
 
 struct msi_wmi_platform_quirk {
 	bool shift_mode;	/* Shift mode is supported */
+	int ppt_min;		/* Minimum PLx value */
+	int ppt_pl1_spl_max;	/* Maximum PL1/SPL value */
+	int ppt_pl2_sppt_max;	/* Maximum PL2/SPPT value */
+	int ppt_pl3_fppt;		/* Maximum FPPT value */
 };
 
 struct msi_wmi_platform_data {
@@ -119,6 +130,47 @@ struct msi_wmi_platform_data {
 	struct msi_wmi_platform_quirk *quirks;
 	struct mutex wmi_lock;	/* Necessary when calling WMI methods */
 	struct device *ppdev;
+	struct device *fw_attrs_dev;
+	struct kset *fw_attrs_kset;
+};
+
+enum msi_fw_attr_id {
+	MSI_ATTR_PPT_PL1_SPL,
+	MSI_ATTR_PPT_PL2_SPPT,
+	MSI_ATTR_PPT_PL3_FPPT,
+};
+
+static const char *const msi_fw_attr_name[] = {
+	[MSI_ATTR_PPT_PL1_SPL] = "ppt_pl1_spl",
+	[MSI_ATTR_PPT_PL2_SPPT] = "ppt_pl2_sppt",
+	[MSI_ATTR_PPT_PL3_FPPT] = "ppt_pl3_fppt",
+};
+
+static const char *const msi_fw_attr_desc[] = {
+	[MSI_ATTR_PPT_PL1_SPL] = "CPU Steady package limit (PL1/SPL)",
+	[MSI_ATTR_PPT_PL2_SPPT] = "CPU Boost slow package limit (PL2/SPPT)",
+	[MSI_ATTR_PPT_PL3_FPPT] = "CPU Boost fast package limit (FPPT)",
+};
+
+#define MSI_ATTR_LANGUAGE_CODE "en_US.UTF-8"
+
+struct msi_fw_attr {
+	struct msi_wmi_platform_data *data;
+	enum msi_fw_attr_id fw_attr_id;
+	struct attribute_group attr_group;
+	struct kobj_attribute display_name;
+	struct kobj_attribute current_value;
+	struct kobj_attribute min_value;
+	struct kobj_attribute max_value;
+
+	u32 min;
+	u32 max;
+
+	int (*get_value)(struct msi_wmi_platform_data *data,
+			 struct msi_fw_attr *fw_attr, char *buf);
+	ssize_t (*set_value)(struct msi_wmi_platform_data *data,
+			     struct msi_fw_attr *fw_attr, const char *buf,
+			     size_t count);
 };
 
 struct msi_wmi_platform_debugfs_data {
@@ -163,12 +215,23 @@ static const char * const msi_wmi_platform_debugfs_names[] = {
 
 static struct msi_wmi_platform_quirk quirk_default = {};
 static struct msi_wmi_platform_quirk quirk_gen1 = {
-	.shift_mode = true
+	.shift_mode = true,
+	.ppt_min = 8,
+	.ppt_pl1_spl_max = 43,
+	.ppt_pl2_sppt_max = 45
 };
 static struct msi_wmi_platform_quirk quirk_gen2 = {
-	.shift_mode = true
+	.shift_mode = true,
+	.ppt_min = 8,
+	.ppt_pl1_spl_max = 30,
+	.ppt_pl2_sppt_max = 37,
 };
 static struct msi_wmi_platform_quirk quirk_amd = {
+	.shift_mode = true,
+	.ppt_min = 4,
+	.ppt_pl1_spl_max = 37,
+	.ppt_pl2_sppt_max = 45,
+	.ppt_pl3_fppt = 55
 };
 
 static const struct dmi_system_id msi_quirks[] = {
@@ -670,6 +733,317 @@ static const struct platform_profile_ops msi_wmi_platform_profile_ops = {
 	.profile_set = msi_wmi_platform_profile_set,
 };
 
+/* Firmware Attributes setup */
+static int data_get_addr(struct msi_wmi_platform_data *data,
+			 const enum msi_fw_attr_id id)
+{
+	switch (id) {
+	case MSI_ATTR_PPT_PL1_SPL:
+		return MSI_PLATFORM_PPT_PL1_SPL_ADDR;
+	case MSI_ATTR_PPT_PL2_SPPT:
+		return MSI_PLATFORM_PPT_PL2_SPPT_ADDR;
+	case MSI_ATTR_PPT_PL3_FPPT:
+		return MSI_PLATFORM_PPT_PL3_FPPT_ADDR;
+	default:
+		pr_warn("Invalid attribute id %d\n", id);
+		return -EINVAL;
+	}
+}
+
+static ssize_t data_set_value(struct msi_wmi_platform_data *data,
+			      struct msi_fw_attr *fw_attr, const char *buf,
+			      size_t count)
+{
+	u8 buffer[32] = { 0 };
+	int ret, fwid;
+	u32 value;
+
+	fwid = data_get_addr(data, fw_attr->fw_attr_id);
+	if (fwid < 0)
+		return fwid;
+
+	ret = kstrtou32(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	if (fw_attr->min >= 0 && value < fw_attr->min)
+		return -EINVAL;
+	if (fw_attr->max >= 0 && value > fw_attr->max)
+		return -EINVAL;
+
+	buffer[0] = fwid;
+	put_unaligned_le32(value, &buffer[1]);
+
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_SET_DATA, buffer, sizeof(buffer));
+	if (ret) {
+		pr_warn("Failed to set_data with id %d: %d\n",
+			fw_attr->fw_attr_id, ret);
+		return ret;
+	}
+
+	return count;
+}
+
+static int data_get_value(struct msi_wmi_platform_data *data,
+			  struct msi_fw_attr *fw_attr, char *buf)
+{
+	u8 buffer[32] = { 0 };
+	u32 value;
+	int ret, addr;
+
+	addr = data_get_addr(data, fw_attr->fw_attr_id);
+	if (addr < 0)
+		return addr;
+
+	buffer[0] = addr;
+
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_DATA, buffer, sizeof(buffer));
+	if (ret) {
+		pr_warn("Failed to show set_data for id %d: %d\n",
+			fw_attr->fw_attr_id, ret);
+		return ret;
+	}
+
+	value = get_unaligned_le32(&buffer[1]);
+
+	return sysfs_emit(buf, "%d\n", value);
+}
+
+static ssize_t display_name_language_code_show(struct kobject *kobj, struct kobj_attribute *attr,
+					       char *buf)
+{
+	return sysfs_emit(buf, "%s\n", MSI_ATTR_LANGUAGE_CODE);
+}
+
+static struct kobj_attribute fw_attr_display_name_language_code =
+	__ATTR_RO(display_name_language_code);
+
+static ssize_t scalar_increment_show(struct kobject *kobj,
+					       struct kobj_attribute *attr,
+					       char *buf)
+{
+	return sysfs_emit(buf, "1\n");
+}
+
+static struct kobj_attribute fw_attr_scalar_increment =
+	__ATTR_RO(scalar_increment);
+
+static ssize_t pending_reboot_show(struct kobject *kobj,
+				     struct kobj_attribute *attr, char *buf)
+{
+	return sysfs_emit(buf, "0\n");
+}
+
+static struct kobj_attribute fw_attr_pending_reboot = __ATTR_RO(pending_reboot);
+
+static ssize_t display_name_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	struct msi_fw_attr *fw_attr =
+		container_of(attr, struct msi_fw_attr, display_name);
+
+	return sysfs_emit(buf, "%s\n", msi_fw_attr_desc[fw_attr->fw_attr_id]);
+}
+
+static ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	struct msi_fw_attr *fw_attr =
+		container_of(attr, struct msi_fw_attr, current_value);
+
+	return fw_attr->get_value(fw_attr->data, fw_attr, buf);
+}
+
+static ssize_t current_value_store(struct kobject *kobj, struct kobj_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct msi_fw_attr *fw_attr =
+		container_of(attr, struct msi_fw_attr, current_value);
+
+	return fw_attr->set_value(fw_attr->data, fw_attr, buf, count);
+}
+
+static ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	return sysfs_emit(buf, "integer\n");
+}
+
+static struct kobj_attribute fw_attr_type_int = {
+	.attr = { .name = "type", .mode = 0444 },
+	.show = type_show,
+};
+
+static ssize_t min_value_show(struct kobject *kobj, struct kobj_attribute *attr,
+			      char *buf)
+{
+	struct msi_fw_attr *fw_attr =
+		container_of(attr, struct msi_fw_attr, min_value);
+
+	return sysfs_emit(buf, "%d\n", fw_attr->min);
+}
+
+static ssize_t max_value_show(struct kobject *kobj, struct kobj_attribute *attr,
+			      char *buf)
+{
+	struct msi_fw_attr *fw_attr =
+		container_of(attr, struct msi_fw_attr, max_value);
+
+	return sysfs_emit(buf, "%d\n", fw_attr->max);
+}
+
+#define FW_ATTR_ENUM_MAX_ATTRS  7
+
+static int
+msi_fw_attr_init(struct msi_wmi_platform_data *data,
+		 const enum msi_fw_attr_id fw_attr_id,
+		 struct kobj_attribute *fw_attr_type, const s32 min,
+		 const s32 max,
+		 int (*get_value)(struct msi_wmi_platform_data *data,
+				  struct msi_fw_attr *fw_attr, char *buf),
+		 ssize_t (*set_value)(struct msi_wmi_platform_data *data,
+				      struct msi_fw_attr *fw_attr,
+				      const char *buf, size_t count))
+{
+	struct msi_fw_attr *fw_attr;
+	struct attribute **attrs;
+	int idx = 0;
+
+	fw_attr = devm_kzalloc(&data->wdev->dev, sizeof(*fw_attr), GFP_KERNEL);
+	if (!fw_attr)
+		return -ENOMEM;
+
+	attrs = devm_kcalloc(&data->wdev->dev, FW_ATTR_ENUM_MAX_ATTRS + 1,
+			     sizeof(*attrs), GFP_KERNEL);
+	if (!attrs)
+		return -ENOMEM;
+
+	fw_attr->data = data;
+	fw_attr->fw_attr_id = fw_attr_id;
+	fw_attr->attr_group.name = msi_fw_attr_name[fw_attr_id];
+	fw_attr->attr_group.attrs = attrs;
+	fw_attr->get_value = get_value;
+	fw_attr->set_value = set_value;
+
+	attrs[idx++] = &fw_attr_type->attr;
+	if (fw_attr_type == &fw_attr_type_int)
+		attrs[idx++] = &fw_attr_scalar_increment.attr;
+	attrs[idx++] = &fw_attr_display_name_language_code.attr;
+
+	sysfs_attr_init(&fw_attr->display_name.attr);
+	fw_attr->display_name.attr.name = "display_name";
+	fw_attr->display_name.attr.mode = 0444;
+	fw_attr->display_name.show = display_name_show;
+	attrs[idx++] = &fw_attr->display_name.attr;
+
+	sysfs_attr_init(&fw_attr->current_value.attr);
+	fw_attr->current_value.attr.name = "current_value";
+	fw_attr->current_value.attr.mode = 0644;
+	fw_attr->current_value.show = current_value_show;
+	fw_attr->current_value.store = current_value_store;
+	attrs[idx++] = &fw_attr->current_value.attr;
+
+	if (min >= 0) {
+		fw_attr->min = min;
+		sysfs_attr_init(&fw_attr->min_value.attr);
+		fw_attr->min_value.attr.name = "min_value";
+		fw_attr->min_value.attr.mode = 0444;
+		fw_attr->min_value.show = min_value_show;
+		attrs[idx++] = &fw_attr->min_value.attr;
+	} else {
+		fw_attr->min = -1;
+	}
+
+	if (max >= 0) {
+		fw_attr->max = max;
+		sysfs_attr_init(&fw_attr->max_value.attr);
+		fw_attr->max_value.attr.name = "max_value";
+		fw_attr->max_value.attr.mode = 0444;
+		fw_attr->max_value.show = max_value_show;
+		attrs[idx++] = &fw_attr->max_value.attr;
+	} else {
+		fw_attr->max = -1;
+	}
+
+	attrs[idx] = NULL;
+	return sysfs_create_group(&data->fw_attrs_kset->kobj, &fw_attr->attr_group);
+}
+
+static void msi_kset_unregister(void *data)
+{
+	struct kset *kset = data;
+
+	sysfs_remove_file(&kset->kobj, &fw_attr_pending_reboot.attr);
+	kset_unregister(kset);
+}
+
+static void msi_fw_attrs_dev_unregister(void *data)
+{
+	struct device *fw_attrs_dev = data;
+
+	device_unregister(fw_attrs_dev);
+}
+
+static int msi_wmi_fw_attrs_init(struct msi_wmi_platform_data *data)
+{
+	int err;
+
+	data->fw_attrs_dev = device_create(&firmware_attributes_class, NULL, MKDEV(0, 0),
+						 NULL, "%s", DRIVER_NAME);
+	if (IS_ERR(data->fw_attrs_dev))
+		return PTR_ERR(data->fw_attrs_dev);
+
+	err = devm_add_action_or_reset(&data->wdev->dev,
+				       msi_fw_attrs_dev_unregister,
+				       data->fw_attrs_dev);
+	if (err)
+		return err;
+
+	data->fw_attrs_kset = kset_create_and_add("attributes", NULL,
+						  &data->fw_attrs_dev->kobj);
+	if (!data->fw_attrs_kset)
+		return -ENOMEM;
+
+	err = sysfs_create_file(&data->fw_attrs_kset->kobj,
+				&fw_attr_pending_reboot.attr);
+	if (err) {
+		kset_unregister(data->fw_attrs_kset);
+		return err;
+	}
+
+	err = devm_add_action_or_reset(&data->wdev->dev, msi_kset_unregister,
+				       data->fw_attrs_kset);
+	if (err)
+		return err;
+
+	if (data->quirks->ppt_pl1_spl_max) {
+		err = msi_fw_attr_init(data, MSI_ATTR_PPT_PL1_SPL,
+					&fw_attr_type_int, data->quirks->ppt_min,
+					data->quirks->ppt_pl1_spl_max,
+					&data_get_value, &data_set_value);
+		if (err)
+			return err;
+	}
+
+	if (data->quirks->ppt_pl2_sppt_max) {
+		err = msi_fw_attr_init(data, MSI_ATTR_PPT_PL2_SPPT,
+				       &fw_attr_type_int, data->quirks->ppt_min,
+				       data->quirks->ppt_pl2_sppt_max,
+				       &data_get_value, &data_set_value);
+		if (err)
+			return err;
+	}
+
+	if (data->quirks->ppt_pl3_fppt) {
+		err = msi_fw_attr_init(data, MSI_ATTR_PPT_PL3_FPPT,
+				       &fw_attr_type_int, data->quirks->ppt_min,
+				       data->quirks->ppt_pl3_fppt,
+				       &data_get_value, &data_set_value);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
 static ssize_t msi_wmi_platform_debugfs_write(struct file *fp, const char __user *input,
 					      size_t length, loff_t *offset)
 {
@@ -894,6 +1268,10 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 	if (ret < 0)
 		return ret;
 
+	ret = msi_wmi_fw_attrs_init(data);
+	if (ret < 0)
+		return ret;
+
 	msi_wmi_platform_debugfs_init(data);
 
 	msi_wmi_platform_profile_setup(data);
-- 
2.52.0


From e01e6f9e5c0832b7c511669be51ff61776695fda Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:24 +0200
Subject: [PATCH 080/112] platform/x86: msi-wmi-platform: Add charge_threshold
 support

The battery of MSI laptops supports charge threshold. Add support for it.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/Kconfig            |   1 +
 drivers/platform/x86/msi-wmi-platform.c | 111 ++++++++++++++++++++++++
 2 files changed, 112 insertions(+)

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 1ce198133..7d104b2d4 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -552,6 +552,7 @@ config MSI_WMI
 
 config MSI_WMI_PLATFORM
 	tristate "MSI WMI Platform features"
+	depends on ACPI_BATTERY
 	depends on ACPI_WMI
 	depends on DMI
 	depends on HWMON
diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index f4afeab94..7cd967f57 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -31,6 +31,7 @@
 #include <linux/sysfs.h>
 #include <linux/types.h>
 #include <linux/wmi.h>
+#include <acpi/battery.h>
 
 #include <linux/unaligned.h>
 
@@ -80,6 +81,7 @@
 #define MSI_PLATFORM_PPT_PL1_SPL_ADDR	0x50
 #define MSI_PLATFORM_PPT_PL2_SPPT_ADDR	0x51
 #define MSI_PLATFORM_PPT_PL3_FPPT_ADDR	0x52
+#define MSI_PLATFORM_BAT_ADDR	0xd7
 
 static bool force;
 module_param_unsafe(force, bool, 0);
@@ -119,6 +121,7 @@ enum msi_wmi_platform_method {
 
 struct msi_wmi_platform_quirk {
 	bool shift_mode;	/* Shift mode is supported */
+	bool charge_threshold;	/* Charge threshold is supported */
 	int ppt_min;		/* Minimum PLx value */
 	int ppt_pl1_spl_max;	/* Maximum PL1/SPL value */
 	int ppt_pl2_sppt_max;	/* Maximum PL2/SPPT value */
@@ -130,6 +133,7 @@ struct msi_wmi_platform_data {
 	struct msi_wmi_platform_quirk *quirks;
 	struct mutex wmi_lock;	/* Necessary when calling WMI methods */
 	struct device *ppdev;
+	struct acpi_battery_hook battery_hook;
 	struct device *fw_attrs_dev;
 	struct kset *fw_attrs_kset;
 };
@@ -216,18 +220,21 @@ static const char * const msi_wmi_platform_debugfs_names[] = {
 static struct msi_wmi_platform_quirk quirk_default = {};
 static struct msi_wmi_platform_quirk quirk_gen1 = {
 	.shift_mode = true,
+	.charge_threshold = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 43,
 	.ppt_pl2_sppt_max = 45
 };
 static struct msi_wmi_platform_quirk quirk_gen2 = {
 	.shift_mode = true,
+	.charge_threshold = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 30,
 	.ppt_pl2_sppt_max = 37,
 };
 static struct msi_wmi_platform_quirk quirk_amd = {
 	.shift_mode = true,
+	.charge_threshold = true,
 	.ppt_min = 4,
 	.ppt_pl1_spl_max = 37,
 	.ppt_pl2_sppt_max = 45,
@@ -1044,6 +1051,94 @@ static int msi_wmi_fw_attrs_init(struct msi_wmi_platform_data *data)
 	return 0;
 }
 
+static int msi_platform_psy_ext_get_prop(struct power_supply *psy,
+					 const struct power_supply_ext *ext,
+					 void *data,
+					 enum power_supply_property psp,
+					 union power_supply_propval *val)
+{
+	struct msi_wmi_platform_data *msi = data;
+	u8 buffer[32] = { 0 };
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD:
+		buffer[0] = MSI_PLATFORM_BAT_ADDR;
+		ret = msi_wmi_platform_query(msi, MSI_PLATFORM_GET_DATA,
+					     buffer, sizeof(buffer));
+		if (ret)
+			return ret;
+
+		val->intval = buffer[1] & ~BIT(7);
+		if (val->intval > 100)
+			return -EINVAL;
+
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int msi_platform_psy_ext_set_prop(struct power_supply *psy,
+					 const struct power_supply_ext *ext,
+					 void *data,
+					 enum power_supply_property psp,
+					 const union power_supply_propval *val)
+{
+	struct msi_wmi_platform_data *msi = data;
+	u8 buffer[32] = { 0 };
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD:
+		if (val->intval > 100)
+			return -EINVAL;
+		buffer[0] = MSI_PLATFORM_BAT_ADDR;
+		buffer[1] = val->intval | BIT(7);
+		return msi_wmi_platform_query(msi, MSI_PLATFORM_SET_DATA,
+					      buffer, sizeof(buffer));
+	default:
+		return -EINVAL;
+	}
+}
+
+static int
+msi_platform_psy_prop_is_writeable(struct power_supply *psy,
+				   const struct power_supply_ext *ext,
+				   void *data, enum power_supply_property psp)
+{
+	return true;
+}
+
+static const enum power_supply_property oxp_psy_ext_props[] = {
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD,
+};
+
+static const struct power_supply_ext msi_platform_psy_ext = {
+	.name			= "msi-platform-charge-control",
+	.properties		= oxp_psy_ext_props,
+	.num_properties		= ARRAY_SIZE(oxp_psy_ext_props),
+	.get_property		= msi_platform_psy_ext_get_prop,
+	.set_property		= msi_platform_psy_ext_set_prop,
+	.property_is_writeable	= msi_platform_psy_prop_is_writeable,
+};
+
+static int msi_wmi_platform_battery_add(struct power_supply *battery,
+					struct acpi_battery_hook *hook)
+{
+	struct msi_wmi_platform_data *data =
+		container_of(hook, struct msi_wmi_platform_data, battery_hook);
+
+	return power_supply_register_extension(battery, &msi_platform_psy_ext,
+					       &data->wdev->dev, data);
+}
+
+static int msi_wmi_platform_battery_remove(struct power_supply *battery,
+					   struct acpi_battery_hook *hook)
+{
+	power_supply_unregister_extension(battery, &msi_platform_psy_ext);
+	return 0;
+}
+
 static ssize_t msi_wmi_platform_debugfs_write(struct file *fp, const char __user *input,
 					      size_t length, loff_t *offset)
 {
@@ -1272,6 +1367,13 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 	if (ret < 0)
 		return ret;
 
+	if (data->quirks->charge_threshold) {
+		data->battery_hook.name = "MSI Battery";
+		data->battery_hook.add_battery = msi_wmi_platform_battery_add;
+		data->battery_hook.remove_battery = msi_wmi_platform_battery_remove;
+		battery_hook_register(&data->battery_hook);
+	}
+
 	msi_wmi_platform_debugfs_init(data);
 
 	msi_wmi_platform_profile_setup(data);
@@ -1279,6 +1381,14 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 	return msi_wmi_platform_hwmon_init(data);
 }
 
+static void msi_wmi_platform_remove(struct wmi_device *wdev)
+{
+	struct msi_wmi_platform_data *data = dev_get_drvdata(&wdev->dev);
+
+	if (data->quirks->charge_threshold)
+		battery_hook_unregister(&data->battery_hook);
+}
+
 static const struct wmi_device_id msi_wmi_platform_id_table[] = {
 	{ MSI_PLATFORM_GUID, NULL },
 	{ }
@@ -1292,6 +1402,7 @@ static struct wmi_driver msi_wmi_platform_driver = {
 	},
 	.id_table = msi_wmi_platform_id_table,
 	.probe = msi_wmi_platform_probe,
+	.remove = msi_wmi_platform_remove,
 	.no_singleton = true,
 };
 
-- 
2.52.0


From c709d57bf7f5b5f34aeb0524681923cd198a734c Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:25 +0200
Subject: [PATCH 081/112] platform/x86: msi-wmi-platform: Drop excess fans in
 dual fan devices

Currently, the platform driver always exposes 4 fans, since the
underlying WMI interface reads 4 values from the EC. However, most
devices only have two fans. Therefore, at least in the case of the
Claw series, quirk the driver to only show two hwmon fans.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 29 ++++++++++++++++++++++---
 1 file changed, 26 insertions(+), 3 deletions(-)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 7cd967f57..8ef2a8318 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -122,6 +122,7 @@ enum msi_wmi_platform_method {
 struct msi_wmi_platform_quirk {
 	bool shift_mode;	/* Shift mode is supported */
 	bool charge_threshold;	/* Charge threshold is supported */
+	bool dual_fans;		/* For devices with two hwmon fans */
 	int ppt_min;		/* Minimum PLx value */
 	int ppt_pl1_spl_max;	/* Maximum PL1/SPL value */
 	int ppt_pl2_sppt_max;	/* Maximum PL2/SPPT value */
@@ -221,6 +222,7 @@ static struct msi_wmi_platform_quirk quirk_default = {};
 static struct msi_wmi_platform_quirk quirk_gen1 = {
 	.shift_mode = true,
 	.charge_threshold = true,
+	.dual_fans = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 43,
 	.ppt_pl2_sppt_max = 45
@@ -228,6 +230,7 @@ static struct msi_wmi_platform_quirk quirk_gen1 = {
 static struct msi_wmi_platform_quirk quirk_gen2 = {
 	.shift_mode = true,
 	.charge_threshold = true,
+	.dual_fans = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 30,
 	.ppt_pl2_sppt_max = 37,
@@ -235,6 +238,7 @@ static struct msi_wmi_platform_quirk quirk_gen2 = {
 static struct msi_wmi_platform_quirk quirk_amd = {
 	.shift_mode = true,
 	.charge_threshold = true,
+	.dual_fans = true,
 	.ppt_min = 4,
 	.ppt_pl1_spl_max = 37,
 	.ppt_pl2_sppt_max = 45,
@@ -656,6 +660,23 @@ static const struct hwmon_chip_info msi_wmi_platform_chip_info = {
 	.info = msi_wmi_platform_info,
 };
 
+static const struct hwmon_channel_info * const msi_wmi_platform_info_dual[] = {
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT,
+			   HWMON_F_INPUT
+			   ),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_ENABLE,
+			   HWMON_PWM_ENABLE
+			   ),
+	NULL
+};
+
+static const struct hwmon_chip_info msi_wmi_platform_chip_info_dual = {
+	.ops = &msi_wmi_platform_ops,
+	.info = msi_wmi_platform_info_dual,
+};
+
 static int msi_wmi_platform_profile_probe(void *drvdata, unsigned long *choices)
 {
 	set_bit(PLATFORM_PROFILE_LOW_POWER, choices);
@@ -1259,9 +1280,11 @@ static int msi_wmi_platform_hwmon_init(struct msi_wmi_platform_data *data)
 {
 	struct device *hdev;
 
-	hdev = devm_hwmon_device_register_with_info(&data->wdev->dev, "msi_wmi_platform", data,
-						    &msi_wmi_platform_chip_info,
-						    msi_wmi_platform_hwmon_groups);
+	hdev = devm_hwmon_device_register_with_info(
+		&data->wdev->dev, "msi_wmi_platform", data,
+		data->quirks->dual_fans ? &msi_wmi_platform_chip_info_dual :
+					&msi_wmi_platform_chip_info,
+		msi_wmi_platform_hwmon_groups);
 
 	return PTR_ERR_OR_ZERO(hdev);
 }
-- 
2.52.0


From 5bd88d16e313af962440a843ee5e92cdc564db94 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:26 +0200
Subject: [PATCH 082/112] platform/x86: msi-wmi-platform: Update header text

Update copyright information in the header and specify
that this driver also applies to handhelds.

Reviewed-by: Armin Wolf <W_Armin@gmx.de>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 8ef2a8318..51452a680 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -1,8 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * Linux driver for WMI platform features on MSI notebooks.
+ * Linux driver for WMI platform features on MSI notebooks and handhelds.
  *
- * Copyright (C) 2024 Armin Wolf <W_Armin@gmx.de>
+ * Copyright (C) 2024-2025 Armin Wolf <W_Armin@gmx.de>
+ * Copyright (C) 2025 Antheas Kapenekakis <lkml@antheas.dev>
  */
 
 #define pr_format(fmt) KBUILD_MODNAME ": " fmt
-- 
2.52.0


From f730c4073d15bf174a93d2b4a3ced8b8d9ea6ef4 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:27 +0200
Subject: [PATCH 083/112] platform/x86: msi-wmi-platform: Restore fan curves on
 PWM disable and unload

MSI software is a bit weird in that even when the manual fan curve is
disabled, the fan speed is still somewhat affected by the curve. So
we have to restore the fan curves on unload and PWM disable, as it
is done in Windows.

Suggested-by: Armin Wolf <W_Armin@gmx.de>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 124 +++++++++++++++++++++++-
 1 file changed, 123 insertions(+), 1 deletion(-)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 51452a680..2dbaa3c1f 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -124,17 +124,26 @@ struct msi_wmi_platform_quirk {
 	bool shift_mode;	/* Shift mode is supported */
 	bool charge_threshold;	/* Charge threshold is supported */
 	bool dual_fans;		/* For devices with two hwmon fans */
+	bool restore_curves;	/* Restore factory curves on unload */
 	int ppt_min;		/* Minimum PLx value */
 	int ppt_pl1_spl_max;	/* Maximum PL1/SPL value */
 	int ppt_pl2_sppt_max;	/* Maximum PL2/SPPT value */
 	int ppt_pl3_fppt;		/* Maximum FPPT value */
 };
 
+struct msi_wmi_platform_factory_curves {
+	u8 cpu_fan_table[32];
+	u8 gpu_fan_table[32];
+	u8 cpu_temp_table[32];
+	u8 gpu_temp_table[32];
+};
+
 struct msi_wmi_platform_data {
 	struct wmi_device *wdev;
 	struct msi_wmi_platform_quirk *quirks;
 	struct mutex wmi_lock;	/* Necessary when calling WMI methods */
 	struct device *ppdev;
+	struct msi_wmi_platform_factory_curves factory_curves;
 	struct acpi_battery_hook battery_hook;
 	struct device *fw_attrs_dev;
 	struct kset *fw_attrs_kset;
@@ -224,6 +233,7 @@ static struct msi_wmi_platform_quirk quirk_gen1 = {
 	.shift_mode = true,
 	.charge_threshold = true,
 	.dual_fans = true,
+	.restore_curves = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 43,
 	.ppt_pl2_sppt_max = 45
@@ -232,6 +242,7 @@ static struct msi_wmi_platform_quirk quirk_gen2 = {
 	.shift_mode = true,
 	.charge_threshold = true,
 	.dual_fans = true,
+	.restore_curves = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 30,
 	.ppt_pl2_sppt_max = 37,
@@ -240,6 +251,7 @@ static struct msi_wmi_platform_quirk quirk_amd = {
 	.shift_mode = true,
 	.charge_threshold = true,
 	.dual_fans = true,
+	.restore_curves = true,
 	.ppt_min = 4,
 	.ppt_pl1_spl_max = 37,
 	.ppt_pl2_sppt_max = 45,
@@ -529,6 +541,94 @@ static struct attribute *msi_wmi_platform_hwmon_attrs[] = {
 };
 ATTRIBUTE_GROUPS(msi_wmi_platform_hwmon);
 
+static int msi_wmi_platform_curves_save(struct msi_wmi_platform_data *data)
+{
+	int ret;
+
+	data->factory_curves.cpu_fan_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE;
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_GET_FAN,
+		data->factory_curves.cpu_fan_table,
+		sizeof(data->factory_curves.cpu_fan_table));
+	if (ret < 0)
+		return ret;
+	data->factory_curves.cpu_fan_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE;
+
+	data->factory_curves.gpu_fan_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE;
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_GET_FAN,
+		data->factory_curves.gpu_fan_table,
+		sizeof(data->factory_curves.gpu_fan_table));
+	if (ret < 0)
+		return ret;
+	data->factory_curves.gpu_fan_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE;
+
+	data->factory_curves.cpu_temp_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE;
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_GET_TEMPERATURE,
+		data->factory_curves.cpu_temp_table,
+		sizeof(data->factory_curves.cpu_temp_table));
+	if (ret < 0)
+		return ret;
+	data->factory_curves.cpu_temp_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE;
+
+	data->factory_curves.gpu_temp_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE;
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_GET_TEMPERATURE,
+		data->factory_curves.gpu_temp_table,
+		sizeof(data->factory_curves.gpu_temp_table));
+	if (ret < 0)
+		return ret;
+	data->factory_curves.gpu_temp_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE;
+
+	return 0;
+}
+
+static int msi_wmi_platform_curves_load(struct msi_wmi_platform_data *data)
+{
+	u8 buffer[32] = { };
+	int ret;
+
+	memcpy(buffer, data->factory_curves.cpu_fan_table,
+	       sizeof(data->factory_curves.cpu_fan_table));
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_SET_FAN,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	memcpy(buffer, data->factory_curves.gpu_fan_table,
+	       sizeof(data->factory_curves.gpu_fan_table));
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_SET_FAN,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	memcpy(buffer, data->factory_curves.cpu_temp_table,
+	       sizeof(data->factory_curves.cpu_temp_table));
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_SET_TEMPERATURE, buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	memcpy(buffer, data->factory_curves.gpu_temp_table,
+	       sizeof(data->factory_curves.gpu_temp_table));
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_SET_TEMPERATURE, buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+
 static umode_t msi_wmi_platform_is_visible(const void *drvdata, enum hwmon_sensor_types type,
 					   u32 attr, int channel)
 {
@@ -625,9 +725,19 @@ static int msi_wmi_platform_write(struct device *dev, enum hwmon_sensor_types ty
 				return -EINVAL;
 			}
 
-			return msi_wmi_platform_query_unlocked(
+			ret = msi_wmi_platform_query_unlocked(
 				data, MSI_PLATFORM_SET_AP, buffer,
 				sizeof(buffer));
+			if (ret < 0)
+				return ret;
+
+			if (val == 2 && data->quirks->restore_curves) {
+				ret = msi_wmi_platform_curves_load(data);
+				if (ret < 0)
+					return ret;
+			}
+
+			return 0;
 		default:
 			return -EOPNOTSUPP;
 		}
@@ -1402,6 +1512,13 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 
 	msi_wmi_platform_profile_setup(data);
 
+	if (data->quirks->restore_curves) {
+		guard(mutex)(&data->wmi_lock);
+		ret = msi_wmi_platform_curves_save(data);
+		if (ret < 0)
+			return ret;
+	}
+
 	return msi_wmi_platform_hwmon_init(data);
 }
 
@@ -1411,6 +1528,11 @@ static void msi_wmi_platform_remove(struct wmi_device *wdev)
 
 	if (data->quirks->charge_threshold)
 		battery_hook_unregister(&data->battery_hook);
+
+	if (data->quirks->restore_curves) {
+		guard(mutex)(&data->wmi_lock);
+		msi_wmi_platform_curves_load(data);
+	}
 }
 
 static const struct wmi_device_id msi_wmi_platform_id_table[] = {
-- 
2.52.0


From ea1f38808b6113687abfb3602c8d65e539572a6f Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Tue, 9 Dec 2025 00:19:48 +0100
Subject: [PATCH 084/112] msi-wmi-platform: fix quirk end missing

Signed-off-by: Antheas Kapenekakis <git@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 2dbaa3c1f..fc6569791 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -291,6 +291,7 @@ static const struct dmi_system_id msi_quirks[] = {
 		},
 		.driver_data = &quirk_amd,
 	},
+	{ }
 };
 
 static int msi_wmi_platform_parse_buffer(union acpi_object *obj, u8 *output, size_t length)
-- 
2.52.0


From 1ab5889558ddda6eb49ef04e942bf0b4d676dc29 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 24 Oct 2025 22:46:08 +0200
Subject: [PATCH 085/112] hwmon: (gpd-fan) Add GPD Win 5

The GPD Win 5 is a new device by GPD with an AMD AI MAX 395 chip.
It uses the same fan control registers as the GPD Win 4.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hwmon/gpd-fan.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/drivers/hwmon/gpd-fan.c b/drivers/hwmon/gpd-fan.c
index 237f496c4..3f0e59a67 100644
--- a/drivers/hwmon/gpd-fan.c
+++ b/drivers/hwmon/gpd-fan.c
@@ -143,6 +143,14 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = &gpd_win4_drvdata,
 	},
+	{
+		// GPD Win 5 with AMD AI MAX 395
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1618-05"),
+		},
+		.driver_data = &gpd_duo_drvdata,
+	},
 	{
 		// GPD Win 4 with Ryzen 7840U
 		.matches = {
-- 
2.52.0


From 51d2dab6665b0ea8b0e67f092fc4622e645ef83e Mon Sep 17 00:00:00 2001
From: Mario Limonciello <mario.limonciello@amd.com>
Date: Thu, 1 May 2025 16:17:32 -0500
Subject: [PATCH 086/112] PM: Add suspend and hibernate notifications for after
 freeze

Suspend and hibernate notifications are available specifically when
the sequence starts and finishes.  However there are no notifications
during the process when tasks have been frozen.

Introduce two new events `PM_SUSPEND_POST_FREEZE` and
`PM_HIBERNATE_POST_FREEZE` that drivers can subscribe to and take
different actions specifically knowing userspace is frozen.

Suggested-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
---
 Documentation/driver-api/pm/notifiers.rst | 19 ++++++++++++++++---
 include/linux/suspend.h                   | 14 ++++++++------
 kernel/power/hibernate.c                  |  9 +++++++--
 kernel/power/suspend.c                    | 10 ++++++++--
 4 files changed, 39 insertions(+), 13 deletions(-)

diff --git a/Documentation/driver-api/pm/notifiers.rst b/Documentation/driver-api/pm/notifiers.rst
index 186435c43..6a1912fbe 100644
--- a/Documentation/driver-api/pm/notifiers.rst
+++ b/Documentation/driver-api/pm/notifiers.rst
@@ -32,6 +32,18 @@ will be called upon the following events by the PM core:
 	additional work is done between the notifiers and the invocation of PM
 	callbacks for the "freeze" transition.
 
+``PM_HIBERNATION_POST_FREEZE``
+	The system is going to hibernate and tasks have just been frozen.
+
+``PM_SUSPEND_PREPARE``
+	The system is going to suspend, tasks will be frozen immediately.  This
+	is different from ``PM_HIBERNATION_PREPARE`` above, because in this case
+	additional work is done between the notifiers and the invocation of PM
+	callbacks for the "freeze" transition.
+
+``PM_SUSPEND_POST_FREEZE``
+	The system is going to suspend and tasks have just been frozen.
+
 ``PM_POST_HIBERNATION``
 	The system memory state has been restored from a hibernation image or an
 	error occurred during hibernation.  Device restore callbacks have been
@@ -54,9 +66,10 @@ will be called upon the following events by the PM core:
 	resume callbacks have been executed and tasks have been thawed.
 
 It is generally assumed that whatever the notifiers do for
-``PM_HIBERNATION_PREPARE``, should be undone for ``PM_POST_HIBERNATION``.
-Analogously, operations carried out for ``PM_SUSPEND_PREPARE`` should be
-reversed for ``PM_POST_SUSPEND``.
+``PM_HIBERNATION_PREPARE`` and ``PM_HIBERNATION_POST_FREEZE``, should be undone
+for ``PM_POST_HIBERNATION``.
+Analogously, operations carried out for ``PM_SUSPEND_PREPARE`` and ``PM_SUSPEND_POST_FREEZE``
+should be reversed for ``PM_POST_SUSPEND``.
 
 Moreover, if one of the notifiers fails for the ``PM_HIBERNATION_PREPARE`` or
 ``PM_SUSPEND_PREPARE`` event, the notifiers that have already succeeded for that
diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index b02876f1a..c997974a4 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -433,12 +433,14 @@ static inline int is_hibernate_resume_dev(dev_t dev) { return 0; }
 #endif
 
 /* Hibernation and suspend events */
-#define PM_HIBERNATION_PREPARE	0x0001 /* Going to hibernate */
-#define PM_POST_HIBERNATION	0x0002 /* Hibernation finished */
-#define PM_SUSPEND_PREPARE	0x0003 /* Going to suspend the system */
-#define PM_POST_SUSPEND		0x0004 /* Suspend finished */
-#define PM_RESTORE_PREPARE	0x0005 /* Going to restore a saved image */
-#define PM_POST_RESTORE		0x0006 /* Restore failed */
+#define PM_HIBERNATION_PREPARE		0x0001 /* Going to hibernate */
+#define PM_HIBERNATION_POST_FREEZE	0x0002 /* Prepared for hibernation and tasks have been frozen */
+#define PM_POST_HIBERNATION		0x0003 /* Hibernation finished */
+#define PM_SUSPEND_PREPARE		0x0004 /* Going to suspend the system */
+#define PM_SUSPEND_POST_FREEZE		0x0005 /* Prepared and tasks have been frozen */
+#define PM_POST_SUSPEND			0x0006 /* Suspend finished */
+#define PM_RESTORE_PREPARE		0x0007 /* Going to restore a saved image */
+#define PM_POST_RESTORE			0x0008 /* Restore failed */
 
 extern struct mutex system_transition_mutex;
 
diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c
index af8d07baf..93bfd979a 100644
--- a/kernel/power/hibernate.c
+++ b/kernel/power/hibernate.c
@@ -830,11 +830,15 @@ int hibernate(void)
 	if (error)
 		goto Exit;
 
+	error = pm_notifier_call_chain_robust(PM_HIBERNATION_POST_FREEZE, PM_POST_HIBERNATION);
+	if (error)
+		goto Thaw;
+
 	lock_device_hotplug();
 	/* Allocate memory management structures */
 	error = create_basic_memory_bitmaps();
 	if (error)
-		goto Thaw;
+		goto Unlock_hotplug;
 
 	error = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);
 	if (error || freezer_test_done)
@@ -880,8 +884,9 @@ int hibernate(void)
 
  Free_bitmaps:
 	free_basic_memory_bitmaps();
- Thaw:
+ Unlock_hotplug:
 	unlock_device_hotplug();
+ Thaw:
 	if (snapshot_test) {
 		pm_pr_dbg("Checking hibernation image\n");
 		error = swsusp_check(false);
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 57c442686..344dbb559 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -386,14 +386,20 @@ static int suspend_prepare(suspend_state_t state)
 	trace_suspend_resume(TPS("freeze_processes"), 0, true);
 	error = suspend_freeze_processes();
 	trace_suspend_resume(TPS("freeze_processes"), 0, false);
-	if (!error)
-		return 0;
+	if (error)
+		goto Unfreeze;
+	error = pm_notifier_call_chain_robust(PM_SUSPEND_POST_FREEZE, PM_POST_SUSPEND);
+	if (error)
+		goto Unfreeze;
+	return 0;
 
+Unfreeze:
 	dpm_save_failed_step(SUSPEND_FREEZE);
 	filesystems_thaw();
 	pm_notifier_call_chain(PM_POST_SUSPEND);
  Restore:
 	pm_restore_console();
+	dpm_save_failed_step(SUSPEND_FREEZE);
 	return error;
 }
 
-- 
2.52.0


From 315be8626021ade96275fae0a65c1ffa002b72d0 Mon Sep 17 00:00:00 2001
From: Mario Limonciello <mario.limonciello@amd.com>
Date: Thu, 1 May 2025 16:17:33 -0500
Subject: [PATCH 087/112] drm/amd: Use suspend and hibernate post freeze
 notifications

commit 2965e6355dcd ("drm/amd: Add Suspend/Hibernate notification
callback support") introduced a VRAM eviction earlier in the PM
sequences when swap was still available for evicting to. This helped
to fix a number of memory pressure related bugs but also exposed a
new one.

If a userspace process is actively using the GPU when suspend starts
then a deadlock could occur.

Instead of going off the prepare notifier, use the PM notifiers that
occur after processes have been frozen to do evictions.

Closes: https://gitlab.freedesktop.org/drm/amd/-/issues/4178
Fixes: 2965e6355dcd ("drm/amd: Add Suspend/Hibernate notification callback support")
Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index d2c3885de..a95efb47c 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -5202,10 +5202,21 @@ static int amdgpu_device_pm_notifier(struct notifier_block *nb, unsigned long mo
 				     void *data)
 {
 	struct amdgpu_device *adev = container_of(nb, struct amdgpu_device, pm_nb);
+	int r = 0;
 
 	switch (mode) {
-	case PM_HIBERNATION_PREPARE:
+	case PM_HIBERNATION_POST_FREEZE:
 		adev->in_s4 = true;
+		fallthrough;
+	case PM_SUSPEND_POST_FREEZE:
+		r = amdgpu_device_evict_resources(adev);
+		/*
+		 * This is considered non-fatal at this time because
+		 * amdgpu_device_prepare() will also fatally evict resources.
+		 * See https://gitlab.freedesktop.org/drm/amd/-/issues/3781
+		 */
+		if (r)
+			drm_warn(adev_to_drm(adev), "Failed to evict resources, freeze active processes if problems occur: %d\n", r);
 		break;
 	case PM_POST_HIBERNATION:
 		adev->in_s4 = false;
-- 
2.52.0


From 92a474cec2331ff080820a09702f65035ee4032b Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 16 Jul 2025 19:01:47 +0200
Subject: [PATCH 088/112] Input: evdev - allow releasing keys on grab

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/input/evdev.c            | 10 +++---
 drivers/input/input.c            | 52 ++++++++++++++++++--------------
 drivers/input/tests/input_test.c |  6 ++--
 include/linux/input.h            |  2 +-
 4 files changed, 39 insertions(+), 31 deletions(-)

diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c
index 90ff6be85..6e2808616 100644
--- a/drivers/input/evdev.c
+++ b/drivers/input/evdev.c
@@ -329,14 +329,14 @@ static void evdev_free(struct device *dev)
  * Grabs an event device (along with underlying input device).
  * This function is called with evdev->mutex taken.
  */
-static int evdev_grab(struct evdev *evdev, struct evdev_client *client)
+static int evdev_grab(struct evdev *evdev, struct evdev_client *client, bool clean)
 {
 	int error;
 
 	if (evdev->grab)
 		return -EBUSY;
 
-	error = input_grab_device(&evdev->handle);
+	error = input_grab_device(&evdev->handle, clean);
 	if (error)
 		return error;
 
@@ -1082,8 +1082,10 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 		return 0;
 
 	case EVIOCGRAB:
-		if (p)
-			return evdev_grab(evdev, client);
+		if (p == (void *)2)
+			return evdev_grab(evdev, client, true);
+		else if (p)
+			return evdev_grab(evdev, client, false);
 		else
 			return evdev_ungrab(evdev, client);
 
diff --git a/drivers/input/input.c b/drivers/input/input.c
index a500e1e27..81e32030c 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -509,29 +509,6 @@ void input_copy_abs(struct input_dev *dst, unsigned int dst_axis,
 }
 EXPORT_SYMBOL(input_copy_abs);
 
-/**
- * input_grab_device - grabs device for exclusive use
- * @handle: input handle that wants to own the device
- *
- * When a device is grabbed by an input handle all events generated by
- * the device are delivered only to this handle. Also events injected
- * by other input handles are ignored while device is grabbed.
- */
-int input_grab_device(struct input_handle *handle)
-{
-	struct input_dev *dev = handle->dev;
-
-	scoped_cond_guard(mutex_intr, return -EINTR, &dev->mutex) {
-		if (dev->grab)
-			return -EBUSY;
-
-		rcu_assign_pointer(dev->grab, handle);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(input_grab_device);
-
 static void __input_release_device(struct input_handle *handle)
 {
 	struct input_dev *dev = handle->dev;
@@ -1735,6 +1712,35 @@ void input_reset_device(struct input_dev *dev)
 }
 EXPORT_SYMBOL(input_reset_device);
 
+/**
+ * input_grab_device - grabs device for exclusive use
+ * @handle: input handle that wants to own the device
+ * @release_keys: whether to release pressed keys before grabbing
+ *
+ * When a device is grabbed by an input handle all events generated by
+ * the device are delivered only to this handle. Also events injected
+ * by other input handles are ignored while device is grabbed.
+ */
+int input_grab_device(struct input_handle *handle, bool release_keys)
+{
+	struct input_dev *dev = handle->dev;
+
+	scoped_cond_guard(mutex_intr, return -EINTR, &dev->mutex) {
+		guard(spinlock_irqsave)(&dev->event_lock);
+
+		if (dev->grab)
+			return -EBUSY;
+
+		if (release_keys && input_dev_release_keys(dev))
+			input_handle_event(dev, EV_SYN, SYN_REPORT, 1);
+
+		rcu_assign_pointer(dev->grab, handle);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(input_grab_device);
+
 static int input_inhibit_device(struct input_dev *dev)
 {
 	guard(mutex)(&dev->mutex);
diff --git a/drivers/input/tests/input_test.c b/drivers/input/tests/input_test.c
index e105ce71a..ff6d195ba 100644
--- a/drivers/input/tests/input_test.c
+++ b/drivers/input/tests/input_test.c
@@ -145,18 +145,18 @@ static void input_test_grab(struct kunit *test)
 	handle.dev = input_get_device(input_dev);
 	handle.name = dev_name(&input_dev->dev);
 	handle.handler = &handler;
-	res = input_grab_device(&handle);
+	res = input_grab_device(&handle, false);
 	KUNIT_ASSERT_TRUE(test, res == 0);
 
 	test_handle.dev = input_get_device(input_dev);
 	test_handle.name = dev_name(&input_dev->dev);
 	test_handle.handler = &handler;
-	res = input_grab_device(&test_handle);
+	res = input_grab_device(&test_handle, false);
 	KUNIT_ASSERT_EQ(test, res, -EBUSY);
 
 	input_release_device(&handle);
 	input_put_device(input_dev);
-	res = input_grab_device(&test_handle);
+	res = input_grab_device(&test_handle, false);
 	KUNIT_ASSERT_TRUE(test, res == 0);
 	input_put_device(input_dev);
 }
diff --git a/include/linux/input.h b/include/linux/input.h
index 7d7cb0593..ef4dd65d1 100644
--- a/include/linux/input.h
+++ b/include/linux/input.h
@@ -420,7 +420,7 @@ int input_handler_for_each_handle(struct input_handler *, void *data,
 int input_register_handle(struct input_handle *);
 void input_unregister_handle(struct input_handle *);
 
-int input_grab_device(struct input_handle *);
+int input_grab_device(struct input_handle *, bool release_keys);
 void input_release_device(struct input_handle *);
 
 int input_open_device(struct input_handle *);
-- 
2.52.0


From b92480e81380aa807b472e6f1367ea1bff26d954 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 17 Jul 2025 13:28:12 +0200
Subject: [PATCH 089/112] watchdog: reduce error message level to maintain
 plymouth

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/watchdog/watchdog_dev.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/watchdog/watchdog_dev.c b/drivers/watchdog/watchdog_dev.c
index 8369fd94f..be8d00e0d 100644
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@ -965,7 +965,7 @@ static int watchdog_release(struct inode *inode, struct file *file)
 
 	/* If the watchdog was not stopped, send a keepalive ping */
 	if (err < 0) {
-		pr_crit("watchdog%d: watchdog did not stop!\n", wdd->id);
+		pr_err("watchdog%d: watchdog did not stop!\n", wdd->id);
 		watchdog_ping(wdd);
 	}
 
-- 
2.52.0


From 97a44cea593d99b380fbb392e9dab5e549ac7206 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 17 Jul 2025 23:12:32 +0200
Subject: [PATCH 090/112] HID: hid-steam: keep evdev connected while steam is
 active

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-steam.c | 18 +++++-------------
 1 file changed, 5 insertions(+), 13 deletions(-)

diff --git a/drivers/hid/hid-steam.c b/drivers/hid/hid-steam.c
index 197126d6e..09abb62f7 100644
--- a/drivers/hid/hid-steam.c
+++ b/drivers/hid/hid-steam.c
@@ -983,11 +983,11 @@ static int steam_register(struct steam_device *steam)
 	client_opened = steam->client_opened;
 	spin_unlock_irqrestore(&steam->lock, flags);
 
+	ret = steam_input_register(steam);
+	if (ret != 0)
+		goto steam_register_input_fail;
 	if (!client_opened) {
 		steam_set_lizard_mode(steam, lizard_mode);
-		ret = steam_input_register(steam);
-		if (ret != 0)
-			goto steam_register_input_fail;
 		ret = steam_sensors_register(steam);
 		if (ret != 0)
 			goto steam_register_sensors_fail;
@@ -1081,12 +1081,11 @@ static void steam_work_unregister_cb(struct work_struct *work)
 	spin_unlock_irqrestore(&steam->lock, flags);
 
 	if (connected) {
+		steam_input_register(steam);
 		if (opened) {
 			steam_sensors_unregister(steam);
-			steam_input_unregister(steam);
 		} else {
 			steam_set_lizard_mode(steam, lizard_mode);
-			steam_input_register(steam);
 			steam_sensors_register(steam);
 		}
 	}
@@ -1615,9 +1614,6 @@ static void steam_do_deck_input_event(struct steam_device *steam,
 		schedule_delayed_work(&steam->mode_switch, 45 * HZ / 100);
 	}
 
-	if (!steam->gamepad_mode && lizard_mode)
-		return;
-
 	lpad_touched = b10 & BIT(3);
 	rpad_touched = b10 & BIT(4);
 
@@ -1767,8 +1763,6 @@ static int steam_raw_event(struct hid_device *hdev,
 
 	switch (data[2]) {
 	case ID_CONTROLLER_STATE:
-		if (steam->client_opened)
-			return 0;
 		rcu_read_lock();
 		input = rcu_dereference(steam->input);
 		if (likely(input))
@@ -1776,14 +1770,12 @@ static int steam_raw_event(struct hid_device *hdev,
 		rcu_read_unlock();
 		break;
 	case ID_CONTROLLER_DECK_STATE:
-		if (steam->client_opened)
-			return 0;
 		rcu_read_lock();
 		input = rcu_dereference(steam->input);
 		if (likely(input))
 			steam_do_deck_input_event(steam, input, data);
 		sensors = rcu_dereference(steam->sensors);
-		if (likely(sensors))
+		if (!steam->client_opened && likely(sensors))
 			steam_do_deck_sensors_event(steam, sensors, data);
 		rcu_read_unlock();
 		break;
-- 
2.52.0


From 49fe650c8651fcc6bb13ab854efe3b329de6d33b Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 20 Aug 2025 16:49:11 +0200
Subject: [PATCH 091/112] platform/x86: ayaneo-ec: Remove charge inhibition for
 other devices

On Bazzite, charge inhibition is currently provided by the oot
ayaneo-platform driver. To avoid stacking modules, remove the support
from the ayaneo-ec driver.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/ayaneo-ec.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/drivers/platform/x86/ayaneo-ec.c b/drivers/platform/x86/ayaneo-ec.c
index 41a24e091..b7fc7ee44 100644
--- a/drivers/platform/x86/ayaneo-ec.c
+++ b/drivers/platform/x86/ayaneo-ec.c
@@ -66,7 +66,6 @@ static const struct ayaneo_ec_quirk quirk_fan = {
 
 static const struct ayaneo_ec_quirk quirk_charge_limit = {
 	.has_fan_control = true,
-	.has_charge_control = true,
 };
 
 static const struct ayaneo_ec_quirk quirk_ayaneo3 = {
-- 
2.52.0


From 66ed767af97c32de0a01b3af870e1cc9af8e41a4 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 3 Aug 2025 05:16:39 +0200
Subject: [PATCH 092/112] ACPI: EC: Set ec_no_wakeup for MSI Claw A8

Same panel as the Legion Go S, and is an AMD variant.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/ec.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c
index 59b3d50ff..b94266ee5 100644
--- a/drivers/acpi/ec.c
+++ b/drivers/acpi/ec.c
@@ -2351,6 +2351,15 @@ static const struct dmi_system_id acpi_ec_no_wakeup[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "83Q3"),
 		}
 	},
+	/*
+	 * MSI Claw A8. Similar issue to Legion Go S (and same screen)
+	 */
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-1T8K"),
+		}
+	},
 	{
 		// TUXEDO InfinityBook Pro AMD Gen9
 		.matches = {
-- 
2.52.0


From 0d55ab8e460fbe85852d19632db0dbae6518446a Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Mon, 11 Aug 2025 17:43:46 +0200
Subject: [PATCH 093/112] drm/amdgpu/vpe: increase VPE_IDLE_TIMEOUT to fix hang
 on Strix Halo

On the Asus Z13 2025, which uses a Strix Halo platform, around 8% of the
suspend resumes result in a soft lock around 1 second after the screen
turns on (it freezes). This happens due to power gating VPE when it is
not used, which happens 1 second after inactivity.

Specifically, the VPE gating after resume is as follows: an initial
ungate, followed by a gate in the resume process. Then,
amdgpu_device_delayed_init_work_handler with a delay of 2s is scheduled
to run tests, one of which is testing VPE in vpe_ring_test_ib. This
causes an ungate, After that test, vpe_idle_work_handler is scheduled
with VPE_IDLE_TIMEOUT (1s).

When vpe_idle_work_handler runs and tries to gate VPE, it causes the
SMU to hang and partially freezes half of the GPU IPs, with the thread
that called the command being stuck processing it.

Specifically, after that SMU command tries to run, we get the following:

snd_hda_intel 0000:c4:00.1: Refused to change power state from D0 to D3hot
...
xhci_hcd 0000:c4:00.4: Refused to change power state from D0 to D3hot
...
amdgpu 0000:c4:00.0: amdgpu: SMU: I'm not done with your previous command: SMN_C2PMSG_66:0x00000032 SMN_C2PMSG_82:0x00000000
amdgpu 0000:c4:00.0: amdgpu: Failed to power gate VPE!
[drm:vpe_set_powergating_state [amdgpu]] *ERROR* Dpm disable vpe failed, ret = -62.
amdgpu 0000:c4:00.0: [drm] *ERROR* [CRTC:93:crtc-0] flip_done timed out
amdgpu 0000:c4:00.0: amdgpu: SMU: I'm not done with your previous command: SMN_C2PMSG_66:0x00000032 SMN_C2PMSG_82:0x00000000
amdgpu 0000:c4:00.0: amdgpu: Failed to power gate JPEG!
[drm:jpeg_v4_0_5_set_powergating_state [amdgpu]] *ERROR* Dpm disable jpeg failed, ret = -62.
amdgpu 0000:c4:00.0: amdgpu: SMU: I'm not done with your previous command: SMN_C2PMSG_66:0x00000032 SMN_C2PMSG_82:0x00000000
amdgpu 0000:c4:00.0: amdgpu: Failed to power gate VCN instance 0!
[drm:vcn_v4_0_5_stop [amdgpu]] *ERROR* Dpm disable uvd failed, ret = -62.
thunderbolt 0000:c6:00.5: 0: timeout reading config space 1 from 0xd3
thunderbolt 0000:c6:00.5: 0: timeout reading config space 2 from 0x5
thunderbolt 0000:c6:00.5: Refused to change power state from D0 to D3hot
amdgpu 0000:c4:00.0: [drm] *ERROR* [CRTC:97:crtc-1] flip_done timed out
amdgpu 0000:c4:00.0: amdgpu: SMU: I'm not done with your previous command: SMN_C2PMSG_66:0x00000032 SMN_C2PMSG_82:0x00000000
amdgpu 0000:c4:00.0: amdgpu: Failed to power gate VCN instance 1!

In addition to e.g., kwin errors in journalctl. 0000:c4.00.0 is the GPU.
Interestingly, 0000:c4.00.6, which is another HDA block, 0000:c4.00.5,
a PCI controller, and 0000:c4.00.2, resume normally. 0x00000032 is the
PowerDownVpe(50) command which is the common failure point in all
failed resumes.

On a normal resume, we should get the following power gates:
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerDownVpe(50) param: 0x00000000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerDownJpeg0(33) param: 0x00000000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerDownJpeg1(38) param: 0x00010000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerDownVcn1(4) param: 0x00010000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerDownVcn0(6) param: 0x00000000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerUpVcn0(7) param: 0x00000000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerUpVcn1(5) param: 0x00010000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerUpJpeg0(34) param: 0x00000000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerUpJpeg1(39) param: 0x00010000, resp: 0x00000001

To fix this, increase VPE_IDLE_TIMEOUT to 2 seconds. This increases
reliability from 4-25 suspends to 200+ (tested) suspends with a cycle
time of 12s sleep, 8s resume. The suspected reason here is that 1s
was a borderline delay before, and it does not give enough time for
VPE to be ready to be gated on Strix Halo.

Fixes: 5f82a0c90cca ("drm/amdgpu/vpe: enable vpe dpm")
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c
index aa78c2ee9..3155ac010 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c
@@ -34,8 +34,8 @@
 /* VPE CSA resides in the 4th page of CSA */
 #define AMDGPU_CSA_VPE_OFFSET 	(4096 * 3)
 
-/* 1 second timeout */
-#define VPE_IDLE_TIMEOUT	msecs_to_jiffies(1000)
+/* 2 second timeout */
+#define VPE_IDLE_TIMEOUT	msecs_to_jiffies(2000)
 
 #define VPE_MAX_DPM_LEVEL			4
 #define FIXED1_8_BITS_PER_FRACTIONAL_PART	8
-- 
2.52.0


From c10642aa2bc88b91a10650f9946168b4ee68d1cb Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 24 Aug 2025 22:02:02 +0200
Subject: [PATCH 094/112] drm: panel-backlight-quirks: Add Steam Decks

On the SteamOS kernel, Valve universally makes minimum brightness 0
for all devices. SteamOS is (was?) meant for the Steam Deck, so
enabling it universally is reasonable. However, it causes issues in
certain devices. Therefore, introduce it just for the Steam Deck here.

SteamOS kernel does not have a public mirror, but this replaces commit
806dd74bb225 ("amd/drm: override backlight min value from 12 -> 0")
in the latest, as of this writing, SteamOS kernel (6.11.11-valve24).
See unofficial mirror reconstructed from sources below.

Link: https://gitlab.com/evlaV/linux-integration/-/commit/806dd74bb225
Reviewed-by: Robert Beckett <bob.beckett@collabora.com>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_backlight_quirks.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_backlight_quirks.c b/drivers/gpu/drm/drm_panel_backlight_quirks.c
index 537dc6dd0..69c73f0f9 100644
--- a/drivers/gpu/drm/drm_panel_backlight_quirks.c
+++ b/drivers/gpu/drm/drm_panel_backlight_quirks.c
@@ -96,6 +96,21 @@ static const struct drm_get_panel_backlight_quirk drm_panel_min_backlight_quirks
 		.dmi_match_other.value = "ONEXPLAYER F1 EVA-02",
 		.quirk = { .brightness_mask = 3, },
 	},
+	/* Steam Deck models */
+	{
+		.dmi_match.field = DMI_SYS_VENDOR,
+		.dmi_match.value = "Valve",
+		.dmi_match_other.field = DMI_PRODUCT_NAME,
+		.dmi_match_other.value = "Jupiter",
+		.quirk = { .min_brightness = 1, },
+	},
+	{
+		.dmi_match.field = DMI_SYS_VENDOR,
+		.dmi_match.value = "Valve",
+		.dmi_match_other.field = DMI_PRODUCT_NAME,
+		.dmi_match_other.value = "Galileo",
+		.quirk = { .min_brightness = 1, },
+	},
 };
 
 static bool drm_panel_min_backlight_quirk_matches(
-- 
2.52.0


From 227646dc0c2ae5134502e1bf0324b83d11e251c9 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 28 Aug 2025 11:21:41 +0200
Subject: [PATCH 095/112] drm/amdgpu: tweak min and max clocks of
 cyan_skillfish

Certain aftermarket cyan_skillfish boards that are
used for gaming have an expanded clock range that
is limited by this driver. Update it to reflect
the actual min and max clocks of the board.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c
index 55401e6b2..4db6cc9a1 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c
@@ -45,8 +45,8 @@
 #undef pr_debug
 
 /* unit: MHz */
-#define CYAN_SKILLFISH_SCLK_MIN			1000
-#define CYAN_SKILLFISH_SCLK_MAX			2000
+#define CYAN_SKILLFISH_SCLK_MIN			350
+#define CYAN_SKILLFISH_SCLK_MAX			2230
 
 /* unit: mV */
 #define CYAN_SKILLFISH_VDDC_MIN			700
-- 
2.52.0


From 89d2b60ff680dbf05edc708489ebae7707632e16 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 5 Sep 2025 12:54:46 +0200
Subject: [PATCH 096/112] disable custom brightness curve for now

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 52c2490ed..ffc859fac 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -5032,6 +5032,8 @@ static void convert_custom_brightness(const struct amdgpu_dm_backlight_caps *cap
 	u8 lower_signal, upper_signal, upper_lum, lower_lum, lum;
 	int left, right;
 
+	return;
+
 	if (amdgpu_dc_debug_mask & DC_DISABLE_CUSTOM_BRIGHTNESS_CURVE)
 		return;
 
-- 
2.52.0


From d1ca339d899e27f9528d6e3f6c9ad8c8b3186909 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 10 Sep 2025 17:43:17 +0200
Subject: [PATCH 097/112] drm: panel-orientation-quirks: add SuiPlay0X1

Very similar to the AYANEO 2S, the Mysten SuiPlay0X1 is a handheld
gaming device with a 1200x1920 display that is mounted in a
right-side-up orientation. Add a quirk for it.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index ed1901de4..15820d1ec 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -503,6 +503,12 @@ static const struct dmi_system_id orientation_data[] = {
 		 DMI_MATCH(DMI_PRODUCT_VERSION, "Blade3-10A-001"),
 		},
 		.driver_data = (void *)&lcd1600x2560_rightside_up,
+	}, {	/* Mysten SuiPlay0X1 */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Mysten Labs, Inc."),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "SuiPlay0X1"),
+		},
+		.driver_data = (void *)&lcd1200x1920_rightside_up,
 	}, {	/* Nanote UMPC-01 */
 		.matches = {
 		 DMI_MATCH(DMI_SYS_VENDOR, "RWC CO.,LTD"),
-- 
2.52.0


From 24e2ec0731176d534788d11c8e16ea51b24afef3 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 10 Sep 2025 17:45:42 +0200
Subject: [PATCH 098/112] add suiplay

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/ayaneo-ec.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/platform/x86/ayaneo-ec.c b/drivers/platform/x86/ayaneo-ec.c
index b7fc7ee44..a4d76eab3 100644
--- a/drivers/platform/x86/ayaneo-ec.c
+++ b/drivers/platform/x86/ayaneo-ec.c
@@ -138,6 +138,13 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = (void *)&quirk_ayaneo3,
 	},
+	{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Mysten Labs, Inc."),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "SuiPlay0X1"),
+		},
+		.driver_data = (void *)&quirk_fan,
+	},
 	{},
 };
 
-- 
2.52.0


From 90d05f740a8046dbb78dc9768ba877fa14c696c6 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 18 Sep 2025 21:10:04 +0200
Subject: [PATCH 099/112] platform/x86: oxpec: Add support for OneXPlayer X1z

This is a variant of OneXPlayer X1 A with 8840U. It seems that only one
user has this one.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/oxpec.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/platform/x86/oxpec.c b/drivers/platform/x86/oxpec.c
index 144a45410..adb8a1a9b 100644
--- a/drivers/platform/x86/oxpec.c
+++ b/drivers/platform/x86/oxpec.c
@@ -212,6 +212,13 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = (void *)oxp_mini_amd_pro,
 	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "ONEXPLAYER X1z"),
+		},
+		.driver_data = (void *)oxp_x1,
+	},
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
-- 
2.52.0


From 9692dd429cf3c0cb44369d637cbeaaa1eea96d48 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 18 Sep 2025 21:12:24 +0200
Subject: [PATCH 100/112] add orientation for x1z

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 15820d1ec..24741dfc5 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -540,6 +540,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 A"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 AMD second variant */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1z"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OneXPlayer X1 AMD Strix Point */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
-- 
2.52.0


From b71ff604741b4b393652e2d77d2d65d3d333ae70 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 21 Sep 2025 15:47:29 +0200
Subject: [PATCH 101/112] tmp: add MSI Center button event to msi-wmi

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi.c | 18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)

diff --git a/drivers/platform/x86/msi-wmi.c b/drivers/platform/x86/msi-wmi.c
index 4a7ac85c4..20de3173e 100644
--- a/drivers/platform/x86/msi-wmi.c
+++ b/drivers/platform/x86/msi-wmi.c
@@ -41,6 +41,7 @@ enum msi_scancodes {
 	MSI_KEY_MUTE,
 	/* MSI Wind keys */
 	WIND_KEY_TOUCHPAD	= 0x08,	/* Fn+F3 touchpad toggle */
+	WIND_KEY_MSI_CENTER	= 0x29,
 	WIND_KEY_BLUETOOTH	= 0x56,	/* Fn+F11 Bluetooth toggle */
 	WIND_KEY_CAMERA,		/* Fn+F6 webcam toggle */
 	WIND_KEY_WLAN		= 0x5f,	/* Fn+F11 Wi-Fi toggle */
@@ -68,6 +69,7 @@ static struct key_entry msi_wmi_keymap[] = {
 	/* These are MSI Wind keys that should be handled via WMI */
 	{ KE_KEY, WIND_KEY_TURBO,		{KEY_PROG1} },
 	{ KE_KEY, WIND_KEY_ECO,			{KEY_PROG2} },
+	{ KE_KEY, WIND_KEY_MSI_CENTER,		{KEY_F15}},
 
 	{ KE_END, 0 }
 };
@@ -173,14 +175,24 @@ static const struct backlight_ops msi_backlight_ops = {
 static void msi_wmi_notify(union acpi_object *obj, void *context)
 {
 	struct key_entry *key;
+	int eventcode;
+
+	if (obj) {
+		if (obj->type == ACPI_TYPE_INTEGER)
+			eventcode = obj->integer.value;
+		else if (obj->type == ACPI_TYPE_BUFFER && obj->buffer.length)
+			eventcode = obj->buffer.pointer[0];
+		else {
+			pr_info("Unknown event received\n");
+			return;
+		}
 
-	if (obj && obj->type == ACPI_TYPE_INTEGER) {
-		int eventcode = obj->integer.value;
 		pr_debug("Eventcode: 0x%x\n", eventcode);
 		key = sparse_keymap_entry_from_scancode(msi_wmi_input_dev,
 				eventcode);
 		if (!key) {
-			pr_info("Unknown key pressed - %x\n", eventcode);
+			pr_info("Unknown key pressed - %x (ACPI type: %d)\n",
+				eventcode, obj->type);
 			return;
 		}
 
-- 
2.52.0


From 672a1afef03bae9cb6f44a1e661a9c6e41a1499f Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 21 Sep 2025 19:41:37 +0200
Subject: [PATCH 102/112] oxpec: add a2 pro

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/oxpec.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/platform/x86/oxpec.c b/drivers/platform/x86/oxpec.c
index adb8a1a9b..924d698b7 100644
--- a/drivers/platform/x86/oxpec.c
+++ b/drivers/platform/x86/oxpec.c
@@ -114,6 +114,13 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = (void *)aok_zoe_a1,
 	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AOKZOE"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AOKZOE A2 Pro"),
+		},
+		.driver_data = (void *)aok_zoe_a1,
+	},
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "AOKZOE"),
-- 
2.52.0


From d64b7b7b51937df3da1a03eb9cc9b650405f67dc Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 21 Sep 2025 19:41:46 +0200
Subject: [PATCH 103/112] panel quirks: add a2 pro

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 24741dfc5..7deff55b0 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -185,6 +185,12 @@ static const struct dmi_system_id orientation_data[] = {
 		 DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AOKZOE A1 Pro"),
 		},
 		.driver_data = (void *)&lcd1200x1920_leftside_up,
+	}, {	/* AOKZOE A2 Pro */
+		.matches = {
+		 DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AOKZOE"),
+		 DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AOKZOE A2 Pro"),
+		},
+		.driver_data = (void *)&lcd1200x1920_leftside_up,
 	}, {	/* Asus T100HA */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
-- 
2.52.0


From c3eb44ee94c92cfa8c8f87587ae4e91b16ccd03b Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 28 Sep 2025 17:05:22 +0200
Subject: [PATCH 104/112] lower sleep interval to avoid waking up too long

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/amd/pmc/pmc.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/platform/x86/amd/pmc/pmc.c b/drivers/platform/x86/amd/pmc/pmc.c
index cae3fcafd..79870f371 100644
--- a/drivers/platform/x86/amd/pmc/pmc.c
+++ b/drivers/platform/x86/amd/pmc/pmc.c
@@ -637,7 +637,7 @@ static void amd_pmc_s2idle_check(void)
 
 	/* Avoid triggering OVP */
 	if (!get_metrics_table(pdev, &table) && table.s0i3_last_entry_status)
-		msleep(2500);
+		msleep(500);
 
 	/* Dump the IdleMask before we add to the STB */
 	amd_pmc_idlemask_read(pdev, pdev->dev, NULL);
-- 
2.52.0


From 00286062572c65fd77133db3eee66a22351e3373 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 28 Sep 2025 21:37:07 +0200
Subject: [PATCH 105/112] drm/amdgpu: enable override by default for APUs

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index a95efb47c..2aef9d16a 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -2868,6 +2868,9 @@ static int amdgpu_device_ip_early_init(struct amdgpu_device *adev)
 	}
 
 	adev->pm.pp_feature = amdgpu_pp_feature_mask;
+
+	if (adev->flags & AMD_IS_APU)
+		adev->pm.pp_feature |= PP_OVERDRIVE_MASK;
 	if (amdgpu_sriov_vf(adev) || sched_policy == KFD_SCHED_POLICY_NO_HWS)
 		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
 	if (amdgpu_sriov_vf(adev) && adev->asic_type == CHIP_SIENNA_CICHLID)
-- 
2.52.0


From 8a0cfbf85f245dbda68e27ba238277dbd141e3f2 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 7 Oct 2025 22:06:32 +0200
Subject: [PATCH 106/112] oxpec: add x1 air

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/oxpec.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/platform/x86/oxpec.c b/drivers/platform/x86/oxpec.c
index 924d698b7..64a778ebb 100644
--- a/drivers/platform/x86/oxpec.c
+++ b/drivers/platform/x86/oxpec.c
@@ -240,6 +240,13 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = (void *)oxp_x1,
 	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "ONEXPLAYER X1Air"),
+		},
+		.driver_data = (void *)oxp_x1,
+	},
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
-- 
2.52.0


From cd2e61c0680d962e3f791f9c186adebc0bcc9d27 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 7 Oct 2025 22:07:28 +0200
Subject: [PATCH 107/112] orientation: add x1 air

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 7deff55b0..6e7dac6f8 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -570,6 +570,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 i"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 Intel */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Air"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OneXPlayer X1 mini (AMD) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
-- 
2.52.0


From 94dc9287caa16ee0aa6e8faa73b2d6d9707d1f46 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 2 Nov 2025 16:58:58 +0100
Subject: [PATCH 108/112] platform/x86: asus-wmi: Don't reset charge threshold
 on boot

Currently, the driver resets the charge threshold to 100% on every boot.
This is because the driver cannot read the current threshold from the
EC. The EC is perfectly capable of storing it across reboots.

This causes e.g., Powerdevil, to think the charge limit is 100% on boot
and for users to have to set it every time. Just skip setting it on boot
even if this causes userspace to drift.

Fixes: 7973353e92ee ("platform/x86: asus-wmi: Refactor charge threshold to use the battery hooking API")
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/asus-wmi.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 1046ad699..5f2389475 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1541,7 +1541,7 @@ static int asus_wmi_battery_add(struct power_supply *battery, struct acpi_batter
 	 * and we can't get the current threshold so let set it to 100% when
 	 * a battery is added.
 	 */
-	asus_wmi_set_devstate(ASUS_WMI_DEVID_RSOC, 100, NULL);
+	// asus_wmi_set_devstate(ASUS_WMI_DEVID_RSOC, 100, NULL);
 	charge_end_threshold = 100;
 
 	return 0;
-- 
2.52.0


From 57fd03fac48b3e226e7338f2c0966570e5ebca1f Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 12 Nov 2025 23:20:48 +0100
Subject: [PATCH 109/112] Revert "Input: xpad - change buttons the D-Pad gets
 mapped as to BTN_DPAD_*"

This reverts commit a43a503df996739ae34f179f6b73b0ae91000c5c.
---
 drivers/input/joystick/xpad.c | 28 ++++++++++++++--------------
 1 file changed, 14 insertions(+), 14 deletions(-)

diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c
index 363d50949..8111250b0 100644
--- a/drivers/input/joystick/xpad.c
+++ b/drivers/input/joystick/xpad.c
@@ -446,8 +446,8 @@ static const signed short xpad_btn[] = {
 
 /* used when dpad is mapped to buttons */
 static const signed short xpad_btn_pad[] = {
-	BTN_DPAD_LEFT, BTN_DPAD_RIGHT,	/* d-pad left, right */
-	BTN_DPAD_UP, BTN_DPAD_DOWN,	/* d-pad up, down */
+	BTN_TRIGGER_HAPPY1, BTN_TRIGGER_HAPPY2,		/* d-pad left, right */
+	BTN_TRIGGER_HAPPY3, BTN_TRIGGER_HAPPY4,		/* d-pad up, down */
 	-1				/* terminating entry */
 };
 
@@ -847,10 +847,10 @@ static void xpad_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *d
 	/* digital pad */
 	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
 		/* dpad as buttons (left, right, up, down) */
-		input_report_key(dev, BTN_DPAD_LEFT, data[2] & BIT(2));
-		input_report_key(dev, BTN_DPAD_RIGHT, data[2] & BIT(3));
-		input_report_key(dev, BTN_DPAD_UP, data[2] & BIT(0));
-		input_report_key(dev, BTN_DPAD_DOWN, data[2] & BIT(1));
+		input_report_key(dev, BTN_TRIGGER_HAPPY1, data[2] & BIT(2));
+		input_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & BIT(3));
+		input_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & BIT(0));
+		input_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & BIT(1));
 	} else {
 		input_report_abs(dev, ABS_HAT0X,
 				 !!(data[2] & 0x08) - !!(data[2] & 0x04));
@@ -898,10 +898,10 @@ static void xpad360_process_packet(struct usb_xpad *xpad, struct input_dev *dev,
 	/* digital pad */
 	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
 		/* dpad as buttons (left, right, up, down) */
-		input_report_key(dev, BTN_DPAD_LEFT, data[2] & BIT(2));
-		input_report_key(dev, BTN_DPAD_RIGHT, data[2] & BIT(3));
-		input_report_key(dev, BTN_DPAD_UP, data[2] & BIT(0));
-		input_report_key(dev, BTN_DPAD_DOWN, data[2] & BIT(1));
+		input_report_key(dev, BTN_TRIGGER_HAPPY1, data[2] & BIT(2));
+		input_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & BIT(3));
+		input_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & BIT(0));
+		input_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & BIT(1));
 	}
 
 	/*
@@ -1120,10 +1120,10 @@ static void xpadone_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char
 		/* digital pad */
 		if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
 			/* dpad as buttons (left, right, up, down) */
-			input_report_key(dev, BTN_DPAD_LEFT, data[5] & BIT(2));
-			input_report_key(dev, BTN_DPAD_RIGHT, data[5] & BIT(3));
-			input_report_key(dev, BTN_DPAD_UP, data[5] & BIT(0));
-			input_report_key(dev, BTN_DPAD_DOWN, data[5] & BIT(1));
+			input_report_key(dev, BTN_TRIGGER_HAPPY1, data[5] & BIT(2));
+			input_report_key(dev, BTN_TRIGGER_HAPPY2, data[5] & BIT(3));
+			input_report_key(dev, BTN_TRIGGER_HAPPY3, data[5] & BIT(0));
+			input_report_key(dev, BTN_TRIGGER_HAPPY4, data[5] & BIT(1));
 		} else {
 			input_report_abs(dev, ABS_HAT0X,
 					!!(data[5] & 0x08) - !!(data[5] & 0x04));
-- 
2.52.0


From c80e497b82d1bceb11f17658cbfad875892fa63a Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 12 Nov 2025 23:20:52 +0100
Subject: [PATCH 110/112] Revert "Input: xpad - use new BTN_GRIP* buttons"

This reverts commit e7412ba919f625438c570d8b4fbf16c5f31b583d.
---
 drivers/input/joystick/xpad.c | 36 +++++++++++++++++------------------
 1 file changed, 18 insertions(+), 18 deletions(-)

diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c
index 8111250b0..42af0aaaa 100644
--- a/drivers/input/joystick/xpad.c
+++ b/drivers/input/joystick/xpad.c
@@ -483,8 +483,8 @@ static const signed short xpad_abs_triggers[] = {
 
 /* used when the controller has extra paddle buttons */
 static const signed short xpad_btn_paddles[] = {
-	BTN_GRIPR, BTN_GRIPR2, /* paddle upper right, lower right */
-	BTN_GRIPL, BTN_GRIPL2, /* paddle upper left, lower left */
+	BTN_TRIGGER_HAPPY5, BTN_TRIGGER_HAPPY6, /* paddle upper right, lower right */
+	BTN_TRIGGER_HAPPY7, BTN_TRIGGER_HAPPY8, /* paddle upper left, lower left */
 	-1						/* terminating entry */
 };
 
@@ -1082,10 +1082,10 @@ static void xpadone_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char
 				data[18] = 0;
 
 			/* Elite Series 2 split packet paddle bits */
-			input_report_key(dev, BTN_GRIPR, data[18] & BIT(0));
-			input_report_key(dev, BTN_GRIPR2, data[18] & BIT(1));
-			input_report_key(dev, BTN_GRIPL, data[18] & BIT(2));
-			input_report_key(dev, BTN_GRIPL2, data[18] & BIT(3));
+			input_report_key(dev, BTN_TRIGGER_HAPPY5, data[18] & BIT(0));
+			input_report_key(dev, BTN_TRIGGER_HAPPY6, data[18] & BIT(1));
+			input_report_key(dev, BTN_TRIGGER_HAPPY7, data[18] & BIT(2));
+			input_report_key(dev, BTN_TRIGGER_HAPPY8, data[18] & BIT(3));
 
 			do_sync = true;
 		}
@@ -1182,10 +1182,10 @@ static void xpadone_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char
 					data[32] = 0;
 
 				/* OG Elite Series Controller paddle bits */
-				input_report_key(dev, BTN_GRIPR, data[32] & BIT(1));
-				input_report_key(dev, BTN_GRIPR2, data[32] & BIT(3));
-				input_report_key(dev, BTN_GRIPL, data[32] & BIT(0));
-				input_report_key(dev, BTN_GRIPL2, data[32] & BIT(2));
+				input_report_key(dev, BTN_TRIGGER_HAPPY5, data[32] & BIT(1));
+				input_report_key(dev, BTN_TRIGGER_HAPPY6, data[32] & BIT(3));
+				input_report_key(dev, BTN_TRIGGER_HAPPY7, data[32] & BIT(0));
+				input_report_key(dev, BTN_TRIGGER_HAPPY8, data[32] & BIT(2));
 			} else if (xpad->packet_type == PKT_XBE2_FW_OLD) {
 				/* Mute paddles if controller has a custom mapping applied.
 				 * Checked by comparing the current mapping
@@ -1195,10 +1195,10 @@ static void xpadone_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char
 					data[18] = 0;
 
 				/* Elite Series 2 4.x firmware paddle bits */
-				input_report_key(dev, BTN_GRIPR, data[18] & BIT(0));
-				input_report_key(dev, BTN_GRIPR2, data[18] & BIT(1));
-				input_report_key(dev, BTN_GRIPL, data[18] & BIT(2));
-				input_report_key(dev, BTN_GRIPL2, data[18] & BIT(3));
+				input_report_key(dev, BTN_TRIGGER_HAPPY5, data[18] & BIT(0));
+				input_report_key(dev, BTN_TRIGGER_HAPPY6, data[18] & BIT(1));
+				input_report_key(dev, BTN_TRIGGER_HAPPY7, data[18] & BIT(2));
+				input_report_key(dev, BTN_TRIGGER_HAPPY8, data[18] & BIT(3));
 			} else if (xpad->packet_type == PKT_XBE2_FW_5_EARLY) {
 				/* Mute paddles if controller has a custom mapping applied.
 				 * Checked by comparing the current mapping
@@ -1210,10 +1210,10 @@ static void xpadone_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char
 				/* Elite Series 2 5.x firmware paddle bits
 				 * (before the packet was split)
 				 */
-				input_report_key(dev, BTN_GRIPR, data[22] & BIT(0));
-				input_report_key(dev, BTN_GRIPR2, data[22] & BIT(1));
-				input_report_key(dev, BTN_GRIPL, data[22] & BIT(2));
-				input_report_key(dev, BTN_GRIPL2, data[22] & BIT(3));
+				input_report_key(dev, BTN_TRIGGER_HAPPY5, data[22] & BIT(0));
+				input_report_key(dev, BTN_TRIGGER_HAPPY6, data[22] & BIT(1));
+				input_report_key(dev, BTN_TRIGGER_HAPPY7, data[22] & BIT(2));
+				input_report_key(dev, BTN_TRIGGER_HAPPY8, data[22] & BIT(3));
 			}
 		}
 
-- 
2.52.0


From 4e46f79594e76154907b99da2fcba83f310046aa Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 14 Nov 2025 14:57:18 +0100
Subject: [PATCH 111/112] Revert "drm/amd/display: Clear DPP 3DLUT Cap"

This reverts commit 39923050615cd04231ea664c4cc5dbc8560b8b42.
---
 drivers/gpu/drm/amd/display/dc/dc.h                          | 1 -
 .../gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c   | 3 +--
 .../gpu/drm/amd/display/dc/resource/dcn321/dcn321_resource.c | 5 ++---
 .../gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c   | 3 +--
 .../gpu/drm/amd/display/dc/resource/dcn351/dcn351_resource.c | 3 +--
 .../gpu/drm/amd/display/dc/resource/dcn36/dcn36_resource.c   | 3 +--
 .../gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c | 1 -
 7 files changed, 6 insertions(+), 13 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 94147fcf1..e6ee39c96 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -260,7 +260,6 @@ struct mpc_color_caps {
 	struct rom_curve_caps ogam_rom_caps;
 	struct lut3d_caps mcm_3d_lut_caps;
 	struct lut3d_caps rmcm_3d_lut_caps;
-	bool preblend;
 };
 
 /**
diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c
index b276fec3e..142617779 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn32/dcn32_resource.c
@@ -2256,7 +2256,7 @@ static bool dcn32_resource_construct(
 	dc->caps.color.dpp.gamma_corr = 1;
 	dc->caps.color.dpp.dgam_rom_for_yuv = 0;
 
-	dc->caps.color.dpp.hw_3d_lut = 0;
+	dc->caps.color.dpp.hw_3d_lut = 1;
 	dc->caps.color.dpp.ogam_ram = 0;  // no OGAM in DPP since DCN1
 	// no OGAM ROM on DCN2 and later ASICs
 	dc->caps.color.dpp.ogam_rom_caps.srgb = 0;
@@ -2275,7 +2275,6 @@ static bool dcn32_resource_construct(
 	dc->caps.color.mpc.ogam_rom_caps.pq = 0;
 	dc->caps.color.mpc.ogam_rom_caps.hlg = 0;
 	dc->caps.color.mpc.ocsc = 1;
-	dc->caps.color.mpc.preblend = true;
 
 	/* Use pipe context based otg sync logic */
 	dc->config.use_pipe_ctx_sync_logic = true;
diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn321/dcn321_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn321/dcn321_resource.c
index 3466ca34c..11ba0970a 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn321/dcn321_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn321/dcn321_resource.c
@@ -1758,8 +1758,8 @@ static bool dcn321_resource_construct(
 	dc->caps.color.dpp.gamma_corr = 1;
 	dc->caps.color.dpp.dgam_rom_for_yuv = 0;
 
-	dc->caps.color.dpp.hw_3d_lut = 0;
-	dc->caps.color.dpp.ogam_ram = 0;
+	dc->caps.color.dpp.hw_3d_lut = 1;
+	dc->caps.color.dpp.ogam_ram = 1;
 	// no OGAM ROM on DCN2 and later ASICs
 	dc->caps.color.dpp.ogam_rom_caps.srgb = 0;
 	dc->caps.color.dpp.ogam_rom_caps.bt2020 = 0;
@@ -1777,7 +1777,6 @@ static bool dcn321_resource_construct(
 	dc->caps.color.mpc.ogam_rom_caps.pq = 0;
 	dc->caps.color.mpc.ogam_rom_caps.hlg = 0;
 	dc->caps.color.mpc.ocsc = 1;
-	dc->caps.color.mpc.preblend = true;
 
 	/* Use pipe context based otg sync logic */
 	dc->config.use_pipe_ctx_sync_logic = true;
diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c
index d056e5fd5..36c9aa64d 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn35/dcn35_resource.c
@@ -1893,7 +1893,7 @@ static bool dcn35_resource_construct(
 	dc->caps.color.dpp.gamma_corr = 1;
 	dc->caps.color.dpp.dgam_rom_for_yuv = 0;
 
-	dc->caps.color.dpp.hw_3d_lut = 0;
+	dc->caps.color.dpp.hw_3d_lut = 1;
 	dc->caps.color.dpp.ogam_ram = 0;  // no OGAM in DPP since DCN1
 	// no OGAM ROM on DCN301
 	dc->caps.color.dpp.ogam_rom_caps.srgb = 0;
@@ -1912,7 +1912,6 @@ static bool dcn35_resource_construct(
 	dc->caps.color.mpc.ogam_rom_caps.pq = 0;
 	dc->caps.color.mpc.ogam_rom_caps.hlg = 0;
 	dc->caps.color.mpc.ocsc = 1;
-	dc->caps.color.mpc.preblend = true;
 
 	dc->caps.num_of_host_routers = 2;
 	dc->caps.num_of_dpias_per_host_router = 2;
diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn351/dcn351_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn351/dcn351_resource.c
index 9fab31690..230e79e0e 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn351/dcn351_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn351/dcn351_resource.c
@@ -1866,7 +1866,7 @@ static bool dcn351_resource_construct(
 	dc->caps.color.dpp.gamma_corr = 1;
 	dc->caps.color.dpp.dgam_rom_for_yuv = 0;
 
-	dc->caps.color.dpp.hw_3d_lut = 0;
+	dc->caps.color.dpp.hw_3d_lut = 1;
 	dc->caps.color.dpp.ogam_ram = 0;  // no OGAM in DPP since DCN1
 	// no OGAM ROM on DCN301
 	dc->caps.color.dpp.ogam_rom_caps.srgb = 0;
@@ -1885,7 +1885,6 @@ static bool dcn351_resource_construct(
 	dc->caps.color.mpc.ogam_rom_caps.pq = 0;
 	dc->caps.color.mpc.ogam_rom_caps.hlg = 0;
 	dc->caps.color.mpc.ocsc = 1;
-	dc->caps.color.mpc.preblend = true;
 
 	dc->caps.num_of_host_routers = 2;
 	dc->caps.num_of_dpias_per_host_router = 2;
diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn36/dcn36_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn36/dcn36_resource.c
index 6469d5fe2..aa74bfb99 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn36/dcn36_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn36/dcn36_resource.c
@@ -1866,7 +1866,7 @@ static bool dcn36_resource_construct(
 	dc->caps.color.dpp.gamma_corr = 1;
 	dc->caps.color.dpp.dgam_rom_for_yuv = 0;
 
-	dc->caps.color.dpp.hw_3d_lut = 0;
+	dc->caps.color.dpp.hw_3d_lut = 1;
 	dc->caps.color.dpp.ogam_ram = 0;  // no OGAM in DPP since DCN1
 	// no OGAM ROM on DCN301
 	dc->caps.color.dpp.ogam_rom_caps.srgb = 0;
@@ -1885,7 +1885,6 @@ static bool dcn36_resource_construct(
 	dc->caps.color.mpc.ogam_rom_caps.pq = 0;
 	dc->caps.color.mpc.ogam_rom_caps.hlg = 0;
 	dc->caps.color.mpc.ocsc = 1;
-	dc->caps.color.mpc.preblend = true;
 
 	dc->caps.num_of_host_routers = 2;
 	dc->caps.num_of_dpias_per_host_router = 2;
diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
index 875ae9748..2e3fd454e 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn401/dcn401_resource.c
@@ -1955,7 +1955,6 @@ static bool dcn401_resource_construct(
 	dc->caps.color.mpc.ogam_rom_caps.pq = 0;
 	dc->caps.color.mpc.ogam_rom_caps.hlg = 0;
 	dc->caps.color.mpc.ocsc = 1;
-	dc->caps.color.mpc.preblend = true;
 	dc->config.use_spl = true;
 	dc->config.prefer_easf = true;
 
-- 
2.52.0


From a689fb3c9451dbd58d31e1a04ec98cbea467f7ae Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 14 Nov 2025 14:59:04 +0100
Subject: [PATCH 112/112] Revert "drm/amd/display: Use mpc.preblend flag to
 indicate preblend"

This reverts commit 1c3217dd557d4f04eb4c2afcd7c76de6b4d66ccb.
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c | 2 +-
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index 1dcc79b35..1c66f6ede 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -1104,7 +1104,7 @@ int amdgpu_dm_verify_lut3d_size(struct amdgpu_device *adev,
 	struct dm_plane_state *dm_plane_state = to_dm_plane_state(plane_state);
 	const struct drm_color_lut *shaper = NULL, *lut3d = NULL;
 	uint32_t exp_size, size, dim_size = MAX_COLOR_3DLUT_SIZE;
-	bool has_3dlut = adev->dm.dc->caps.color.dpp.hw_3d_lut || adev->dm.dc->caps.color.mpc.preblend;
+	bool has_3dlut = adev->dm.dc->caps.color.dpp.hw_3d_lut;
 
 	/* shaper LUT is only available if 3D LUT color caps */
 	exp_size = has_3dlut ? MAX_COLOR_LUT_ENTRIES : 0;
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
index 7c4496fb4..b7017cacc 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
@@ -1634,7 +1634,7 @@ dm_atomic_plane_attach_color_mgmt_properties(struct amdgpu_display_manager *dm,
 		drm_object_attach_property(&plane->base,
 					   dm->adev->mode_info.plane_ctm_property, 0);
 
-	if (dpp_color_caps.hw_3d_lut || dm->dc->caps.color.mpc.preblend) {
+	if (dpp_color_caps.hw_3d_lut) {
 		drm_object_attach_property(&plane->base,
 					   mode_info.plane_shaper_lut_property, 0);
 		drm_object_attach_property(&plane->base,
-- 
2.52.0

