From 3dd0789e89f49aaa1e2885a521ed5f66cc475455 Mon Sep 17 00:00:00 2001
From: Robert Beckett <bob.beckett@collabora.com>
Date: Thu, 21 Nov 2024 21:12:03 +0000
Subject: [PATCH 017/108] Bluetooth: btrtl: add suspend handling to ignore
 BT_DIS

With new fw, btrtl can be set to ignore the BT_DIS
pin that is usually asserted during suspend.
This allows the device to be a wakeup source and
allows us to wakeup via bluetooth peripherals.

Signed-off-by: Robert Beckett <bob.beckett@collabora.com>
[Rebased onto v6.11.[4,5] to fix conflicts on drivers/bluetooth/btusb.c]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/bluetooth/btrtl.c | 144 ++++++++++++++++++++++++++++++++++++++
 drivers/bluetooth/btrtl.h |  13 ++++
 drivers/bluetooth/btusb.c |  16 +++++
 3 files changed, 173 insertions(+)

diff --git a/drivers/bluetooth/btrtl.c b/drivers/bluetooth/btrtl.c
index 5603b282f..1ecf85f2e 100644
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@ -9,6 +9,7 @@
 #include <linux/firmware.h>
 #include <linux/unaligned.h>
 #include <linux/usb.h>
+#include <linux/dmi.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
@@ -51,6 +52,9 @@
 #define	RTL_CHIP_SUBVER (&(struct rtl_vendor_cmd) {{0x10, 0x38, 0x04, 0x28, 0x80}})
 #define	RTL_CHIP_REV    (&(struct rtl_vendor_cmd) {{0x10, 0x3A, 0x04, 0x28, 0x80}})
 #define	RTL_SEC_PROJ    (&(struct rtl_vendor_cmd) {{0x10, 0xA4, 0xAD, 0x00, 0xb0}})
+#define	RTL_IGNORE_MASK (&(struct rtl_vendor_cmd) {{0x10, 0x34, 0x60, 0x00, 0xb0}})
+
+#define	RTL_IGNORE_BT_DIS BIT(0)
 
 #define RTL_PATCH_SNIPPETS		0x01
 #define RTL_PATCH_DUMMY_HEADER		0x02
@@ -449,6 +453,58 @@ static int btrtl_vendor_read_reg16(struct hci_dev *hdev,
 	return 0;
 }
 
+static int btrtl_vendor_read_reg16_unlocked(struct hci_dev *hdev,
+					    struct rtl_vendor_cmd *cmd, u8 *rp)
+{
+	int ret;
+
+	hci_req_sync_lock(hdev);
+	ret = btrtl_vendor_read_reg16(hdev, cmd, rp);
+	hci_req_sync_unlock(hdev);
+
+	return ret;
+}
+
+static int btrtl_vendor_write_reg16(struct hci_dev *hdev,
+				    struct rtl_vendor_cmd *cmd, const u8 * const rp)
+{
+	struct sk_buff *skb;
+	u8 buf[sizeof(*cmd) + 2];
+	int err = 0;
+
+	memcpy(buf, cmd, sizeof(*cmd));
+	memcpy(buf + sizeof(*cmd), rp, 2);
+
+	skb = __hci_cmd_sync(hdev, 0xfc62, sizeof(buf), buf, HCI_INIT_TIMEOUT);
+	if (IS_ERR(skb)) {
+		err = PTR_ERR(skb);
+		rtl_dev_err(hdev, "RTL: Write reg16 failed (%d)", err);
+		return err;
+	}
+
+	if (skb->len != 1 || skb->data[0]) {
+		bt_dev_err(hdev, "RTL: Write reg16 length mismatch");
+		kfree_skb(skb);
+		return -EIO;
+	}
+
+	kfree_skb(skb);
+
+	return 0;
+}
+
+static int btrtl_vendor_write_reg16_unlocked(struct hci_dev *hdev,
+					    struct rtl_vendor_cmd *cmd, u8 *rp)
+{
+	int ret;
+
+	hci_req_sync_lock(hdev);
+	ret = btrtl_vendor_write_reg16(hdev, cmd, rp);
+	hci_req_sync_unlock(hdev);
+
+	return ret;
+}
+
 static void *rtl_iov_pull_data(struct rtl_iovec *iov, u32 len)
 {
 	void *data = iov->data;
@@ -1297,8 +1353,44 @@ int btrtl_download_firmware(struct hci_dev *hdev,
 }
 EXPORT_SYMBOL_GPL(btrtl_download_firmware);
 
+static const struct dmi_system_id btrtl_can_ignore_bt_dis_table[] = {
+	{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Valve"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Jupiter"),
+		},
+	},
+	{}
+};
+
+static bool btrtl_fw_can_ignore_bt_dis(struct hci_dev *hdev)
+{
+	struct sk_buff *skb;
+	struct hci_rp_read_local_version *rp;
+	bool ret = false;
+
+	if (!dmi_check_system(btrtl_can_ignore_bt_dis_table))
+		return false;
+
+	skb = btrtl_read_local_version(hdev);
+	if (IS_ERR(skb))
+		return false;
+
+	rp = (struct hci_rp_read_local_version *)skb->data;
+	if (le16_to_cpu(rp->hci_rev) == 0x98d7 &&
+	    le16_to_cpu(rp->lmp_subver) == 0x081e)
+		ret = true;
+
+	kfree_skb(skb);
+
+	return ret;
+}
+
 void btrtl_set_quirks(struct hci_dev *hdev, struct btrtl_device_info *btrtl_dev)
 {
+	if (btrtl_fw_can_ignore_bt_dis(hdev))
+		btrealtek_set_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS);
+
 	/* Enable controller to do both LE scan and BR/EDR inquiry
 	 * simultaneously.
 	 */
@@ -1511,6 +1603,58 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 }
 EXPORT_SYMBOL_GPL(btrtl_get_uart_settings);
 
+int btrtl_early_suspend(struct hci_dev *hdev)
+{
+	int ret = 0;
+	u16 ignore_mask;
+	u8 buf[2];
+
+	if (!btrealtek_test_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS))
+		return -EOPNOTSUPP;
+
+	if (hci_dev_test_flag(hdev, HCI_POWERING_DOWN))
+		return 0;
+
+	ret = btrtl_vendor_read_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+	if (ret)
+		return ret;
+
+	ignore_mask = get_unaligned_le16(buf);
+	ignore_mask |= RTL_IGNORE_BT_DIS;
+	put_unaligned_le16(ignore_mask, buf);
+
+	ret = btrtl_vendor_write_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(btrtl_early_suspend);
+
+int btrtl_late_resume(struct hci_dev *hdev)
+{
+	int ret = 0;
+	u16 ignore_mask;
+	u8 buf[2];
+
+	if (!btrealtek_test_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS))
+		return -EOPNOTSUPP;
+
+	if (hci_dev_test_flag(hdev, HCI_POWERING_DOWN))
+		return 0;
+
+	ret = btrtl_vendor_read_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+	if (ret)
+		return ret;
+
+	ignore_mask = get_unaligned_le16(buf);
+	ignore_mask &= ~RTL_IGNORE_BT_DIS;
+	put_unaligned_le16(ignore_mask, buf);
+
+	ret = btrtl_vendor_write_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(btrtl_late_resume);
+
 MODULE_AUTHOR("Daniel Drake <drake@endlessm.com>");
 MODULE_DESCRIPTION("Bluetooth support for Realtek devices ver " VERSION);
 MODULE_VERSION(VERSION);
diff --git a/drivers/bluetooth/btrtl.h b/drivers/bluetooth/btrtl.h
index a2d9d34f9..61be34ccb 100644
--- a/drivers/bluetooth/btrtl.h
+++ b/drivers/bluetooth/btrtl.h
@@ -105,6 +105,7 @@ struct rtl_vendor_cmd {
 
 enum {
 	REALTEK_ALT6_CONTINUOUS_TX_CHIP,
+	REALTEK_CAN_IGNORE_BT_DIS,
 
 	__REALTEK_NUM_FLAGS,
 };
@@ -148,6 +149,8 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 			    unsigned int *controller_baudrate,
 			    u32 *device_baudrate, bool *flow_control);
 void btrtl_set_driver_name(struct hci_dev *hdev, const char *driver_name);
+int btrtl_early_suspend(struct hci_dev *hdev);
+int btrtl_late_resume(struct hci_dev *hdev);
 
 #else
 
@@ -195,4 +198,14 @@ static inline void btrtl_set_driver_name(struct hci_dev *hdev, const char *drive
 {
 }
 
+static inline int btrtl_early_suspend(struct hci_dev *hdev, pm_message_t message)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int btrtl_late_resume(struct hci_dev *hdev)
+{
+	return -EOPNOTSUPP;
+}
+
 #endif
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index ded09e94d..77c96a6d4 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -963,9 +963,11 @@ struct btusb_data {
 
 	int (*setup_on_usb)(struct hci_dev *hdev);
 
+	int (*early_suspend)(struct hci_dev *hdev);
 	int (*suspend)(struct hci_dev *hdev);
 	int (*resume)(struct hci_dev *hdev);
 	int (*disconnect)(struct hci_dev *hdev);
+	int (*late_resume)(struct hci_dev *hdev);
 
 	int oob_wake_irq;   /* irq for out-of-band wake-on-bt */
 
@@ -4300,6 +4302,8 @@ static int btusb_probe(struct usb_interface *intf,
 		hdev->shutdown = btrtl_shutdown_realtek;
 		hdev->reset = btusb_rtl_reset;
 		hdev->hw_error = btusb_rtl_hw_error;
+		data->early_suspend = btrtl_early_suspend;
+		data->late_resume = btrtl_late_resume;
 
 		/* Realtek devices need to set remote wakeup on auto-suspend */
 		set_bit(BTUSB_WAKEUP_AUTOSUSPEND, &data->flags);
@@ -4466,6 +4470,8 @@ static void btusb_disconnect(struct usb_interface *intf)
 static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct btusb_data *data = usb_get_intfdata(intf);
+	struct hci_dev *hdev = data->hdev;
+	int ret = 0;
 
 	BT_DBG("intf %p", intf);
 
@@ -4478,6 +4484,11 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 	if (data->suspend_count++)
 		return 0;
 
+	if (data->early_suspend)
+		ret = data->early_suspend(hdev);
+	if (ret && ret != -EOPNOTSUPP)
+		return ret;
+
 	spin_lock_irq(&data->txlock);
 	if (!(PMSG_IS_AUTO(message) && data->tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &data->flags);
@@ -4605,6 +4616,11 @@ static int btusb_resume(struct usb_interface *intf)
 	spin_unlock_irq(&data->txlock);
 	schedule_work(&data->work);
 
+	if (data->late_resume)
+		err = data->late_resume(hdev);
+	if (err && err != -EOPNOTSUPP)
+		goto done;
+
 	return 0;
 
 failed:
-- 
2.52.0

