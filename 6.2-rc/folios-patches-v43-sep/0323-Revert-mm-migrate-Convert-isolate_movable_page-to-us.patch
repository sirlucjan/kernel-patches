From 7ca8ac9a30b35826e3c17e16bbb59d7768b55f2f Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Wed, 25 Jan 2023 19:18:58 +0100
Subject: [PATCH 323/353] Revert "mm/migrate: Convert isolate_movable_page() to
 use folios"

This reverts commit 4cd24646aa3cd55d0cb9201641ad0cc1e4bd8165.

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 mm/migrate.c | 39 +++++++++++++++++++--------------------
 1 file changed, 19 insertions(+), 20 deletions(-)

diff --git a/mm/migrate.c b/mm/migrate.c
index 10677aba8..0104151b6 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -60,7 +60,6 @@
 
 int isolate_movable_page(struct page *page, isolate_mode_t mode)
 {
-	struct folio *folio = page_folio(page);
 	const struct movable_operations *mops;
 
 	/*
@@ -72,11 +71,11 @@ int isolate_movable_page(struct page *page, isolate_mode_t mode)
 	 * the put_page() at the end of this block will take care of
 	 * release this page, thus avoiding a nasty leakage.
 	 */
-	if (unlikely(!folio_try_get(folio)))
+	if (unlikely(!get_page_unless_zero(page)))
 		goto out;
 
-	if (unlikely(folio_test_slab(folio)))
-		goto out_putfolio;
+	if (unlikely(PageSlab(page)))
+		goto out_putpage;
 	/* Pairs with smp_wmb() in slab freeing, e.g. SLUB's __free_slab() */
 	smp_rmb();
 	/*
@@ -84,12 +83,12 @@ int isolate_movable_page(struct page *page, isolate_mode_t mode)
 	 * we use non-atomic bitops on newly allocated page flags so
 	 * unconditionally grabbing the lock ruins page's owner side.
 	 */
-	if (unlikely(!__folio_test_movable(folio)))
-		goto out_putfolio;
+	if (unlikely(!__PageMovable(page)))
+		goto out_putpage;
 	/* Pairs with smp_wmb() in slab allocation, e.g. SLUB's alloc_slab_page() */
 	smp_rmb();
-	if (unlikely(folio_test_slab(folio)))
-		goto out_putfolio;
+	if (unlikely(PageSlab(page)))
+		goto out_putpage;
 
 	/*
 	 * As movable pages are not isolated from LRU lists, concurrent
@@ -102,29 +101,29 @@ int isolate_movable_page(struct page *page, isolate_mode_t mode)
 	 * lets be sure we have the page lock
 	 * before proceeding with the movable page isolation steps.
 	 */
-	if (unlikely(!folio_trylock(folio)))
-		goto out_putfolio;
+	if (unlikely(!trylock_page(page)))
+		goto out_putpage;
 
-	if (!folio_test_movable(folio) || folio_test_isolated(folio))
+	if (!PageMovable(page) || PageIsolated(page))
 		goto out_no_isolated;
 
-	mops = folio_movable_ops(folio);
-	VM_BUG_ON_FOLIO(!mops, folio);
+	mops = page_movable_ops(page);
+	VM_BUG_ON_PAGE(!mops, page);
 
-	if (!mops->isolate_page(&folio->page, mode))
+	if (!mops->isolate_page(page, mode))
 		goto out_no_isolated;
 
 	/* Driver shouldn't use PG_isolated bit of page->flags */
-	WARN_ON_ONCE(folio_test_isolated(folio));
-	folio_set_isolated(folio);
-	folio_unlock(folio);
+	WARN_ON_ONCE(PageIsolated(page));
+	SetPageIsolated(page);
+	unlock_page(page);
 
 	return 0;
 
 out_no_isolated:
-	folio_unlock(folio);
-out_putfolio:
-	folio_put(folio);
+	unlock_page(page);
+out_putpage:
+	put_page(page);
 out:
 	return -EBUSY;
 }
-- 
2.39.0.rc2.1.gbd5df96b79

