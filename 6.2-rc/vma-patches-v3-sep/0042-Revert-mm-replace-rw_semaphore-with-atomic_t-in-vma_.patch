From 321e5de1b4e6b95b62556a05acf97d257e77a557 Mon Sep 17 00:00:00 2001
From: Piotr Gorski <lucjan.lucjanov@gmail.com>
Date: Sat, 7 Jan 2023 02:19:22 +0100
Subject: [PATCH 42/45] Revert "mm: replace rw_semaphore with atomic_t in
 vma_lock"

This reverts commit 5f641d9b32c94873b6560aa96dce471560056518.

Signed-off-by: Piotr Gorski <lucjan.lucjanov@gmail.com>
---
 include/linux/mm.h       | 37 ++++++++++++-------------------------
 include/linux/mm_types.h | 10 ++--------
 kernel/fork.c            |  6 +++---
 mm/init-mm.c             |  2 --
 4 files changed, 17 insertions(+), 38 deletions(-)

diff --git a/include/linux/mm.h b/include/linux/mm.h
index 294dd44b2..d40bf8a5e 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -627,16 +627,12 @@ static inline void vma_write_lock(struct vm_area_struct *vma)
 	 * mm->mm_lock_seq can't be concurrently modified.
 	 */
 	mm_lock_seq = READ_ONCE(vma->vm_mm->mm_lock_seq);
-	if (vma->vm_lock->lock_seq == mm_lock_seq)
+	if (vma->vm_lock_seq == mm_lock_seq)
 		return;
 
-	if (atomic_cmpxchg(&vma->vm_lock->count, 0, -1))
-		wait_event(vma->vm_mm->vma_writer_wait,
-			   atomic_cmpxchg(&vma->vm_lock->count, 0, -1) == 0);
-	vma->vm_lock->lock_seq = mm_lock_seq;
-	/* Write barrier to ensure lock_seq change is visible before count */
-	smp_wmb();
-	atomic_set(&vma->vm_lock->count, 0);
+	down_write(&vma->vm_lock->lock);
+	vma->vm_lock_seq = mm_lock_seq;
+	up_write(&vma->vm_lock->lock);
 }
 
 /*
@@ -647,28 +643,20 @@ static inline void vma_write_lock(struct vm_area_struct *vma)
 static inline bool vma_read_trylock(struct vm_area_struct *vma)
 {
 	/* Check before locking. A race might cause false locked result. */
-	if (vma->vm_lock->lock_seq == READ_ONCE(vma->vm_mm->mm_lock_seq))
+	if (vma->vm_lock_seq == READ_ONCE(vma->vm_mm->mm_lock_seq))
 		return false;
 
-	if (unlikely(!atomic_inc_unless_negative(&vma->vm_lock->count)))
+	if (unlikely(down_read_trylock(&vma->vm_lock->lock) == 0))
 		return false;
 
-	/* If atomic_t overflows, restore and fail to lock. */
-	if (unlikely(atomic_read(&vma->vm_lock->count) < 0)) {
-		if (atomic_dec_and_test(&vma->vm_lock->count))
-			wake_up(&vma->vm_mm->vma_writer_wait);
-		return false;
-	}
-
 	/*
 	 * Overflow might produce false locked result.
 	 * False unlocked result is impossible because we modify and check
 	 * vma->vm_lock_seq under vma->vm_lock protection and mm->mm_lock_seq
 	 * modification invalidates all existing locks.
 	 */
-	if (unlikely(vma->vm_lock->lock_seq == READ_ONCE(vma->vm_mm->mm_lock_seq))) {
-		if (atomic_dec_and_test(&vma->vm_lock->count))
-			wake_up(&vma->vm_mm->vma_writer_wait);
+	if (unlikely(vma->vm_lock_seq == READ_ONCE(vma->vm_mm->mm_lock_seq))) {
+		up_read(&vma->vm_lock->lock);
 		return false;
 	}
 	return true;
@@ -676,8 +664,7 @@ static inline bool vma_read_trylock(struct vm_area_struct *vma)
 
 static inline void vma_read_unlock(struct vm_area_struct *vma)
 {
-	if (atomic_dec_and_test(&vma->vm_lock->count))
-		wake_up(&vma->vm_mm->vma_writer_wait);
+	up_read(&vma->vm_lock->lock);
 }
 
 static inline void vma_assert_write_locked(struct vm_area_struct *vma)
@@ -687,13 +674,13 @@ static inline void vma_assert_write_locked(struct vm_area_struct *vma)
 	 * current task is holding mmap_write_lock, both vma->vm_lock_seq and
 	 * mm->mm_lock_seq can't be concurrently modified.
 	 */
-	VM_BUG_ON_VMA(vma->vm_lock->lock_seq != READ_ONCE(vma->vm_mm->mm_lock_seq), vma);
+	VM_BUG_ON_VMA(vma->vm_lock_seq != READ_ONCE(vma->vm_mm->mm_lock_seq), vma);
 }
 
 static inline void vma_assert_no_reader(struct vm_area_struct *vma)
 {
-	VM_BUG_ON_VMA(atomic_read(&vma->vm_lock->count) > 0 &&
-		      vma->vm_lock->lock_seq != READ_ONCE(vma->vm_mm->mm_lock_seq),
+	VM_BUG_ON_VMA(rwsem_is_locked(&vma->vm_lock->lock) &&
+		      vma->vm_lock_seq != READ_ONCE(vma->vm_mm->mm_lock_seq),
 		      vma);
 }
 
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index a6050c38c..faa61b400 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -527,13 +527,7 @@ struct anon_vma_name {
 };
 
 struct vma_lock {
-	/*
-	 * count > 0 ==> read-locked with 'count' number of readers
-	 * count < 0 ==> write-locked
-	 * count = 0 ==> unlocked
-	 */
-	atomic_t count;
-	int lock_seq;
+	struct rw_semaphore lock;
 };
 
 /*
@@ -572,6 +566,7 @@ struct vm_area_struct {
 	unsigned long vm_flags;
 
 #ifdef CONFIG_PER_VMA_LOCK
+	int vm_lock_seq;
 	struct vma_lock *vm_lock;
 #endif
 
@@ -711,7 +706,6 @@ struct mm_struct {
 					  * by mmlist_lock
 					  */
 #ifdef CONFIG_PER_VMA_LOCK
-		struct wait_queue_head vma_writer_wait;
 		int mm_lock_seq;
 		struct {
 			struct list_head head;
diff --git a/kernel/fork.c b/kernel/fork.c
index b221ad182..95db6a521 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -461,8 +461,9 @@ static bool vma_init_lock(struct vm_area_struct *vma)
 	vma->vm_lock = kmem_cache_alloc(vma_lock_cachep, GFP_KERNEL);
 	if (!vma->vm_lock)
 		return false;
-	atomic_set(&vma->vm_lock->count, 0);
-	vma->vm_lock->lock_seq = -1;
+
+	init_rwsem(&vma->vm_lock->lock);
+	vma->vm_lock_seq = -1;
 
 	return true;
 }
@@ -1228,7 +1229,6 @@ static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,
 	mmap_init_lock(mm);
 	INIT_LIST_HEAD(&mm->mmlist);
 #ifdef CONFIG_PER_VMA_LOCK
-	init_waitqueue_head(&mm->vma_writer_wait);
 	WRITE_ONCE(mm->mm_lock_seq, 0);
 	INIT_LIST_HEAD(&mm->vma_free_list.head);
 	spin_lock_init(&mm->vma_free_list.lock);
diff --git a/mm/init-mm.c b/mm/init-mm.c
index 0088e31e5..b53d23c2d 100644
--- a/mm/init-mm.c
+++ b/mm/init-mm.c
@@ -38,8 +38,6 @@ struct mm_struct init_mm = {
 	.arg_lock	=  __SPIN_LOCK_UNLOCKED(init_mm.arg_lock),
 	.mmlist		= LIST_HEAD_INIT(init_mm.mmlist),
 #ifdef CONFIG_PER_VMA_LOCK
-	.vma_writer_wait =
-		__WAIT_QUEUE_HEAD_INITIALIZER(init_mm.vma_writer_wait),
 	.mm_lock_seq	= 0,
 	.vma_free_list.head = LIST_HEAD_INIT(init_mm.vma_free_list.head),
 	.vma_free_list.lock =  __SPIN_LOCK_UNLOCKED(init_mm.vma_free_list.lock),
-- 
2.39.0.rc2.1.gbd5df96b79

