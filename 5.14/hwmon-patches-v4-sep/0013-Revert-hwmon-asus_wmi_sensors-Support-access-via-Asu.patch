From cc7d14cb82374f401582651e6fde791f2b16f3cd Mon Sep 17 00:00:00 2001
From: Oleksandr Natalenko <oleksandr@natalenko.name>
Date: Tue, 12 Oct 2021 14:16:44 +0200
Subject: [PATCH 13/17] Revert "hwmon: (asus_wmi_sensors) Support access via
 Asus WMI."

This reverts commit 2e8739d5fd7e39d6efea278737f0ad0cc326f1c7.
---
 drivers/hwmon/Kconfig            |  12 -
 drivers/hwmon/Makefile           |   1 -
 drivers/hwmon/asus_wmi_sensors.c | 595 -------------------------------
 3 files changed, 608 deletions(-)
 delete mode 100644 drivers/hwmon/asus_wmi_sensors.c

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index d128520b0..9eefb1014 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -2185,18 +2185,6 @@ config SENSORS_ATK0110
 	  This driver can also be built as a module. If so, the module
 	  will be called asus_atk0110.
 
-config SENSORS_ASUS_WMI
-	tristate "ASUS WMI"
-	depends on X86
-	help
-	  If you say yes here you get support for the ACPI hardware
-	  monitoring interface found in many ASUS motherboards. This
-	  driver will provide readings of fans, voltages and temperatures
-	  through the system firmware.
-
-	  This driver can also be built as a module. If so, the module
-	  will be called asus_wmi_sensors.
-
 endif # ACPI
 
 endif # HWMON
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index ffcde3697..0241ed84b 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -9,7 +9,6 @@ obj-$(CONFIG_HWMON_VID)		+= hwmon-vid.o
 # APCI drivers
 obj-$(CONFIG_SENSORS_ACPI_POWER) += acpi_power_meter.o
 obj-$(CONFIG_SENSORS_ATK0110)	+= asus_atk0110.o
-obj-$(CONFIG_SENSORS_ASUS_WMI)	+= asus_wmi_sensors.o
 
 # Native drivers
 # asb100, then w83781d go first, as they can override other drivers' addresses.
diff --git a/drivers/hwmon/asus_wmi_sensors.c b/drivers/hwmon/asus_wmi_sensors.c
deleted file mode 100644
index 6b04fad18..000000000
--- a/drivers/hwmon/asus_wmi_sensors.c
+++ /dev/null
@@ -1,595 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * HWMON driver for ASUS motherboards that publish some sensor values
- * via the embedded controller registers
- *
- * Copyright (C) 2021 Eugene Shalygin <eugene.shalygin@gmail.com>
- * Copyright (C) 2018-2019 Ed Brindley <kernel@maidavale.org>
- */
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-#define DRVNAME "asus_wmi_sensors"
-
-#include <linux/dmi.h>
-#include <linux/hwmon.h>
-#include <linux/hwmon-sysfs.h>
-#include <linux/init.h>
-#include <linux/jiffies.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/platform_device.h>
-#include <linux/acpi.h>
-#include <linux/wmi.h>
-
-#define ASUSWMI_MONITORING_GUID		"466747A0-70EC-11DE-8A39-0800200C9A66"
-#define ASUSWMI_METHODID_BLOCK_READ_EC		0x42524543 /* BREC */
-
-#define HWMON_MAX	9
-
-#define ASUS_WMI_BLOCK_READ_REGISTERS_MAX 0x10 /* from the ASUS DSDT source */
-/* from the ASUS_WMI_BLOCK_READ_REGISTERS_MAX value */
-#define ASUS_WMI_MAX_BUF_LEN 0x80
-#define MAX_SENSOR_LABEL_LENGTH 0x10
-
-#define ASUSWMI_SENSORS_MAX 11
-#define ASUS_EC_KNOWN_EC_REGISTERS 14
-
-enum asus_wmi_ec_board {
-	BOARD_R_C8H, // ROG Crosshair VIII Hero
-	BOARD_R_C8DH, // ROG Crosshair VIII Dark Hero
-	BOARD_R_C8F, // ROG Crosshair VIII Formula
-	BOARD_RS_X570_E_G, // ROG STRIX X570-E GAMING
-	BOARD_RS_B550_E_G, // ROG STRIX B550-E GAMING
-};
-
-/* boards with EC support */
-static const char *const asus_wmi_ec_boards_names[] = {
-	[BOARD_R_C8H] = "ROG CROSSHAIR VIII HERO",
-	[BOARD_R_C8DH] = "ROG CROSSHAIR VIII DARK HERO",
-	[BOARD_R_C8F] = "ROG CROSSHAIR VIII FORMULA",
-	[BOARD_RS_X570_E_G] = "ROG STRIX X570-E GAMING",
-	[BOARD_RS_B550_E_G] = "ROG STRIX B550-E GAMING",
-};
-
-static u32 hwmon_attributes[] = {
-	[hwmon_chip] = HWMON_C_REGISTER_TZ,
-	[hwmon_temp] = HWMON_T_INPUT | HWMON_T_LABEL,
-	[hwmon_in] = HWMON_I_INPUT | HWMON_I_LABEL,
-	[hwmon_curr] = HWMON_C_INPUT | HWMON_C_LABEL,
-	[hwmon_fan] = HWMON_F_INPUT | HWMON_F_LABEL,
-};
-
-union asus_wmi_ec_sensor_address {
-	u32 value;
-	struct {
-		u8 index;
-		u8 bank;
-		u8 size;
-		u8 dummy;
-	} addr;
-};
-
-struct asus_wmi_ec_sensor_info {
-	char label[MAX_SENSOR_LABEL_LENGTH];
-	enum hwmon_sensor_types type;
-	union asus_wmi_ec_sensor_address addr;
-	u32 cached_value;
-};
-
-struct asus_wmi_ec_info {
-	struct asus_wmi_ec_sensor_info sensors[ASUSWMI_SENSORS_MAX];
-	/* UTF-16 string to pass to BRxx() WMI function */
-	char read_arg[((ASUS_WMI_BLOCK_READ_REGISTERS_MAX * 4) + 1) * 2];
-	u8 read_buffer[ASUS_WMI_BLOCK_READ_REGISTERS_MAX];
-	u8 nr_sensors; /* number of board EC sensors */
-	/* number of EC registers to read (sensor might span more than 1 register) */
-	u8 nr_registers;
-	unsigned long last_updated; /* in jiffies */
-};
-
-struct asus_wmi_sensors {
-	/* lock access to instrnal cache */
-	struct mutex lock;
-	struct asus_wmi_ec_info ec;
-
-	int ec_board;
-};
-
-struct asus_wmi_data {
-	int ec_board;
-};
-
-static inline union asus_wmi_ec_sensor_address asus_wmi_ec_make_sensor_address(u8 size,
-									       u8 bank,
-									       u8 index)
-{
-	union asus_wmi_ec_sensor_address res;
-
-	res.value = (size << 16) + (bank << 8) + index;
-	return res;
-}
-
-static inline void asus_wmi_ec_set_sensor_info(struct asus_wmi_ec_sensor_info *sensor_info,
-					       const char *label,
-					       enum hwmon_sensor_types type,
-					       union asus_wmi_ec_sensor_address addr,
-					       u8 *nr_regs)
-{
-	sensor_info->type = type;
-	strcpy(sensor_info->label, label);
-	sensor_info->cached_value = 0;
-	sensor_info->addr.value = addr.value;
-	*nr_regs += sensor_info->addr.addr.size;
-}
-
-static void asus_wmi_ec_fill_board_sensors(struct asus_wmi_ec_info *ec, int board)
-{
-	struct asus_wmi_ec_sensor_info *si;
-
-	si = ec->sensors;
-	ec->nr_registers = 0;
-
-	switch (board) {
-	case BOARD_RS_B550_E_G:
-	case BOARD_RS_X570_E_G:
-	case BOARD_R_C8H:
-	case BOARD_R_C8DH:
-	case BOARD_R_C8F:
-		asus_wmi_ec_set_sensor_info(si++, "Chipset", hwmon_temp,
-					    asus_wmi_ec_make_sensor_address(1, 0x00, 0x3A),
-					    &ec->nr_registers);
-		asus_wmi_ec_set_sensor_info(si++, "CPU", hwmon_temp,
-					    asus_wmi_ec_make_sensor_address(1, 0x00, 0x3B),
-					    &ec->nr_registers);
-		asus_wmi_ec_set_sensor_info(si++, "Motherboard", hwmon_temp,
-					    asus_wmi_ec_make_sensor_address(1, 0x00, 0x3C),
-					    &ec->nr_registers);
-		asus_wmi_ec_set_sensor_info(si++, "T_Sensor", hwmon_temp,
-					    asus_wmi_ec_make_sensor_address(1, 0x00, 0x3D),
-					    &ec->nr_registers);
-		asus_wmi_ec_set_sensor_info(si++, "VRM", hwmon_temp,
-					    asus_wmi_ec_make_sensor_address(1, 0x00, 0x3E),
-					    &ec->nr_registers);
-	}
-
-	switch (board) {
-	case BOARD_RS_X570_E_G:
-	case BOARD_R_C8H:
-	case BOARD_R_C8DH:
-	case BOARD_R_C8F:
-		asus_wmi_ec_set_sensor_info(si++, "CPU_Opt", hwmon_fan,
-					    asus_wmi_ec_make_sensor_address(2, 0x00, 0xB0),
-					    &ec->nr_registers);
-		asus_wmi_ec_set_sensor_info(si++, "CPU", hwmon_curr,
-					    asus_wmi_ec_make_sensor_address(1, 0x00, 0xF4),
-					    &ec->nr_registers);
-	}
-
-	switch (board) {
-	case BOARD_RS_X570_E_G:
-	case BOARD_R_C8H:
-	case BOARD_R_C8F:
-		asus_wmi_ec_set_sensor_info(si++, "Chipset", hwmon_fan,
-					    asus_wmi_ec_make_sensor_address(2, 0x00, 0xB4),
-					    &ec->nr_registers);
-	}
-
-	switch (board) {
-	case BOARD_R_C8H:
-	case BOARD_R_C8DH:
-	case BOARD_R_C8F:
-		asus_wmi_ec_set_sensor_info(si++, "Water", hwmon_fan,
-					    asus_wmi_ec_make_sensor_address(2, 0x00, 0xBC),
-					    &ec->nr_registers);
-		asus_wmi_ec_set_sensor_info(si++, "Water_In", hwmon_temp,
-					    asus_wmi_ec_make_sensor_address(1, 0x01, 0x00),
-					    &ec->nr_registers);
-		asus_wmi_ec_set_sensor_info(si++, "Water_Out", hwmon_temp,
-					    asus_wmi_ec_make_sensor_address(1, 0x01, 0x01),
-					    &ec->nr_registers);
-	}
-
-	ec->nr_sensors = si - ec->sensors;
-}
-
-/*
- * The next four functions converts to/from BRxx string argument format
- * The format of the string is as follows:
- * The string consists of two-byte UTF-16 characters
- * The value of the very first byte int the string is equal to the total length
- * of the next string in bytes, thus excluding the first two-byte character
- * The rest of the string encodes pairs of (bank, index) pairs, where both
- * values are byte-long (0x00 to 0xFF)
- * Numbers are encoded as UTF-16 hex values
- */
-
-static inline char *asus_wmi_ec_hex_utf_16_le_pack(char *buf, u8 byte)
-{
-	*buf++ = hex_asc_hi(byte);
-	*buf++ = 0;
-	*buf++ = hex_asc_lo(byte);
-	*buf++ = 0;
-	return buf;
-}
-
-static void asus_wmi_ec_decode_reply_buffer(const u8 *inp, u8 *out)
-{
-	u8 len = ACPI_MIN(ASUS_WMI_MAX_BUF_LEN, inp[0] / 4);
-	const u8 *data = inp + 2;
-	u8 i;
-
-	for (i = 0; i < len; ++i, data += 4)
-		out[i] = (hex_to_bin(data[0]) << 4) + hex_to_bin(data[2]);
-}
-
-static void asus_wmi_ec_encode_registers(u16 *registers, u8 len, char *out)
-{
-	u8 i;
-
-	// assert(len <= 30)
-	*out++ = len * 8;
-	*out++ = 0;
-	for (i = 0; i < len; ++i) {
-		out = asus_wmi_ec_hex_utf_16_le_pack(out, (registers[i] & 0xFF00) >> 8);
-		out = asus_wmi_ec_hex_utf_16_le_pack(out, (registers[i] & 0x00FF));
-	}
-}
-
-static void asus_wmi_ec_make_block_read_query(struct asus_wmi_ec_info *ec)
-{
-	u16 registers[ASUS_EC_KNOWN_EC_REGISTERS];
-	u8 i, j, register_idx = 0;
-
-	/* if we can get values for all the registers in a single query,
-	 * the query will not change from call to call
-	 */
-	if (ec->nr_registers <= ASUS_WMI_BLOCK_READ_REGISTERS_MAX &&
-	    ec->read_arg[0] > 0) {
-		/* no need to update */
-		return;
-	}
-
-	for (i = 0; i < ec->nr_sensors; ++i) {
-		for (j = 0; j < ec->sensors[i].addr.addr.size;
-		     ++j, ++register_idx) {
-			registers[register_idx] =
-				(ec->sensors[i].addr.addr.bank << 8) +
-				ec->sensors[i].addr.addr.index + j;
-		}
-	}
-
-	asus_wmi_ec_encode_registers(registers, ec->nr_registers, ec->read_arg);
-}
-
-static int asus_wmi_ec_block_read(u32 method_id, const char *query, u8 *out)
-{
-	struct acpi_buffer input;
-	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER,
-				      NULL }; // TODO use pre-allocated buffer
-	acpi_status status;
-	union acpi_object *obj;
-
-	/* the first byte of the BRxx() argument string has to be the string size */
-	input.length = (acpi_size)query[0] + 2;
-	input.pointer = (void *)query;
-	status = wmi_evaluate_method(ASUSWMI_MONITORING_GUID, 0, method_id, &input,
-				     &output);
-
-	if (ACPI_FAILURE(status)) {
-		acpi_os_free(output.pointer);
-		return -EIO;
-	}
-
-	obj = output.pointer;
-	if (!obj || obj->type != ACPI_TYPE_BUFFER) {
-		pr_err("unexpected reply type from ASUS ACPI code");
-		acpi_os_free(output.pointer);
-		return -EIO;
-	}
-	asus_wmi_ec_decode_reply_buffer(obj->buffer.pointer, out);
-	acpi_os_free(output.pointer);
-	return 0;
-}
-
-static int asus_wmi_ec_update_ec_sensors(struct asus_wmi_ec_info *ec)
-{
-	struct asus_wmi_ec_sensor_info *si;
-	u32 value;
-	int status;
-	u8 i_sensor, read_reg_ct, i_sensor_register;
-
-	asus_wmi_ec_make_block_read_query(ec);
-	status = asus_wmi_ec_block_read(ASUSWMI_METHODID_BLOCK_READ_EC,
-					ec->read_arg,
-					ec->read_buffer);
-	if (status)
-		return status;
-
-	read_reg_ct = 0;
-	for (i_sensor = 0; i_sensor < ec->nr_sensors; ++i_sensor) {
-		si = &ec->sensors[i_sensor];
-		value = ec->read_buffer[read_reg_ct++];
-		for (i_sensor_register = 1;
-		     i_sensor_register < si->addr.addr.size;
-		     ++i_sensor_register) {
-			value <<= 8;
-			value += ec->read_buffer[read_reg_ct++];
-		}
-		si->cached_value = value;
-	}
-	return 0;
-}
-
-static int asus_wmi_ec_scale_sensor_value(u32 value, int data_type)
-{
-	switch (data_type) {
-	case hwmon_curr:
-	case hwmon_temp:
-	case hwmon_in:
-		return value * 1000;
-	default:
-		return value;
-	}
-}
-
-static u8 asus_wmi_ec_find_sensor_index(const struct asus_wmi_ec_info *ec,
-					enum hwmon_sensor_types type, int channel)
-{
-	u8 i;
-
-	for (i = 0; i < ec->nr_sensors; ++i) {
-		if (ec->sensors[i].type == type) {
-			if (channel == 0)
-				return i;
-
-			--channel;
-		}
-	}
-	return 0xFF;
-}
-
-static int asus_wmi_ec_get_cached_value_or_update(int sensor_index,
-						  struct asus_wmi_sensors *state,
-						  u32 *value)
-{
-	int ret;
-
-	if (time_after(jiffies, state->ec.last_updated + HZ)) {
-		ret = asus_wmi_ec_update_ec_sensors(&state->ec);
-
-		if (ret) {
-			pr_err("asus_wmi_ec_update_ec_sensors() failure\n");
-			return -EIO;
-		}
-
-		state->ec.last_updated = jiffies;
-	}
-
-	*value = state->ec.sensors[sensor_index].cached_value;
-	return 0;
-}
-
-/*
- * Now follow the functions that implement the hwmon interface
- */
-
-static int asus_wmi_ec_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
-				  u32 attr, int channel, long *val)
-{
-	int ret;
-	u32 value = 0;
-	struct asus_wmi_sensors *sensor_data = dev_get_drvdata(dev);
-
-	u8 sidx = asus_wmi_ec_find_sensor_index(&sensor_data->ec, type, channel);
-
-	mutex_lock(&sensor_data->lock);
-
-	ret = asus_wmi_ec_get_cached_value_or_update(sidx, sensor_data, &value);
-	mutex_unlock(&sensor_data->lock);
-
-	if (!ret)
-		*val = asus_wmi_ec_scale_sensor_value(value, sensor_data->ec.sensors[sidx].type);
-
-	return ret;
-}
-
-static int asus_wmi_ec_hwmon_read_string(struct device *dev,
-					 enum hwmon_sensor_types type, u32 attr,
-					 int channel, const char **str)
-{
-	struct asus_wmi_sensors *sensor_data = dev_get_drvdata(dev);
-
-	u8 sensor_index = asus_wmi_ec_find_sensor_index(&sensor_data->ec, type, channel);
-	*str = sensor_data->ec.sensors[sensor_index].label;
-
-	return 0;
-}
-
-static umode_t asus_wmi_ec_hwmon_is_visible(const void *drvdata,
-					    enum hwmon_sensor_types type, u32 attr,
-					    int channel)
-{
-	const struct asus_wmi_sensors *sensor_data = drvdata;
-
-	return asus_wmi_ec_find_sensor_index(&sensor_data->ec, type, channel) != 0xFF ?
-			     0444 :
-			     0;
-}
-
-static int asus_wmi_hwmon_add_chan_info(struct hwmon_channel_info *asus_wmi_hwmon_chan,
-					struct device *dev, int num,
-					enum hwmon_sensor_types type, u32 config)
-{
-	int i;
-	u32 *cfg = devm_kcalloc(dev, num + 1, sizeof(*cfg), GFP_KERNEL);
-
-	if (!cfg)
-		return -ENOMEM;
-
-	asus_wmi_hwmon_chan->type = type;
-	asus_wmi_hwmon_chan->config = cfg;
-	for (i = 0; i < num; i++, cfg++)
-		*cfg = config;
-
-	return 0;
-}
-
-static const struct hwmon_ops asus_wmi_ec_hwmon_ops = {
-	.is_visible = asus_wmi_ec_hwmon_is_visible,
-	.read = asus_wmi_ec_hwmon_read,
-	.read_string = asus_wmi_ec_hwmon_read_string,
-};
-
-static struct hwmon_chip_info asus_wmi_ec_chip_info = {
-	.ops = &asus_wmi_ec_hwmon_ops,
-	.info = NULL,
-};
-
-static int asus_wmi_ec_configure_sensor_setup(struct platform_device *pdev,
-					      struct asus_wmi_sensors *sensor_data)
-{
-	int i;
-	int nr_count[HWMON_MAX] = { 0 }, nr_types = 0;
-	struct device *hwdev;
-	struct device *dev = &pdev->dev;
-	struct hwmon_channel_info *asus_wmi_hwmon_chan;
-	const struct hwmon_channel_info **ptr_asus_wmi_ci;
-	const struct hwmon_chip_info *chip_info;
-	const struct asus_wmi_ec_sensor_info *si;
-	enum hwmon_sensor_types type;
-
-	if (sensor_data->ec_board < 0)
-		return 0;
-
-	asus_wmi_ec_fill_board_sensors(&sensor_data->ec, sensor_data->ec_board);
-
-	if (!sensor_data->ec.nr_sensors)
-		return -ENODEV;
-
-	for (i = 0; i < sensor_data->ec.nr_sensors; ++i) {
-		si = &sensor_data->ec.sensors[i];
-		if (!nr_count[si->type])
-			++nr_types;
-		++nr_count[si->type];
-	}
-
-	if (nr_count[hwmon_temp])
-		nr_count[hwmon_chip]++, nr_types++;
-
-	asus_wmi_hwmon_chan = devm_kcalloc(dev, nr_types,
-					   sizeof(*asus_wmi_hwmon_chan),
-					   GFP_KERNEL);
-	if (!asus_wmi_hwmon_chan)
-		return -ENOMEM;
-
-	ptr_asus_wmi_ci = devm_kcalloc(dev, nr_types + 1,
-				       sizeof(*ptr_asus_wmi_ci), GFP_KERNEL);
-	if (!ptr_asus_wmi_ci)
-		return -ENOMEM;
-
-	asus_wmi_ec_chip_info.info = ptr_asus_wmi_ci;
-	chip_info = &asus_wmi_ec_chip_info;
-
-	for (type = 0; type < HWMON_MAX; type++) {
-		if (!nr_count[type])
-			continue;
-
-		asus_wmi_hwmon_add_chan_info(asus_wmi_hwmon_chan, dev,
-					     nr_count[type], type,
-					     hwmon_attributes[type]);
-		*ptr_asus_wmi_ci++ = asus_wmi_hwmon_chan++;
-	}
-
-	pr_info("%s board has %d EC sensors that span %d registers",
-		asus_wmi_ec_boards_names[sensor_data->ec_board],
-		sensor_data->ec.nr_sensors,
-		sensor_data->ec.nr_registers);
-
-	hwdev = devm_hwmon_device_register_with_info(dev, "asuswmiecsensors",
-						     sensor_data, chip_info, NULL);
-
-	return PTR_ERR_OR_ZERO(hwdev);
-}
-
-static int asus_wmi_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct asus_wmi_data *data = dev_get_platdata(dev);
-	struct asus_wmi_sensors *sensor_data;
-	int err;
-
-	sensor_data = devm_kzalloc(dev, sizeof(struct asus_wmi_sensors),
-				   GFP_KERNEL);
-	if (!sensor_data)
-		return -ENOMEM;
-
-	mutex_init(&sensor_data->lock);
-	sensor_data->ec_board = data->ec_board;
-
-	platform_set_drvdata(pdev, sensor_data);
-
-	/* ec init */
-	err = asus_wmi_ec_configure_sensor_setup(pdev,
-						 sensor_data);
-
-	return err;
-}
-
-static struct platform_driver asus_wmi_sensors_platform_driver = {
-	.driver = {
-		.name	= "asus-wmi-sensors",
-	},
-	.probe = asus_wmi_probe
-};
-
-static struct platform_device *sensors_pdev;
-
-static int __init asus_wmi_init(void)
-{
-	const char *board_vendor, *board_name;
-	struct asus_wmi_data data;
-
-	data.ec_board = -1;
-
-	board_vendor = dmi_get_system_info(DMI_BOARD_VENDOR);
-	board_name = dmi_get_system_info(DMI_BOARD_NAME);
-
-	if (board_vendor && board_name &&
-	    !strcmp(board_vendor, "ASUSTeK COMPUTER INC.")) {
-		if (!wmi_has_guid(ASUSWMI_MONITORING_GUID))
-			return -ENODEV;
-
-		data.ec_board = match_string(asus_wmi_ec_boards_names,
-					     ARRAY_SIZE(asus_wmi_ec_boards_names),
-					     board_name);
-	}
-
-	/* Nothing to support */
-	if (data.ec_board < 0)
-		return -ENODEV;
-
-	sensors_pdev = platform_create_bundle(&asus_wmi_sensors_platform_driver,
-					      asus_wmi_probe,
-					      NULL, 0,
-					      &data, sizeof(struct asus_wmi_data));
-
-	if (IS_ERR(sensors_pdev))
-		return PTR_ERR(sensors_pdev);
-
-	return 0;
-}
-
-static void __exit asus_wmi_exit(void)
-{
-	platform_device_unregister(sensors_pdev);
-	platform_driver_unregister(&asus_wmi_sensors_platform_driver);
-}
-
-MODULE_AUTHOR("Ed Brindley <kernel@maidavale.org>");
-MODULE_AUTHOR("Eugene Shalygin <eugene.shalygin@gmail.com>");
-MODULE_DESCRIPTION("Asus WMI Sensors Driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("1");
-
-module_init(asus_wmi_init);
-module_exit(asus_wmi_exit);
-- 
2.33.0.610.gcefe983a32

