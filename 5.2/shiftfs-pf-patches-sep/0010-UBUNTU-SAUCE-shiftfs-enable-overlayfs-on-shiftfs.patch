From b297d4c2cf44f584fa428b369995c45b9d80afe4 Mon Sep 17 00:00:00 2001
From: Christian Brauner <christian.brauner@canonical.com>
Date: Thu, 1 Aug 2019 20:08:29 +0200
Subject: [PATCH 10/12] UBUNTU: SAUCE: shiftfs: enable overlayfs on shiftfs

BugLink: https://bugs.launchpad.net/bugs/1838677

This patch enables overlayfs to use shiftfs as an underlay.

Currently it is not possible to use overlayfs on top of shiftfs. This
means Docker inside of LXD cannot make user of the overlay2 graph driver
which is blocking users such as Travis from making use of it
efficiently.

Co-Developed-by: Seth Forshee <seth.forshee@canonical.com>
Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
Signed-off-by: Christian Brauner <christian.brauner@canonical.com>
---
 fs/open.c            | 4 +++-
 fs/overlayfs/file.c  | 1 +
 fs/overlayfs/super.c | 5 +++--
 fs/shiftfs.c         | 4 +++-
 include/linux/fs.h   | 3 ++-
 5 files changed, 12 insertions(+), 5 deletions(-)

diff --git a/fs/open.c b/fs/open.c
index b5b80469b93d..ca7b67d80020 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -911,13 +911,15 @@ struct file *dentry_open(const struct path *path, int flags,
 EXPORT_SYMBOL(dentry_open);
 
 struct file *open_with_fake_path(const struct path *path, int flags,
-				struct inode *inode, const struct cred *cred)
+				 struct inode *inode, struct dentry *dentry,
+				 const struct cred *cred)
 {
 	struct file *f = alloc_empty_file_noaccount(flags, cred);
 	if (!IS_ERR(f)) {
 		int error;
 
 		f->f_path = *path;
+		f->f_path.dentry = dentry;
 		error = do_dentry_open(f, inode, NULL);
 		if (error) {
 			fput(f);
diff --git a/fs/overlayfs/file.c b/fs/overlayfs/file.c
index e235a635d9ec..644e9e999b7e 100644
--- a/fs/overlayfs/file.c
+++ b/fs/overlayfs/file.c
@@ -31,6 +31,7 @@ static struct file *ovl_open_realfile(const struct file *file,
 
 	old_cred = ovl_override_creds(inode->i_sb);
 	realfile = open_with_fake_path(&file->f_path, flags, realinode,
+				       ovl_dentry_real(file->f_path.dentry),
 				       current_cred());
 	revert_creds(old_cred);
 
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index b368e2e102fa..f3fe11ed092b 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -749,13 +749,14 @@ static int ovl_mount_dir(const char *name, struct path *path)
 		ovl_unescape(tmp);
 		err = ovl_mount_dir_noesc(tmp, path);
 
-		if (!err)
-			if (ovl_dentry_remote(path->dentry)) {
+		if (!err) {
+			if ((path->dentry->d_sb->s_magic != SHIFTFS_MAGIC) && ovl_dentry_remote(path->dentry)) {
 				pr_err("overlayfs: filesystem on '%s' not supported as upperdir\n",
 				       tmp);
 				path_put_init(path);
 				err = -EINVAL;
 			}
+		}
 		kfree(tmp);
 	}
 	return err;
diff --git a/fs/shiftfs.c b/fs/shiftfs.c
index 49f6714e9f95..400c3062365c 100644
--- a/fs/shiftfs.c
+++ b/fs/shiftfs.c
@@ -1048,7 +1048,9 @@ static struct file *shiftfs_open_realfile(const struct file *file,
 	oldcred = shiftfs_override_creds(inode->i_sb);
 	/* XXX: open_with_fake_path() not gauranteed to stay around, if
 	 * removed use dentry_open() */
-	lowerf = open_with_fake_path(realpath, file->f_flags, loweri, info->creator_cred);
+	lowerf = open_with_fake_path(realpath, file->f_flags, loweri,
+				     realpath->dentry,
+				     info->creator_cred);
 	revert_creds(oldcred);
 
 	return lowerf;
diff --git a/include/linux/fs.h b/include/linux/fs.h
index f7fdfe93e25d..445fc81fad4e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2519,7 +2519,8 @@ extern struct file *file_open_root(struct dentry *, struct vfsmount *,
 				   const char *, int, umode_t);
 extern struct file * dentry_open(const struct path *, int, const struct cred *);
 extern struct file * open_with_fake_path(const struct path *, int,
-					 struct inode*, const struct cred *);
+					 struct inode*, struct dentry *dentry,
+					 const struct cred *);
 static inline struct file *file_clone_open(struct file *file)
 {
 	return dentry_open(&file->f_path, file->f_flags, file->f_cred);
-- 
2.23.0

