From ae924390d8945d46c24224ec76b7112e6e1c4d2c Mon Sep 17 00:00:00 2001
From: Luke Jones <luke@ljones.dev>
Date: Wed, 5 Mar 2025 17:40:54 +1300
Subject: [PATCH 35/50] zotac-zone-hid: initial impl

The full base driver for HID and platform is implemented.
This now requires splitting in to base commits for upstreaming.

Signed-off-by: Luke Jones <luke@ljones.dev>
---
 drivers/hid/Kconfig                           |    2 +
 drivers/hid/Makefile                          |    2 +
 drivers/hid/hid-ids.h                         |    4 +
 drivers/hid/zotac-zone-hid/Kconfig            |    8 +
 drivers/hid/zotac-zone-hid/Makefile           |    6 +
 .../zotac-zone-hid/zotac-zone-hid-config.c    | 2231 +++++++++++++++++
 .../hid/zotac-zone-hid/zotac-zone-hid-core.c  |  597 +++++
 .../hid/zotac-zone-hid/zotac-zone-hid-input.c |  522 ++++
 .../hid/zotac-zone-hid/zotac-zone-hid-rgb.c   |  717 ++++++
 drivers/hid/zotac-zone-hid/zotac-zone.h       |  214 ++
 drivers/platform/x86/Kconfig                  |   10 +
 drivers/platform/x86/Makefile                 |    2 +
 drivers/platform/x86/zotac-zone-platform.c    | 1122 +++++++++
 13 files changed, 5437 insertions(+)
 create mode 100644 drivers/hid/zotac-zone-hid/Kconfig
 create mode 100644 drivers/hid/zotac-zone-hid/Makefile
 create mode 100644 drivers/hid/zotac-zone-hid/zotac-zone-hid-config.c
 create mode 100644 drivers/hid/zotac-zone-hid/zotac-zone-hid-core.c
 create mode 100644 drivers/hid/zotac-zone-hid/zotac-zone-hid-input.c
 create mode 100644 drivers/hid/zotac-zone-hid/zotac-zone-hid-rgb.c
 create mode 100644 drivers/hid/zotac-zone-hid/zotac-zone.h
 create mode 100644 drivers/platform/x86/zotac-zone-platform.c

diff --git a/drivers/hid/Kconfig b/drivers/hid/Kconfig
index cdb6b2ddf..e52545f34 100644
--- a/drivers/hid/Kconfig
+++ b/drivers/hid/Kconfig
@@ -1438,4 +1438,6 @@ endif # HID
 
 source "drivers/hid/usbhid/Kconfig"
 
+source "drivers/hid/zotac-zone-hid/Kconfig"
+
 endif # HID_SUPPORT
diff --git a/drivers/hid/Makefile b/drivers/hid/Makefile
index 4d2bc270d..e9b7dab97 100644
--- a/drivers/hid/Makefile
+++ b/drivers/hid/Makefile
@@ -172,6 +172,8 @@ obj-$(CONFIG_INTEL_ISH_HID)	+= intel-ish-hid/
 
 obj-$(CONFIG_AMD_SFH_HID)       += amd-sfh-hid/
 
+obj-$(CONFIG_ZOTAC_ZONE_HID)  += zotac-zone-hid/
+
 obj-$(CONFIG_SURFACE_HID_CORE)  += surface-hid/
 
 obj-$(CONFIG_INTEL_THC_HID)     += intel-thc-hid/
diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 8926f4866..3151acdf1 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -1508,6 +1508,10 @@
 #define USB_VENDOR_ID_ZYTRONIC		0x14c8
 #define USB_DEVICE_ID_ZYTRONIC_ZXY100	0x0005
 
+#define USB_VENDOR_ID_ZOTAC		0x1EE9
+#define USB_VENDOR_ID_ZOTAC_ALT		0x1E19
+#define USB_DEVICE_ID_ZOTAC_ZONE_GAME_CONTROLLER	0x1590
+
 #define USB_VENDOR_ID_PRIMAX	0x0461
 #define USB_DEVICE_ID_PRIMAX_MOUSE_4D22	0x4d22
 #define USB_DEVICE_ID_PRIMAX_MOUSE_4E2A	0x4e2a
diff --git a/drivers/hid/zotac-zone-hid/Kconfig b/drivers/hid/zotac-zone-hid/Kconfig
new file mode 100644
index 000000000..89fb2ac08
--- /dev/null
+++ b/drivers/hid/zotac-zone-hid/Kconfig
@@ -0,0 +1,8 @@
+config ZOTAC_ZONE_HID
+	tristate "Zotac Zone handheld support"
+	depends on USB_HID
+	depends on LEDS_CLASS
+	depends on LEDS_CLASS_MULTICOLOR
+	select POWER_SUPPLY
+	help
+	Support for the Zotac Zone handheld gaming console.
diff --git a/drivers/hid/zotac-zone-hid/Makefile b/drivers/hid/zotac-zone-hid/Makefile
new file mode 100644
index 000000000..2f7053b98
--- /dev/null
+++ b/drivers/hid/zotac-zone-hid/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Makefile - Zotac Zone handheld device driver
+#
+zotac-zone-hid-y := zotac-zone-hid-core.o zotac-zone-hid-rgb.o zotac-zone-hid-input.o zotac-zone-hid-config.o
+obj-$(CONFIG_ZOTAC_ZONE_HID) := zotac-zone-hid.o
diff --git a/drivers/hid/zotac-zone-hid/zotac-zone-hid-config.c b/drivers/hid/zotac-zone-hid/zotac-zone-hid-config.c
new file mode 100644
index 000000000..049615194
--- /dev/null
+++ b/drivers/hid/zotac-zone-hid/zotac-zone-hid-config.c
@@ -0,0 +1,2231 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+* HID driver for ZOTAC Gaming Zone Controller - RGB LED control
+*
+* Copyright (c) 2025 Luke D. Jones <luke@ljones.dev>
+*/
+
+#include "asm-generic/errno-base.h"
+#include "linux/kstrtox.h"
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/usb.h>
+
+#include "zotac-zone.h"
+
+#define REPORT_SIZE 64
+
+#define HEADER_TAG_POS 0
+#define RESERVED_POS 1
+#define SEQUENCE_POS 2
+#define PAYLOADSIZE_POS 3
+#define COMMAND_POS 4
+#define SETTING_POS 5
+#define VALUE_POS 6
+#define CRC_H_POS 0x3E
+#define CRC_L_POS 0x3F
+
+#define HEADER_TAG 0xE1
+#define PAYLOAD_SIZE 0x3C
+
+/*
+ * Button mapping structure indices (relative to data buffer)
+ * The data buffer is copied to the correct location in the HID report.
+ */
+#define HEADER_LEN 5
+#define BTN_MAP_SOURCE_IDX (0x05 - HEADER_LEN) /* Source button ID */
+#define BTN_MAP_GAMEPAD_START_IDX (0x06 - HEADER_LEN)
+#define BTN_MAP_GAMEPAD_SIZE 4
+#define BTN_MAP_MODIFIER_IDX (0x0A - HEADER_LEN)
+#define BTN_MAP_KEYBOARD_START_IDX (0x0C - HEADER_LEN)
+#define BTN_MAP_KEYBOARD_SIZE 6
+#define BTN_MAP_MOUSE_IDX (0x12 - HEADER_LEN)
+#define BTN_MAP_RESPONSE_MIN_SIZE 14
+
+#define GAMEPAD_DPAD_STICK_IDX 0 /* DPad, Stick buttons */
+#define GAMEPAD_FACE_BUMPER_IDX 1 /* Face buttons, Bumpers */
+#define GAMEPAD_TRIGGER_IDX 2 /* Triggers */
+#define GAMEPAD_RESERVED_IDX 3 /* Reserved/unused */
+/*
+ * Note: The above indices are relative to our data buffer, not the full protocol packet.
+ * In the full protocol packet (as described in documentation), these fields would be
+ * at different positions due to the packet header.
+ *
+ * For example, BTN_MAP_MOUSE_IDX (13 in our buffer) corresponds to offset 0x12-0x13
+ * in the full protocol packet.
+ */
+
+/* Mouse speed constants */
+#define CMD_SET_MOUSE_SPEED 0xA3
+#define CMD_GET_MOUSE_SPEED 0xA4
+#define MOUSE_SPEED_MIN 0x01 /* Slow */
+#define MOUSE_SPEED_MAX 0x0A /* Fast */
+
+#define STICK_SENSITIVITY_NUM_IDX 0
+#define STICK_SENSITIVITY_DATA_IDX 1
+#define STICK_SENSITIVITY_SIZE 8
+
+#define DZ_LEFT_INNER_IDX 0
+#define DZ_LEFT_OUTER_IDX 1
+#define DZ_RIGHT_INNER_IDX 2
+#define DZ_RIGHT_OUTER_IDX 3
+#define DZ_RESPONSE_SIZE 4
+
+#define VIB_LEFT_TRIGGER_IDX 0
+#define VIB_RIGHT_TRIGGER_IDX 1
+#define VIB_LEFT_RUMBLE_IDX 2
+#define VIB_RIGHT_RUMBLE_IDX 3
+#define VIB_RESPONSE_SIZE 4
+
+#define CMD_SET_PROFILE 0xB1
+#define CMD_GET_PROFILE 0xB2
+#define CMD_GET_PROFILE_NUM 0xB3
+#define CMD_RESTORE_PROFILE 0xF1
+#define CMD_SAVE_CONFIG 0xFB
+
+#define CMD_SET_VIBRATION_STRENGTH 0xA9
+#define CMD_GET_VIBRATION_STRENGTH 0xAA
+#define CMD_SET_STICK_DEADZONES 0xA5
+#define CMD_GET_STICK_DEADZONES 0xA6
+#define CMD_SET_TRIGGER_DEADZONES 0xB4
+#define CMD_GET_TRIGGER_DEADZONES 0xB5
+#define CMD_SET_STICK_SENSITIVITY 0xBA
+#define CMD_GET_STICK_SENSITIVITY 0xBB
+#define CMD_SET_BUTTON_TURBO 0xB8
+#define CMD_GET_BUTTON_TURBO 0xB9
+#define CMD_GET_DEVICE_INFO 0xFA
+#define CMD_MOTOR_TEST 0xBD
+
+#define MOTOR_TEST_SIZE 4
+
+#define STICK_LEFT 0
+#define STICK_RIGHT 1
+
+#define PROFILE_DEFAULT 0x00
+#define PROFILE_SECONDARY 0x01
+
+/* Button bit positions within the turbo byte */
+#define A_BTN_POS 0
+#define B_BTN_POS 1
+#define X_BTN_POS 2
+#define Y_BTN_POS 3
+#define LB_BTN_POS 4
+#define RB_BTN_POS 5
+#define LT_BTN_POS 6
+#define RT_BTN_POS 7
+
+/* Button ID definitions */
+#define BUTTON_NONE 0x00
+#define BUTTON_M1 0x01
+#define BUTTON_M2 0x02
+#define BUTTON_L_TOUCH_UP 0x03
+#define BUTTON_L_TOUCH_DOWN 0x04
+#define BUTTON_L_TOUCH_LEFT 0x05
+#define BUTTON_L_TOUCH_RIGHT 0x06
+#define BUTTON_R_TOUCH_UP 0x07
+#define BUTTON_R_TOUCH_DOWN 0x08
+#define BUTTON_R_TOUCH_LEFT 0x09
+#define BUTTON_R_TOUCH_RIGHT 0x0A
+#define BUTTON_LB 0x0B
+#define BUTTON_RB 0x0C
+#define BUTTON_LT 0x0D
+#define BUTTON_RT 0x0E
+#define BUTTON_A 0x0F
+#define BUTTON_B 0x10
+#define BUTTON_X 0x11
+#define BUTTON_Y 0x12
+#define BUTTON_DPAD_UP 0x13
+#define BUTTON_DPAD_DOWN 0x14
+#define BUTTON_DPAD_LEFT 0x15
+#define BUTTON_DPAD_RIGHT 0x16
+#define BUTTON_LS 0x17
+#define BUTTON_RS 0x18
+
+/* Modifier key definitions */
+#define MOD_NONE 0x00
+#define MOD_LEFT_CTRL 0x01
+#define MOD_LEFT_SHIFT 0x02
+#define MOD_LEFT_ALT 0x04
+#define MOD_LEFT_WIN 0x08
+#define MOD_RIGHT_CTRL 0x10
+#define MOD_RIGHT_SHIFT 0x20
+#define MOD_RIGHT_ALT 0x40
+#define MOD_RIGHT_WIN 0x80
+
+int zotac_cfg_refresh(struct zotac_device *zotac);
+
+struct button_directory {
+	const char *name; /* Directory name (e.g., "btn_a") */
+	u8 button_id; /* Associated button ID */
+	bool has_turbo; /* Whether this button supports turbo */
+	struct kobject *
+		kobj; /* kobject for this directory (filled during registration) */
+	struct attribute_group *main_group; /* Main button attributes */
+	struct attribute_group *remap_group; /* Remap subdirectory attributes */
+};
+
+/* Structure to map button names to their byte and bit positions */
+struct button_mapping_entry {
+	const char *name;
+	u8 byte_index;
+	u8 bit_mask;
+};
+
+/* Define all supported buttons with their byte index and bit mask */
+static const struct button_mapping_entry button_map[] = {
+	{ "dpad_up", 0, 0x01 },
+	{ "dpad_down", 0, 0x02 },
+	{ "dpad_left", 0, 0x04 },
+	{ "dpad_right", 0, 0x08 },
+	{ "ls", 0, 0x40 },
+	{ "rs", 0, 0x80 },
+	{ "lb", 1, 0x01 },
+	{ "rb", 1, 0x02 },
+	{ "a", 1, 0x10 },
+	{ "b", 1, 0x20 },
+	{ "x", 1, 0x40 },
+	{ "y", 1, 0x80 },
+	{ "lt", 2, 0x01 },
+	{ "rt", 2, 0x02 },
+	{ NULL, 0, 0 } /* Terminator */
+};
+
+static const struct {
+	const char *name;
+	u8 id;
+} gamepad_button_names[] = {
+	{ "none", BUTTON_NONE },
+	{ "a", BUTTON_A },
+	{ "b", BUTTON_B },
+	{ "x", BUTTON_X },
+	{ "y", BUTTON_Y },
+	{ "lb", BUTTON_LB },
+	{ "rb", BUTTON_RB },
+	{ "lt", BUTTON_LT },
+	{ "rt", BUTTON_RT },
+	{ "ls", BUTTON_LS },
+	{ "rs", BUTTON_RS },
+	{ "dpad_up", BUTTON_DPAD_UP },
+	{ "dpad_down", BUTTON_DPAD_DOWN },
+	{ "dpad_left", BUTTON_DPAD_LEFT },
+	{ "dpad_right", BUTTON_DPAD_RIGHT },
+};
+
+static const struct {
+	const char *name;
+	u8 value;
+} modifier_names[] = {
+	{ "none", MOD_NONE },
+	{ "left_ctrl", MOD_LEFT_CTRL },
+	{ "left_shift", MOD_LEFT_SHIFT },
+	{ "left_alt", MOD_LEFT_ALT },
+	{ "left_win", MOD_LEFT_WIN },
+	{ "right_ctrl", MOD_RIGHT_CTRL },
+	{ "right_shift", MOD_RIGHT_SHIFT },
+	{ "right_alt", MOD_RIGHT_ALT },
+	{ "right_win", MOD_RIGHT_WIN },
+};
+
+/* Keyboard key definitions */
+struct key_name_mapping {
+	const char *name;
+	u8 keycode;
+};
+
+static const struct key_name_mapping keyboard_keys[] = {
+	{ "none", 0x00 },	 { "a", 0x04 },		 { "b", 0x05 },
+	{ "c", 0x06 },		 { "d", 0x07 },		 { "e", 0x08 },
+	{ "f", 0x09 },		 { "g", 0x0a },		 { "h", 0x0b },
+	{ "i", 0x0c },		 { "j", 0x0d },		 { "k", 0x0e },
+	{ "l", 0x0f },		 { "m", 0x10 },		 { "n", 0x11 },
+	{ "o", 0x12 },		 { "p", 0x13 },		 { "q", 0x14 },
+	{ "r", 0x15 },		 { "s", 0x16 },		 { "t", 0x17 },
+	{ "u", 0x18 },		 { "v", 0x19 },		 { "w", 0x1a },
+	{ "x", 0x1b },		 { "y", 0x1c },		 { "z", 0x1d },
+	{ "1", 0x1e },		 { "2", 0x1f },		 { "3", 0x20 },
+	{ "4", 0x21 },		 { "5", 0x22 },		 { "6", 0x23 },
+	{ "7", 0x24 },		 { "8", 0x25 },		 { "9", 0x26 },
+	{ "0", 0x27 },		 { "enter", 0x28 },	 { "esc", 0x29 },
+	{ "backspace", 0x2a },	 { "tab", 0x2b },	 { "space", 0x2c },
+	{ "minus", 0x2d },	 { "equals", 0x2e },	 { "leftbrace", 0x2f },
+	{ "rightbrace", 0x30 },	 { "backslash", 0x31 },	 { "semicolon", 0x33 },
+	{ "apostrophe", 0x34 },	 { "grave", 0x35 },	 { "comma", 0x36 },
+	{ "dot", 0x37 },	 { "slash", 0x38 },	 { "capslock", 0x39 },
+	{ "f1", 0x3a },		 { "f2", 0x3b },	 { "f3", 0x3c },
+	{ "f4", 0x3d },		 { "f5", 0x3e },	 { "f6", 0x3f },
+	{ "f7", 0x40 },		 { "f8", 0x41 },	 { "f9", 0x42 },
+	{ "f10", 0x43 },	 { "f11", 0x44 },	 { "f12", 0x45 },
+	{ "printscreen", 0x46 }, { "scrolllock", 0x47 }, { "pause", 0x48 },
+	{ "insert", 0x49 },	 { "home", 0x4a },	 { "pageup", 0x4b },
+	{ "delete", 0x4c },	 { "end", 0x4d },	 { "pagedown", 0x4e },
+	{ "right", 0x4f },	 { "left", 0x50 },	 { "down", 0x51 },
+	{ "up", 0x52 },		 { "numlock", 0x53 },	 { "kpslash", 0x54 },
+	{ "kpasterisk", 0x55 },	 { "kpminus", 0x56 },	 { "kpplus", 0x57 },
+	{ "kpenter", 0x58 },	 { "kp1", 0x59 },	 { "kp2", 0x5a },
+	{ "kp3", 0x5b },	 { "kp4", 0x5c },	 { "kp5", 0x5d },
+	{ "kp6", 0x5e },	 { "kp7", 0x5f },	 { "kp8", 0x60 },
+	{ "kp9", 0x61 },	 { "kp0", 0x62 },	 { "kpdot", 0x63 },
+	{ "application", 0x65 }
+};
+
+/* Mouse button definitions */
+#define MOUSE_LEFT 0x01
+#define MOUSE_RIGHT 0x02
+#define MOUSE_MIDDLE 0x04
+
+static const struct {
+	const char *name;
+	u8 value;
+} mouse_button_names[] = {
+	{ "left", MOUSE_LEFT },
+	{ "right", MOUSE_RIGHT },
+	{ "middle", MOUSE_MIDDLE },
+};
+
+struct zotac_device_info {
+	u64 device_id;
+	u16 vid;
+	u16 pid;
+	u8 num_led_zones;
+	struct {
+		u8 major;
+		u8 mid;
+		u8 minor;
+		u16 revision;
+	} fw_version;
+	struct {
+		u8 major;
+		u8 mid;
+		u8 minor;
+	} hw_version;
+};
+
+static u16 zotac_calc_crc(u8 *data)
+{
+	const int payload_end = 0x3D;
+	const int payload_start = 4;
+	const u16 crc_seed = 0;
+	u16 crc = crc_seed;
+	u32 h1, h2, h3, h4;
+	int i;
+
+	for (i = payload_start; i <= payload_end; i++) {
+		h1 = (u32)((crc ^ data[i]) & 0xFF);
+		h2 = h1 & 0x0F;
+		h3 = (h2 << 4) ^ h1;
+		h4 = h3 >> 4;
+
+		crc = (u16)((((((h3 << 1) ^ h4) << 4) ^ h2) << 3) ^ h4 ^
+			    (crc >> 8));
+	}
+
+	return crc;
+}
+
+static int zotac_send_command_and_get_response_usb(struct hid_device *hdev,
+						   u8 *send_buf, int send_len,
+						   u8 *recv_buf, int recv_len)
+{
+	struct usb_device *udev =
+		interface_to_usbdev(to_usb_interface(hdev->dev.parent));
+	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+	const int polling_interval_ms = 50;
+	int actual_length = 0;
+
+	unsigned int pipe_in, pipe_out;
+	int ret;
+
+	if (!intf || !udev) {
+		hid_err(hdev, "Failed to get USB interface or device\n");
+		return -ENODEV;
+	}
+
+	pipe_out = usb_sndintpipe(udev, 0x05);
+	pipe_in = usb_rcvintpipe(udev, 0x84);
+
+	ret = usb_interrupt_msg(udev, pipe_out, send_buf, send_len,
+				&actual_length, 1000);
+	if (ret < 0) {
+		hid_err(hdev, "Failed to send USB command: %d\n", ret);
+		return ret;
+	}
+
+	memset(recv_buf, 0, recv_len);
+	ret = usb_interrupt_msg(udev, pipe_in, recv_buf, recv_len,
+				&actual_length, polling_interval_ms);
+	if (ret == 0 && actual_length > 0) {
+		return actual_length;
+	}
+
+	hid_err(hdev, "Timeout waiting for USB response\n");
+	return -ETIMEDOUT;
+}
+
+static int zotac_send_command_raw(struct zotac_device *zotac, u8 cmd_code,
+				  u8 setting, const u8 *data, size_t data_len,
+				  u8 *response_buffer, size_t *response_len)
+{
+	bool is_cmd = (cmd_code == CMD_SET_RGB || cmd_code == CMD_GET_RGB);
+	int reply_len, result = -EIO;
+
+	struct zotac_cfg_data *cfg;
+	size_t copy_len;
+	u8 *buffer;
+	u16 crc;
+
+	if (!zotac->cfg_data || !zotac->hdev)
+		return -ENODEV;
+
+	cfg = zotac->cfg_data;
+
+	buffer = kzalloc(REPORT_SIZE, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	if (mutex_lock_interruptible(&cfg->command_mutex)) {
+		kfree(buffer);
+		return -EINTR;
+	}
+
+	memset(buffer, 0, REPORT_SIZE);
+	buffer[HEADER_TAG_POS] = HEADER_TAG;
+	buffer[RESERVED_POS] = 0x00;
+	buffer[SEQUENCE_POS] = cfg->sequence_num;
+	buffer[PAYLOADSIZE_POS] = PAYLOAD_SIZE;
+	buffer[COMMAND_POS] = cmd_code;
+
+	if (is_cmd) {
+		buffer[SETTING_POS] = setting;
+
+		if (data && data_len > 0) {
+			copy_len = min_t(size_t, data_len, PAYLOAD_SIZE - 2);
+			memcpy(&buffer[VALUE_POS], data, copy_len);
+		}
+	} else {
+		if (data && data_len > 0) {
+			copy_len = min_t(size_t, data_len, PAYLOAD_SIZE - 1);
+			memcpy(&buffer[SETTING_POS], data, copy_len);
+		} else {
+			buffer[SETTING_POS] = setting;
+		}
+	}
+
+	crc = zotac_calc_crc(buffer);
+	buffer[CRC_H_POS] = (crc >> 8) & 0xFF;
+	buffer[CRC_L_POS] = crc & 0xFF;
+
+	reply_len = zotac_send_command_and_get_response_usb(
+		zotac->hdev, buffer, REPORT_SIZE, response_buffer, REPORT_SIZE);
+
+	if (reply_len > 0) {
+		if (response_buffer[COMMAND_POS] == cmd_code) {
+			*response_len = reply_len;
+			cfg->sequence_num = (cfg->sequence_num + 1) & 0xFF;
+			result = 0;
+		} else {
+			hid_err(zotac->hdev,
+				"Command mismatch in response: expected 0x%02x, got 0x%02x\n",
+				cmd_code, response_buffer[COMMAND_POS]);
+			result = -EIO;
+		}
+	} else {
+		hid_err(zotac->hdev,
+			"No response received for command 0x%02x: %d\n",
+			cmd_code, reply_len);
+		result = reply_len < 0 ? reply_len : -EIO;
+	}
+
+	mutex_unlock(&cfg->command_mutex);
+	kfree(buffer);
+
+	return result;
+}
+
+int zotac_send_get_command(struct zotac_device *zotac, u8 cmd_code, u8 setting,
+			   const u8 *req_data, size_t req_data_len,
+			   u8 *output_data, size_t *output_len)
+{
+	bool is_status_offset =
+		(cmd_code == CMD_SET_RGB || cmd_code == CMD_SET_BUTTON_MAPPING);
+	size_t response_size = REPORT_SIZE, available, to_copy;
+	int data_offset, ret;
+	u8 *response_buffer;
+
+	response_buffer = kzalloc(REPORT_SIZE, GFP_KERNEL);
+	if (!response_buffer)
+		return -ENOMEM;
+
+	ret = zotac_send_command_raw(zotac, cmd_code, setting, req_data,
+				     req_data_len, response_buffer,
+				     &response_size);
+	if (ret < 0) {
+		kfree(response_buffer);
+		return ret;
+	}
+
+	if (response_size <= COMMAND_POS ||
+	    response_buffer[COMMAND_POS] != cmd_code) {
+		kfree(response_buffer);
+		return -EIO;
+	}
+
+	data_offset = is_status_offset ? 7 : 5;
+
+	if (output_data && output_len && *output_len > 0 &&
+	    response_size > data_offset) {
+		available = response_size - data_offset;
+		to_copy = min_t(size_t, available, *output_len);
+
+		memcpy(output_data, &response_buffer[data_offset], to_copy);
+		*output_len = to_copy;
+	}
+
+	kfree(response_buffer);
+	return 0;
+}
+
+int zotac_send_set_command(struct zotac_device *zotac, u8 cmd_code, u8 setting,
+			   const u8 *data, size_t data_len)
+{
+	bool is_status_offset =
+		(cmd_code == CMD_SET_RGB || cmd_code == CMD_SET_BUTTON_MAPPING);
+	size_t response_size = REPORT_SIZE;
+
+	int ret, status_offset;
+	u8 *response_buffer;
+
+	response_buffer = kzalloc(REPORT_SIZE, GFP_KERNEL);
+	if (!response_buffer) {
+		hid_err(zotac->hdev,
+			"SET_COMMAND: Failed to allocate response buffer");
+		return -ENOMEM;
+	}
+
+	ret = zotac_send_command_raw(zotac, cmd_code, setting, data, data_len,
+				     response_buffer, &response_size);
+
+	if (ret < 0) {
+		hid_err(zotac->hdev,
+			"SET_COMMAND: Command failed with error %d", ret);
+		kfree(response_buffer);
+		return ret;
+	}
+
+	if (response_size <= COMMAND_POS ||
+	    response_buffer[COMMAND_POS] != cmd_code) {
+		hid_err(zotac->hdev,
+			"SET_COMMAND: Invalid response - size=%zu, cmd=0x%02x",
+			response_size, response_buffer[COMMAND_POS]);
+		kfree(response_buffer);
+		return -EIO;
+	}
+
+	status_offset = is_status_offset ? 6 : 5;
+
+	if (response_size > status_offset) {
+		if (response_buffer[status_offset] != 0) {
+			hid_err(zotac->hdev,
+				"SET_COMMAND: Command rejected by device, status=0x%02x",
+				response_buffer[status_offset]);
+			kfree(response_buffer);
+			return -EIO;
+		}
+	}
+
+	kfree(response_buffer);
+	return 0;
+}
+
+int zotac_send_get_byte(struct zotac_device *zotac, u8 cmd_code, u8 setting,
+			const u8 *req_data, size_t req_data_len)
+{
+	size_t output_len = 1;
+	u8 output_data = 0;
+	int ret;
+
+	ret = zotac_send_get_command(zotac, cmd_code, setting, req_data,
+				     req_data_len, &output_data, &output_len);
+	if (ret < 0)
+		return ret;
+
+	if (output_len < 1)
+		return -EIO;
+
+	return output_data;
+}
+
+static int zotac_get_device_info(struct zotac_device *zotac,
+				 struct zotac_device_info *info)
+{
+	u8 data[21];
+	size_t data_len = sizeof(data);
+	int ret;
+
+	if (!zotac || !info)
+		return -EINVAL;
+
+	ret = zotac_send_get_command(zotac, CMD_GET_DEVICE_INFO, 0, NULL, 0,
+				     data, &data_len);
+	if (ret < 0)
+		return ret;
+
+	if (data_len < 20) {
+		dev_err(&zotac->hdev->dev,
+			"Incomplete device info received: %zu bytes\n",
+			data_len);
+		return -EIO;
+	}
+
+	info->device_id = ((u64)data[0] | ((u64)data[1] << 8) |
+			   ((u64)data[2] << 16) | ((u64)data[3] << 24) |
+			   ((u64)data[4] << 32) | ((u64)data[5] << 40) |
+			   ((u64)data[6] << 48) | ((u64)data[7] << 56));
+
+	info->vid = data[8] | (data[9] << 8);
+	info->pid = data[10] | (data[11] << 8);
+
+	info->num_led_zones = data[12];
+
+	info->fw_version.major = data[13];
+	info->fw_version.mid = data[14];
+	info->fw_version.minor = data[15];
+	info->fw_version.revision = data[19] | (data[20] << 8);
+
+	info->hw_version.major = data[16];
+	info->hw_version.mid = data[17];
+	info->hw_version.minor = data[18];
+
+	return 0;
+}
+
+static void zotac_log_device_info(struct zotac_device *zotac)
+{
+	struct zotac_device_info info;
+	int ret;
+
+	ret = zotac_get_device_info(zotac, &info);
+	if (ret < 0) {
+		dev_err(&zotac->hdev->dev, "Failed to get device info: %d\n",
+			ret);
+		return;
+	}
+
+	dev_info(&zotac->hdev->dev,
+		 "Device Info:\n"
+		 "  Device ID: %016llx\n"
+		 "  VID/PID: %04x:%04x\n"
+		 "  LED Zones: %u\n"
+		 "  Firmware: %u.%u.%u (revision %u)\n"
+		 "  Hardware: %u.%u.%u\n",
+		 info.device_id, info.vid, info.pid, info.num_led_zones,
+		 info.fw_version.major, info.fw_version.mid,
+		 info.fw_version.minor, info.fw_version.revision,
+		 info.hw_version.major, info.hw_version.mid,
+		 info.hw_version.minor);
+}
+
+static const struct button_mapping_entry *find_button_by_name(const char *name)
+{
+	int i;
+	for (i = 0; button_map[i].name != NULL; i++) {
+		if (strcmp(button_map[i].name, name) == 0)
+			return &button_map[i];
+	}
+	return NULL;
+}
+
+static bool is_button_in_mapping(u8 *mapping_bytes,
+				 const struct button_mapping_entry *button)
+{
+	return (mapping_bytes[button->byte_index] & button->bit_mask) != 0;
+}
+
+static void add_button_to_mapping(u8 *mapping_bytes,
+				  const struct button_mapping_entry *button)
+{
+	mapping_bytes[button->byte_index] |= button->bit_mask;
+}
+
+static int zotac_get_button_mapping(struct zotac_device *zotac, u8 button_id)
+{
+	if (!zotac || !zotac->cfg_data || button_id > BUTTON_MAX ||
+	    button_id == 0)
+		return -EINVAL;
+	return 0;
+}
+
+static int zotac_set_button_mapping(struct zotac_device *zotac, u8 button_id)
+{
+	struct button_mapping *mapping =
+		&zotac->cfg_data->button_mappings[button_id];
+	u8 data[BTN_MAP_RESPONSE_MIN_SIZE] = { 0 };
+	u8 *gamepad_bytes = (u8 *)&mapping->target_gamepad_buttons;
+
+	/* Source button goes at offset 0 */
+	data[BTN_MAP_SOURCE_IDX] = button_id;
+
+	/* Controller button mappings */
+	data[BTN_MAP_GAMEPAD_START_IDX + GAMEPAD_DPAD_STICK_IDX] =
+		gamepad_bytes[GAMEPAD_DPAD_STICK_IDX];
+	data[BTN_MAP_GAMEPAD_START_IDX + GAMEPAD_FACE_BUMPER_IDX] =
+		gamepad_bytes[GAMEPAD_FACE_BUMPER_IDX];
+	data[BTN_MAP_GAMEPAD_START_IDX + GAMEPAD_TRIGGER_IDX] =
+		gamepad_bytes[GAMEPAD_TRIGGER_IDX];
+	data[BTN_MAP_GAMEPAD_START_IDX + GAMEPAD_RESERVED_IDX] =
+		gamepad_bytes[GAMEPAD_RESERVED_IDX];
+
+	data[BTN_MAP_MODIFIER_IDX] = mapping->target_modifier_keys;
+
+	memcpy(&data[BTN_MAP_KEYBOARD_START_IDX], mapping->target_keyboard_keys,
+	       BTN_MAP_KEYBOARD_SIZE);
+
+	data[BTN_MAP_MOUSE_IDX] = mapping->target_mouse_buttons;
+
+	return zotac_send_set_command(zotac, CMD_SET_BUTTON_MAPPING, 0, data,
+				      BTN_MAP_RESPONSE_MIN_SIZE);
+}
+
+static void zotac_modifier_value_to_names(u8 modifiers, char *buf,
+					  size_t buf_size)
+{
+	bool first = true;
+	int i, pos = 0;
+
+	if (modifiers == 0) {
+		strscpy(buf, "none", buf_size);
+		return;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(modifier_names); i++) {
+		if (modifier_names[i].value != MOD_NONE &&
+		    (modifiers & modifier_names[i].value)) {
+			if (!first)
+				pos += scnprintf(buf + pos, buf_size - pos,
+						 " ");
+			pos += scnprintf(buf + pos, buf_size - pos, "%s",
+					 modifier_names[i].name);
+			first = false;
+
+			if (pos >= buf_size - 1)
+				break;
+		}
+	}
+}
+
+static ssize_t gamepad_show(struct device *dev, struct device_attribute *attr,
+			    char *buf, u8 button_id)
+{
+	struct button_mapping *mapping =
+		&zotac.cfg_data->button_mappings[button_id];
+	bool found = false;
+	char *p = buf;
+
+	u8 *mapping_bytes;
+	int i;
+
+	if (zotac_get_button_mapping(&zotac, button_id) < 0)
+		return -EIO;
+
+	mapping_bytes = (u8 *)&mapping->target_gamepad_buttons;
+
+	for (i = 0; button_map[i].name != NULL; i++) {
+		if (is_button_in_mapping(mapping_bytes, &button_map[i])) {
+			p += sprintf(p, "%s ", button_map[i].name);
+			found = true;
+		}
+	}
+
+	if (found) {
+		*(p - 1) = '\n';
+	} else {
+		p += sprintf(p, "none\n");
+	}
+
+	return p - buf;
+}
+
+static ssize_t gamepad_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count, u8 button_id)
+{
+	struct button_mapping *mapping =
+		&zotac.cfg_data->button_mappings[button_id];
+	u8 *mapping_bytes = (u8 *)&mapping->target_gamepad_buttons;
+	char *buffer, *token, *cursor;
+	bool any_valid = false;
+
+	/* Make a copy of the input buffer for tokenization */
+	buffer = kstrndup(buf, count, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	memset(mapping_bytes, 0, 4);
+
+	cursor = buffer;
+	while ((token = strsep(&cursor, " \t\n")) != NULL) {
+		if (*token == '\0')
+			continue;
+
+		if (strcmp(token, "none") == 0) {
+			any_valid = true;
+			break;
+		}
+
+		const struct button_mapping_entry *button =
+			find_button_by_name(token);
+		if (button) {
+			add_button_to_mapping(mapping_bytes, button);
+			any_valid = true;
+		}
+	}
+
+	kfree(buffer);
+
+	if (!any_valid)
+		return -EINVAL;
+
+	return zotac_set_button_mapping(&zotac, button_id) ? -EIO : count;
+}
+
+static ssize_t modifier_show(struct device *dev, struct device_attribute *attr,
+			     char *buf, u8 button_id)
+{
+	struct button_mapping *mapping =
+		&zotac.cfg_data->button_mappings[button_id];
+	u8 modifiers;
+
+	modifiers = mapping->target_modifier_keys;
+	/* Leave room for newline and null */
+	zotac_modifier_value_to_names(modifiers, buf, PAGE_SIZE - 2);
+	strcat(buf, "\n");
+	return strlen(buf);
+}
+
+static ssize_t modifier_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count, u8 button_id)
+{
+	struct button_mapping *mapping =
+		&zotac.cfg_data->button_mappings[button_id];
+	char *buffer, *token, *cursor;
+	u8 new_modifiers = 0;
+	bool any_valid = false;
+
+	buffer = kstrndup(buf, count, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	cursor = buffer;
+	while ((token = strsep(&cursor, " \t\n")) != NULL) {
+		if (*token == '\0')
+			continue;
+
+		if (strcmp(token, "none") == 0) {
+			any_valid = true;
+			new_modifiers = 0;
+			break;
+		}
+
+		int i;
+		for (i = 0; i < ARRAY_SIZE(modifier_names); i++) {
+			if (strcmp(token, modifier_names[i].name) == 0) {
+				new_modifiers |= modifier_names[i].value;
+				any_valid = true;
+				break;
+			}
+		}
+	}
+
+	kfree(buffer);
+
+	if (!any_valid)
+		return -EINVAL;
+
+	mapping->target_modifier_keys = new_modifiers;
+
+	return zotac_set_button_mapping(&zotac, button_id) ? -EIO : count;
+}
+
+static u8 find_key_code_by_name(const char *name)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(keyboard_keys); i++) {
+		if (strcmp(keyboard_keys[i].name, name) == 0)
+			return keyboard_keys[i].keycode;
+	}
+	return 0; /* Return "none" if not found */
+}
+
+static const char *find_key_name_by_code(u8 code)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(keyboard_keys); i++) {
+		if (keyboard_keys[i].keycode == code)
+			return keyboard_keys[i].name;
+	}
+	return "none";
+}
+
+static ssize_t keyboard_keys_show(struct device *dev,
+				  struct device_attribute *attr, char *buf,
+				  u8 button_id)
+{
+	struct button_mapping *mapping =
+		&zotac.cfg_data->button_mappings[button_id];
+	bool any_key = false;
+	char *p = buf;
+	int i;
+
+	if (zotac_get_button_mapping(&zotac, button_id) < 0)
+		return -EIO;
+
+	/* Check each key code in the mapping */
+	for (i = 0; i < BTN_MAP_KEYBOARD_SIZE; i++) {
+		u8 keycode = mapping->target_keyboard_keys[i];
+		if (keycode != 0) {
+			p += sprintf(p, "%s ", find_key_name_by_code(keycode));
+			any_key = true;
+		}
+	}
+
+	if (any_key) {
+		*(p - 1) = '\n';
+	} else {
+		p += sprintf(p, "none\n");
+	}
+
+	return p - buf;
+}
+
+static ssize_t keyboard_keys_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count, u8 button_id)
+{
+	struct button_mapping *mapping =
+		&zotac.cfg_data->button_mappings[button_id];
+	u8 new_keys[BTN_MAP_KEYBOARD_SIZE] = { 0 };
+	bool any_valid = false;
+	int key_count = 0;
+
+	char *buffer, *token, *cursor;
+
+	buffer = kstrndup(buf, count, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	cursor = buffer;
+	while ((token = strsep(&cursor, " \t\n")) != NULL) {
+		if (*token == '\0')
+			continue;
+
+		if (strcmp(token, "none") == 0) {
+			any_valid = true;
+			key_count = 0; /* Clear all keys */
+			break;
+		}
+
+		if (key_count < BTN_MAP_KEYBOARD_SIZE) {
+			u8 keycode = find_key_code_by_name(token);
+			if (keycode != 0) {
+				new_keys[key_count++] = keycode;
+				any_valid = true;
+			}
+		}
+	}
+
+	kfree(buffer);
+
+	if (!any_valid)
+		return -EINVAL;
+
+	memcpy(mapping->target_keyboard_keys, new_keys, BTN_MAP_KEYBOARD_SIZE);
+
+	return zotac_set_button_mapping(&zotac, button_id) ? -EIO : count;
+}
+
+static ssize_t keyboard_list_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	char *p = buf;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(keyboard_keys); i++) {
+		if (keyboard_keys[i].keycode != 0x00) {
+			int len = sprintf(p, "%s ", keyboard_keys[i].name);
+			p += len;
+
+			if (p - buf > PAGE_SIZE - 32) {
+				/* Add an indication that the list was truncated */
+				p += sprintf(p, "...");
+				break;
+			}
+		}
+	}
+
+	if (p > buf)
+		*(p - 1) = '\n';
+	else
+		*p++ = '\n';
+
+	return p - buf;
+}
+static DEVICE_ATTR_RO_NAMED(keyboard_list, "keyboard_list");
+
+static ssize_t mouse_buttons_show(struct device *dev,
+				  struct device_attribute *attr, char *buf,
+				  u8 button_id)
+{
+	struct button_mapping *mapping =
+		&zotac.cfg_data->button_mappings[button_id];
+	u8 mouse_buttons = mapping->target_mouse_buttons;
+	bool found = false;
+	char *p = buf;
+	int i;
+
+	if (zotac_get_button_mapping(&zotac, button_id) < 0)
+		return -EIO;
+
+	for (i = 0; i < ARRAY_SIZE(mouse_button_names); i++) {
+		if (mouse_buttons & mouse_button_names[i].value) {
+			p += sprintf(p, "%s ", mouse_button_names[i].name);
+			found = true;
+		}
+	}
+
+	if (found) {
+		*(p - 1) = '\n';
+	} else {
+		p += sprintf(p, "none\n");
+	}
+
+	return p - buf;
+}
+
+static ssize_t mouse_buttons_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count, u8 button_id)
+{
+	struct button_mapping *mapping =
+		&zotac.cfg_data->button_mappings[button_id];
+	char *buffer, *token, *cursor;
+	u8 new_mouse_buttons = 0;
+	bool any_valid = false;
+
+	buffer = kstrndup(buf, count, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	cursor = buffer;
+	while ((token = strsep(&cursor, " \t\n")) != NULL) {
+		if (*token == '\0')
+			continue;
+
+		if (strcmp(token, "none") == 0) {
+			any_valid = true;
+			new_mouse_buttons = 0;
+			break;
+		}
+
+		/* Find the button value */
+		int i;
+		for (i = 0; i < ARRAY_SIZE(mouse_button_names); i++) {
+			if (strcmp(token, mouse_button_names[i].name) == 0) {
+				new_mouse_buttons |=
+					mouse_button_names[i].value;
+				any_valid = true;
+				break;
+			}
+		}
+	}
+
+	kfree(buffer);
+
+	if (!any_valid)
+		return -EINVAL;
+
+	mapping->target_mouse_buttons = new_mouse_buttons;
+
+	return zotac_set_button_mapping(&zotac, button_id) ? -EIO : count;
+}
+
+static ssize_t mouse_list_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	char *p = buf;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mouse_button_names); i++) {
+		p += sprintf(p, "%s ", mouse_button_names[i].name);
+	}
+
+	if (p > buf)
+		*(p - 1) = '\n';
+	else
+		*p++ = '\n';
+
+	return p - buf;
+}
+static DEVICE_ATTR_RO_NAMED(mouse_list, "mouse_list");
+
+static ssize_t modifier_list_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	char *p = buf;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(modifier_names); i++) {
+		p += sprintf(p, "%s ", modifier_names[i].name);
+	}
+
+	if (p > buf)
+		*(p - 1) = '\n';
+	else
+		*p++ = '\n';
+
+	return p - buf;
+}
+static DEVICE_ATTR_RO_NAMED(modifier_list, "modifier_list");
+
+/* List attributes for showing available options */
+static ssize_t gamepad_list_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	char *p = buf;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(gamepad_button_names); i++) {
+		if (gamepad_button_names[i].id != BUTTON_NONE)
+			p += sprintf(p, "%s ", gamepad_button_names[i].name);
+	}
+
+	if (p > buf)
+		*(p - 1) = '\n';
+	else
+		*p++ = '\n';
+
+	return p - buf;
+}
+
+static ssize_t gamepad_max_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", MAX_GAMEPAD_BUTTONS);
+}
+
+static ssize_t keyboard_max_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", MAX_KEYBOARD_KEYS);
+}
+
+static ssize_t mouse_max_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	return sprintf(buf, "%d\n", MAX_MOUSE_BUTTONS);
+}
+
+static DEVICE_ATTR_RO_NAMED(gamepad_list, "gamepad_list");
+static DEVICE_ATTR_RO_NAMED(gamepad_max, "gamepad_max");
+static DEVICE_ATTR_RO_NAMED(keyboard_max, "keyboard_max");
+static DEVICE_ATTR_RO_NAMED(mouse_max, "mouse_max");
+
+#define DEFINE_BUTTON_REMAP_ATTRS(btn_name, btn_id)                            \
+	static ssize_t btn_name##_gamepad_show(                                \
+		struct device *dev, struct device_attribute *attr, char *buf)  \
+	{                                                                      \
+		return gamepad_show(dev, attr, buf, btn_id);                   \
+	}                                                                      \
+                                                                               \
+	static ssize_t btn_name##_gamepad_store(struct device *dev,            \
+						struct device_attribute *attr, \
+						const char *buf, size_t count) \
+	{                                                                      \
+		return gamepad_store(dev, attr, buf, count, btn_id);           \
+	}                                                                      \
+                                                                               \
+	static ssize_t btn_name##_modifier_show(                               \
+		struct device *dev, struct device_attribute *attr, char *buf)  \
+	{                                                                      \
+		return modifier_show(dev, attr, buf, btn_id);                  \
+	}                                                                      \
+                                                                               \
+	static ssize_t btn_name##_modifier_store(                              \
+		struct device *dev, struct device_attribute *attr,             \
+		const char *buf, size_t count)                                 \
+	{                                                                      \
+		return modifier_store(dev, attr, buf, count, btn_id);          \
+	}                                                                      \
+                                                                               \
+	static ssize_t btn_name##_keyboard_keys_show(                          \
+		struct device *dev, struct device_attribute *attr, char *buf)  \
+	{                                                                      \
+		return keyboard_keys_show(dev, attr, buf, btn_id);             \
+	}                                                                      \
+                                                                               \
+	static ssize_t btn_name##_keyboard_keys_store(                         \
+		struct device *dev, struct device_attribute *attr,             \
+		const char *buf, size_t count)                                 \
+	{                                                                      \
+		return keyboard_keys_store(dev, attr, buf, count, btn_id);     \
+	}                                                                      \
+                                                                               \
+	static ssize_t btn_name##_mouse_buttons_show(                          \
+		struct device *dev, struct device_attribute *attr, char *buf)  \
+	{                                                                      \
+		return mouse_buttons_show(dev, attr, buf, btn_id);             \
+	}                                                                      \
+                                                                               \
+	static ssize_t btn_name##_mouse_buttons_store(                         \
+		struct device *dev, struct device_attribute *attr,             \
+		const char *buf, size_t count)                                 \
+	{                                                                      \
+		return mouse_buttons_store(dev, attr, buf, count, btn_id);     \
+	}                                                                      \
+                                                                               \
+	static DEVICE_ATTR_RW_NAMED(btn_name##_gamepad, "gamepad");            \
+	static DEVICE_ATTR_RW_NAMED(btn_name##_modifier, "modifier");          \
+	static DEVICE_ATTR_RW_NAMED(btn_name##_keyboard_keys, "keyboard");     \
+	static DEVICE_ATTR_RW_NAMED(btn_name##_mouse_buttons, "mouse");
+
+/* Create all button attribute groups */
+DEFINE_BUTTON_REMAP_ATTRS(btn_a, BUTTON_A);
+DEFINE_BUTTON_REMAP_ATTRS(btn_b, BUTTON_B);
+DEFINE_BUTTON_REMAP_ATTRS(btn_x, BUTTON_X);
+DEFINE_BUTTON_REMAP_ATTRS(btn_y, BUTTON_Y);
+DEFINE_BUTTON_REMAP_ATTRS(btn_lb, BUTTON_LB);
+DEFINE_BUTTON_REMAP_ATTRS(btn_rb, BUTTON_RB);
+DEFINE_BUTTON_REMAP_ATTRS(btn_lt, BUTTON_LT);
+DEFINE_BUTTON_REMAP_ATTRS(btn_rt, BUTTON_RT);
+DEFINE_BUTTON_REMAP_ATTRS(btn_ls, BUTTON_LS);
+DEFINE_BUTTON_REMAP_ATTRS(btn_rs, BUTTON_RS);
+DEFINE_BUTTON_REMAP_ATTRS(dpad_up, BUTTON_DPAD_UP);
+DEFINE_BUTTON_REMAP_ATTRS(dpad_down, BUTTON_DPAD_DOWN);
+DEFINE_BUTTON_REMAP_ATTRS(dpad_left, BUTTON_DPAD_LEFT);
+DEFINE_BUTTON_REMAP_ATTRS(dpad_right, BUTTON_DPAD_RIGHT);
+DEFINE_BUTTON_REMAP_ATTRS(btn_m1, BUTTON_M1);
+DEFINE_BUTTON_REMAP_ATTRS(btn_m2, BUTTON_M2);
+
+static int zotac_get_button_turbo(struct zotac_device *zotac)
+{
+	size_t data_len = 1;
+	u8 turbo_byte;
+	int ret;
+
+	ret = zotac_send_get_command(zotac, CMD_GET_BUTTON_TURBO, 0, NULL, 0,
+				     &turbo_byte, &data_len);
+	if (ret < 0)
+		return ret;
+
+	if (data_len < 1)
+		return -EIO;
+
+	zotac->cfg_data->button_turbo = turbo_byte;
+	return 0;
+}
+
+static int zotac_set_button_turbo(struct zotac_device *zotac, u8 turbo_byte)
+{
+	int ret;
+
+	ret = zotac_send_set_command(zotac, CMD_SET_BUTTON_TURBO, 0,
+				     &turbo_byte, 1);
+	if (ret < 0)
+		return ret;
+
+	zotac->cfg_data->button_turbo = turbo_byte;
+	return 0;
+}
+
+static ssize_t button_turbo_show(struct device *dev,
+				 struct device_attribute *attr, char *buf,
+				 int btn_pos)
+{
+	u8 turbo_val;
+	int ret;
+
+	ret = zotac_get_button_turbo(&zotac);
+	if (ret < 0)
+		return ret;
+
+	turbo_val = (zotac.cfg_data->button_turbo >> btn_pos) & 0x01;
+	return sprintf(buf, "%d\n", turbo_val);
+}
+
+static ssize_t button_turbo_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count, int btn_pos)
+{
+	u8 turbo_byte;
+	int val, ret;
+
+	ret = kstrtoint(buf, 10, &val);
+	if (ret)
+		return ret;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	ret = zotac_get_button_turbo(&zotac);
+	if (ret < 0)
+		return ret;
+
+	turbo_byte = zotac.cfg_data->button_turbo;
+
+	if (val)
+		turbo_byte |= (1 << btn_pos);
+	else
+		turbo_byte &= ~(1 << btn_pos);
+
+	ret = zotac_set_button_turbo(&zotac, turbo_byte);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+#define DEFINE_BUTTON_TURBO_ATTRS(btn_name, btn_pos)                          \
+	static ssize_t btn_##btn_name##_turbo_show(                           \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		return button_turbo_show(dev, attr, buf, btn_pos);            \
+	}                                                                     \
+                                                                              \
+	static ssize_t btn_##btn_name##_turbo_store(                          \
+		struct device *dev, struct device_attribute *attr,            \
+		const char *buf, size_t count)                                \
+	{                                                                     \
+		return button_turbo_store(dev, attr, buf, count, btn_pos);    \
+	}                                                                     \
+	static DEVICE_ATTR_RW_NAMED(btn_##btn_name##_turbo, "turbo");
+
+DEFINE_BUTTON_TURBO_ATTRS(a, A_BTN_POS);
+DEFINE_BUTTON_TURBO_ATTRS(b, B_BTN_POS);
+DEFINE_BUTTON_TURBO_ATTRS(x, X_BTN_POS);
+DEFINE_BUTTON_TURBO_ATTRS(y, Y_BTN_POS);
+DEFINE_BUTTON_TURBO_ATTRS(lb, LB_BTN_POS);
+DEFINE_BUTTON_TURBO_ATTRS(rb, RB_BTN_POS);
+DEFINE_BUTTON_TURBO_ATTRS(lt, LT_BTN_POS);
+DEFINE_BUTTON_TURBO_ATTRS(rt, RT_BTN_POS);
+
+/* Create attribute groups for buttons with/without turbo */
+#define DEFINE_BUTTON_TURBO_GROUP(btn_name, btn_id)                   \
+	static struct attribute *btn_name##_main_attrs[] = {          \
+		&dev_attr_##btn_name##_turbo.attr, NULL               \
+	};                                                            \
+	static const struct attribute_group btn_name##_main_group = { \
+		.attrs = btn_name##_main_attrs,                       \
+	};
+
+#define DEFINE_BUTTON_NO_TURBO_GROUP(btn_name, btn_id)                \
+	static struct attribute *btn_name##_main_attrs[] = { NULL };  \
+	static const struct attribute_group btn_name##_main_group = { \
+		.attrs = btn_name##_main_attrs,                       \
+	};
+
+/* Define remap subgroups */
+#define DEFINE_BUTTON_REMAP_GROUP(btn_name, btn_id)                    \
+	static struct attribute *btn_name##_remap_attrs[] = {          \
+		&dev_attr_##btn_name##_gamepad.attr,                   \
+		&dev_attr_##btn_name##_modifier.attr,                  \
+		&dev_attr_##btn_name##_keyboard_keys.attr,             \
+		&dev_attr_##btn_name##_mouse_buttons.attr,             \
+		&dev_attr_gamepad_list.attr,                           \
+		&dev_attr_gamepad_max.attr,                            \
+		&dev_attr_modifier_list.attr,                          \
+		&dev_attr_keyboard_list.attr,                          \
+		&dev_attr_keyboard_max.attr,                           \
+		&dev_attr_mouse_list.attr,                             \
+		&dev_attr_mouse_max.attr,                              \
+		NULL                                                   \
+	};                                                             \
+	static const struct attribute_group btn_name##_remap_group = { \
+		.name = "remap",                                       \
+		.attrs = btn_name##_remap_attrs,                       \
+	};
+
+/* Define button directory */
+#define DEFINE_BUTTON_GROUP_WITH_TURBO(btn_name, btn_id) \
+	DEFINE_BUTTON_TURBO_GROUP(btn_name, btn_id)      \
+	DEFINE_BUTTON_REMAP_GROUP(btn_name, btn_id)
+
+#define DEFINE_BUTTON_DIR_WITH_TURBO(btn_name, btn_id)                     \
+	{                                                                  \
+		.name = #btn_name,                                         \
+		.button_id = btn_id,                                       \
+		.has_turbo = true,                                         \
+		.kobj = NULL,                                              \
+		.main_group =                                              \
+			(struct attribute_group *)&btn_name##_main_group,  \
+		.remap_group =                                             \
+			(struct attribute_group *)&btn_name##_remap_group, \
+	}
+
+#define DEFINE_BUTTON_GROUP_NO_TURBO(btn_name, btn_id) \
+	DEFINE_BUTTON_NO_TURBO_GROUP(btn_name, btn_id) \
+	DEFINE_BUTTON_REMAP_GROUP(btn_name, btn_id)
+
+#define DEFINE_BUTTON_DIR_NO_TURBO(btn_name, btn_id)                       \
+	{                                                                  \
+		.name = #btn_name,                                         \
+		.button_id = btn_id,                                       \
+		.has_turbo = false,                                        \
+		.kobj = NULL,                                              \
+		.main_group =                                              \
+			(struct attribute_group *)&btn_name##_main_group,  \
+		.remap_group =                                             \
+			(struct attribute_group *)&btn_name##_remap_group, \
+	}
+
+DEFINE_BUTTON_GROUP_WITH_TURBO(btn_a, BUTTON_A);
+DEFINE_BUTTON_GROUP_WITH_TURBO(btn_b, BUTTON_B);
+DEFINE_BUTTON_GROUP_WITH_TURBO(btn_x, BUTTON_X);
+DEFINE_BUTTON_GROUP_WITH_TURBO(btn_y, BUTTON_Y);
+DEFINE_BUTTON_GROUP_WITH_TURBO(btn_lb, BUTTON_LB);
+DEFINE_BUTTON_GROUP_WITH_TURBO(btn_rb, BUTTON_RB);
+DEFINE_BUTTON_GROUP_WITH_TURBO(btn_lt, BUTTON_LT);
+DEFINE_BUTTON_GROUP_WITH_TURBO(btn_rt, BUTTON_RT);
+DEFINE_BUTTON_GROUP_NO_TURBO(btn_ls, BUTTON_LS);
+DEFINE_BUTTON_GROUP_NO_TURBO(btn_rs, BUTTON_RS);
+DEFINE_BUTTON_GROUP_NO_TURBO(dpad_up, BUTTON_DPAD_UP);
+DEFINE_BUTTON_GROUP_NO_TURBO(dpad_down, BUTTON_DPAD_DOWN);
+DEFINE_BUTTON_GROUP_NO_TURBO(dpad_left, BUTTON_DPAD_LEFT);
+DEFINE_BUTTON_GROUP_NO_TURBO(dpad_right, BUTTON_DPAD_RIGHT);
+DEFINE_BUTTON_GROUP_NO_TURBO(btn_m1, BUTTON_M1);
+DEFINE_BUTTON_GROUP_NO_TURBO(btn_m2, BUTTON_M2);
+
+/* Define all button directories */
+static struct button_directory button_dirs[] = {
+	DEFINE_BUTTON_DIR_WITH_TURBO(btn_a, BUTTON_A),
+	DEFINE_BUTTON_DIR_WITH_TURBO(btn_b, BUTTON_B),
+	DEFINE_BUTTON_DIR_WITH_TURBO(btn_x, BUTTON_X),
+	DEFINE_BUTTON_DIR_WITH_TURBO(btn_y, BUTTON_Y),
+	DEFINE_BUTTON_DIR_WITH_TURBO(btn_lb, BUTTON_LB),
+	DEFINE_BUTTON_DIR_WITH_TURBO(btn_rb, BUTTON_RB),
+	DEFINE_BUTTON_DIR_WITH_TURBO(btn_lt, BUTTON_LT),
+	DEFINE_BUTTON_DIR_WITH_TURBO(btn_rt, BUTTON_RT),
+	DEFINE_BUTTON_DIR_NO_TURBO(btn_ls, BUTTON_LS),
+	DEFINE_BUTTON_DIR_NO_TURBO(btn_rs, BUTTON_RS),
+	DEFINE_BUTTON_DIR_NO_TURBO(dpad_up, BUTTON_DPAD_UP),
+	DEFINE_BUTTON_DIR_NO_TURBO(dpad_down, BUTTON_DPAD_DOWN),
+	DEFINE_BUTTON_DIR_NO_TURBO(dpad_left, BUTTON_DPAD_LEFT),
+	DEFINE_BUTTON_DIR_NO_TURBO(dpad_right, BUTTON_DPAD_RIGHT),
+	DEFINE_BUTTON_DIR_NO_TURBO(btn_m1, BUTTON_M1),
+	DEFINE_BUTTON_DIR_NO_TURBO(btn_m2, BUTTON_M2),
+	{ NULL, 0, false, NULL, NULL, NULL } /* Terminator */
+};
+
+static int zotac_get_stick_sensitivity(struct zotac_device *zotac,
+				       int stick_num, u8 *output_values)
+{
+	u8 request_data = stick_num;
+	u8 temp_values[STICK_SENSITIVITY_SIZE];
+	size_t output_len = STICK_SENSITIVITY_SIZE;
+	int i, ret;
+
+	ret = zotac_send_get_command(zotac, CMD_GET_STICK_SENSITIVITY, 0,
+				     &request_data, 1, temp_values,
+				     &output_len);
+
+	if (ret == 0 && output_len == STICK_SENSITIVITY_SIZE) {
+		/* Scale from percentage (0-100) to device values (0-255) */
+		for (i = 0; i < STICK_SENSITIVITY_SIZE; i++) {
+			output_values[i] = temp_values[i] * 255 / 100;
+		}
+	}
+
+	return ret;
+}
+
+static struct stick_sensitivity *
+get_sensitivity_for_stick(struct zotac_device *zotac, int stick_num)
+{
+	if (stick_num == STICK_LEFT)
+		return &zotac->cfg_data->left_stick_sensitivity;
+	else
+		return &zotac->cfg_data->right_stick_sensitivity;
+}
+
+static ssize_t curve_response_show(struct device *dev,
+				   struct device_attribute *attr, char *buf,
+				   int stick_num, int point_index)
+{
+	struct stick_sensitivity *sensitivity =
+		get_sensitivity_for_stick(&zotac, stick_num);
+	int base_idx = point_index * 2;
+
+	// Dev input is 0-255, but it outputs 0-100. So we store as 0-255
+	int x_pct = sensitivity->values[base_idx] * 100 / 255;
+	int y_pct = sensitivity->values[base_idx + 1] * 100 / 255;
+
+	return sprintf(buf, "%d %d\n", x_pct, y_pct);
+}
+
+static ssize_t curve_response_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count,
+				    int stick_num, int point_index)
+{
+	struct stick_sensitivity *sensitivity =
+		get_sensitivity_for_stick(&zotac, stick_num);
+	u8 data[STICK_SENSITIVITY_SIZE + 1]; // +1 for stick ID
+	int base_idx = point_index * 2;
+
+	int x_pct, y_pct;
+	int ret;
+
+	ret = sscanf(buf, "%d %d", &x_pct, &y_pct);
+	if (ret != 2)
+		return -EINVAL;
+
+	x_pct = clamp_val(x_pct, 0, 100);
+	y_pct = clamp_val(y_pct, 0, 100);
+
+	sensitivity->values[base_idx] = x_pct * 255 / 100;
+	sensitivity->values[base_idx + 1] = y_pct * 255 / 100;
+
+	data[STICK_SENSITIVITY_NUM_IDX] = stick_num;
+
+	memcpy(&data[STICK_SENSITIVITY_DATA_IDX], sensitivity->values,
+	       STICK_SENSITIVITY_SIZE);
+
+	ret = zotac_send_set_command(&zotac, CMD_SET_STICK_SENSITIVITY, 0, data,
+				     sizeof(data));
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+#define DEFINE_CURVE_RESPONSE_ATTRS(stick_name, stick_num, point_num)           \
+	static ssize_t stick_##stick_name##_curve_response_##point_num##_show(  \
+		struct device *dev, struct device_attribute *attr, char *buf)   \
+	{                                                                       \
+		return curve_response_show(dev, attr, buf, stick_num,           \
+					   point_num - 1);                      \
+	}                                                                       \
+                                                                                \
+	static ssize_t stick_##stick_name##_curve_response_##point_num##_store( \
+		struct device *dev, struct device_attribute *attr,              \
+		const char *buf, size_t count)                                  \
+	{                                                                       \
+		return curve_response_store(dev, attr, buf, count, stick_num,   \
+					    point_num - 1);                     \
+	}                                                                       \
+	static DEVICE_ATTR_RW_NAMED(                                            \
+		stick_##stick_name##_curve_response_##point_num,                \
+		"curve_response_pct_" #point_num);
+
+DEFINE_CURVE_RESPONSE_ATTRS(xy_left, STICK_LEFT, 1)
+DEFINE_CURVE_RESPONSE_ATTRS(xy_left, STICK_LEFT, 2)
+DEFINE_CURVE_RESPONSE_ATTRS(xy_left, STICK_LEFT, 3)
+DEFINE_CURVE_RESPONSE_ATTRS(xy_left, STICK_LEFT, 4)
+
+DEFINE_CURVE_RESPONSE_ATTRS(xy_right, STICK_RIGHT, 1)
+DEFINE_CURVE_RESPONSE_ATTRS(xy_right, STICK_RIGHT, 2)
+DEFINE_CURVE_RESPONSE_ATTRS(xy_right, STICK_RIGHT, 3)
+DEFINE_CURVE_RESPONSE_ATTRS(xy_right, STICK_RIGHT, 4)
+
+static ssize_t axis_xyz_deadzone_index_show(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	return sprintf(buf, "inner outer\n");
+}
+static DEVICE_ATTR_RO_NAMED(axis_xyz_deadzone_index, "deadzone_index");
+
+static ssize_t axis_xyz_deadzone_show(struct device *dev,
+				      struct device_attribute *attr, char *buf,
+				      struct deadzone *dz)
+{
+	return sprintf(buf, "%d %d\n", dz->inner, dz->outer);
+}
+
+static int zotac_apply_deadzones(struct zotac_device *zotac,
+				 struct deadzone *left_dz,
+				 struct deadzone *right_dz, u8 cmd_code)
+{
+	u8 data[DZ_RESPONSE_SIZE];
+	int ret;
+
+	data[DZ_LEFT_INNER_IDX] = left_dz->inner;
+	data[DZ_LEFT_OUTER_IDX] = left_dz->outer;
+	data[DZ_RIGHT_INNER_IDX] = right_dz->inner;
+	data[DZ_RIGHT_OUTER_IDX] = right_dz->outer;
+
+	ret = zotac_send_set_command(zotac, cmd_code, 0, data, sizeof(data));
+
+	return ret;
+}
+
+static ssize_t axis_xyz_deadzone_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count,
+				       struct deadzone *dz)
+{
+	struct zotac_cfg_data *cfg = zotac.cfg_data;
+	int inner, outer;
+	u8 cmd_code;
+	int ret;
+
+	ret = sscanf(buf, "%d %d", &inner, &outer);
+	if (ret != 2)
+		return -EINVAL;
+
+	if (inner < 0 || inner > 100 || outer < 0 || outer > 100)
+		return -EINVAL;
+
+	dz->inner = inner;
+	dz->outer = outer;
+
+	/* Determine which command to use based on which deadzone is being modified */
+	if (dz == &cfg->ls_dz || dz == &cfg->rs_dz) {
+		cmd_code = CMD_SET_STICK_DEADZONES;
+		ret = zotac_apply_deadzones(&zotac, &cfg->ls_dz, &cfg->rs_dz,
+					    cmd_code);
+	} else {
+		cmd_code = CMD_SET_TRIGGER_DEADZONES;
+		ret = zotac_apply_deadzones(&zotac, &cfg->lt_dz, &cfg->rt_dz,
+					    cmd_code);
+	}
+
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+#define DEFINE_DEADZONE_HANDLERS(axis_name, dz_field)                         \
+	static ssize_t axis_##axis_name##_deadzone_show(                      \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		return axis_xyz_deadzone_show(dev, attr, buf,                 \
+					      &zotac.cfg_data->dz_field);    \
+	}                                                                     \
+                                                                              \
+	static ssize_t axis_##axis_name##_deadzone_store(                     \
+		struct device *dev, struct device_attribute *attr,            \
+		const char *buf, size_t count)                                \
+	{                                                                     \
+		return axis_xyz_deadzone_store(dev, attr, buf, count,         \
+					       &zotac.cfg_data->dz_field);   \
+	}                                                                     \
+	static DEVICE_ATTR_RW_NAMED(axis_##axis_name##_deadzone, "deadzone");
+
+#define DEFINE_XY_AXIS_ATTR_GROUP(axis_name)                                  \
+	static struct attribute *axis_##axis_name##_attrs[] = {               \
+		&dev_attr_axis_##axis_name##_deadzone.attr,                   \
+		&dev_attr_stick_##axis_name##_curve_response_1.attr,          \
+		&dev_attr_stick_##axis_name##_curve_response_2.attr,          \
+		&dev_attr_stick_##axis_name##_curve_response_3.attr,          \
+		&dev_attr_stick_##axis_name##_curve_response_4.attr,          \
+		&dev_attr_axis_xyz_deadzone_index.attr,                       \
+		NULL                                                          \
+	};                                                                    \
+                                                                              \
+	static const struct attribute_group axis_##axis_name##_attr_group = { \
+		.name = "axis_" #axis_name,                                   \
+		.attrs = axis_##axis_name##_attrs,                            \
+	};
+
+#define DEFINE_Z_AXIS_ATTR_GROUP(axis_name)                                   \
+	static struct attribute *axis_##axis_name##_attrs[] = {               \
+		&dev_attr_axis_##axis_name##_deadzone.attr,                   \
+		&dev_attr_axis_xyz_deadzone_index.attr, NULL                  \
+	};                                                                    \
+                                                                              \
+	static const struct attribute_group axis_##axis_name##_attr_group = { \
+		.name = "axis_" #axis_name,                                   \
+		.attrs = axis_##axis_name##_attrs,                            \
+	};
+
+DEFINE_DEADZONE_HANDLERS(xy_left, ls_dz);
+DEFINE_DEADZONE_HANDLERS(xy_right, rs_dz);
+DEFINE_DEADZONE_HANDLERS(z_left, lt_dz);
+DEFINE_DEADZONE_HANDLERS(z_right, rt_dz);
+
+DEFINE_XY_AXIS_ATTR_GROUP(xy_left);
+DEFINE_XY_AXIS_ATTR_GROUP(xy_right);
+DEFINE_Z_AXIS_ATTR_GROUP(z_left);
+DEFINE_Z_AXIS_ATTR_GROUP(z_right);
+
+static ssize_t vibration_intensity_index_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	return sprintf(buf,
+		       "trigger_left trigger_right rumble_left rumble_right\n");
+}
+static DEVICE_ATTR_RO_NAMED(vibration_intensity_index,
+			    "vibration_intensity_index");
+
+static ssize_t vibration_intensity_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	u8 data[VIB_RESPONSE_SIZE];
+	size_t data_len = sizeof(data);
+	int ret;
+
+	ret = zotac_send_get_command(&zotac, CMD_GET_VIBRATION_STRENGTH, 0, NULL,
+				     0, data, &data_len);
+	if (ret < 0)
+		return ret;
+
+	if (data_len < VIB_RESPONSE_SIZE) {
+		dev_err(&zotac.hdev->dev,
+			"Incomplete vibration data received: %zu bytes\n",
+			data_len);
+		return -EIO;
+	}
+
+	return sprintf(buf, "%d %d %d %d\n", data[VIB_LEFT_TRIGGER_IDX],
+		       data[VIB_RIGHT_TRIGGER_IDX], data[VIB_LEFT_RUMBLE_IDX],
+		       data[VIB_RIGHT_RUMBLE_IDX]);
+}
+
+static ssize_t vibration_intensity_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	u8 data[VIB_RESPONSE_SIZE];
+	int lt, rt, lr, rr;
+	int ret;
+
+	ret = sscanf(buf, "%d %d %d %d", &lt, &rt, &lr, &rr);
+	if (ret != 4)
+		return -EINVAL;
+
+	data[VIB_LEFT_TRIGGER_IDX] = clamp_val(lt, 0, 100);
+	data[VIB_RIGHT_TRIGGER_IDX] = clamp_val(rt, 0, 100);
+	data[VIB_LEFT_RUMBLE_IDX] = clamp_val(lr, 0, 100);
+	data[VIB_RIGHT_RUMBLE_IDX] = clamp_val(rr, 0, 100);
+
+	ret = zotac_send_set_command(&zotac, CMD_SET_VIBRATION_STRENGTH, 0, data,
+				     sizeof(data));
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+static DEVICE_ATTR_RW(vibration_intensity);
+
+static ssize_t mouse_speed_max_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", MOUSE_SPEED_MAX);
+}
+static DEVICE_ATTR_RO_NAMED(mouse_speed_max, "mouse_speed_max");
+
+static ssize_t mouse_speed_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int speed;
+
+	speed = zotac_send_get_byte(&zotac, CMD_GET_MOUSE_SPEED, 0, NULL, 0);
+	if (speed < 0)
+		return speed;
+
+	return sprintf(buf, "%d\n", speed);
+}
+
+static ssize_t mouse_speed_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	int speed_val;
+	u8 speed;
+	int ret;
+
+	ret = kstrtoint(buf, 10, &speed_val);
+	if (ret)
+		return ret;
+
+	if (speed_val < MOUSE_SPEED_MIN || speed_val > MOUSE_SPEED_MAX)
+		return -EINVAL;
+
+	speed = (u8)speed_val;
+	ret = zotac_send_set_command(&zotac, CMD_SET_MOUSE_SPEED, 0, &speed, 1);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+static DEVICE_ATTR_RW(mouse_speed);
+
+static ssize_t motor_test_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	u8 data[MOTOR_TEST_SIZE] = { 0 };
+
+	int left_trigger, right_trigger, left_rumble, right_rumble;
+	int ret;
+
+	ret = sscanf(buf, "%d %d %d %d", &left_trigger, &right_trigger,
+		     &left_rumble, &right_rumble);
+	if (ret != 4)
+		return -EINVAL;
+
+	left_trigger = clamp_val(left_trigger, 0, 100);
+	right_trigger = clamp_val(right_trigger, 0, 100);
+	left_rumble = clamp_val(left_rumble, 0, 100);
+	right_rumble = clamp_val(right_rumble, 0, 100);
+
+	data[0] = (u8)left_trigger; /* Left Trigger Motor */
+	data[1] = (u8)right_trigger; /* Right Trigger Motor */
+	data[2] = (u8)left_rumble; /* Left Rumble Motor */
+	data[3] = (u8)right_rumble; /* Right Rumble Motor */
+
+	ret = zotac_send_set_command(&zotac, CMD_MOTOR_TEST, 0, data,
+				     MOTOR_TEST_SIZE);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+static DEVICE_ATTR_WO(motor_test);
+
+static ssize_t motor_test_index_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf,
+		       "left_trigger right_trigger left_rumble right_rumble\n");
+}
+static DEVICE_ATTR_RO_NAMED(motor_test_index, "motor_test_index");
+
+static ssize_t profile_show(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	int profile;
+
+	profile = zotac_send_get_byte(&zotac, CMD_GET_PROFILE, 0, NULL, 0);
+	if (profile < 0)
+		return profile;
+
+	return sprintf(buf, "%d\n", profile);
+}
+
+static ssize_t profile_store(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int profile_id, ret;
+	u8 profile;
+
+	ret = kstrtoint(buf, 10, &profile_id);
+	if (ret)
+		return ret;
+
+	if (profile_id > PROFILE_SECONDARY)
+		return -EINVAL;
+
+	profile = (u8)profile_id;
+	ret = zotac_send_set_command(&zotac, CMD_SET_PROFILE, 0, &profile, 1);
+	if (ret)
+		return ret;
+
+	ret = zotac_cfg_refresh(&zotac);
+	if (ret)
+		return ret;
+
+	return count;
+}
+static DEVICE_ATTR_RW_NAMED(profile, "current");
+
+static ssize_t profile_count_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+
+	return sprintf(buf, "%d\n",
+		       zotac_send_get_byte(&zotac, CMD_GET_PROFILE_NUM, 0, NULL,
+					   0));
+}
+static DEVICE_ATTR_RO_NAMED(profile_count, "count");
+
+/* The device resets and reconnects */
+static ssize_t restore_profile_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	int val, ret;
+
+	ret = kstrtoint(buf, 10, &val);
+	if (ret)
+		return ret;
+
+	if (val != 1)
+		return -EINVAL;
+
+	dev_warn(dev, "Restoring profile, the device will reset and reconnect");
+	ret = zotac_send_set_command(&zotac, CMD_RESTORE_PROFILE, 0, NULL, 0);
+	if (ret)
+		return ret;
+
+	return count;
+}
+static DEVICE_ATTR_WO_NAMED(restore_profile, "restore");
+
+static struct attribute *zotac_profile_attrs[] = {
+	&dev_attr_profile.attr, &dev_attr_profile_count.attr,
+	&dev_attr_restore_profile.attr, NULL
+};
+
+static const struct attribute_group zotac_profile_attr_group = {
+	.name = "profile",
+	.attrs = zotac_profile_attrs,
+};
+
+static ssize_t save_config_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	int val, ret;
+
+	ret = kstrtoint(buf, 10, &val);
+	if (ret)
+		return ret;
+
+	if (val != 1)
+		return -EINVAL;
+
+	ret = zotac_send_set_command(&zotac, CMD_SAVE_CONFIG, 0, NULL, 0);
+	if (ret)
+		return ret;
+
+	return count;
+}
+static DEVICE_ATTR_WO(save_config);
+
+static ssize_t qam_mode_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	if (!zotac.gamepad)
+		return -ENODEV;
+
+	return sprintf(buf, "%i\n", zotac.gamepad->qam_mode);
+}
+
+static ssize_t qam_mode_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	u8 value;
+	int ret;
+
+	if (!zotac.gamepad)
+		return -ENODEV;
+
+	ret = kstrtou8(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	if (value >= QAM_MODE_LENGTH)
+		return -EINVAL;
+
+	zotac.gamepad->qam_mode = value;
+
+	return count;
+}
+DEVICE_ATTR_RW(qam_mode);
+
+static struct attribute *zotac_root_attrs[] = {
+	&dev_attr_save_config.attr,
+	&dev_attr_qam_mode.attr,
+	&dev_attr_vibration_intensity.attr,
+	&dev_attr_vibration_intensity_index.attr,
+	&dev_attr_mouse_speed.attr,
+	&dev_attr_mouse_speed_max.attr,
+	&dev_attr_motor_test.attr,
+	&dev_attr_motor_test_index.attr,
+	NULL
+};
+
+static const struct attribute_group zotac_root_attr_group = {
+	.attrs = zotac_root_attrs,
+};
+
+static const struct attribute_group *zotac_top_level_attr_groups[] = {
+	&zotac_profile_attr_group,
+	&zotac_root_attr_group,
+	&axis_xy_left_attr_group,
+	&axis_xy_right_attr_group,
+	&axis_z_left_attr_group,
+	&axis_z_right_attr_group,
+	NULL
+};
+
+int zotac_register_sysfs(struct zotac_device *zotac)
+{
+	struct device *dev;
+	int ret, i;
+
+	if (!zotac || !zotac->hdev)
+		return -ENODEV;
+
+	dev = &zotac->hdev->dev;
+
+	ret = sysfs_create_groups(&dev->kobj, zotac_top_level_attr_groups);
+	if (ret) {
+		dev_err(dev, "Failed to create top-level sysfs groups: %d\n",
+			ret);
+		return ret;
+	}
+
+	for (i = 0; button_dirs[i].name != NULL; i++) {
+		struct button_directory *btn_dir = &button_dirs[i];
+
+		/* Create the button directory kobject */
+		btn_dir->kobj =
+			kobject_create_and_add(btn_dir->name, &dev->kobj);
+		if (!btn_dir->kobj) {
+			dev_err(dev, "Failed to create kobject for %s\n",
+				btn_dir->name);
+			ret = -ENOMEM;
+			goto cleanup;
+		}
+
+		/* Add the main attributes to the button directory */
+		ret = sysfs_create_group(btn_dir->kobj, btn_dir->main_group);
+		if (ret) {
+			dev_err(dev, "Failed to create main group for %s: %d\n",
+				btn_dir->name, ret);
+			goto cleanup;
+		}
+
+		/* Add the remap subgroup to the button directory */
+		ret = sysfs_create_group(btn_dir->kobj, btn_dir->remap_group);
+		if (ret) {
+			dev_err(dev,
+				"Failed to create remap group for %s: %d\n",
+				btn_dir->name, ret);
+			goto cleanup;
+		}
+	}
+
+	return 0;
+
+cleanup:
+	/* Clean up on error */
+	for (i = 0; button_dirs[i].name != NULL; i++) {
+		if (button_dirs[i].kobj) {
+			kobject_put(button_dirs[i].kobj);
+			button_dirs[i].kobj = NULL;
+		}
+	}
+	sysfs_remove_groups(&dev->kobj, zotac_top_level_attr_groups);
+	return ret;
+}
+
+void zotac_unregister_sysfs(struct zotac_device *zotac)
+{
+	int i;
+	struct device *dev;
+
+	if (!zotac || !zotac->hdev) {
+		pr_err("Invalid zotac device in unregister_sysfs\n");
+		return;
+	}
+
+	dev = &zotac->hdev->dev;
+
+	/* Remove button directories and their attributes */
+	for (i = 0; button_dirs[i].name != NULL; i++) {
+		if (button_dirs[i].kobj) {
+			kobject_put(button_dirs[i].kobj);
+			button_dirs[i].kobj = NULL;
+		}
+	}
+
+	sysfs_remove_groups(&dev->kobj, zotac_top_level_attr_groups);
+}
+
+/**
+ * zotac_cfg_refresh - Refresh all configuration data from the device
+ * @zotac: The zotac device to refresh
+ *
+ * This function queries the device for all current configuration and
+ * updates the driver's cached values. It should be called during
+ * initialization and after profile changes or restores.
+ */
+int zotac_cfg_refresh(struct zotac_device *zotac)
+{
+	struct zotac_cfg_data *cfg;
+	u8 data[DZ_RESPONSE_SIZE];
+	size_t data_len = sizeof(data);
+	int ret, i;
+
+	if (!zotac->cfg_data)
+		return -EINVAL;
+
+	cfg = zotac->cfg_data;
+
+	ret = zotac_send_get_command(zotac, CMD_GET_STICK_DEADZONES, 0, NULL, 0,
+				     data, &data_len);
+	if (ret == 0 && data_len >= DZ_RESPONSE_SIZE) {
+		cfg->ls_dz.inner = data[DZ_LEFT_INNER_IDX];
+		cfg->ls_dz.outer = data[DZ_LEFT_OUTER_IDX];
+		cfg->rs_dz.inner = data[DZ_RIGHT_INNER_IDX];
+		cfg->rs_dz.outer = data[DZ_RIGHT_OUTER_IDX];
+	} else {
+		dev_info(
+			&zotac->hdev->dev,
+			"Could not retrieve stick deadzone settings, using defaults\n");
+		cfg->ls_dz.inner = 0;
+		cfg->ls_dz.outer = 100;
+		cfg->rs_dz.inner = 0;
+		cfg->rs_dz.outer = 100;
+	}
+
+	ret = zotac_send_get_command(zotac, CMD_GET_TRIGGER_DEADZONES, 0, NULL,
+				     0, data, &data_len);
+	if (ret == 0 && data_len >= DZ_RESPONSE_SIZE) {
+		cfg->lt_dz.inner = data[DZ_LEFT_INNER_IDX];
+		cfg->lt_dz.outer = data[DZ_LEFT_OUTER_IDX];
+		cfg->rt_dz.inner = data[DZ_RIGHT_INNER_IDX];
+		cfg->rt_dz.outer = data[DZ_RIGHT_OUTER_IDX];
+	} else {
+		dev_info(
+			&zotac->hdev->dev,
+			"Could not retrieve trigger deadzone settings, using defaults\n");
+		cfg->lt_dz.inner = 0;
+		cfg->lt_dz.outer = 100;
+		cfg->rt_dz.inner = 0;
+		cfg->rt_dz.outer = 100;
+	}
+
+	ret = zotac_get_stick_sensitivity(zotac, STICK_LEFT,
+					  cfg->left_stick_sensitivity.values);
+	if (ret < 0) {
+		dev_info(
+			&zotac->hdev->dev,
+			"Could not retrieve left stick sensitivity, using defaults\n");
+		/* Initialize with linear response: 25%, 50%, 75%, 100% */
+		cfg->left_stick_sensitivity.values[0] = 64; /* X1 = 25% */
+		cfg->left_stick_sensitivity.values[1] = 64; /* Y1 = 25% */
+		cfg->left_stick_sensitivity.values[2] = 128; /* X2 = 50% */
+		cfg->left_stick_sensitivity.values[3] = 128; /* Y2 = 50% */
+		cfg->left_stick_sensitivity.values[4] = 192; /* X3 = 75% */
+		cfg->left_stick_sensitivity.values[5] = 192; /* Y3 = 75% */
+		cfg->left_stick_sensitivity.values[6] = 255; /* X4 = 100% */
+		cfg->left_stick_sensitivity.values[7] = 255; /* Y4 = 100% */
+	}
+
+	ret = zotac_get_stick_sensitivity(zotac, STICK_RIGHT,
+					  cfg->right_stick_sensitivity.values);
+	if (ret < 0) {
+		dev_info(
+			&zotac->hdev->dev,
+			"Could not retrieve right stick sensitivity, using defaults\n");
+		/* Copy the left stick values which may be initialized or linear defaults */
+		memcpy(cfg->right_stick_sensitivity.values,
+		       cfg->left_stick_sensitivity.values,
+		       sizeof(cfg->right_stick_sensitivity.values));
+	}
+
+	ret = zotac_get_button_turbo(zotac);
+	if (ret < 0) {
+		dev_info(
+			&zotac->hdev->dev,
+			"Could not retrieve button turbo settings, using defaults\n");
+		cfg->button_turbo = 0; /* Default: no turbo buttons */
+	}
+
+	for (i = 1; i <= BUTTON_MAX; i++) {
+		u8 request_data = i;
+		u8 response_data[BTN_MAP_RESPONSE_MIN_SIZE];
+		size_t response_len = sizeof(response_data);
+
+		/* Set default values first */
+		cfg->button_mappings[i].target_gamepad_buttons = 0;
+		cfg->button_mappings[i].target_modifier_keys = 0;
+		memset(cfg->button_mappings[i].target_keyboard_keys, 0,
+		       MAX_KEYBOARD_KEYS);
+		cfg->button_mappings[i].target_mouse_buttons = 0;
+
+		ret = zotac_send_get_command(zotac, CMD_GET_BUTTON_MAPPING, 0,
+					     &request_data, 1, response_data,
+					     &response_len);
+		if (ret == 0 && response_len >= BTN_MAP_RESPONSE_MIN_SIZE) {
+			memcpy(&cfg->button_mappings[i].target_gamepad_buttons,
+			       &response_data[BTN_MAP_GAMEPAD_START_IDX],
+			       BTN_MAP_GAMEPAD_SIZE);
+
+			cfg->button_mappings[i].target_modifier_keys =
+				response_data[BTN_MAP_MODIFIER_IDX];
+
+			memcpy(cfg->button_mappings[i].target_keyboard_keys,
+			       &response_data[BTN_MAP_KEYBOARD_START_IDX],
+			       BTN_MAP_KEYBOARD_SIZE);
+
+			cfg->button_mappings[i].target_mouse_buttons =
+				response_data[BTN_MAP_MOUSE_IDX];
+		} else {
+			dev_info(
+				&zotac->hdev->dev,
+				"Could not retrieve button %d mapping, using defaults\n",
+				i);
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * zotac_cfg_setup - Allocate and initialize config data structure
+ * @zotac: The zotac device to set up
+ *
+ * This function allocates the config data structure and initializes
+ * the mutex and sequence number. It should be called once during
+ * driver initialization.
+ */
+static int zotac_cfg_setup(struct zotac_device *zotac)
+{
+	struct zotac_cfg_data *cfg;
+
+	if (!zotac)
+		return -EINVAL;
+
+	cfg = kzalloc(sizeof(*cfg), GFP_KERNEL);
+	if (!cfg)
+		return -ENOMEM;
+
+	mutex_init(&cfg->command_mutex);
+	cfg->sequence_num = 0;
+	zotac->cfg_data = cfg;
+
+	zotac_log_device_info(zotac);
+
+	return 0;
+}
+
+/**
+ * zotac_cfg_init - Initialize the device configuration system
+ * @zotac: The zotac device to initialize
+ *
+ * This function sets up the configuration system and loads the initial
+ * configuration from the device.
+ */
+int zotac_cfg_init(struct zotac_device *zotac)
+{
+	int ret;
+
+	ret = zotac_cfg_setup(zotac);
+	if (ret < 0)
+		return ret;
+
+	ret = zotac_cfg_refresh(zotac);
+	if (ret < 0) {
+		/* If refresh fails, still keep the structure but log an error */
+		dev_err(&zotac->hdev->dev,
+			"Failed to load initial configuration: %d\n", ret);
+	}
+
+	return 0;
+}
+
+void zotac_cfg_cleanup(struct zotac_device *zotac)
+{
+	if (!zotac || !zotac->cfg_data)
+		return;
+
+	kfree(zotac->cfg_data);
+	zotac->cfg_data = NULL;
+}
diff --git a/drivers/hid/zotac-zone-hid/zotac-zone-hid-core.c b/drivers/hid/zotac-zone-hid/zotac-zone-hid-core.c
new file mode 100644
index 000000000..6f80ea2f9
--- /dev/null
+++ b/drivers/hid/zotac-zone-hid/zotac-zone-hid-core.c
@@ -0,0 +1,597 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * HID driver for ZOTAC Gaming Zone Controller - RGB LED control
+ *
+ * Copyright (c) 2025 Luke D. Jones <luke@ljones.dev>
+ */
+
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/usb.h>
+
+#include "zotac-zone.h"
+
+#define ZOTAC_VENDOR_ID 0x1ee9
+#define ZOTAC_ALT_VENDOR_ID 0x1e19
+#define ZOTAC_PRODUCT_ID 0x1590
+
+#define ZOTAC_DIAL_INTERFACE 1
+#define ZOTAC_REPORT_INTERFACE 2
+#define ZOTAC_COMMAND_INTERFACE 3
+
+#define ZOTAC_DIAL_REPORT_ID 0x03
+#define ZOTAC_KBD_REPORT_ID 0x02
+#define ZOTAC_MOUSE_REPORT_ID 0x04
+#define ZOTAC_STATUS_REPORT_ID 0x07
+#define ZOTAC_STATUS2_REPORT_ID 0x08
+#define ZOTAC_STATUS3_REPORT_ID 0x09
+
+#define ZOTAC_RIGHT_DIAL_CW_BIT 0
+#define ZOTAC_RIGHT_DIAL_CCW_BIT 1
+#define ZOTAC_LEFT_DIAL_CW_BIT 3
+#define ZOTAC_LEFT_DIAL_CCW_BIT 4
+
+#define HID_USAGE_F16 0x6B
+#define HID_USAGE_F17 0x6C
+#define HID_USAGE_F18 0x6D
+#define HID_USAGE_F19 0x6E
+#define HID_USAGE_F20 0x6F
+
+struct zotac_device zotac;
+
+typedef void (*zotac_report_handler)(struct zotac_device *zotac, u8 *data,
+				     int size);
+
+struct zotac_report_handler {
+	u8 report_id;
+	zotac_report_handler handler;
+	const char *name;
+};
+
+/**
+	* zotac_get_usb_interface - Get the USB interface from a HID device
+	* @hdev: The HID device
+	*
+	* Returns the USB interface if the device is a USB device, NULL otherwise
+	*/
+struct usb_interface *zotac_get_usb_interface(struct hid_device *hdev)
+{
+	struct usb_interface *intf = NULL;
+
+	if (hid_is_usb(hdev))
+		intf = to_usb_interface(hdev->dev.parent);
+
+	return intf;
+}
+
+static int get_interface_num(struct hid_device *hdev)
+{
+	struct usb_interface *intf = zotac_get_usb_interface(hdev);
+
+	if (intf && intf->cur_altsetting)
+		return intf->cur_altsetting->desc.bInterfaceNumber;
+
+	return -1;
+}
+
+static void process_dial_wheel_report(struct zotac_device *zotac, u8 *data,
+				      int size)
+{
+	u8 value;
+
+	if (size < 4 || !zotac->wheel_input)
+		return;
+
+	value = data[3];
+	if (value == 0)
+		return;
+
+	if (value & BIT(ZOTAC_RIGHT_DIAL_CW_BIT))
+		input_report_rel(zotac->wheel_input, REL_WHEEL, 1);
+	if (value & BIT(ZOTAC_RIGHT_DIAL_CCW_BIT))
+		input_report_rel(zotac->wheel_input, REL_WHEEL, -1);
+
+	if (value & BIT(ZOTAC_LEFT_DIAL_CW_BIT))
+		input_report_rel(zotac->wheel_input, REL_HWHEEL, 1);
+	if (value & BIT(ZOTAC_LEFT_DIAL_CCW_BIT))
+		input_report_rel(zotac->wheel_input, REL_HWHEEL, -1);
+
+	input_sync(zotac->wheel_input);
+}
+
+static int process_keyboard_report(struct zotac_device *zotac, u8 *data,
+				   int size)
+{
+	u32 pattern;
+	enum qam_mode qam_mode;
+
+	if (zotac->gamepad)
+		qam_mode = zotac->gamepad->qam_mode;
+
+	if (size < 5)
+		return 0;
+
+	pattern = (data[1] << 16) | (data[2] << 8) | data[3];
+
+	if (pattern == 0x09006c || pattern == 0x09006d || pattern == 0x080007 || pattern == 0x050063) {
+		switch (data[3]) {
+		case 0x63:
+			switch (qam_mode) {
+			case QAM_MODE_KEYBOARD:
+				data[3] = HID_USAGE_F19;
+				break;
+			case QAM_MODE_CUSTOM:
+				zotac_gamepad_send_button(zotac, (int[]){ BTN_TRIGGER_HAPPY6 }, 1);
+				break;
+			default:
+				zotac_gamepad_send_button(zotac, (int[]){ BTN_MODE, BTN_X }, 2);
+				break;
+			}
+			break;
+		case 0x6C:
+			switch (qam_mode) {
+			case QAM_MODE_KEYBOARD:
+				data[3] = HID_USAGE_F16;
+				break;
+			default:
+				zotac_gamepad_send_button(zotac, (int[]){ BTN_MODE }, 1);
+				break;
+			}
+			break;
+		case 0x6D:
+			switch (qam_mode) {
+			case QAM_MODE_KEYBOARD:
+				data[3] = HID_USAGE_F17;
+				break;
+			default:
+				zotac_gamepad_send_button(zotac, (int[]){ BTN_MODE, BTN_A }, 2);
+				break;
+			}
+			break;
+		case 0x07:
+			switch (qam_mode) {
+			case QAM_MODE_KEYBOARD:
+				data[3] = HID_USAGE_F18;
+				break;
+			case QAM_MODE_CUSTOM:
+				zotac_gamepad_send_button(zotac, (int[]){ BTN_TRIGGER_HAPPY5 }, 1);
+				break;
+			default:
+				zotac_gamepad_send_button(zotac, (int[]){ BTN_MODE, BTN_B }, 2);
+				break;
+			}
+			break;
+		}
+		if (qam_mode) {
+			memset(data, 0, size);
+			return 1;
+		} else {
+			data[1] = 0;
+			return 0;
+		}
+	}
+	return 0;
+}
+
+static void process_mouse_report(struct zotac_device *zotac, u8 *data, int size)
+{
+	s8 x_movement = 0, y_movement = 0, wheel_movement = 0;
+	int bit, i;
+
+	if (size < 5 || !zotac->mouse_input)
+		return;
+
+	x_movement = (s8)data[2];
+	y_movement = (s8)data[3];
+
+	if (size >= 5)
+		wheel_movement = (s8)data[4];
+
+	for (i = 0; i < 8; i++) {
+		bit = 1 << i;
+		input_report_key(zotac->mouse_input, BTN_LEFT + i,
+				 (data[1] & bit) ? 1 : 0);
+	}
+
+	input_report_rel(zotac->mouse_input, REL_X, x_movement);
+	input_report_rel(zotac->mouse_input, REL_Y, y_movement);
+
+	if (wheel_movement)
+		input_report_rel(zotac->mouse_input, REL_WHEEL, wheel_movement);
+
+	input_sync(zotac->mouse_input);
+}
+
+static const struct zotac_report_handler dial_interface_handlers[] = {
+	{ .report_id = ZOTAC_DIAL_REPORT_ID,
+	  .handler = process_dial_wheel_report,
+	  .name = "dial wheel" },
+	{ .report_id = ZOTAC_MOUSE_REPORT_ID,
+	  .handler = process_mouse_report,
+	  .name = "mouse" },
+	{ 0 }
+};
+
+static int zotac_process_report(struct zotac_device *zotac,
+				const struct zotac_report_handler *handlers,
+				u8 *data, int size)
+{
+	const struct zotac_report_handler *handler;
+	u8 report_id;
+
+	if (size < 1)
+		return 0;
+
+	report_id = data[0];
+
+	for (handler = handlers; handler->handler; handler++) {
+		if (handler->report_id == report_id) {
+			handler->handler(zotac, data, size);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int zotac_raw_event(struct hid_device *hdev, struct hid_report *report,
+			   u8 *data, int size)
+{
+	int intf_num = get_interface_num(hdev);
+	int handled = 0;
+
+	if (size < 2)
+		return 0;
+
+	switch (intf_num) {
+	case ZOTAC_GAMEPAD_INTERFACE:
+		if (zotac.gamepad) {
+			zotac_process_gamepad_report(&zotac, data, size);
+			handled = 1;
+		}
+		break;
+	case ZOTAC_DIAL_INTERFACE:
+		if (data[0] == ZOTAC_KBD_REPORT_ID)
+			return process_keyboard_report(&zotac, data, size);
+
+		handled = zotac_process_report(&zotac, dial_interface_handlers,
+					       data, size);
+		break;
+	case ZOTAC_REPORT_INTERFACE:
+		if (data[0] >= ZOTAC_STATUS_REPORT_ID &&
+		    data[0] <= ZOTAC_STATUS3_REPORT_ID)
+			handled = 1;
+		break;
+	}
+
+	return handled;
+}
+
+static int zotac_input_mapping(struct hid_device *hdev, struct hid_input *hi,
+			       struct hid_field *field, struct hid_usage *usage,
+			       unsigned long **bit, int *max)
+{
+	int intf_num = get_interface_num(hdev);
+
+	if (intf_num == ZOTAC_REPORT_INTERFACE ||
+	    intf_num == ZOTAC_COMMAND_INTERFACE)
+		return -1;
+
+	if (intf_num == ZOTAC_DIAL_INTERFACE) {
+		if (field->report &&
+		    (field->report->id == ZOTAC_MOUSE_REPORT_ID ||
+		     field->report->id == ZOTAC_DIAL_REPORT_ID))
+			return -1;
+
+		if (field->report && field->report->id == ZOTAC_KBD_REPORT_ID)
+			return 0;
+	}
+
+	return 0;
+}
+
+/**
+	* zotac_init_input_device - Initialize common input device properties
+	* @input_dev: The input device to initialize
+	* @hdev: The HID device associated with this input device
+	* @name: The name to assign to the input device
+	*
+	* Sets up common properties for an input device based on the HID device
+	*/
+void zotac_init_input_device(struct input_dev *input_dev,
+			     struct hid_device *hdev, const char *name)
+{
+	input_dev->name = name;
+	input_dev->phys = hdev->phys;
+	input_dev->uniq = hdev->uniq;
+	input_dev->id.bustype = hdev->bus;
+	input_dev->id.vendor = hdev->vendor;
+	input_dev->id.product = hdev->product;
+	input_dev->id.version = hdev->version;
+	input_dev->dev.parent = &hdev->dev;
+}
+
+static int setup_wheel_input_device(struct zotac_device *zotac)
+{
+	int ret;
+
+	zotac->wheel_input = devm_input_allocate_device(&zotac->hdev->dev);
+	if (!zotac->wheel_input) {
+		hid_err(zotac->hdev, "Failed to allocate wheel input device\n");
+		return -ENOMEM;
+	}
+
+	zotac_init_input_device(zotac->wheel_input, zotac->hdev,
+				"ZOTAC Gaming Zone Dials");
+
+	__set_bit(EV_REL, zotac->wheel_input->evbit);
+	__set_bit(REL_WHEEL, zotac->wheel_input->relbit);
+	__set_bit(REL_HWHEEL, zotac->wheel_input->relbit);
+
+	ret = input_register_device(zotac->wheel_input);
+	if (ret) {
+		hid_err(zotac->hdev, "Failed to register wheel input device\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int setup_mouse_input_device(struct zotac_device *zotac)
+{
+	int ret, i;
+
+	zotac->mouse_input = devm_input_allocate_device(&zotac->hdev->dev);
+	if (!zotac->mouse_input) {
+		hid_err(zotac->hdev, "Failed to allocate mouse input device\n");
+		return -ENOMEM;
+	}
+
+	zotac_init_input_device(zotac->mouse_input, zotac->hdev,
+				"ZOTAC Gaming Zone Mouse");
+
+	__set_bit(EV_KEY, zotac->mouse_input->evbit);
+	__set_bit(EV_REL, zotac->mouse_input->evbit);
+
+	for (i = 0; i < 8; i++)
+		__set_bit(BTN_LEFT + i, zotac->mouse_input->keybit);
+
+	__set_bit(REL_X, zotac->mouse_input->relbit);
+	__set_bit(REL_Y, zotac->mouse_input->relbit);
+	__set_bit(REL_WHEEL, zotac->mouse_input->relbit);
+
+	ret = input_register_device(zotac->mouse_input);
+	if (ret) {
+		hid_err(zotac->hdev, "Failed to register mouse input device\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int zotac_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+	int intf_num, ret;
+	bool gamepad_initialized = false;
+	bool cfg_initialized = false;
+
+	intf_num = get_interface_num(hdev);
+
+	zotac.hdev = hdev;
+	hid_set_drvdata(hdev, &zotac);
+
+	ret = hid_parse(hdev);
+	if (ret) {
+		hid_err(hdev, "Parse failed\n");
+		return ret;
+	}
+
+	switch (intf_num) {
+	case ZOTAC_DIAL_INTERFACE:
+		ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+		break;
+	case ZOTAC_REPORT_INTERFACE:
+	case ZOTAC_COMMAND_INTERFACE:
+		ret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);
+		break;
+	default:
+		ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+		break;
+	}
+
+	if (ret) {
+		hid_err(hdev, "HID hw start failed\n");
+		goto err;
+	}
+
+	if (intf_num == ZOTAC_DIAL_INTERFACE) {
+		ret = setup_wheel_input_device(&zotac);
+		if (ret) {
+			hid_err(hdev, "Wheel input setup failed\n");
+			goto err_stop_hw;
+		}
+
+		ret = setup_mouse_input_device(&zotac);
+		if (ret) {
+			hid_err(hdev, "Mouse input setup failed\n");
+			/* Unregister wheel input before jumping to err_stop_hw */
+			input_unregister_device(zotac.wheel_input);
+			zotac.wheel_input = NULL;
+			goto err_stop_hw;
+		}
+
+		ret = zotac_init_gamepad(&zotac, zotac_get_usb_interface(hdev));
+		if (ret) {
+			hid_warn(hdev, "Gamepad initialization failed: %d\n",
+				 ret);
+		} else {
+			gamepad_initialized = true;
+		}
+	}
+
+	if (intf_num == ZOTAC_COMMAND_INTERFACE) {
+		ret = zotac_cfg_init(&zotac);
+		if (ret) {
+			hid_warn(hdev, "Cfg data initialization failed: %d\n",
+				 ret);
+			goto err_stop_hw;
+		} else {
+			cfg_initialized = true;
+			zotac_register_sysfs(&zotac);
+		}
+		ret = zotac_rgb_init(&zotac);
+		if (ret)
+			hid_warn(hdev, "RGB initialization failed: %d\n", ret);
+	}
+
+	hid_info(hdev, "Loaded version %s\n", ZOTAC_VERSION);
+
+	return 0;
+
+err_stop_hw:
+	if (gamepad_initialized)
+		zotac_cleanup_gamepad(&zotac);
+	if (cfg_initialized)
+		zotac_cfg_cleanup(&zotac);
+
+	hid_hw_stop(hdev);
+err:
+	return ret;
+}
+
+static int zotac_input_configured(struct hid_device *hdev, struct hid_input *hi)
+{
+	int intf_num = get_interface_num(hdev);
+
+	if (intf_num == ZOTAC_DIAL_INTERFACE)
+		hi->input->name = "ZOTAC Gaming Zone Keyboard";
+
+	return 0;
+}
+
+static int zotac_resubmit_urbs(struct hid_device *hdev)
+{
+	int intf_num = get_interface_num(hdev);
+	int ret = 0;
+
+	if (zotac.gamepad && zotac.gamepad->urbs[0] &&
+	    (intf_num == ZOTAC_GAMEPAD_INTERFACE ||
+	     intf_num == ZOTAC_DIAL_INTERFACE)) {
+		ret = usb_submit_urb(zotac.gamepad->urbs[0], GFP_NOIO);
+		if (ret) {
+			hid_err(hdev, "Failed to resubmit gamepad URB: %d\n",
+				ret);
+			return ret;
+		}
+		hid_dbg(hdev, "Gamepad URB resubmitted successfully\n");
+	}
+
+	return 0;
+}
+
+static int zotac_resume(struct hid_device *hdev)
+{
+	hid_dbg(hdev, "resume called for interface %d\n",
+		get_interface_num(hdev));
+	return zotac_resubmit_urbs(hdev);
+}
+
+static int zotac_reset_resume(struct hid_device *hdev)
+{
+	int intf_num = get_interface_num(hdev);
+
+	hid_info(hdev, "reset_resume called for interface %d\n", intf_num);
+
+	if (zotac.led_rgb_dev && intf_num == ZOTAC_COMMAND_INTERFACE)
+		zotac_rgb_resume(&zotac);
+
+	return zotac_resubmit_urbs(hdev);
+}
+
+static int zotac_suspend(struct hid_device *hdev, pm_message_t message)
+{
+	int intf_num = get_interface_num(hdev);
+	int i;
+
+	hid_dbg(hdev, "suspend called for interface %d\n", intf_num);
+
+	if (zotac.gamepad && (intf_num == ZOTAC_GAMEPAD_INTERFACE ||
+			intf_num == ZOTAC_DIAL_INTERFACE)) {
+		/* Kill all input URBs */
+		for (i = 0; i < ZOTAC_NUM_URBS; i++) {
+			if (zotac.gamepad->urbs[i]) {
+				usb_kill_urb(zotac.gamepad->urbs[i]);
+				hid_dbg(hdev,
+					"Gamepad URB %d killed for suspend\n",
+					i);
+			}
+		}
+
+		/* Kill all force feedback URBs */
+		for (i = 0; i < ZOTAC_NUM_FF_URBS; i++) {
+			if (zotac.gamepad->ff_urbs[i]) {
+				usb_kill_urb(zotac.gamepad->ff_urbs[i]);
+				hid_dbg(hdev,
+					"Force feedback URB %d killed for suspend\n",
+					i);
+			}
+		}
+	}
+
+	if (zotac.led_rgb_dev && intf_num == ZOTAC_COMMAND_INTERFACE)
+		zotac_rgb_suspend(&zotac);
+
+	return 0;
+}
+
+static void zotac_remove(struct hid_device *hdev)
+{
+	int intf_num = get_interface_num(hdev);
+
+	dev_info(&hdev->dev, "Removing driver for interface %d", intf_num);
+
+	if (intf_num == ZOTAC_COMMAND_INTERFACE) {
+		dev_info(&hdev->dev, "Unregistering sysfs entries");
+		zotac_unregister_sysfs(&zotac);
+	}
+
+	if (zotac.gamepad)
+		zotac_cleanup_gamepad(&zotac);
+
+	if (zotac.cfg_data)
+		zotac_cfg_cleanup(&zotac);
+
+	if (zotac.led_rgb_dev)
+		zotac_rgb_cleanup(&zotac);
+
+	hid_hw_stop(hdev);
+}
+
+static const struct hid_device_id zotac_devices[] = {
+	{ HID_USB_DEVICE(ZOTAC_VENDOR_ID, ZOTAC_PRODUCT_ID) },
+	{ HID_USB_DEVICE(ZOTAC_ALT_VENDOR_ID, ZOTAC_PRODUCT_ID) },
+	{}
+};
+
+MODULE_DEVICE_TABLE(hid, zotac_devices);
+
+static struct hid_driver zotac_driver = {
+	.name = "zotac_zone_hid",
+	.id_table = zotac_devices,
+	.probe = zotac_probe,
+	.remove = zotac_remove,
+	.raw_event = zotac_raw_event,
+	.input_mapping = zotac_input_mapping,
+	.input_configured = zotac_input_configured,
+	.reset_resume = zotac_reset_resume,
+	.suspend = zotac_suspend,
+	.resume = zotac_resume,
+};
+
+module_hid_driver(zotac_driver);
+
+MODULE_AUTHOR("Luke D. Jones");
+MODULE_DESCRIPTION("HID driver for ZOTAC Gaming Zone Controller");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hid/zotac-zone-hid/zotac-zone-hid-input.c b/drivers/hid/zotac-zone-hid/zotac-zone-hid-input.c
new file mode 100644
index 000000000..571eec2df
--- /dev/null
+++ b/drivers/hid/zotac-zone-hid/zotac-zone-hid-input.c
@@ -0,0 +1,522 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * HID driver for ZOTAC Gaming Zone Controller - RGB LED control
+ *
+ * Copyright (c) 2025 Luke D. Jones <luke@ljones.dev>
+ */
+
+#include "linux/input-event-codes.h"
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/usb.h>
+#include <linux/slab.h>
+#include <linux/atomic.h>
+
+#include "zotac-zone.h"
+
+#define ZOTAC_GAMEPAD_REPORT_SIZE 64
+#define ZOTAC_GAMEPAD_URB_INTERVAL 1
+
+static void zotac_gamepad_urb_irq(struct urb *urb)
+{
+	struct zotac_device *zotac = urb->context;
+	struct zotac_gamepad *gamepad;
+	unsigned char *data = urb->transfer_buffer;
+	int retval, status = urb->status;
+
+	if (!zotac || !zotac->gamepad)
+		return;
+
+	gamepad = zotac->gamepad;
+
+	/* Use memory barrier before reading disconnect flag to ensure latest value */
+	smp_rmb();
+	if (READ_ONCE(gamepad->disconnect)) {
+		return;
+	}
+
+	switch (status) {
+	case 0:
+		break;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		return;
+	default:
+		goto exit;
+	}
+
+	zotac_process_gamepad_report(zotac, data, urb->actual_length);
+
+exit:
+	/* Use memory barrier before reading disconnect flag to ensure latest value */
+	smp_rmb();
+	if (!READ_ONCE(gamepad->disconnect)) {
+		retval = usb_submit_urb(urb, GFP_ATOMIC);
+		if (retval)
+			dev_err(&urb->dev->dev,
+				"usb_submit_urb failed with result %d\n",
+				retval);
+	}
+}
+
+static void zotac_gamepad_ff_urb_complete(struct urb *urb)
+{
+	struct zotac_device *zotac = urb->context;
+	struct zotac_gamepad *gamepad;
+	int i;
+
+	if (!zotac || !zotac->gamepad)
+		return;
+
+	gamepad = zotac->gamepad;
+
+	if (urb->status)
+		dev_dbg(&urb->dev->dev, "FF urb status %d\n", urb->status);
+
+	for (i = 0; i < ZOTAC_NUM_FF_URBS; i++) {
+		if (gamepad->ff_urbs[i] == urb) {
+			gamepad->ff_urbs[i]->transfer_flags &=
+				~URB_NO_TRANSFER_DMA_MAP;
+			atomic_set(&gamepad->ff_active[i], 0);
+			break;
+		}
+	}
+}
+
+static int zotac_gamepad_play_effect(struct input_dev *dev, void *data,
+				     struct ff_effect *effect)
+{
+	struct zotac_device *zotac = input_get_drvdata(dev);
+	struct zotac_gamepad *gamepad = zotac->gamepad;
+	int retval = -EBUSY, i;
+	u16 strong, weak;
+
+	if (!gamepad || READ_ONCE(gamepad->disconnect))
+		return -ENODEV;
+	if (effect->type != FF_RUMBLE)
+		return 0;
+
+	strong = effect->u.rumble.strong_magnitude;
+	weak = effect->u.rumble.weak_magnitude;
+
+	for (i = 0; i < ZOTAC_NUM_FF_URBS; i++) {
+		if (atomic_read(&gamepad->ff_active[i]) == 0) {
+			gamepad->ff_data[i][0] = ZOTAC_FF_REPORT_ID;
+			gamepad->ff_data[i][1] = 0x08;
+			gamepad->ff_data[i][2] = 0x00;
+			gamepad->ff_data[i][3] = strong / 256;
+			gamepad->ff_data[i][4] = weak / 256;
+			gamepad->ff_data[i][5] = 0x00;
+			gamepad->ff_data[i][6] = 0x00;
+			gamepad->ff_data[i][7] = 0x00;
+
+			/* Use atomic compare-and-swap to claim this URB */
+			if (atomic_cmpxchg(&gamepad->ff_active[i], 0, 1) == 0) {
+				retval = usb_submit_urb(gamepad->ff_urbs[i],
+							GFP_ATOMIC);
+				if (retval) {
+					dev_err(&zotac->hdev->dev,
+						"usb_submit_urb(ff) failed: %d\n",
+						retval);
+					atomic_set(&gamepad->ff_active[i], 0);
+				}
+				break;
+			}
+		}
+	}
+	return retval;
+}
+
+void zotac_process_gamepad_report(struct zotac_device *zotac, u8 *data,
+				  int size)
+{
+	struct zotac_gamepad *gamepad = zotac->gamepad;
+	struct input_dev *input_dev;
+
+	if (!gamepad || size < 14 || !(input_dev = gamepad->dev) ||
+	    data[0] != 0x00)
+		return;
+
+	input_report_abs(input_dev, ABS_HAT0X,
+			 !!(data[2] & 0x08) - !!(data[2] & 0x04));
+	input_report_abs(input_dev, ABS_HAT0Y,
+			 !!(data[2] & 0x02) - !!(data[2] & 0x01));
+	input_report_key(input_dev, BTN_START, data[2] & BIT(4));
+	input_report_key(input_dev, BTN_SELECT, data[2] & BIT(5));
+	input_report_key(input_dev, BTN_THUMBL, data[2] & BIT(6));
+	input_report_key(input_dev, BTN_THUMBR, data[2] & BIT(7));
+	input_report_key(input_dev, BTN_A, data[3] & BIT(4));
+	input_report_key(input_dev, BTN_B, data[3] & BIT(5));
+	input_report_key(input_dev, BTN_X, data[3] & BIT(6));
+	input_report_key(input_dev, BTN_Y, data[3] & BIT(7));
+	input_report_key(input_dev, BTN_TL, data[3] & BIT(0));
+	input_report_key(input_dev, BTN_TR, data[3] & BIT(1));
+	input_report_key(input_dev, BTN_MODE, data[3] & BIT(2));
+	input_report_abs(input_dev, ABS_X,
+			 (__s16)le16_to_cpup((__le16 *)(data + 6)));
+	input_report_abs(input_dev, ABS_Y,
+			 ~(__s16)le16_to_cpup((__le16 *)(data + 8)));
+	input_report_abs(input_dev, ABS_RX,
+			 (__s16)le16_to_cpup((__le16 *)(data + 10)));
+	input_report_abs(input_dev, ABS_RY,
+			 ~(__s16)le16_to_cpup((__le16 *)(data + 12)));
+	input_report_abs(input_dev, ABS_Z, data[4]);
+	input_report_abs(input_dev, ABS_RZ, data[5]);
+	input_sync(input_dev);
+}
+
+static void zotac_button_work_func(struct work_struct *work)
+{
+	struct zotac_gamepad *gamepad = container_of(
+		to_delayed_work(work), struct zotac_gamepad, button_work);
+	unsigned int button2, button;
+	bool qam_update;
+
+	if (READ_ONCE(gamepad->disconnect) || !gamepad->dev)
+		return;
+
+	/* Access these values atomically without a spinlock */
+	/* We copy them locally to avoid races */
+	button = READ_ONCE(gamepad->button_to_press);
+	button2 = READ_ONCE(gamepad->button_to_press2);
+	qam_update = READ_ONCE(gamepad->update_qam);
+
+	/* Update the state variables */
+	WRITE_ONCE(gamepad->update_qam, false);
+	WRITE_ONCE(gamepad->button_to_press, 0);
+	WRITE_ONCE(gamepad->button_to_press2, 0);
+
+	/* Memory barrier to ensure these writes complete before proceeding */
+	smp_wmb();
+
+	if (qam_update) {
+		input_report_key(gamepad->dev, button, 1);
+		input_sync(gamepad->dev);
+		msleep(150);
+		input_report_key(gamepad->dev, button2, 1);
+		input_sync(gamepad->dev);
+		input_report_key(gamepad->dev, button2, 0);
+		input_sync(gamepad->dev);
+		input_report_key(gamepad->dev, button, 0);
+		input_sync(gamepad->dev);
+	} else if (button) {
+		input_report_key(gamepad->dev, button, 1);
+		input_sync(gamepad->dev);
+		input_report_key(gamepad->dev, button, 0);
+		input_sync(gamepad->dev);
+	}
+
+	/* Release the button press lock so others can schedule button presses */
+	atomic_set(&gamepad->button_press_in_progress, 0);
+}
+
+void zotac_gamepad_send_button(struct zotac_device *zotac, int buttons[],
+			       int num_buttons)
+{
+	struct zotac_gamepad *gamepad;
+
+	if (!zotac || !zotac->gamepad || !zotac->gamepad->dev ||
+	    READ_ONCE(zotac->gamepad->disconnect))
+		return;
+
+	gamepad = zotac->gamepad;
+
+	/* Try to atomically take the button press lock */
+	if (atomic_cmpxchg(&gamepad->button_press_in_progress, 0, 1) == 0) {
+		/* We got the lock, update button values */
+
+		/* Reset button state first */
+		WRITE_ONCE(gamepad->button_to_press, 0);
+		WRITE_ONCE(gamepad->button_to_press2, 0);
+		WRITE_ONCE(gamepad->update_qam, false);
+
+		/* Set new button values */
+		if (num_buttons == 1) {
+			WRITE_ONCE(gamepad->button_to_press, buttons[0]);
+		} else if (num_buttons == 2) {
+			WRITE_ONCE(gamepad->update_qam, true);
+			WRITE_ONCE(gamepad->button_to_press, buttons[0]);
+			WRITE_ONCE(gamepad->button_to_press2, buttons[1]);
+		} else {
+			/* No buttons to press, release the lock */
+			atomic_set(&gamepad->button_press_in_progress, 0);
+			return;
+		}
+
+		/* Memory barrier to ensure writes complete before scheduling work */
+		smp_wmb();
+
+		/* Schedule the work */
+		schedule_delayed_work(&gamepad->button_work,
+				      msecs_to_jiffies(5));
+	}
+}
+
+static void zotac_find_endpoints(struct usb_interface *intf,
+				 struct usb_endpoint_descriptor **ep_in,
+				 struct usb_endpoint_descriptor **ep_out)
+{
+	struct usb_host_interface *host_interface = intf->cur_altsetting;
+	int i;
+
+	*ep_in = *ep_out = NULL;
+	for (i = 0; i < host_interface->desc.bNumEndpoints; i++) {
+		struct usb_endpoint_descriptor *ep =
+			&host_interface->endpoint[i].desc;
+		if (usb_endpoint_is_int_in(ep))
+			*ep_in = ep;
+		else if (usb_endpoint_is_int_out(ep))
+			*ep_out = ep;
+	}
+}
+
+int zotac_init_gamepad(struct zotac_device *zotac, struct usb_interface *intf)
+{
+	struct usb_endpoint_descriptor *ep_in = NULL, *ep_out = NULL;
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct hid_device *hdev = zotac->hdev;
+	int pipe, maxp, interval, ret = 0, i;
+
+	struct usb_interface *gamepad_intf;
+	struct zotac_gamepad *gamepad;
+	struct input_dev *input_dev;
+
+	if (!(gamepad = kzalloc(sizeof(*gamepad), GFP_KERNEL)))
+		return -ENOMEM;
+
+	WRITE_ONCE(gamepad->disconnect, false);
+	gamepad->zotac = zotac;
+	zotac->gamepad = gamepad;
+	zotac->udev = udev;
+
+	if (!(gamepad_intf = usb_ifnum_to_if(udev, ZOTAC_GAMEPAD_INTERFACE))) {
+		ret = -ENODEV;
+		goto err_free_gamepad;
+	}
+
+	zotac_find_endpoints(gamepad_intf, &ep_in, &ep_out);
+	if (!ep_in) {
+		ret = -ENODEV;
+		goto err_free_gamepad;
+	}
+
+	gamepad->qam_mode = QAM_MODE_STEAM;
+	gamepad->ep_in = ep_in;
+	gamepad->ep_out = ep_out;
+
+	if (!(input_dev = input_allocate_device())) {
+		ret = -ENOMEM;
+		goto err_free_gamepad;
+	}
+
+	gamepad->dev = input_dev;
+	zotac_init_input_device(input_dev, hdev, "ZOTAC Gaming Zone Gamepad");
+	input_set_drvdata(input_dev, zotac);
+
+	input_set_abs_params(input_dev, ABS_X, -32768, 32767, 16, 128);
+	input_set_abs_params(input_dev, ABS_Y, -32768, 32767, 16, 128);
+	input_set_abs_params(input_dev, ABS_RX, -32768, 32767, 16, 128);
+	input_set_abs_params(input_dev, ABS_RY, -32768, 32767, 16, 128);
+	input_set_abs_params(input_dev, ABS_Z, 0, 255, 0, 0);
+	input_set_abs_params(input_dev, ABS_RZ, 0, 255, 0, 0);
+	input_set_abs_params(input_dev, ABS_HAT0X, -1, 1, 0, 0);
+	input_set_abs_params(input_dev, ABS_HAT0Y, -1, 1, 0, 0);
+
+	input_set_capability(input_dev, EV_KEY, BTN_A);
+	input_set_capability(input_dev, EV_KEY, BTN_B);
+	input_set_capability(input_dev, EV_KEY, BTN_X);
+	input_set_capability(input_dev, EV_KEY, BTN_Y);
+	input_set_capability(input_dev, EV_KEY, BTN_TL);
+	input_set_capability(input_dev, EV_KEY, BTN_TR);
+	input_set_capability(input_dev, EV_KEY, BTN_MODE);
+	input_set_capability(input_dev, EV_KEY, BTN_START);
+	input_set_capability(input_dev, EV_KEY, BTN_SELECT);
+	input_set_capability(input_dev, EV_KEY, BTN_THUMBL);
+	input_set_capability(input_dev, EV_KEY, BTN_THUMBR);
+
+	/* Allow the gamepad to emit these events for screenface buttons */
+	input_set_capability(input_dev, EV_KEY, KEY_F14);
+	input_set_capability(input_dev, EV_KEY, KEY_F15);
+	input_set_capability(input_dev, EV_KEY, KEY_F16);
+	input_set_capability(input_dev, EV_KEY, KEY_F17);
+	input_set_capability(input_dev, EV_KEY, KEY_F18);
+	input_set_capability(input_dev, EV_KEY, KEY_F19);
+
+	input_set_capability(input_dev, EV_KEY, BTN_TRIGGER_HAPPY1);
+	input_set_capability(input_dev, EV_KEY, BTN_TRIGGER_HAPPY2);
+	input_set_capability(input_dev, EV_KEY, BTN_TRIGGER_HAPPY3);
+	input_set_capability(input_dev, EV_KEY, BTN_TRIGGER_HAPPY4);
+	input_set_capability(input_dev, EV_KEY, BTN_TRIGGER_HAPPY5);
+	input_set_capability(input_dev, EV_KEY, BTN_TRIGGER_HAPPY6);
+
+	pipe = usb_rcvintpipe(udev, gamepad->ep_in->bEndpointAddress);
+	if (!(maxp = usb_maxpacket(udev, pipe))) {
+		ret = -EINVAL;
+		goto err_free_input;
+	}
+
+	interval = gamepad->ep_in->bInterval ? gamepad->ep_in->bInterval :
+					       ZOTAC_GAMEPAD_URB_INTERVAL;
+
+	for (i = 0; i < ZOTAC_NUM_URBS; i++) {
+		if (!(gamepad->urb_buf[i] =
+			      kzalloc(ZOTAC_GAMEPAD_REPORT_SIZE, GFP_KERNEL))) {
+			ret = -ENOMEM;
+			goto err_free_urbs;
+		}
+		if (!(gamepad->urbs[i] = usb_alloc_urb(0, GFP_KERNEL))) {
+			ret = -ENOMEM;
+			goto err_free_urbs;
+		}
+		usb_fill_int_urb(gamepad->urbs[i], udev, pipe,
+				 gamepad->urb_buf[i], ZOTAC_GAMEPAD_REPORT_SIZE,
+				 zotac_gamepad_urb_irq, zotac, interval);
+	}
+
+	INIT_DELAYED_WORK(&gamepad->button_work, zotac_button_work_func);
+
+	/* Initialize atomic variables */
+	atomic_set(&gamepad->button_press_in_progress, 0);
+
+	if (gamepad->ep_out) {
+		input_set_capability(input_dev, EV_FF, FF_RUMBLE);
+
+		for (i = 0; i < ZOTAC_NUM_FF_URBS; i++) {
+			/* Initialize atomic ff_active */
+			atomic_set(&gamepad->ff_active[i], 0);
+
+			if (!(gamepad->ff_data[i] = usb_alloc_coherent(
+				      udev, ZOTAC_FF_REPORT_LEN, GFP_KERNEL,
+				      &gamepad->ff_dma[i]))) {
+				ret = -ENOMEM;
+				goto err_free_ff_data;
+			}
+			if (!(gamepad->ff_urbs[i] =
+				      usb_alloc_urb(0, GFP_KERNEL))) {
+				ret = -ENOMEM;
+				goto err_free_ff_urbs;
+			}
+			usb_fill_int_urb(
+				gamepad->ff_urbs[i], udev,
+				usb_sndintpipe(
+					udev,
+					gamepad->ep_out->bEndpointAddress),
+				gamepad->ff_data[i], ZOTAC_FF_REPORT_LEN,
+				zotac_gamepad_ff_urb_complete, zotac,
+				gamepad->ep_out->bInterval);
+			gamepad->ff_urbs[i]->transfer_dma = gamepad->ff_dma[i];
+			gamepad->ff_urbs[i]->transfer_flags |=
+				URB_NO_TRANSFER_DMA_MAP;
+		}
+
+		if ((ret = input_ff_create_memless(
+			     input_dev, NULL, zotac_gamepad_play_effect))) {
+			dev_err(&zotac->hdev->dev,
+				"Failed to create FF device: %d\n", ret);
+			goto err_free_ff_urbs;
+		}
+	}
+
+	if ((ret = input_register_device(input_dev))) {
+		dev_err(&zotac->hdev->dev,
+			"Failed to register input device: %d\n", ret);
+		goto err_free_ff_urbs;
+	}
+
+	for (i = 0; i < ZOTAC_NUM_URBS; i++) {
+		if ((ret = usb_submit_urb(gamepad->urbs[i], GFP_KERNEL))) {
+			dev_err(&zotac->hdev->dev,
+				"Failed to submit URB %d: %d\n", i, ret);
+			while (--i >= 0)
+				usb_kill_urb(gamepad->urbs[i]);
+			input_unregister_device(input_dev);
+			gamepad->dev = NULL;
+			goto err_free_ff_urbs;
+		}
+	}
+	return 0;
+
+err_free_ff_urbs:
+	for (i = 0; i < ZOTAC_NUM_FF_URBS; i++) {
+		if (gamepad->ff_urbs[i]) {
+			usb_free_urb(gamepad->ff_urbs[i]);
+			gamepad->ff_urbs[i] = NULL;
+		}
+	}
+
+err_free_ff_data:
+	for (i = 0; i < ZOTAC_NUM_FF_URBS; i++) {
+		if (gamepad->ff_data[i]) {
+			usb_free_coherent(udev, ZOTAC_FF_REPORT_LEN,
+					  gamepad->ff_data[i],
+					  gamepad->ff_dma[i]);
+			gamepad->ff_data[i] = NULL;
+		}
+	}
+
+err_free_urbs:
+	for (i = 0; i < ZOTAC_NUM_URBS; i++) {
+		if (gamepad->urbs[i]) {
+			usb_free_urb(gamepad->urbs[i]);
+			gamepad->urbs[i] = NULL;
+		}
+		if (gamepad->urb_buf[i]) {
+			kfree(gamepad->urb_buf[i]);
+			gamepad->urb_buf[i] = NULL;
+		}
+	}
+
+err_free_input:
+	if (gamepad->dev) {
+		input_free_device(gamepad->dev);
+		gamepad->dev = NULL;
+	}
+
+err_free_gamepad:
+	zotac->gamepad = NULL;
+	kfree(gamepad);
+	return ret;
+}
+
+void zotac_cleanup_gamepad(struct zotac_device *zotac)
+{
+	struct zotac_gamepad *gamepad;
+	int i;
+
+	if (!zotac || !zotac->gamepad)
+		return;
+
+	gamepad = zotac->gamepad;
+
+	/* Set disconnect first, use WRITE_ONCE and memory barrier to ensure visibility */
+	WRITE_ONCE(gamepad->disconnect, true);
+	smp_wmb();
+
+	cancel_delayed_work_sync(&gamepad->button_work);
+
+	for (i = 0; i < ZOTAC_NUM_URBS; i++) {
+		if (gamepad->urbs[i]) {
+			usb_kill_urb(gamepad->urbs[i]);
+			usb_free_urb(gamepad->urbs[i]);
+			gamepad->urbs[i] = NULL;
+		}
+	}
+
+	for (i = 0; i < ZOTAC_NUM_FF_URBS; i++) {
+		if (gamepad->ff_urbs[i]) {
+			usb_kill_urb(gamepad->ff_urbs[i]);
+			usb_free_urb(gamepad->ff_urbs[i]);
+			gamepad->ff_urbs[i] = NULL;
+		}
+	}
+
+	if (gamepad->dev) {
+		input_unregister_device(gamepad->dev);
+		gamepad->dev = NULL;
+	}
+
+	zotac->gamepad = NULL;
+}
diff --git a/drivers/hid/zotac-zone-hid/zotac-zone-hid-rgb.c b/drivers/hid/zotac-zone-hid/zotac-zone-hid-rgb.c
new file mode 100644
index 000000000..0305de2bd
--- /dev/null
+++ b/drivers/hid/zotac-zone-hid/zotac-zone-hid-rgb.c
@@ -0,0 +1,717 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+	* HID driver for ZOTAC Gaming Zone Controller - RGB LED control
+	*
+	* Copyright (c) 2025 Luke D. Jones <luke@ljones.dev>
+	*/
+
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/module.h>
+#include <linux/leds.h>
+#include <linux/led-class-multicolor.h>
+#include <linux/usb.h>
+
+#include "zotac-zone.h"
+
+#define SETTING_COLOR 0x00
+#define SETTING_SPEED 0x01
+#define SETTING_EFFECT 0x02
+#define SETTING_BRIGHTNESS 0x03
+#define SETTING_REAL_TIME 0x04
+
+#define EFFECT_RAINBOW 0x00
+#define EFFECT_BREATHE 0x01
+#define EFFECT_STARS 0x02
+#define EFFECT_FADE 0x03
+#define EFFECT_DANCE 0x04
+#define EFFECT_OFF 0xF0
+
+#define SPEED_SLOW 0x00
+#define SPEED_NORMAL 0x01
+#define SPEED_FAST 0x02
+
+#define BRIGHTNESS_OFF 0x00 /* 0% */
+#define BRIGHTNESS_LOW 0x19 /* 25% */
+#define BRIGHTNESS_MED 0x32 /* 50% */
+#define BRIGHTNESS_HIGH 0x4B /* 75% */
+#define BRIGHTNESS_MAX 0x64 /* 100% */
+
+static void zotac_rgb_set_default_colors(struct zotac_device *zotac,
+					 struct zotac_rgb_dev *led_rgb,
+					 int zone_idx)
+{
+	int j, led_index;
+
+	for (j = 0; j < ZOTAC_RGB_LEDS_PER_ZONE; j++) {
+		led_index = zone_idx * ZOTAC_RGB_LEDS_PER_ZONE + j;
+
+		led_rgb->red[led_index] = 128;
+		led_rgb->green[led_index] = 128;
+		led_rgb->blue[led_index] = 128;
+
+		zotac->led_rgb_data.zone[zone_idx].red[j] = 128;
+		zotac->led_rgb_data.zone[zone_idx].green[j] = 128;
+		zotac->led_rgb_data.zone[zone_idx].blue[j] = 128;
+	}
+}
+
+static int zotac_rgb_read_zone_colors(struct zotac_device *zotac,
+				      struct zotac_rgb_dev *led_rgb,
+				      u8 zone_idx)
+{
+	size_t expected_len = 1 + ZOTAC_RGB_LEDS_PER_ZONE * 3;
+	u8 zone_rgb_data[1 + ZOTAC_RGB_LEDS_PER_ZONE * 3];
+	size_t data_len = sizeof(zone_rgb_data);
+	int ret, j, led_index, red_idx, green_idx, blue_idx;
+	u8 red, green, blue;
+
+	zone_rgb_data[0] = zone_idx;
+
+	ret = zotac_send_get_command(zotac, CMD_GET_RGB, SETTING_COLOR,
+				     &zone_idx, 1, zone_rgb_data, &data_len);
+
+	if (ret < 0) {
+		hid_err(zotac->hdev, "Failed to read RGB data for zone %d\n",
+			zone_idx);
+		zotac_rgb_set_default_colors(zotac, led_rgb, zone_idx);
+		return ret;
+	}
+
+	if (data_len < expected_len) {
+		hid_warn(zotac->hdev,
+			 "Incomplete RGB data for zone %d: %zu bytes\n",
+			 zone_idx, data_len);
+		zotac_rgb_set_default_colors(zotac, led_rgb, zone_idx);
+		return 0;
+	}
+
+	for (j = 0; j < ZOTAC_RGB_LEDS_PER_ZONE; j++) {
+		led_index = zone_idx * ZOTAC_RGB_LEDS_PER_ZONE + j;
+		red_idx = 1 + (j * 3);
+		green_idx = red_idx + 1;
+		blue_idx = red_idx + 2;
+
+		if (red_idx >= data_len || green_idx >= data_len ||
+		    blue_idx >= data_len) {
+			hid_warn(zotac->hdev,
+				 "Index out of bounds for zone %d, LED %d\n",
+				 zone_idx, j);
+			break;
+		}
+
+		red = zone_rgb_data[red_idx];
+		green = zone_rgb_data[green_idx];
+		blue = zone_rgb_data[blue_idx];
+
+		if (led_index <
+		    ZOTAC_RGB_ZONE_COUNT * ZOTAC_RGB_LEDS_PER_ZONE) {
+			led_rgb->red[led_index] = red;
+			led_rgb->green[led_index] = green;
+			led_rgb->blue[led_index] = blue;
+
+			zotac->led_rgb_data.zone[zone_idx].red[j] = red;
+			zotac->led_rgb_data.zone[zone_idx].green[j] = green;
+			zotac->led_rgb_data.zone[zone_idx].blue[j] = blue;
+		} else {
+			hid_warn(
+				zotac->hdev,
+				"Output index out of bounds for zone %d, LED %d\n",
+				zone_idx, j);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int zotac_rgb_set_globals(struct zotac_device *zotac)
+{
+	int effect, speed, brightness;
+
+	effect = zotac_send_get_byte(zotac, CMD_GET_RGB, SETTING_EFFECT, NULL,
+				     0);
+	if (effect < 0) {
+		hid_warn(
+			zotac->hdev,
+			"Could not read effect from device, using default: %d\n",
+			EFFECT_RAINBOW);
+		effect = EFFECT_RAINBOW;
+	}
+
+	speed = zotac_send_get_byte(zotac, CMD_GET_RGB, SETTING_SPEED, NULL, 0);
+	if (speed < 0) {
+		hid_warn(
+			zotac->hdev,
+			"Could not read speed from device, using default: %d\n",
+			SPEED_NORMAL);
+		speed = SPEED_NORMAL;
+	}
+
+	/* This brightness is firmware level, not LED class level */
+	brightness = zotac_send_get_byte(zotac, CMD_GET_RGB, SETTING_BRIGHTNESS,
+					 NULL, 0);
+	if (brightness < 0) {
+		hid_warn(
+			zotac->hdev,
+			"Could not read brightness from device, using default: %d\n",
+			BRIGHTNESS_MED);
+		brightness = BRIGHTNESS_MED;
+	}
+
+	zotac->led_rgb_data.effect = effect;
+	zotac->led_rgb_data.speed = speed;
+	zotac->led_rgb_data.brightness = brightness;
+
+	return 0;
+}
+
+static void zotac_rgb_schedule_work(struct zotac_rgb_dev *led)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&led->lock, flags);
+	if (!led->removed)
+		schedule_work(&led->work);
+	spin_unlock_irqrestore(&led->lock, flags);
+}
+
+static void zotac_rgb_do_work(struct work_struct *work)
+{
+	struct zotac_rgb_dev *led =
+		container_of(work, struct zotac_rgb_dev, work);
+	struct zotac_device *zotac = led->zotac;
+	u8 zone_idx = led - zotac->led_rgb_dev;
+	u8 zone_data[3 + ZOTAC_RGB_LEDS_PER_ZONE * 3];
+	unsigned long flags;
+	int j, led_index;
+
+	spin_lock_irqsave(&led->lock, flags);
+	if (!led->update_rgb) {
+		spin_unlock_irqrestore(&led->lock, flags);
+		return;
+	}
+	led->update_rgb = false;
+
+	zone_data[0] = zone_idx;
+
+	// [0] = zone number, [1..2] = blank, [3..] = data
+	for (j = 0; j < ZOTAC_RGB_LEDS_PER_ZONE; j++) {
+		led_index = zone_idx * ZOTAC_RGB_LEDS_PER_ZONE + j;
+		zone_data[3 + (j * 3)] = led->red[led_index];
+		zone_data[4 + (j * 3)] = led->green[led_index];
+		zone_data[5 + (j * 3)] = led->blue[led_index];
+	}
+	spin_unlock_irqrestore(&led->lock, flags);
+
+	zotac_send_set_command(zotac, CMD_SET_RGB, SETTING_COLOR, zone_data,
+			       sizeof(zone_data));
+
+	if (zone_idx == 0) {
+		zotac_send_set_command(zotac, CMD_SET_RGB, SETTING_EFFECT,
+				       &zotac->led_rgb_data.effect, 1);
+		zotac_send_set_command(zotac, CMD_SET_RGB, SETTING_SPEED,
+				       &zotac->led_rgb_data.speed, 1);
+		zotac_send_set_command(zotac, CMD_SET_RGB, SETTING_BRIGHTNESS,
+				       &led->brightness, 1);
+	}
+
+	zotac_send_set_command(zotac, CMD_SAVE_CONFIG, 0, NULL, 0);
+}
+
+static void zotac_rgb_set_brightness(struct led_classdev *cdev,
+				     enum led_brightness brightness)
+{
+	struct led_classdev_mc *mc_cdev = lcdev_to_mccdev(cdev);
+	struct zotac_rgb_dev *led =
+		container_of(mc_cdev, struct zotac_rgb_dev, led_rgb_dev);
+	struct zotac_device *zotac = led->zotac;
+	u8 zone_idx = led - zotac->led_rgb_dev;
+	unsigned long flags;
+	int i, led_index, intensity, bright;
+
+	led_mc_calc_color_components(mc_cdev, brightness);
+
+	spin_lock_irqsave(&led->lock, flags);
+	led->update_rgb = true;
+	bright = mc_cdev->led_cdev.brightness;
+
+	for (i = 0; i < ZOTAC_RGB_LEDS_PER_ZONE; i++) {
+		led_index = zone_idx * ZOTAC_RGB_LEDS_PER_ZONE + i;
+		intensity = mc_cdev->subled_info[i].intensity;
+		led->red[led_index] = (((intensity >> 16) & 0xFF) * bright) / 255;
+		led->green[led_index] = (((intensity >> 8) & 0xFF) * bright) / 255;
+		led->blue[led_index] = ((intensity & 0xFF) * bright) / 255;
+
+		zotac->led_rgb_data.zone[zone_idx].red[i] = led->red[led_index];
+		zotac->led_rgb_data.zone[zone_idx].green[i] = led->green[led_index];
+		zotac->led_rgb_data.zone[zone_idx].blue[i] = led->blue[led_index];
+	}
+
+	zotac->led_rgb_data.zone[zone_idx].brightness = bright;
+	zotac->led_rgb_data.initialized = true;
+	spin_unlock_irqrestore(&led->lock, flags);
+
+	zotac_rgb_schedule_work(led);
+}
+
+static void zotac_rgb_store_settings(struct zotac_device *zotac)
+{
+	struct zotac_rgb_dev *led_rgb;
+	int i, arr_size = ZOTAC_RGB_LEDS_PER_ZONE;
+
+	for (i = 0; i < ZOTAC_RGB_ZONE_COUNT; i++) {
+		led_rgb = &zotac->led_rgb_dev[i];
+
+		zotac->led_rgb_data.zone[i].brightness =
+			led_rgb->led_rgb_dev.led_cdev.brightness;
+
+		memcpy(zotac->led_rgb_data.zone[i].red,
+		       led_rgb->red + (i * ZOTAC_RGB_LEDS_PER_ZONE), arr_size);
+		memcpy(zotac->led_rgb_data.zone[i].green,
+		       led_rgb->green + (i * ZOTAC_RGB_LEDS_PER_ZONE),
+		       arr_size);
+		memcpy(zotac->led_rgb_data.zone[i].blue,
+		       led_rgb->blue + (i * ZOTAC_RGB_LEDS_PER_ZONE), arr_size);
+	}
+}
+
+static void zotac_rgb_restore_settings(struct zotac_rgb_dev *led_rgb,
+				       struct led_classdev *led_cdev,
+				       struct mc_subled *mc_led_info)
+{
+	struct zotac_device *zotac = led_rgb->zotac;
+	u8 zone_idx = led_rgb - zotac->led_rgb_dev;
+	int i, offset = zone_idx * ZOTAC_RGB_LEDS_PER_ZONE;
+	int arr_size = ZOTAC_RGB_LEDS_PER_ZONE;
+
+	memcpy(led_rgb->red + offset, zotac->led_rgb_data.zone[zone_idx].red,
+	       arr_size);
+	memcpy(led_rgb->green + offset,
+	       zotac->led_rgb_data.zone[zone_idx].green, arr_size);
+	memcpy(led_rgb->blue + offset, zotac->led_rgb_data.zone[zone_idx].blue,
+	       arr_size);
+
+	for (i = 0; i < ZOTAC_RGB_LEDS_PER_ZONE; i++) {
+		mc_led_info[i].intensity =
+			(zotac->led_rgb_data.zone[zone_idx].red[i] << 16) |
+			(zotac->led_rgb_data.zone[zone_idx].green[i] << 8) |
+			zotac->led_rgb_data.zone[zone_idx].blue[i];
+	}
+
+	led_cdev->brightness = zotac->led_rgb_data.zone[zone_idx].brightness;
+}
+
+static ssize_t rgb_effect_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int effect;
+
+	if (!zotac.cfg_data)
+		return -ENODEV;
+	effect = zotac_send_get_byte(&zotac, CMD_GET_RGB, SETTING_EFFECT, NULL,
+				     0);
+	if (effect < 0)
+		return effect;
+
+	return sysfs_emit(buf, "%d\n", effect);
+}
+
+static ssize_t rgb_effect_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int effect, ret;
+	u8 effect_val;
+
+	if (!zotac.cfg_data)
+		return -ENODEV;
+
+	ret = kstrtoint(buf, 10, &effect);
+	if (ret)
+		return ret;
+
+	switch (effect) {
+	case EFFECT_RAINBOW:
+	case EFFECT_BREATHE:
+	case EFFECT_STARS:
+	case EFFECT_FADE:
+	case EFFECT_DANCE:
+	case EFFECT_OFF:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	effect_val = (u8)effect;
+	ret = zotac_send_set_command(&zotac, CMD_SET_RGB, SETTING_EFFECT,
+				     &effect_val, 1);
+	if (ret < 0)
+		return ret;
+
+	zotac.led_rgb_data.effect = effect_val;
+
+	return count;
+}
+static DEVICE_ATTR_RW_NAMED(rgb_effect, "effect");
+
+static ssize_t rgb_speed_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	int speed;
+
+	if (!zotac.cfg_data)
+		return -ENODEV;
+
+	speed = zotac_send_get_byte(&zotac, CMD_GET_RGB, SETTING_SPEED, NULL, 0);
+	if (speed < 0)
+		return speed;
+
+	return sysfs_emit(buf, "%d\n", speed);
+}
+
+static ssize_t rgb_speed_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	int speed, ret;
+	u8 speed_val;
+
+	if (!zotac.cfg_data)
+		return -ENODEV;
+
+	ret = kstrtoint(buf, 10, &speed);
+	if (ret) {
+		dev_err(dev, "Invalid speed value format\n");
+		return ret;
+	}
+
+	switch (speed) {
+	case SPEED_SLOW:
+	case SPEED_NORMAL:
+	case SPEED_FAST:
+		break;
+	default:
+		dev_err(dev, "Invalid speed value: %d (valid: 0-2)\n", speed);
+		return -EINVAL;
+	}
+
+	speed_val = (u8)speed;
+	ret = zotac_send_set_command(&zotac, CMD_SET_RGB, SETTING_SPEED,
+				     &speed_val, 1);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set RGB speed: %d\n", ret);
+		return ret;
+	}
+
+	zotac.led_rgb_data.speed = speed_val;
+
+	return count;
+}
+static DEVICE_ATTR_RW_NAMED(rgb_speed, "speed");
+
+static u8 brightness_level_to_value(unsigned int level)
+{
+	switch (level) {
+	case 0:
+		return BRIGHTNESS_OFF;
+	case 1:
+		return BRIGHTNESS_LOW;
+	case 2:
+		return BRIGHTNESS_MED;
+	case 3:
+		return BRIGHTNESS_HIGH;
+	case 4:
+		return BRIGHTNESS_MAX;
+	default:
+		return BRIGHTNESS_MED;
+	}
+}
+
+static unsigned int brightness_value_to_level(u8 value)
+{
+	if (value <= (BRIGHTNESS_OFF + BRIGHTNESS_LOW) / 2)
+		return 0;
+	else if (value <= (BRIGHTNESS_LOW + BRIGHTNESS_MED) / 2)
+		return 1;
+	else if (value <= (BRIGHTNESS_MED + BRIGHTNESS_HIGH) / 2)
+		return 2;
+	else if (value <= (BRIGHTNESS_HIGH + BRIGHTNESS_MAX) / 2)
+		return 3;
+	else
+		return 4;
+}
+
+static ssize_t rgb_brightness_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	int brightness = 0;
+	unsigned int level;
+
+	if (!zotac.cfg_data)
+		return -ENODEV;
+
+	brightness = zotac_send_get_byte(&zotac, CMD_GET_RGB, SETTING_BRIGHTNESS,
+					 NULL, 0);
+	if (brightness < 0)
+		return brightness;
+
+	level = brightness_value_to_level(brightness);
+
+	return sysfs_emit(buf, "%u\n", level);
+}
+
+static ssize_t rgb_brightness_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int level, ret;
+	u8 brightness;
+
+	if (!zotac.cfg_data)
+		return -ENODEV;
+
+	ret = kstrtoint(buf, 10, &level);
+	if (ret)
+		return ret;
+
+	if (level > 4)
+		return -EINVAL;
+
+	brightness = brightness_level_to_value(level);
+
+	ret = zotac_send_set_command(&zotac, CMD_SET_RGB, SETTING_BRIGHTNESS,
+				     &brightness, 1);
+	if (ret < 0)
+		return ret;
+
+	ret = zotac_send_set_command(&zotac, CMD_SAVE_CONFIG, 0, NULL, 0);
+	if (ret < 0)
+		return ret;
+
+	zotac.led_rgb_data.brightness = brightness;
+
+	return count;
+}
+static DEVICE_ATTR_RW_NAMED(rgb_brightness, "brightness");
+
+static struct attribute *zotac_rgb_attrs[] = { &dev_attr_rgb_effect.attr,
+					       &dev_attr_rgb_speed.attr,
+					       &dev_attr_rgb_brightness.attr,
+					       NULL };
+
+static const struct attribute_group zotac_rgb_attr_group = {
+	.name = "rgb",
+	.attrs = zotac_rgb_attrs,
+};
+
+/**
+* zotac_rgb_resume - Restore RGB LED settings after system resume
+* @zotac: Pointer to the zotac device structure
+*
+* Restores previously saved RGB settings after the system resumes from
+* suspend. This includes effect, speed, and color settings for all zones.
+*/
+void zotac_rgb_resume(struct zotac_device *zotac)
+{
+	struct zotac_rgb_dev *led_rgb;
+	struct led_classdev *led_cdev;
+	struct mc_subled *mc_led_info;
+	int i;
+
+	if (!zotac->led_rgb_dev)
+		return;
+
+	if (!zotac->led_rgb_data.initialized) {
+		hid_warn(
+			zotac->hdev,
+			"RGB data not initialized, skipping resume restoration\n");
+		return;
+	}
+
+	zotac_send_set_command(zotac, CMD_SET_RGB, SETTING_EFFECT,
+			       &zotac->led_rgb_data.effect, 1);
+	zotac_send_set_command(zotac, CMD_SET_RGB, SETTING_SPEED,
+			       &zotac->led_rgb_data.speed, 1);
+	zotac_send_set_command(zotac, CMD_SET_RGB, SETTING_BRIGHTNESS,
+			       &zotac->led_rgb_data.brightness, 1);
+
+	for (i = 0; i < ZOTAC_RGB_ZONE_COUNT; i++) {
+		led_rgb = &zotac->led_rgb_dev[i];
+		led_cdev = &led_rgb->led_rgb_dev.led_cdev;
+		mc_led_info = led_rgb->led_rgb_dev.subled_info;
+
+		zotac_rgb_restore_settings(led_rgb, led_cdev, mc_led_info);
+		led_rgb->update_rgb = true;
+		zotac_rgb_schedule_work(led_rgb);
+	}
+}
+
+/**
+* zotac_rgb_suspend - Save RGB LED settings before system suspend
+* @zotac: Pointer to the zotac device structure
+*
+* Stores current RGB settings before the system suspends so they
+* can be restored when the system resumes.
+*/
+void zotac_rgb_suspend(struct zotac_device *zotac)
+{
+	if (!zotac->led_rgb_dev)
+		return;
+
+	zotac_rgb_store_settings(zotac);
+}
+
+static int zotac_rgb_register_zone(struct hid_device *hdev,
+				   struct zotac_rgb_dev *led_rgb,
+				   int zone_index)
+{
+	struct mc_subled *mc_led_info;
+	struct led_classdev *led_cdev;
+	char name[32];
+	int i, err;
+
+	snprintf(name, sizeof(name), "zotac:rgb:spectra_zone_%d", zone_index);
+
+	mc_led_info = devm_kmalloc_array(&hdev->dev, ZOTAC_RGB_LEDS_PER_ZONE,
+					 sizeof(*mc_led_info),
+					 GFP_KERNEL | __GFP_ZERO);
+	if (!mc_led_info)
+		return -ENOMEM;
+
+	for (i = 0; i < ZOTAC_RGB_LEDS_PER_ZONE; i++) {
+		mc_led_info[i].color_index = LED_COLOR_ID_RGB;
+	}
+
+	led_rgb->led_rgb_dev.subled_info = mc_led_info;
+	led_rgb->led_rgb_dev.num_colors = ZOTAC_RGB_LEDS_PER_ZONE;
+
+	led_cdev = &led_rgb->led_rgb_dev.led_cdev;
+	led_cdev->brightness = 128;
+	led_cdev->name = kstrdup(name, GFP_KERNEL);
+	if (!led_cdev->name){
+		devm_kfree(&hdev->dev, mc_led_info);
+		return -ENOMEM;
+	}
+
+	led_cdev->max_brightness = 255;
+	led_cdev->brightness_set = zotac_rgb_set_brightness;
+
+	err = devm_led_classdev_multicolor_register(&hdev->dev,
+						    &led_rgb->led_rgb_dev);
+	if (err) {
+		kfree(led_cdev->name);
+		return err;
+	}
+
+	err = sysfs_create_group(&led_cdev->dev->kobj, &zotac_rgb_attr_group);
+	if (err) {
+		return err;
+	}
+
+	return 0;
+}
+
+static int zotac_rgb_init_zone(struct zotac_device *zotac, int zone_idx)
+{
+	struct zotac_rgb_dev *led_rgb = &zotac->led_rgb_dev[zone_idx];
+	int ret;
+
+	led_rgb->hdev = zotac->hdev;
+	led_rgb->zotac = zotac;
+	led_rgb->removed = false;
+	led_rgb->brightness = 128;
+
+	zotac->led_rgb_data.zone[zone_idx].brightness =
+		zotac->led_rgb_data.brightness;
+
+	zotac_rgb_read_zone_colors(zotac, led_rgb, zone_idx);
+
+	INIT_WORK(&led_rgb->work, zotac_rgb_do_work);
+	led_rgb->output_worker_initialized = true;
+	spin_lock_init(&led_rgb->lock);
+
+	ret = zotac_rgb_register_zone(zotac->hdev, led_rgb, zone_idx);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/**
+	* zotac_rgb_cleanup - Clean up resources used by RGB LED subsystem
+	* @zotac: Pointer to the zotac device structure
+	*
+	* Releases resources allocated for RGB LED control, including sysfs
+	* attributes, scheduled work, and allocated memory.
+	*/
+void zotac_rgb_cleanup(struct zotac_device *zotac)
+{
+	struct zotac_rgb_dev *led_rgb;
+	unsigned long flags;
+	int i;
+
+	if (!zotac->led_rgb_dev)
+		return;
+
+	sysfs_remove_group(&zotac->led_rgb_dev->led_rgb_dev.led_cdev.dev->kobj, &zotac_rgb_attr_group);
+
+	for (i = 0; i < ZOTAC_RGB_ZONE_COUNT; i++) {
+		led_rgb = &zotac->led_rgb_dev[i];
+
+		if (led_rgb->removed)
+			continue;
+
+		spin_lock_irqsave(&led_rgb->lock, flags);
+		led_rgb->removed = true;
+		led_rgb->output_worker_initialized = false;
+		spin_unlock_irqrestore(&led_rgb->lock, flags);
+
+		cancel_work_sync(&led_rgb->work);
+	}
+
+	zotac->led_rgb_dev = NULL;
+}
+
+/**
+* zotac_rgb_init - Initialize RGB LED subsystem
+* @zotac: Pointer to the zotac device structure
+*
+* Initializes the RGB LED subsystem by allocating memory for LEDs,
+* fetching current settings from the device, registering LED zones,
+* and creating sysfs attributes for RGB control.
+*
+* Return: 0 on success, negative error code on failure
+*/
+int zotac_rgb_init(struct zotac_device *zotac)
+{
+	struct zotac_rgb_dev *led_rgb;
+	int ret, i;
+
+	led_rgb = devm_kcalloc(&zotac->hdev->dev, ZOTAC_RGB_ZONE_COUNT,
+			       sizeof(*led_rgb), GFP_KERNEL);
+	if (!led_rgb)
+		return -ENOMEM;
+
+	zotac->led_rgb_dev = led_rgb;
+
+	zotac_rgb_set_globals(zotac);
+
+	for (i = 0; i < ZOTAC_RGB_ZONE_COUNT; i++) {
+		ret = zotac_rgb_init_zone(zotac, i);
+		if (ret < 0) {
+			zotac_rgb_cleanup(zotac);
+			return ret;
+		}
+	}
+
+	zotac->led_rgb_data.initialized = true;
+
+	for (i = 0; i < ZOTAC_RGB_ZONE_COUNT; i++) {
+		led_rgb = &zotac->led_rgb_dev[i];
+		led_rgb->update_rgb = true;
+		zotac_rgb_schedule_work(led_rgb);
+	}
+
+	return 0;
+}
diff --git a/drivers/hid/zotac-zone-hid/zotac-zone.h b/drivers/hid/zotac-zone-hid/zotac-zone.h
new file mode 100644
index 000000000..31188cee8
--- /dev/null
+++ b/drivers/hid/zotac-zone-hid/zotac-zone.h
@@ -0,0 +1,214 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * HID driver for ZOTAC Gaming Zone Controller - RGB LED control
+ *
+ * Copyright (c) 2025 Luke D. Jones <luke@ljones.dev>
+ */
+
+#ifndef __HID_ZOTAC_ZONE_H
+#define __HID_ZOTAC_ZONE_H
+
+#include <linux/hid.h>
+#include <linux/usb.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <linux/led-class-multicolor.h>
+
+#define ZOTAC_VERSION "0.1.4"
+
+#define ZOTAC_VENDOR_ID 0x1ee9
+#define ZOTAC_ALT_VENDOR_ID 0x1e19
+#define ZOTAC_PRODUCT_ID 0x1590
+
+#define ZOTAC_GAMEPAD_INTERFACE 0
+#define ZOTAC_DIAL_INTERFACE 1
+#define ZOTAC_REPORT_INTERFACE 2
+#define ZOTAC_COMMAND_INTERFACE 3
+
+#define ZOTAC_FF_REPORT_ID 0x00
+#define ZOTAC_FF_REPORT_LEN 8
+#define ZOTAC_NUM_URBS 3
+#define ZOTAC_NUM_FF_URBS 2
+
+#define CMD_SAVE_CONFIG 0xFB
+#define CMD_SET_RGB 0xAD
+#define CMD_GET_RGB 0xAE
+
+#define ZOTAC_RGB_ZONE_COUNT 2 /* Number of physical zones (0 and 1) */
+#define ZOTAC_RGB_LEDS_PER_ZONE 10 /* Number of LEDs in each zone */
+
+#define SENSITIVITY_POINT_COUNT 4
+
+/* Command codes for button mapping */
+#define CMD_SET_BUTTON_MAPPING 0xA1
+#define CMD_GET_BUTTON_MAPPING 0xA2
+
+#define BUTTON_MAX 0x18
+#define MAX_GAMEPAD_BUTTONS 14
+#define MAX_KEYBOARD_KEYS 6
+#define MAX_MOUSE_BUTTONS 3
+
+#define DEVICE_ATTR_RO_NAMED(_name, _attr_name)               \
+	struct device_attribute dev_attr_##_name = {   \
+		.attr = { .name = _attr_name, .mode = 0444 }, \
+		.show = _name##_show,                         \
+	}
+
+#define DEVICE_ATTR_WO_NAMED(_name, _attr_name)               \
+	struct device_attribute dev_attr_##_name = {   \
+		.attr = { .name = _attr_name, .mode = 0200 }, \
+		.store = _name##_store,                       \
+	}
+
+#define DEVICE_ATTR_RW_NAMED(_name, _attr_name)               \
+	struct device_attribute dev_attr_##_name = {   \
+		.attr = { .name = _attr_name, .mode = 0644 }, \
+		.show = _name##_show,                         \
+		.store = _name##_store,                       \
+	}
+
+enum qam_mode {
+	QAM_MODE_KEYBOARD = 0,
+	QAM_MODE_STEAM,
+	QAM_MODE_CUSTOM,
+	QAM_MODE_LENGTH,
+};
+
+struct zotac_gamepad {
+	struct input_dev *dev; /* input device interface */
+	struct zotac_device *zotac; /* back-pointer to parent zotac device */
+	bool disconnect; /* set when device disconnected */
+
+	struct usb_endpoint_descriptor *ep_in;
+	struct usb_endpoint_descriptor *ep_out;
+
+	struct urb *urbs[ZOTAC_NUM_URBS];
+	unsigned char *urb_buf[ZOTAC_NUM_URBS];
+
+	struct urb *ff_urbs[ZOTAC_NUM_FF_URBS];
+	unsigned char *ff_data[ZOTAC_NUM_FF_URBS];
+	dma_addr_t ff_dma[ZOTAC_NUM_FF_URBS];
+	atomic_t ff_active[ZOTAC_NUM_FF_URBS];
+
+	atomic_t button_press_in_progress;
+
+	struct delayed_work button_work;
+	unsigned int button_to_press;
+	unsigned int button_to_press2;
+	bool update_qam;
+	enum qam_mode qam_mode;
+};
+
+struct zotac_rgb_dev {
+	struct zotac_device *zotac;
+	struct hid_device *hdev;
+	struct led_classdev_mc led_rgb_dev;
+	struct work_struct work;
+	bool output_worker_initialized;
+	spinlock_t lock;
+
+	bool removed;
+	bool update_rgb;
+	uint8_t red[ZOTAC_RGB_LEDS_PER_ZONE];
+	uint8_t green[ZOTAC_RGB_LEDS_PER_ZONE];
+	uint8_t blue[ZOTAC_RGB_LEDS_PER_ZONE];
+	uint8_t brightness;
+};
+
+struct zotac_rgb_data {
+	struct {
+		uint8_t red[ZOTAC_RGB_LEDS_PER_ZONE];
+		uint8_t green[ZOTAC_RGB_LEDS_PER_ZONE];
+		uint8_t blue[ZOTAC_RGB_LEDS_PER_ZONE];
+		uint8_t brightness; // MC LED class level brightness
+	} zone[ZOTAC_RGB_ZONE_COUNT];
+	uint8_t effect; // Global effect
+	uint8_t speed; // Global speed
+	uint8_t brightness; // Global brightness
+	bool initialized;
+};
+
+struct stick_sensitivity {
+	/* X1, Y1, X2, Y2, X3, Y3, X4, Y4 */
+	u8 values[SENSITIVITY_POINT_COUNT * 2];
+};
+
+struct deadzone {
+	u8 inner;
+	u8 outer;
+};
+
+struct button_mapping {
+	u32 target_gamepad_buttons; /* Bit field for controller buttons */
+	u8 target_modifier_keys; /* Bit field for modifier keys */
+	u8 target_keyboard_keys[MAX_KEYBOARD_KEYS]; /* Array of keyboard key codes */
+	u8 target_mouse_buttons; /* Bit field for mouse buttons */
+};
+
+struct zotac_cfg_data {
+	struct mutex command_mutex;
+	u8 sequence_num;
+	/* deadzones */
+	struct deadzone ls_dz; // left stick
+	struct deadzone rs_dz; // right stick
+	struct deadzone lt_dz; // left trigger
+	struct deadzone rt_dz; // right trigger
+	struct stick_sensitivity left_stick_sensitivity;
+	struct stick_sensitivity right_stick_sensitivity;
+	u8 button_turbo;
+	/* Indexed by the button number */
+	struct button_mapping button_mappings[BUTTON_MAX+1];
+};
+
+struct zotac_device {
+	struct hid_device *hdev;
+	struct input_dev *wheel_input;
+	struct input_dev *mouse_input;
+	struct zotac_gamepad *gamepad;
+	struct usb_device *udev;
+	struct zotac_cfg_data *cfg_data;
+	struct zotac_rgb_dev *led_rgb_dev;
+	struct zotac_rgb_data led_rgb_data;
+};
+extern struct zotac_device zotac;
+
+void zotac_init_input_device(struct input_dev *input_dev,
+			     struct hid_device *hdev, const char *name);
+
+struct usb_interface *zotac_get_usb_interface(struct hid_device *hdev);
+
+int zotac_init_gamepad(struct zotac_device *zotac, struct usb_interface *intf);
+
+void zotac_process_gamepad_report(struct zotac_device *zotac, u8 *data,
+				  int size);
+
+void zotac_cleanup_gamepad(struct zotac_device *zotac);
+
+void zotac_gamepad_send_button(struct zotac_device *zotac, int buttons[],
+			       int num_buttons);
+
+int zotac_cfg_init(struct zotac_device *zotac);
+
+void zotac_cfg_cleanup(struct zotac_device *zotac);
+
+int zotac_register_sysfs(struct zotac_device *zotac);
+
+void zotac_unregister_sysfs(struct zotac_device *zotac);
+
+int zotac_send_get_command(struct zotac_device *zotac, u8 cmd_code, u8 setting,
+			   const u8 *req_data, size_t req_data_len,
+			   u8 *output_data, size_t *output_len);
+
+int zotac_send_set_command(struct zotac_device *zotac, u8 cmd_code, u8 setting,
+			   const u8 *data, size_t data_len);
+
+int zotac_send_get_byte(struct zotac_device *zotac, u8 cmd_code, u8 setting,
+			const u8 *req_data, size_t req_data_len);
+
+/* RGB LED functions */
+int zotac_rgb_init(struct zotac_device *zotac);
+void zotac_rgb_cleanup(struct zotac_device *zotac);
+void zotac_rgb_resume(struct zotac_device *zotac);
+void zotac_rgb_suspend(struct zotac_device *zotac);
+
+#endif /* __HID_ZOTAC_ZONE_H */
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 323658013..b673e5a56 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -1027,6 +1027,16 @@ config OXP_EC
 
 source "drivers/platform/x86/tuxedo/Kconfig"
 
+config ZOTAC_ZONE_PLATFORM
+	tristate "Zotac Zone platform driver"
+	select FW_ATTR_CLASS
+	select ACPI_PLATFORM_PROFILE
+	help
+	  Support for fans and PPT on Zotac Zone devices.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called zotac-zone.
+
 endif # X86_PLATFORM_DEVICES
 
 config P2SB
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index a0c584851..9d634c9f6 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -160,5 +160,7 @@ obj-$(CONFIG_WINMATE_FM07_KEYS)		+= winmate-fm07-keys.o
 # SEL
 obj-$(CONFIG_SEL3350_PLATFORM)		+= sel3350-platform.o
 
+obj-$(CONFIG_ZOTAC_ZONE_PLATFORM)	+= zotac-zone-platform.o
+
 # OneXPlayer
 obj-$(CONFIG_OXP_EC)			+= oxpec.o
diff --git a/drivers/platform/x86/zotac-zone-platform.c b/drivers/platform/x86/zotac-zone-platform.c
new file mode 100644
index 000000000..5f1123de4
--- /dev/null
+++ b/drivers/platform/x86/zotac-zone-platform.c
@@ -0,0 +1,1122 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Zotac Handheld Platform Driver
+ *
+ * Copyright (C) 2025 Luke D. Jones
+ */
+
+#include "linux/mod_devicetable.h"
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/mutex.h>
+#include <linux/dmi.h>
+#include <linux/err.h>
+#include <linux/acpi.h>
+#include <linux/ioport.h>
+#include <linux/jiffies.h>
+#include <linux/platform_profile.h>
+#include <linux/wmi.h>
+
+#include "firmware_attributes_class.h"
+
+#define DRIVER_NAME "zotac_zone_platform"
+
+#define EC_COMMAND_PORT 0x4E
+#define EC_DATA_PORT 0x4F
+
+#define EC_FAN_CTRL_ADDR 0x44A
+#define EC_FAN_DUTY_ADDR 0x44B
+#define EC_FAN_SPEED_UPPER_ADDR 0x476
+#define EC_FAN_SPEED_LOWER_ADDR 0x477
+#define EC_CPU_TEMP_ADDR 0x462
+
+/* Internal values */
+#define EC_FAN_MODE_AUTO 0
+#define EC_FAN_MODE_MANUAL 1
+/* Follow standard convention for userspace */
+#define PWM_ENABLE_OFF    0
+#define PWM_ENABLE_MANUAL 1
+#define PWM_ENABLE_AUTO   2  /* Automatic control (EC control) */
+#define PWM_ENABLE_CURVE  3  /* Custom curve control */
+
+#define PWM_MIN 0
+#define PWM_MAX 255
+
+#define FAN_CURVE_POINTS 9 /* 9 points for 10-90°C like in the Zotac C# code */
+
+/* AMD APU WMI DPTC constants */
+#define AMD_APU_WMI_METHODS_GUID "1f72b0f1-bfea-4472-9877-6e62937ab616"
+#define AMD_APU_WMI_DATA_GUID "05901221-d566-11d1-b2f0-00a0c9062910"
+
+/* DPTC command IDs */
+#define DPTC_STAPM_TIME_CONSTANT  1
+#define DPTC_SUSTAINED_POWER      5
+#define DPTC_FAST_POWER_1         6
+#define DPTC_FAST_POWER_2         7
+#define DPTC_SLOW_PPT_CONSTANT    8
+#define DPTC_P3T_LIMIT            0x32
+
+/* DPTC power limits in milliwatts */
+#define DPTC_MIN_POWER            5000
+#define DPTC_MAX_POWER            28000
+
+#define PPT_PL1_SPL_MIN		8
+#define PPT_PL1_SPL_MAX		28
+#define PPT_PL2_SPPT_MIN	8
+#define PPT_PL2_SPPT_MAX	28
+#define PPT_PL3_FPPT_MIN	8
+#define PPT_PL3_FPPT_MAX	28
+
+struct power_limits {
+	u8 ppt_pl1_spl;
+	u8 ppt_pl2_sppt;
+	u8 ppt_pl3_fppt;
+};
+
+static const struct power_limits ppt_quiet_profile = {
+	.ppt_pl1_spl = 5,
+	.ppt_pl2_sppt = 10,
+	.ppt_pl3_fppt = 15,
+};
+
+static const struct power_limits ppt_balanced_profile = {
+	.ppt_pl1_spl = 12,
+	.ppt_pl2_sppt = 19,
+	.ppt_pl3_fppt = 26,
+};
+
+static const struct power_limits ppt_performance_profile = {
+	.ppt_pl1_spl = 28,
+	.ppt_pl2_sppt = 35,
+	.ppt_pl3_fppt = 45,
+};
+
+static struct timer_list fan_curve_timer;
+
+struct zotac_platform_data {
+	struct device *hwmon_dev;
+	struct mutex update_lock;
+	unsigned int fan_rpm;
+	unsigned int pwm;
+	unsigned int pwm_enable;
+	unsigned int temp;
+	unsigned long last_updated;
+	bool valid;
+	bool curve_enabled;
+
+	/* Fan curve points */
+	unsigned int curve_temp[FAN_CURVE_POINTS]; /* Temperature points */
+	unsigned int curve_pwm[FAN_CURVE_POINTS]; /* PWM/duty points */
+
+	/* DPTC values */
+	struct device *ppdev;
+	struct device *fw_attr_dev;
+	struct kset *fw_attr_kset;
+
+	bool wmi_dptc_supported;
+	struct power_limits current_power_limits;
+	enum platform_profile_option current_profile;
+	/* TODO: hacking - must be removed later */
+	unsigned int ppt_pl1_stapm_time_const;
+	unsigned int ppt_pl2_sppt_time_const;
+	unsigned int ppt_platform_sppt;
+};
+
+static struct platform_device *zotac_platform_device;
+static DEFINE_MUTEX(ec_mutex);
+static struct resource ec_io_ports[] = {
+	{
+		.start = EC_COMMAND_PORT,
+		.end = EC_COMMAND_PORT,
+		.name = "ec-command",
+		.flags = IORESOURCE_IO,
+	},
+	{
+		.start = EC_DATA_PORT,
+		.end = EC_DATA_PORT,
+		.name = "ec-data",
+		.flags = IORESOURCE_IO,
+	},
+};
+
+static u8 ec_read_byte(u16 addr)
+{
+	u8 addr_upper = (addr >> 8) & 0xFF;
+	u8 addr_lower = addr & 0xFF;
+	u8 value;
+
+	mutex_lock(&ec_mutex);
+
+	/* Select upper byte address */
+	outb(0x2E, EC_COMMAND_PORT);
+	outb(0x11, EC_DATA_PORT);
+	outb(0x2F, EC_COMMAND_PORT);
+	outb(addr_upper, EC_DATA_PORT);
+
+	/* Select lower byte address */
+	outb(0x2E, EC_COMMAND_PORT);
+	outb(0x10, EC_DATA_PORT);
+	outb(0x2F, EC_COMMAND_PORT);
+	outb(addr_lower, EC_DATA_PORT);
+
+	/* Read data */
+	outb(0x2E, EC_COMMAND_PORT);
+	outb(0x12, EC_DATA_PORT);
+	outb(0x2F, EC_COMMAND_PORT);
+	value = inb(EC_DATA_PORT);
+
+	mutex_unlock(&ec_mutex);
+
+	return value;
+}
+
+static int ec_write_byte(u16 addr, u8 value)
+{
+	u8 addr_upper = (addr >> 8) & 0xFF;
+	u8 addr_lower = addr & 0xFF;
+
+	mutex_lock(&ec_mutex);
+
+	/* Select upper byte address */
+	outb(0x2E, EC_COMMAND_PORT);
+	outb(0x11, EC_DATA_PORT);
+	outb(0x2F, EC_COMMAND_PORT);
+	outb(addr_upper, EC_DATA_PORT);
+
+	/* Select lower byte address */
+	outb(0x2E, EC_COMMAND_PORT);
+	outb(0x10, EC_DATA_PORT);
+	outb(0x2F, EC_COMMAND_PORT);
+	outb(addr_lower, EC_DATA_PORT);
+
+	/* Write data */
+	outb(0x2E, EC_COMMAND_PORT);
+	outb(0x12, EC_DATA_PORT);
+	outb(0x2F, EC_COMMAND_PORT);
+	outb(value, EC_DATA_PORT);
+
+	mutex_unlock(&ec_mutex);
+
+	return 0;
+}
+
+static int send_dptc_cmd(u8 cmd_id, u32 value)
+{
+	struct acpi_buffer input = { 0, NULL };
+	struct acpi_buffer output = { ACPI_ALLOCATE_BUFFER, NULL };
+	u8 *buffer;
+	acpi_status status;
+	int ret;
+
+	buffer = kzalloc(8, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	buffer[0] = cmd_id;
+	*(u32 *)(buffer + 4) = value;
+
+	input.length = 8;
+	input.pointer = buffer;
+
+	status = wmi_evaluate_method(AMD_APU_WMI_METHODS_GUID, 0, 9,
+				&input, &output);
+
+	ret = ACPI_SUCCESS(status) ? 0 : -EIO;
+
+	kfree(buffer);
+	if (output.pointer)
+		kfree(output.pointer);
+
+	return ret;
+}
+
+static struct zotac_platform_data *zotac_platform_update_device(struct device *dev)
+{
+	struct zotac_platform_data *data = dev_get_drvdata(dev);
+	unsigned long current_time = jiffies;
+
+	if (time_after(current_time, data->last_updated + HZ) || !data->valid) {
+		mutex_lock(&data->update_lock);
+
+		data->pwm_enable = ec_read_byte(EC_FAN_CTRL_ADDR);
+		data->pwm = ec_read_byte(EC_FAN_DUTY_ADDR);
+
+		u32 upper = ec_read_byte(EC_FAN_SPEED_UPPER_ADDR);
+		u32 lower = ec_read_byte(EC_FAN_SPEED_LOWER_ADDR);
+		data->fan_rpm = (upper << 8) | lower;
+
+		data->temp = ec_read_byte(EC_CPU_TEMP_ADDR);
+
+		data->last_updated = current_time;
+		data->valid = true;
+
+		mutex_unlock(&data->update_lock);
+	}
+
+	return data;
+}
+
+/* Internal version doesn't acquire the lock */
+static int set_fan_duty_internal(unsigned int duty_percent)
+{
+	u8 duty_val;
+
+	if (duty_percent > 100)
+		return -EINVAL;
+
+	duty_val =
+		(duty_percent * (PWM_MAX - PWM_MIN)) / 100 +
+		PWM_MIN;
+	return ec_write_byte(EC_FAN_DUTY_ADDR, duty_val);
+}
+
+static void fan_curve_function(struct timer_list *t)
+{
+	struct zotac_platform_data *data = platform_get_drvdata(zotac_platform_device);
+	unsigned int current_temp;
+	unsigned int pwm = 0;
+	int i;
+
+	if (!data || !data->curve_enabled) {
+		if (data && data->curve_enabled)
+			mod_timer(&fan_curve_timer, jiffies + HZ);
+		return;
+	}
+
+	mutex_lock(&data->update_lock);
+
+	current_temp = ec_read_byte(EC_CPU_TEMP_ADDR);
+	data->temp = current_temp;
+
+	pwm = data->curve_pwm[0];
+
+	if (current_temp >= data->curve_temp[FAN_CURVE_POINTS - 1]) {
+		/* Above highest temperature point - use maximum PWM */
+		pwm = data->curve_pwm[FAN_CURVE_POINTS - 1];
+	} else {
+		/* Find the temperature range and interpolate */
+		for (i = 0; i < FAN_CURVE_POINTS - 1; i++) {
+			if (current_temp >= data->curve_temp[i] &&
+			    current_temp < data->curve_temp[i + 1]) {
+				/* Linear interpolation between points */
+				int temp_range = data->curve_temp[i + 1] -
+						 data->curve_temp[i];
+				int pwm_range = data->curve_pwm[i + 1] -
+						data->curve_pwm[i];
+				int temp_offset =
+					current_temp - data->curve_temp[i];
+
+				if (temp_range > 0) {
+					pwm = data->curve_pwm[i] +
+					      (pwm_range * temp_offset) /
+						      temp_range;
+				} else {
+					pwm = data->curve_pwm[i];
+				}
+
+				break;
+			}
+		}
+	}
+
+	set_fan_duty_internal(pwm);
+	mutex_unlock(&data->update_lock);
+
+	mod_timer(&fan_curve_timer, jiffies + HZ);
+}
+
+/* Fan speed RPM */
+static ssize_t fan1_input_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct zotac_platform_data *data = zotac_platform_update_device(dev);
+	return sprintf(buf, "%u\n", data->fan_rpm);
+}
+static DEVICE_ATTR_RO(fan1_input);
+
+/* Fan mode */
+
+static int set_pwm_enable(struct device *dev, u8 mode)
+{
+	struct zotac_platform_data *data = dev_get_drvdata(dev);
+	int err = 0;
+	u8 ec_mode;
+
+	/* Convert from standard modes to EC-specific modes */
+	switch (mode) {
+	case PWM_ENABLE_OFF:
+		/* If supported by EC, turn fan off */
+		return -EOPNOTSUPP; /* If EC doesn't support OFF mode */
+	case PWM_ENABLE_MANUAL:
+		ec_mode =
+			EC_FAN_MODE_MANUAL; /* Assuming this is your actual EC value */
+		data->curve_enabled = false;
+		if (data->curve_enabled) {
+			data->curve_enabled = false;
+			del_timer(&fan_curve_timer);
+		}
+		break;
+	case PWM_ENABLE_AUTO:
+		ec_mode =
+			EC_FAN_MODE_AUTO; /* Assuming this is your actual EC value */
+		data->curve_enabled = false;
+		if (data->curve_enabled) {
+			data->curve_enabled = false;
+			del_timer(&fan_curve_timer);
+		}
+		break;
+	case PWM_ENABLE_CURVE:
+		ec_mode =
+			EC_FAN_MODE_MANUAL; /* We'll control manually but via the curve */
+		data->curve_enabled = true;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Set mode to EC if needed */
+	if (!data->curve_enabled || mode != PWM_ENABLE_CURVE) {
+		err = ec_write_byte(EC_FAN_CTRL_ADDR, ec_mode);
+	}
+
+	if (err == 0) {
+		data->pwm_enable = mode;
+		if (mode == PWM_ENABLE_CURVE)
+			mod_timer(&fan_curve_timer, jiffies + HZ);
+	}
+
+	return err;
+}
+
+/* Replace fan1_duty with pwm1 and scale to 0-255 */
+static int set_pwm(struct device *dev, u8 pwm_value)
+{
+	struct zotac_platform_data *data = dev_get_drvdata(dev);
+	int err;
+
+	if (pwm_value > PWM_MAX)
+		return -EINVAL;
+
+	mutex_lock(&data->update_lock);
+	err = ec_write_byte(EC_FAN_DUTY_ADDR, pwm_value);
+	if (err == 0)
+		data->pwm = pwm_value;
+	mutex_unlock(&data->update_lock);
+
+	return err;
+}
+
+static ssize_t pwm1_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct zotac_platform_data *data = zotac_platform_update_device(dev);
+	return sprintf(buf, "%u\n", data->pwm_enable);
+}
+
+static ssize_t pwm1_enable_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	unsigned long mode;
+	int err;
+
+	err = kstrtoul(buf, 10, &mode);
+	if (err)
+		return err;
+
+	if (mode > PWM_ENABLE_CURVE)
+		return -EINVAL;
+
+	err = set_pwm_enable(dev, mode);
+	if (err)
+		return err;
+
+	return count;
+}
+static DEVICE_ATTR_RW(pwm1_enable);
+
+/* Fan duty cycle (percent) */
+static ssize_t pwm1_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct zotac_platform_data *data = zotac_platform_update_device(dev);
+	return sprintf(buf, "%u\n", data->pwm);
+}
+
+static ssize_t pwm1_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	unsigned long pwm_value;
+	int err;
+
+	err = kstrtoul(buf, 10, &pwm_value);
+	if (err)
+		return err;
+
+	if (pwm_value > PWM_MAX)
+		return -EINVAL;
+
+	err = set_pwm(dev, pwm_value);
+	if (err)
+		return err;
+
+	return count;
+}
+static DEVICE_ATTR_RW(pwm1);
+
+/* Macro to generate temperature point attributes */
+#define CURVE_TEMP_ATTR(index)                                                \
+	static ssize_t pwm1_auto_point##index##_temp_show(                    \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		struct zotac_platform_data *data = dev_get_drvdata(dev);      \
+		return sprintf(buf, "%u\n", data->curve_temp[index - 1]);     \
+	}                                                                     \
+                                                                              \
+	static ssize_t pwm1_auto_point##index##_temp_store(                   \
+		struct device *dev, struct device_attribute *attr,            \
+		const char *buf, size_t count)                                \
+	{                                                                     \
+		struct zotac_platform_data *data = dev_get_drvdata(dev);      \
+		unsigned long temp;                                           \
+		int err;                                                      \
+                                                                              \
+		err = kstrtoul(buf, 10, &temp);                               \
+		if (err)                                                      \
+			return err;                                           \
+                                                                              \
+		mutex_lock(&data->update_lock);                               \
+		data->curve_temp[index - 1] = temp;                           \
+		mutex_unlock(&data->update_lock);                             \
+                                                                              \
+		return count;                                                 \
+	}                                                                     \
+	static DEVICE_ATTR_RW(pwm1_auto_point##index##_temp)
+
+/* Macro to generate PWM point attributes */
+#define CURVE_PWM_ATTR(index)                                                 \
+	static ssize_t pwm1_auto_point##index##_pwm_show(                     \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		struct zotac_platform_data *data = dev_get_drvdata(dev);      \
+		return sprintf(buf, "%u\n", data->curve_pwm[index - 1]);      \
+	}                                                                     \
+                                                                              \
+	static ssize_t pwm1_auto_point##index##_pwm_store(                    \
+		struct device *dev, struct device_attribute *attr,            \
+		const char *buf, size_t count)                                \
+	{                                                                     \
+		struct zotac_platform_data *data = dev_get_drvdata(dev);      \
+		unsigned long pwm;                                            \
+		int err;                                                      \
+                                                                              \
+		err = kstrtoul(buf, 10, &pwm);                                \
+		if (err)                                                      \
+			return err;                                           \
+                                                                              \
+		if (pwm > 100)                                                \
+			return -EINVAL;                                       \
+                                                                              \
+		mutex_lock(&data->update_lock);                               \
+		data->curve_pwm[index - 1] = pwm;                             \
+		mutex_unlock(&data->update_lock);                             \
+                                                                              \
+		return count;                                                 \
+	}                                                                     \
+	static DEVICE_ATTR_RW(pwm1_auto_point##index##_pwm)
+
+/* Generate attributes for each point */
+CURVE_TEMP_ATTR(1);
+CURVE_PWM_ATTR(1);
+CURVE_TEMP_ATTR(2);
+CURVE_PWM_ATTR(2);
+CURVE_TEMP_ATTR(3);
+CURVE_PWM_ATTR(3);
+CURVE_TEMP_ATTR(4);
+CURVE_PWM_ATTR(4);
+CURVE_TEMP_ATTR(5);
+CURVE_PWM_ATTR(5);
+CURVE_TEMP_ATTR(6);
+CURVE_PWM_ATTR(6);
+CURVE_TEMP_ATTR(7);
+CURVE_PWM_ATTR(7);
+CURVE_TEMP_ATTR(8);
+CURVE_PWM_ATTR(8);
+CURVE_TEMP_ATTR(9);
+CURVE_PWM_ATTR(9);
+
+/* Temperature reading */
+static ssize_t temp1_input_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct zotac_platform_data *data = zotac_platform_update_device(dev);
+	return sprintf(buf, "%u\n",
+		       data->temp * 1000); /* Convert to milli-degrees */
+}
+static DEVICE_ATTR_RO(temp1_input);
+
+static struct attribute *zotac_platform_hwmon_attrs[] = {
+	&dev_attr_fan1_input.attr,
+	&dev_attr_pwm1_enable.attr,
+	&dev_attr_pwm1.attr,
+	&dev_attr_temp1_input.attr,
+	&dev_attr_pwm1_auto_point1_temp.attr,
+	&dev_attr_pwm1_auto_point1_pwm.attr,
+	&dev_attr_pwm1_auto_point2_temp.attr,
+	&dev_attr_pwm1_auto_point2_pwm.attr,
+	&dev_attr_pwm1_auto_point3_temp.attr,
+	&dev_attr_pwm1_auto_point3_pwm.attr,
+	&dev_attr_pwm1_auto_point4_temp.attr,
+	&dev_attr_pwm1_auto_point4_pwm.attr,
+	&dev_attr_pwm1_auto_point5_temp.attr,
+	&dev_attr_pwm1_auto_point5_pwm.attr,
+	&dev_attr_pwm1_auto_point6_temp.attr,
+	&dev_attr_pwm1_auto_point6_pwm.attr,
+	&dev_attr_pwm1_auto_point7_temp.attr,
+	&dev_attr_pwm1_auto_point7_pwm.attr,
+	&dev_attr_pwm1_auto_point8_temp.attr,
+	&dev_attr_pwm1_auto_point8_pwm.attr,
+	&dev_attr_pwm1_auto_point9_temp.attr,
+	&dev_attr_pwm1_auto_point9_pwm.attr,
+	NULL
+};
+
+/* DPTC attributes */
+#define DPTC_ATTR(display_name, cmd_id, min_val, max_val)                     \
+	static ssize_t display_name##_show(                                   \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		struct zotac_platform_data *data = dev_get_drvdata(dev);      \
+		return sprintf(buf, "%u\n", data->display_name);              \
+	}                                                                     \
+                                                                              \
+	static ssize_t display_name##_store(struct device *dev,               \
+					    struct device_attribute *attr,    \
+					    const char *buf, size_t count)    \
+	{                                                                     \
+		struct zotac_platform_data *data = dev_get_drvdata(dev);      \
+		unsigned long val;                                            \
+		int err;                                                      \
+                                                                              \
+		if (!data->wmi_dptc_supported)                                \
+			return -ENODEV;                                       \
+                                                                              \
+		err = kstrtoul(buf, 10, &val);                                \
+		if (err)                                                      \
+			return err;                                           \
+                                                                              \
+		if (val < min_val || val > max_val)                           \
+			return -EINVAL;                                       \
+                                                                              \
+		mutex_lock(&data->update_lock);                               \
+		err = send_dptc_cmd(cmd_id, val);                             \
+		if (err == 0)                                                 \
+			data->display_name = val;                             \
+		mutex_unlock(&data->update_lock);                             \
+                                                                              \
+		return err ? err : count;                                     \
+	}                                                                     \
+	static DEVICE_ATTR_RW(display_name)
+
+/* Generate DPTC attributes with AMD-specific naming */
+DPTC_ATTR(ppt_pl1_stapm_time_const, DPTC_STAPM_TIME_CONSTANT, 1, 10000);
+DPTC_ATTR(ppt_pl2_sppt_time_const, DPTC_SLOW_PPT_CONSTANT, 1, 0xFF);
+DPTC_ATTR(ppt_platform_sppt, DPTC_P3T_LIMIT, DPTC_MIN_POWER, DPTC_MAX_POWER);
+
+static struct attribute *zotac_platform_dptc_attrs[] = {
+	&dev_attr_ppt_pl1_stapm_time_const.attr,
+	&dev_attr_ppt_pl2_sppt_time_const.attr,
+	&dev_attr_ppt_platform_sppt.attr,
+	NULL
+};
+
+static const struct attribute_group zotac_platform_hwmon_group = {
+	.attrs = zotac_platform_hwmon_attrs,
+};
+
+static const struct attribute_group zotac_platform_dptc_group = {
+	.name = "dptc",
+	.attrs = zotac_platform_dptc_attrs,
+};
+
+static const struct attribute_group *zotac_platform_hwmon_groups[] = {
+	&zotac_platform_hwmon_group,
+	NULL
+};
+
+/* Helper function to show a simple integer attribute */
+static ssize_t show_int_attr(struct device *dev,
+                             struct device_attribute *attr,
+                             char *buf, int value)
+{
+	return sprintf(buf, "%d\n", value);
+}
+
+/* Helper function to show a simple string attribute */
+static ssize_t show_string_attr(struct device *dev,
+                                struct device_attribute *attr,
+                                char *buf, const char *value)
+{
+	return sprintf(buf, "%s\n", value);
+}
+
+#define PPT_ATTR_RO(_name, _attr_name)                        \
+	struct device_attribute dev_attr_##_name = {          \
+		.attr = { .name = _attr_name, .mode = 0444 }, \
+		.show = _name##_show,                         \
+	}
+
+#define PPT_ATTR_RW(_name, _attr_name)                        \
+	struct device_attribute dev_attr_##_name = {          \
+		.attr = { .name = _attr_name, .mode = 0644 }, \
+		.show = _name##_show,                         \
+		.store = _name##_store,                       \
+	}
+
+/* Macro that creates a complete set of attributes for a power limit */
+#define DEFINE_POWER_LIMIT_ATTRS(attr_name, cmd_id, min, max, desc)           \
+	static ssize_t attr_name##_current_value_show(                        \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		struct zotac_platform_data *data =                            \
+			platform_get_drvdata(zotac_platform_device);          \
+		return show_int_attr(dev, attr, buf,                          \
+				     data->current_power_limits.attr_name);   \
+	}                                                                     \
+                                                                              \
+	static ssize_t attr_name##_current_value_store(                       \
+		struct device *dev, struct device_attribute *attr,            \
+		const char *buf, size_t count)                                \
+	{                                                                     \
+		struct zotac_platform_data *data =                            \
+			platform_get_drvdata(zotac_platform_device);          \
+		unsigned long val;                                            \
+		int err;                                                      \
+                                                                              \
+		if (!data->wmi_dptc_supported)                                \
+			return -ENODEV;                                       \
+                                                                              \
+		err = kstrtoul(buf, 10, &val);                                \
+		if (err)                                                      \
+			return err;                                           \
+                                                                              \
+		if (val < min || val > max)                                   \
+			return -EINVAL;                                       \
+                                                                              \
+		mutex_lock(&data->update_lock);                               \
+		data->current_power_limits.attr_name = val;                   \
+		data->current_profile = PLATFORM_PROFILE_CUSTOM;              \
+                                                                              \
+		err = send_dptc_cmd(cmd_id, val * 1000);                      \
+		mutex_unlock(&data->update_lock);                             \
+                                                                              \
+		return err ? err : count;                                     \
+	}                                                                     \
+                                                                              \
+	static ssize_t attr_name##_min_value_show(                            \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		return show_int_attr(dev, attr, buf, min);                    \
+	}                                                                     \
+                                                                              \
+	static ssize_t attr_name##_max_value_show(                            \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		return show_int_attr(dev, attr, buf, max);                    \
+	}                                                                     \
+                                                                              \
+	static ssize_t attr_name##_default_value_show(                        \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		struct zotac_platform_data *data =                            \
+			platform_get_drvdata(zotac_platform_device);          \
+		int default_value;                                            \
+                                                                              \
+		if (data->current_profile == PLATFORM_PROFILE_CUSTOM) {       \
+			default_value = ppt_balanced_profile.attr_name;       \
+		} else {                                                      \
+			const struct power_limits *profile;                   \
+                                                                              \
+			switch (data->current_profile) {                      \
+			case PLATFORM_PROFILE_LOW_POWER:                      \
+				profile = &ppt_quiet_profile;                 \
+				break;                                        \
+			case PLATFORM_PROFILE_BALANCED:                       \
+				profile = &ppt_balanced_profile;              \
+				break;                                        \
+			case PLATFORM_PROFILE_PERFORMANCE:                    \
+				profile = &ppt_performance_profile;           \
+				break;                                        \
+			default:                                              \
+				profile = &ppt_balanced_profile;              \
+				break;                                        \
+			}                                                     \
+                                                                              \
+			default_value = profile->attr_name;                   \
+		}                                                             \
+                                                                              \
+		return show_int_attr(dev, attr, buf, default_value);          \
+	}                                                                     \
+                                                                              \
+	static ssize_t attr_name##_scalar_increment_show(                     \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		return show_int_attr(dev, attr, buf, 1);                      \
+	}                                                                     \
+                                                                              \
+	static ssize_t attr_name##_display_name_show(                         \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		return show_string_attr(dev, attr, buf, desc);                \
+	}                                                                     \
+                                                                              \
+	static ssize_t attr_name##_type_show(                                 \
+		struct device *dev, struct device_attribute *attr, char *buf) \
+	{                                                                     \
+		return show_string_attr(dev, attr, buf, "int");               \
+	}                                                                     \
+                                                                              \
+	static PPT_ATTR_RW(attr_name##_current_value, "current_value");       \
+	static PPT_ATTR_RO(attr_name##_min_value, "min_value");               \
+	static PPT_ATTR_RO(attr_name##_max_value, "max_value");               \
+	static PPT_ATTR_RO(attr_name##_default_value, "default_value");       \
+	static PPT_ATTR_RO(attr_name##_scalar_increment, "scalar_increment"); \
+	static PPT_ATTR_RO(attr_name##_display_name, "display_name");         \
+	static PPT_ATTR_RO(attr_name##_type, "type");                         \
+                                                                              \
+	static struct attribute *attr_name##_attrs[] = {                      \
+		&dev_attr_##attr_name##_current_value.attr,                   \
+		&dev_attr_##attr_name##_min_value.attr,                       \
+		&dev_attr_##attr_name##_max_value.attr,                       \
+		&dev_attr_##attr_name##_default_value.attr,                   \
+		&dev_attr_##attr_name##_scalar_increment.attr,                \
+		&dev_attr_##attr_name##_display_name.attr,                    \
+		&dev_attr_##attr_name##_type.attr,                            \
+		NULL                                                          \
+	};                                                                    \
+                                                                              \
+	static const struct attribute_group attr_name##_attr_group = {        \
+		.name = #attr_name, .attrs = attr_name##_attrs                \
+	}
+
+/* Define the power limit attribute groups */
+DEFINE_POWER_LIMIT_ATTRS(ppt_pl1_spl, DPTC_SUSTAINED_POWER, PPT_PL1_SPL_MIN,
+			 PPT_PL1_SPL_MAX,
+			 "CPU Sustained Power Limit (PL1/SPL)");
+
+DEFINE_POWER_LIMIT_ATTRS(ppt_pl2_sppt, DPTC_FAST_POWER_1, PPT_PL2_SPPT_MIN,
+			 PPT_PL2_SPPT_MAX,
+			 "CPU Short Term Power Limit (PL2/SPPT)");
+
+DEFINE_POWER_LIMIT_ATTRS(ppt_pl3_fppt, DPTC_FAST_POWER_2, PPT_PL3_FPPT_MIN,
+			 PPT_PL3_FPPT_MAX, "CPU Fast Power Limit (PL3/FPPT)");
+
+/* Combine all power attribute groups */
+static const struct attribute_group *zotac_platform_power_groups[] = {
+	&ppt_pl1_spl_attr_group, &ppt_pl2_sppt_attr_group,
+	&ppt_pl3_fppt_attr_group, NULL
+};
+
+/* Helper function to create all power attribute groups */
+static int create_power_attributes(struct platform_device *pdev, struct zotac_platform_data *data)
+{
+	int i, ret = 0;
+
+	if (!data->wmi_dptc_supported)
+		return 0;
+
+	data->fw_attr_dev = device_create(&firmware_attributes_class, NULL, MKDEV(0, 0),
+						NULL, "%s", DRIVER_NAME);
+	if (IS_ERR(data->fw_attr_dev)) {
+		ret = PTR_ERR(data->fw_attr_dev);
+		goto fail_class_get;
+	}
+
+	data->fw_attr_kset = kset_create_and_add("attributes", NULL,
+						&data->fw_attr_dev->kobj);
+	if (!data->fw_attr_kset) {
+		ret = -ENOMEM;
+		goto err_destroy_kset;
+	}
+
+	for (i = 0; zotac_platform_power_groups[i]; i++) {
+		ret = sysfs_create_group(&data->fw_attr_kset->kobj,
+					 zotac_platform_power_groups[i]);
+		if (ret) {
+			dev_warn(&pdev->dev,
+				 "Failed to create power limit group %d\n", i);
+			goto error;
+		}
+	}
+
+	return 0;
+
+error:
+	while (--i >= 0)
+		sysfs_remove_group(&data->fw_attr_kset->kobj,
+				   zotac_platform_power_groups[i]);
+err_destroy_kset:
+	kset_unregister(data->fw_attr_kset);
+fail_class_get:
+	device_destroy(&firmware_attributes_class, MKDEV(0, 0));
+	return ret;
+}
+
+/* Helper function to remove all power attribute groups */
+static void remove_power_attributes(struct platform_device *pdev)
+{
+	struct zotac_platform_data *data = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; zotac_platform_power_groups[i]; i++)
+		sysfs_remove_group(&data->fw_attr_kset->kobj,
+				   zotac_platform_power_groups[i]);
+
+	kset_unregister(data->fw_attr_kset);
+	device_destroy(&firmware_attributes_class, MKDEV(0, 0));
+}
+
+static int zotac_platform_profile_get(struct device *dev,
+				     enum platform_profile_option *profile)
+{
+	struct zotac_platform_data *data = dev_get_drvdata(dev);
+	*profile = data->current_profile;
+	return 0;
+}
+
+static int zotac_platform_profile_set(struct device *dev,
+				     enum platform_profile_option profile)
+{
+	struct zotac_platform_data *data = dev_get_drvdata(dev);
+	const struct power_limits *limits;
+	int ret = 0;
+
+	if (!data->wmi_dptc_supported)
+		return -ENODEV;
+
+	switch (profile) {
+	case PLATFORM_PROFILE_PERFORMANCE:
+		limits = &ppt_performance_profile;
+		break;
+	case PLATFORM_PROFILE_BALANCED:
+		limits = &ppt_balanced_profile;
+		break;
+	case PLATFORM_PROFILE_LOW_POWER:
+		limits = &ppt_quiet_profile;
+		break;
+	case PLATFORM_PROFILE_CUSTOM:
+		limits = &data->current_power_limits;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	mutex_lock(&data->update_lock);
+	ret = send_dptc_cmd(DPTC_SUSTAINED_POWER, limits->ppt_pl1_spl * 1000);
+	if (ret == 0)
+		ret = send_dptc_cmd(DPTC_FAST_POWER_1, limits->ppt_pl2_sppt * 1000);
+	if (ret == 0)
+		ret = send_dptc_cmd(DPTC_FAST_POWER_2, limits->ppt_pl3_fppt * 1000);
+	if (ret == 0) {
+		data->current_profile = profile;
+		if (profile != PLATFORM_PROFILE_CUSTOM)
+			memcpy(&data->current_power_limits, limits, sizeof(struct power_limits));
+	}
+	mutex_unlock(&data->update_lock);
+
+	return ret;
+}
+
+static int zotac_platform_profile_probe(void *drvdata, unsigned long *choices)
+{
+	set_bit(PLATFORM_PROFILE_LOW_POWER, choices);
+	set_bit(PLATFORM_PROFILE_BALANCED, choices);
+	set_bit(PLATFORM_PROFILE_PERFORMANCE, choices);
+	set_bit(PLATFORM_PROFILE_CUSTOM, choices);
+	return 0;
+}
+
+static const struct platform_profile_ops zotac_platform_profile_ops = {
+	.probe = zotac_platform_profile_probe,
+	.profile_get = zotac_platform_profile_get,
+	.profile_set = zotac_platform_profile_set,
+};
+
+static int platform_profile_setup(struct zotac_platform_data *data)
+{
+	struct device *dev = &zotac_platform_device->dev;
+
+	if (!data->wmi_dptc_supported)
+		return 0;
+
+	data->ppdev = devm_platform_profile_register(dev, DRIVER_NAME, data,
+						     &zotac_platform_profile_ops);
+	if (IS_ERR(data->ppdev)) {
+		dev_err(dev, "Failed to register platform_profile device\n");
+		return PTR_ERR(data->ppdev);
+	}
+
+	/* Set default profile */
+	zotac_platform_profile_set(dev, PLATFORM_PROFILE_BALANCED);
+
+	return 0;
+}
+
+static int zotac_platform_probe(struct platform_device *pdev)
+{
+	struct zotac_platform_data *data;
+	struct device *hwmon_dev;
+	int i, ret;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(struct zotac_platform_data),
+			    GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->wmi_dptc_supported = wmi_has_guid(AMD_APU_WMI_METHODS_GUID);
+	data->valid = false;
+	data->curve_enabled = false;
+	mutex_init(&data->update_lock);
+
+	for (i = 0; i < FAN_CURVE_POINTS; i++) {
+		/* Set default temperature points from 10°C to 90°C */
+		data->curve_temp[i] = 10 + (i * 10);
+		/* Set default PWM values - simple linear curve from 20% to 100% */
+		data->curve_pwm[i] = 20 + (i * 10);
+		if (data->curve_pwm[i] > 100)
+			data->curve_pwm[i] = 100;
+	}
+
+	data->current_profile = PLATFORM_PROFILE_BALANCED;
+	memcpy(&data->current_power_limits, &ppt_balanced_profile, sizeof(struct power_limits));
+	data->ppt_pl1_stapm_time_const = 300;
+	data->ppt_pl2_sppt_time_const = 0x11;
+	data->ppt_platform_sppt = 13000;
+
+	hwmon_dev = devm_hwmon_device_register_with_groups(
+		&pdev->dev, "zotac_platform", data, zotac_platform_hwmon_groups);
+	if (IS_ERR(hwmon_dev))
+		return PTR_ERR(hwmon_dev);
+
+	data->hwmon_dev = hwmon_dev;
+
+	if (data->wmi_dptc_supported) {
+		ret = sysfs_create_group(&pdev->dev.kobj, &zotac_platform_dptc_group);
+		if (ret)
+			dev_warn(&pdev->dev, "Failed to create DPTC sysfs group\n");
+	}
+
+	platform_set_drvdata(pdev, data);
+
+	timer_setup(&fan_curve_timer, fan_curve_function, 0);
+
+	zotac_platform_update_device(&pdev->dev);
+
+	ret = platform_profile_setup(data);
+	if (ret)
+		dev_warn(&pdev->dev, "Failed to setup platform profile\n");
+
+	ret = create_power_attributes(pdev, data);
+	if (ret)
+		dev_warn(&pdev->dev, "Failed to setup firmware attributes\n");
+
+	return 0;
+}
+
+static void zotac_platform_remove(struct platform_device *pdev)
+{
+	struct zotac_platform_data *data = platform_get_drvdata(pdev);
+
+	if (data && data->wmi_dptc_supported) {
+		sysfs_remove_group(&pdev->dev.kobj, &zotac_platform_dptc_group);
+		remove_power_attributes(pdev);
+	}
+}
+
+static struct platform_driver zotac_platform_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+	},
+	.probe = zotac_platform_probe,
+	.remove = zotac_platform_remove,
+};
+
+static const struct dmi_system_id zotac_platform_dmi_table[] __initconst = {
+    {
+        .ident = "Zotac Gaming Handheld",
+        .matches = {
+            DMI_MATCH(DMI_SYS_VENDOR, "ZOTAC"),
+            DMI_MATCH(DMI_BOARD_NAME, "G0A1W"),
+        },
+    },
+    {
+        .ident = "Zotac ZONE",
+        .matches = {
+            DMI_MATCH(DMI_SYS_VENDOR, "ZOTAC"),
+            DMI_MATCH(DMI_PRODUCT_NAME, "ZOTAC GAMING ZONE"),
+        },
+    },
+    {}  /* Terminate list */
+};
+MODULE_DEVICE_TABLE(dmi, zotac_platform_dmi_table);
+
+static int __init zotac_platform_init(void)
+{
+	int err;
+
+	if (!dmi_check_system(zotac_platform_dmi_table)) {
+		pr_info("No compatible Zotac hardware found\n");
+		return -ENODEV;
+	}
+
+	/* Request I/O regions */
+	if (!request_region(EC_COMMAND_PORT, 1, "zotac_platform_ec") ||
+	    !request_region(EC_DATA_PORT, 1, "zotac_platform_ec")) {
+		pr_err("Failed to request EC I/O ports\n");
+		err = -EBUSY;
+		goto err_release;
+	}
+
+	zotac_platform_device = platform_device_register_simple(
+		DRIVER_NAME, -1, ec_io_ports, ARRAY_SIZE(ec_io_ports));
+	if (IS_ERR(zotac_platform_device)) {
+		err = PTR_ERR(zotac_platform_device);
+		goto err_release;
+	}
+
+	err = platform_driver_register(&zotac_platform_driver);
+	if (err)
+		goto err_device_unregister;
+
+	return 0;
+
+err_device_unregister:
+	platform_device_unregister(zotac_platform_device);
+err_release:
+	release_region(EC_COMMAND_PORT, 1);
+	release_region(EC_DATA_PORT, 1);
+	return err;
+}
+
+static void __exit zotac_platform_exit(void)
+{
+	del_timer_sync(&fan_curve_timer);
+
+	platform_driver_unregister(&zotac_platform_driver);
+	platform_device_unregister(zotac_platform_device);
+	release_region(EC_COMMAND_PORT, 1);
+	release_region(EC_DATA_PORT, 1);
+}
+
+module_init(zotac_platform_init);
+module_exit(zotac_platform_exit);
+
+MODULE_AUTHOR("Luke D. Jones");
+MODULE_DESCRIPTION("Zotac Handheld Platform Driver");
+MODULE_LICENSE("GPL");
-- 
2.51.0

