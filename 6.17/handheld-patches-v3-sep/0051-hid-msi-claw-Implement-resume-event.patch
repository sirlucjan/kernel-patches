From 6925af0caf13ddfbaed18356c5aa7afe3f9d2c51 Mon Sep 17 00:00:00 2001
From: Eric Naim <dnaim@cachyos.org>
Date: Fri, 24 Oct 2025 00:52:08 +0800
Subject: [PATCH 51/51] hid-msi-claw: Implement resume event

Signed-off-by: Eric Naim <dnaim@cachyos.org>
---
 drivers/hid/hid-msi-claw.c | 156 +++++++++++++++++++++++--------------
 1 file changed, 97 insertions(+), 59 deletions(-)

diff --git a/drivers/hid/hid-msi-claw.c b/drivers/hid/hid-msi-claw.c
index 9876a9f0b..03cf1d449 100644
--- a/drivers/hid/hid-msi-claw.c
+++ b/drivers/hid/hid-msi-claw.c
@@ -92,7 +92,7 @@ struct msi_claw_read_data {
 	const uint8_t *data;
 	int size;
 
-	struct msi_claw_read_data* next;
+	struct msi_claw_read_data *next;
 };
 
 struct msi_claw_drvdata {
@@ -103,7 +103,7 @@ struct msi_claw_drvdata {
 	struct msi_claw_control_status *control;
 
 	struct mutex read_data_mutex;
-	struct msi_claw_read_data* read_data;
+	struct msi_claw_read_data *read_data;
 };
 
 static int msi_claw_write_cmd(struct hid_device *hdev, enum msi_claw_command_type cmdtype,
@@ -121,13 +121,12 @@ static int msi_claw_write_cmd(struct hid_device *hdev, enum msi_claw_command_typ
 		goto msi_claw_write_cmd_err;
 	}
 
-	if (buffer != NULL) {
-		memcpy((void*)&buf[5], buffer, buffer_len);
-	} else {
+	if (buffer != NULL)
+		memcpy((void *)&buf[5], buffer, buffer_len);
+	else
 		buffer_len = 0;
-	}
 
-	memset((void*)&buf[5 + buffer_len], 0, MSI_CLAW_WRITE_SIZE - (5 + buffer_len));
+	memset((void *)&buf[5 + buffer_len], 0, MSI_CLAW_WRITE_SIZE - (5 + buffer_len));
 	dmabuf = kmemdup(buf, MSI_CLAW_WRITE_SIZE, GFP_KERNEL);
 	if (!dmabuf) {
 		ret = -ENOMEM;
@@ -144,8 +143,7 @@ static int msi_claw_write_cmd(struct hid_device *hdev, enum msi_claw_command_typ
 	hid_notice(hdev, "hid-msi-claw sent %d bytes, cmd: 0x%02x\n", ret, dmabuf[4]);
 
 msi_claw_write_cmd_err:
-	if (dmabuf)
-		kfree(dmabuf);
+	kfree(dmabuf);
 
 	return ret;
 }
@@ -164,14 +162,13 @@ static int msi_claw_read(struct hid_device *hdev, uint8_t *const buffer, int siz
 
 	for (uint32_t i = 0; (event == NULL) && (i <= timeout); i++) {
 		if (timeout - i)
-			msleep(1);
+			msleep(20);
 
 		scoped_guard(mutex, &drvdata->read_data_mutex) {
 			event = drvdata->read_data;
 
-			if (event != NULL) {
+			if (event != NULL)
 				drvdata->read_data = event->next;
-			}
 		};
 	}
 
@@ -187,13 +184,13 @@ static int msi_claw_read(struct hid_device *hdev, uint8_t *const buffer, int siz
 		goto msi_claw_read_err;
 	}
 
-	memcpy((void*)buffer, (const void*)event->data, event->size);
+	memcpy((void *)buffer, (const void *)event->data, event->size);
 	ret = event->size;
 
 msi_claw_read_err:
 	if (event != NULL) {
-		kfree((void*)event->data);
-		kfree((void*)event);
+		kfree(event->data);
+		kfree(event);
 	}
 
 	return ret;
@@ -202,7 +199,10 @@ static int msi_claw_read(struct hid_device *hdev, uint8_t *const buffer, int siz
 static int msi_claw_raw_event_control(struct hid_device *hdev, struct msi_claw_drvdata *drvdata,
 	struct hid_report *report, uint8_t *data, int size)
 {
-	int ret = 0;
+	struct msi_claw_read_data **list = NULL;
+	struct msi_claw_read_data *node = NULL;
+	uint8_t *buffer;
+	int ret, i;
 
 	if (size != MSI_CLAW_READ_SIZE) {
 		//hid_err(hdev, "hid-msi-claw got unknown %d bytes\n", size);
@@ -221,8 +221,8 @@ static int msi_claw_raw_event_control(struct hid_device *hdev, struct msi_claw_d
 		goto msi_claw_raw_event_control_err;
 	}
 
-	unsigned char *const buffer = (unsigned char *)kmemdup(data, size, GFP_KERNEL);
-	if (!buffer) {
+	buffer = kmemdup(data, size, GFP_KERNEL);
+	if (buffer == NULL) {
 		ret = -ENOMEM;
 		hid_err(hdev, "hid-msi-claw failed to alloc %d bytes for read buffer: %d\n", size, ret);
 		goto msi_claw_raw_event_control_err;
@@ -233,7 +233,8 @@ static int msi_claw_raw_event_control(struct hid_device *hdev, struct msi_claw_d
 		.size = size,
 		.next = NULL,
 	};
-	struct msi_claw_read_data *const node = (struct msi_claw_read_data*)kmemdup(&evt, sizeof(evt), GFP_KERNEL);
+
+	node = kmemdup(&evt, sizeof(evt), GFP_KERNEL);
 	if (!node) {
 		ret = -ENOMEM;
 		kfree(buffer);
@@ -242,10 +243,9 @@ static int msi_claw_raw_event_control(struct hid_device *hdev, struct msi_claw_d
 	}
 
 	scoped_guard(mutex, &drvdata->read_data_mutex) {
-		struct msi_claw_read_data **list = &drvdata->read_data;
-		for (int i = 0; (i < 32) && (*list != NULL); i++) {
+		list = &drvdata->read_data;
+		for (i = 0; (i < 32) && (*list != NULL); i++)
 			list = &(*list)->next;
-		}
 
 		if (*list != NULL) {
 			ret = -EIO;
@@ -258,7 +258,15 @@ static int msi_claw_raw_event_control(struct hid_device *hdev, struct msi_claw_d
 
 	hid_notice(hdev, "hid-msi-claw received %d bytes, cmd: 0x%02x\n", size, buffer[4]);
 
+	return 0;
+
 msi_claw_raw_event_control_err:
+	if (buffer != NULL)
+		kfree(buffer);
+
+	if (node != NULL)
+		kfree(node);
+
 	return ret;
 }
 
@@ -266,12 +274,12 @@ static int msi_claw_raw_event(struct hid_device *hdev, struct hid_report *report
 {
 	struct msi_claw_drvdata *drvdata = hid_get_drvdata(hdev);
 
-	if (drvdata->control)
-		return msi_claw_raw_event_control(hdev, drvdata, report, data, size);
-	else
+	if (!drvdata->control) {
 		hid_notice(hdev, "hid-msi-claw event not from control interface: ignoring\n");
+		return 0;
+	}
 
-	return 0;
+	return msi_claw_raw_event_control(hdev, drvdata, report, data, size);
 }
 
 static int msi_claw_await_ack(struct hid_device *hdev)
@@ -308,7 +316,8 @@ static int msi_claw_await_ack(struct hid_device *hdev)
 	return ret;
 }
 
-static int sync_to_rom(struct hid_device *hdev) {
+static int sync_to_rom(struct hid_device *hdev)
+{
 	struct msi_claw_drvdata *drvdata = hid_get_drvdata(hdev);
 	int ret;
 
@@ -347,7 +356,8 @@ static int sync_to_rom(struct hid_device *hdev) {
 	return ret;
 }
 
-static int msi_claw_reset_device(struct hid_device *hdev) {
+static int msi_claw_reset_device(struct hid_device *hdev)
+{
 	struct msi_claw_drvdata *drvdata = hid_get_drvdata(hdev);
 	int ret;
 
@@ -399,7 +409,7 @@ static int msi_claw_read_gamepad_mode(struct hid_device *hdev,
 		ret = -EINVAL;
 		goto msi_claw_read_gamepad_mode_err;
 	}
-	
+
 	if (buffer[4] != (uint8_t)MSI_CLAW_COMMAND_TYPE_GAMEPAD_MODE_ACK) {
 		hid_err(hdev, "hid-msi-claw received invalid response: expected 0x27, got 0x%02x\n", buffer[4]);
 		ret = -EINVAL;
@@ -413,7 +423,7 @@ static int msi_claw_read_gamepad_mode(struct hid_device *hdev,
 		ret = -EINVAL;
 		goto msi_claw_read_gamepad_mode_err;
 	}
-	
+
 	status->gamepad_mode = (enum msi_claw_gamepad_mode)buffer[5];
 	status->mkeys_function = (enum msi_claw_mkeys_function)buffer[6];
 
@@ -467,14 +477,14 @@ static int msi_claw_switch_gamepad_mode(struct hid_device *hdev,
 		goto msi_claw_switch_gamepad_mode_err;
 	}
 
-	if (memcmp((const void*)&check_status, (const void*)status, sizeof(struct msi_claw_control_status))) {
+	if (memcmp((const void *)&check_status, (const void *)status, sizeof(*status))) {
 		hid_err(hdev, "hid-msi-claw current status and target one are different\n");
 		ret = -EIO;
 		goto msi_claw_switch_gamepad_mode_err;
 	}
 
 	// the device now sends back 03 00 00 00 00 00 00 00 00
-	
+
 	// this command is always issued by the windows counterpart after a mode switch
 	ret = sync_to_rom(hdev);
 	if (ret) {
@@ -506,11 +516,10 @@ static DEVICE_ATTR_WO(reset);
 
 static ssize_t gamepad_mode_available_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	int ret = 0;
+	int i, ret = 0;
 	int len = ARRAY_SIZE(gamepad_mode_map);
 
-	for (int i = 0; i < len; i++)
-	{
+	for (i = 0; i < len; i++) {
 		if (!gamepad_mode_map[i].available)
 			continue;
 
@@ -529,7 +538,9 @@ static ssize_t gamepad_mode_current_show(struct device *dev, struct device_attri
 {
 	struct hid_device *hdev = to_hid_device(dev);
 	struct msi_claw_control_status status;
-	int ret = msi_claw_read_gamepad_mode(hdev, &status);
+	int ret;
+
+	ret = msi_claw_read_gamepad_mode(hdev, &status);
 	if (ret) {
 		hid_err(hdev, "hid-msi-claw error reaging the gamepad mode: %d\n", ret);
 		return ret;
@@ -540,6 +551,8 @@ static ssize_t gamepad_mode_current_show(struct device *dev, struct device_attri
 
 static ssize_t gamepad_mode_current_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
+	ssize_t ret;
+	uint8_t *input;
 	struct hid_device *hdev = to_hid_device(dev);
 	struct msi_claw_drvdata *drvdata = hid_get_drvdata(hdev);
 	enum msi_claw_gamepad_mode new_gamepad_mode = ARRAY_SIZE(gamepad_mode_map);
@@ -547,14 +560,13 @@ static ssize_t gamepad_mode_current_store(struct device *dev, struct device_attr
 		.gamepad_mode = drvdata->control->gamepad_mode,
 		.mkeys_function = drvdata->control->mkeys_function,
 	};
-	ssize_t ret;
 
 	if (!count) {
 		ret = -EINVAL;
 		goto gamepad_mode_current_store_err;
 	}
 
-	char* input = kmemdup(buf, count+1, GFP_KERNEL);
+	input = kmemdup(buf, count+1, GFP_KERNEL);
 	if (!input) {
 		ret = -ENOMEM;
 		goto gamepad_mode_current_store_err;
@@ -592,11 +604,10 @@ static DEVICE_ATTR_RW(gamepad_mode_current);
 
 static ssize_t mkeys_function_available_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	int ret = 0;
+	int i, ret = 0;
 	int len = ARRAY_SIZE(mkeys_function_map);
 
-	for (int i = 0; i < len; i++)
-	{
+	for (i = 0; i < len; i++) {
 		ret += sysfs_emit_at(buf, ret, "%s", mkeys_function_map[i]);
 
 		if (i < len-1)
@@ -613,6 +624,7 @@ static ssize_t mkeys_function_current_show(struct device *dev, struct device_att
 	struct hid_device *hdev = to_hid_device(dev);
 	struct msi_claw_control_status status;
 	int ret = msi_claw_read_gamepad_mode(hdev, &status);
+
 	if (ret) {
 		hid_err(hdev, "hid-msi-claw error reaging the gamepad mode: %d\n", ret);
 		return ret;
@@ -621,8 +633,11 @@ static ssize_t mkeys_function_current_show(struct device *dev, struct device_att
 	return sysfs_emit(buf, "%s\n", mkeys_function_map[(int)status.mkeys_function]);
 }
 
-static ssize_t mkeys_function_current_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t mkeys_function_current_store(struct device *dev, struct device_attribute *attr,
+					const char *buf, size_t count)
 {
+	uint8_t *input;
+	ssize_t err;
 	struct hid_device *hdev = to_hid_device(dev);
 	struct msi_claw_drvdata *drvdata = hid_get_drvdata(hdev);
 	enum msi_claw_mkeys_function new_mkeys_function = ARRAY_SIZE(mkeys_function_map);
@@ -631,14 +646,10 @@ static ssize_t mkeys_function_current_store(struct device *dev, struct device_at
 		.mkeys_function = drvdata->control->mkeys_function,
 	};
 
-	ssize_t ret;
+	if (!count)
+		return -EINVAL;
 
-	if (!count) {
-		ret = -EINVAL;
-		goto mkeys_function_current_store_err;
-	}
-
-	char* input = kmemdup(buf, count+1, GFP_KERNEL);
+	input = kmemdup(buf, count+1, GFP_KERNEL);
 	if (!input)
 		return -ENOMEM;
 
@@ -654,24 +665,48 @@ static ssize_t mkeys_function_current_store(struct device *dev, struct device_at
 
 	if (new_mkeys_function == ARRAY_SIZE(mkeys_function_map)) {
 		hid_err(hdev, "Invalid mkeys function selected\n");
-		ret= -EINVAL;
-		goto mkeys_function_current_store_err;
+		return -EINVAL;
 	}
 
 	status.mkeys_function = new_mkeys_function;
-	ret = msi_claw_switch_gamepad_mode(hdev, &status);
-	if (ret) {
-		hid_err(hdev, "Error changing mkeys function: %d\n", (int)ret);
-		goto mkeys_function_current_store_err;
+	err = msi_claw_switch_gamepad_mode(hdev, &status);
+	if (err) {
+		hid_err(hdev, "Error changing mkeys function: %d\n", (int)err);
+		return err;
 	}
 
-	ret = count;
-
-mkeys_function_current_store_err:
-	return ret;
+	return count;
 }
 static DEVICE_ATTR_RW(mkeys_function_current);
 
+static int __maybe_unused msi_claw_resume(struct hid_device *hdev)
+{
+	int ret;
+	struct msi_claw_drvdata *drvdata = hid_get_drvdata(hdev);
+	struct msi_claw_control_status status = {
+		.gamepad_mode = drvdata->control->gamepad_mode,
+		.mkeys_function = drvdata->control->mkeys_function,
+	};
+
+	// TODO: clear out events list here (or in suspend?)
+
+	// wait for device to be ready
+	msleep(500);
+
+	ret = msi_claw_switch_gamepad_mode(hdev, &status);
+	if (ret) {
+		hid_err(hdev, "Error changing gamepad mode: %d\n", (int)ret);
+		goto msi_claw_resume_err;
+	}
+
+	// TODO: retry until this works?
+
+	return 0;
+
+msi_claw_resume_err:
+	return ret;
+}
+
 static int msi_claw_probe(struct hid_device *hdev, const struct hid_device_id *id)
 {
 	int ret;
@@ -799,6 +834,9 @@ static struct hid_driver msi_claw_driver = {
 	.raw_event		= msi_claw_raw_event,
 	.probe			= msi_claw_probe,
 	.remove			= msi_claw_remove,
+#ifdef CONFIG_PM
+	.resume			= msi_claw_resume,
+#endif
 };
 module_hid_driver(msi_claw_driver);
 
-- 
2.51.1

